import React, { useEffect, useState, useCallback, useMemo } from 'react';
import { collection, query, where, orderBy, onSnapshot, getDocs, addDoc } from 'firebase/firestore';
import { db } from '../firebaseConfig';

const PROXY_FUNCTION_URL = "https://bejewelled-cobbler-ebae5a.netlify.app/.netlify/functions/getVulnerabilities";

const owaspCategories = {
  A01: ['access control', 'authorization'],
  A02: ['encryption', 'ssl', 'tls', 'cryptographic'],
  A03: ['sql injection', 'xss', 'command injection', 'cross-site scripting'],
  A04: ['insecure design', 'business logic'],
  A05: ['security misconfiguration', 'misconfiguration'],
  A06: ['vulnerable component', 'dependency', 'third-party library'],
  A07: ['broken authentication', 'jwt', 'session'],
  A08: ['ssrf', 'server-side request forgery'],
  A09: ['logging', 'monitoring', 'insufficient logging'],
  A10: ['unsafe consumption of apis']
};

const categorizeOWASP = (desc) => {
  if (!desc) return 'Uncategorized';
  const lower = desc.toLowerCase();
  for (const key in owaspCategories) {
    if (owaspCategories[key].some(k => lower.includes(k))) {
      return key;
    }
  }
  return 'Uncategorized';
};

const VulnerabilityFeed = () => {
  const [vulns, setVulns] = useState([]);
  const [loading, setLoading] = useState(true);
  const [fetchStatus, setFetchStatus] = useState({ loading: false, error: null });

  const fetchVulnerabilities = useCallback(async () => {
    setFetchStatus({ loading: true, error: null });
    try {
      const resp = await fetch(PROXY_FUNCTION_URL);
      if (!resp.ok) throw new Error(`Fetch failed with status: ${resp.status}`);
      const data = await resp.json();

      for (const item of data.data || []) {
        const desc = item?.cve?.descriptions?.find(x => x.lang === 'en')?.value || 'No description available';
        const category = categorizeOWASP(desc);
        if (category === 'Uncategorized') continue;
        const cveId = item?.cve?.id;
        if (!cveId) continue;

        const q = query(collection(db, 'vulnerabilities'), where('id', '==', cveId));
        const snap = await getDocs(q);

        if (snap.empty) {
          const severity = item?.cve?.metrics?.cvssMetricV31?.[0]?.cvssData?.baseSeverity || 'UNKNOWN';
          const techs = ['Node.js', 'React', 'PHP', 'Python', 'Java'];
          const affected = techs.filter(t => desc.toLowerCase().includes(t.toLowerCase()));

          const vulnDoc = {
            id: cveId,
            description: desc,
            severity,
            category,
            tech: affected,
            timestamp: new Date(item?.published || item?.cve?.published || Date.now()),
          };

          await addDoc(collection(db, 'vulnerabilities'), vulnDoc);
        }
      }
      setFetchStatus({ loading: false, error: null });
    } catch (e) {
      setFetchStatus({ loading: false, error: e.message });
      console.error('Fetch error:', e);
    }
  }, []);

  useEffect(() => {
    const q = query(collection(db, 'vulnerabilities'), orderBy('timestamp', 'desc'));
    const unsub = onSnapshot(q, (snap) => {
      const d = snap.docs.map(x => ({ ...x.data(), docId: x.id, timestamp: x.data().timestamp.toDate() }));
      if (d.length === 0) fetchVulnerabilities();
      setVulns(d);
      setLoading(false);
    }, (err) => {
      console.error('Firestore listen error:', err);
      setLoading(false);
    });
    const intid = setInterval(fetchVulnerabilities, 30 * 60 * 1000);
    return () => {
      unsub();
      clearInterval(intid);
    };
  }, [fetchVulnerabilities]);

  const dashData = useMemo(() => {
    const counts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, UNKNOWN: 0 };
    const cats = {};
    const techSet = new Set();
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    vulns.forEach(v => {
      counts[v.severity] = (counts[v.severity] || 0) + 1;
      cats[v.category] = (cats[v.category] || 0) + 1;
      (v.tech || []).forEach(t => techSet.add(t));
    });
    const todaysCriticals = vulns.filter(v => v.severity === 'CRITICAL' && v.timestamp >= today);
    const trending = Object.entries(cats).sort((a, b) => b[1] - a[1]).slice(0, 3).map(([k, v]) => ({ category: k, count: v }));
    return { counts, cats, techs: Array.from(techSet), todaysCriticals, trending };
  }, [vulns]);

  if (loading) return (<div>Loading...</div>);

  return (
    <div>
      <h1>OWASP Top 10 Vulnerability Dashboard</h1>
      <button onClick={fetchVulnerabilities} disabled={fetchStatus.loading}>{fetchStatus.loading ? 'Refreshing...' : 'Refresh'}</button>
      {fetchStatus.error && <span style={{ color: 'red' }}>{fetchStatus.error}</span>}
      <h2>Severity Counts</h2>
      {Object.entries(dashData.counts).map(([k, v]) => <p key={k}>{k}: {v}</p>)}
      <h2>Trending Categories</h2>
      {dashData.trending.length ? dashData.trending.map(tc => <p key={tc.category}>{tc.category}: {tc.count}</p>) : <p>Loading Categories...</p>}
      <h2>Technologies Affected</h2>
      <p>{dashData.techs.length ? dashData.techs.join(', ') : 'None'}</p>
      <h2>Today's Critical Alerts</h2>
      {dashData.todaysCriticals.length ?
        dashData.todaysCriticals.map(({ id, category, description }) =>
          <div key={id}><b>{category}</b>: {id}<p>{description}</p></div>
        )
        : <p>None Today</p>
      }
      <h2>Recent Vulnerabilities</h2>
      {vulns.length ?
        vulns.map(({ id, category, description, severity, tech, timestamp }) =>
          <div key={id}>
            <b>{category}</b>: {id}
            <p>{description}</p>
            <small>Severity: {severity}</small><br />
            <small>Technology: {tech && tech.length ? tech.join(', ') : 'N/A'}</small><br />
            <small>Date: {timestamp?.toLocaleString ? timestamp.toLocaleString() : String(timestamp)}</small>
          </div>
        ) : <p>Loading...</p>
      }
    </div>
  );
};

export default VulnerabilityFeed;
