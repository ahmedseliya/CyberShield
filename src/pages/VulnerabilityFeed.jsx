import React, { useEffect, useState, useMemo, useCallback } from 'react';
import { db } from '../firebaseConfig';
import {
  collection,
  onSnapshot,
  query,
  orderBy,
  addDoc,
  getDocs,
  where
} from 'firebase/firestore';

// ‚úÖ Use the FULL URL of your deployed Netlify Function.
const PROXY_FUNCTION_URL = "https://bejewelled-cobbler-ebae5a.netlify.app/.netlify/functions/getVulnerabilities";

// OWASP Categories for mapping
const owaspCategories = {
  A01: ['access control', 'authorization'],
  A02: ['encryption', 'ssl', 'tls', 'cryptographic'],
  A03: ['sql injection', 'xss', 'command injection', 'cross-site scripting'],
  A04: ['insecure design', 'business logic'],
  A05: ['security misconfiguration', 'misconfiguration'],
  A06: ['vulnerable component', 'dependency', 'third-party library'],
  A07: ['broken authentication', 'jwt', 'session'],
  A08: ['ssrf', 'server-side request forgery'],
  A09: ['logging', 'monitoring', 'insufficient logging'],
  A10: ['unsafe consumption of apis']
};

const categorizeOWASP = (desc) => {
  if (!desc) return 'Uncategorized';
  const lowerDesc = desc.toLowerCase();
  for (const category in owaspCategories) {
    if (owaspCategories[category].some(word => lowerDesc.includes(word))) {
      return category;
    }
  }
  return 'Uncategorized';
};

const VulnerabilityFeed = () => {
  const [vulns, setVulns] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [fetchStatus, setFetchStatus] = useState({ loading: false, error: null });

  const refreshCVEs = useCallback(async () => {
    setFetchStatus({ loading: true, error: null });
    try {
      const response = await fetch(PROXY_FUNCTION_URL);
      if (!response.ok) throw new Error(`Proxy Function Error: ${response.status}`);

      const data = await response.json();

      for (const item of data.data || []) {
        // Defensive description access
        const description = item.cve?.descriptions?.find(d => d.lang === 'en')?.value || 'No description available.';
        const category = categorizeOWASP(description);

        if (category === 'Uncategorized') continue;

        const cveId = item.cve?.id;
        if (!cveId) continue;

        const q = query(collection(db, 'vulnerabilities'), where("id", "==", cveId));
        const querySnapshot = await getDocs(q);

        if (querySnapshot.empty) {
          const newDoc = {
            id: cveId,
            description: description,
            severity: item.cve?.metrics?.cvssMetricV31?.[0]?.cvssData?.baseSeverity || 'UNKNOWN',
            category: category,
            tech: ['Node.js', 'React', 'PHP', 'Python', 'Java'].filter(
              tech => (description?.toLowerCase() || '').includes(tech.toLowerCase())
            ),
            // Defensive timestamp
            timestamp: new Date(item.cve?.published || Date.now()),
          };
          await addDoc(collection(db, 'vulnerabilities'), newDoc);
        }
      }
      setFetchStatus({ loading: false, error: null });
    } catch (err) {
      console.error("Failed to refresh CVEs:", err);
      setFetchStatus({ loading: false, error: err.message });
    }
  }, []);

  useEffect(() => {
    const q = query(collection(db, "vulnerabilities"), orderBy("timestamp", "desc"));
    const unsubscribe = onSnapshot(q, (snapshot) => {
      const data = snapshot.docs.map(doc => ({
        ...doc.data(),
        docId: doc.id,
        timestamp: doc.data().timestamp.toDate ? doc.data().timestamp.toDate() : new Date(doc.data().timestamp)
      }));

      if (data.length === 0 && !isLoading) {
        refreshCVEs();
      }

      setVulns(data);
      setIsLoading(false);
    }, (err) => {
      console.error("Firestore listener error: ", err);
      setIsLoading(false);
    });

    const intervalId = setInterval(refreshCVEs, 30 * 60 * 1000);

    return () => {
      unsubscribe();
      clearInterval(intervalId);
    };
  }, [isLoading, refreshCVEs]);

  const dashboardData = useMemo(() => {
    const severityCounts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, UNKNOWN: 0 };
    const categoryCounts = {};
    let affectedTech = new Set();
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    vulns.forEach(v => {
      if (v.severity) severityCounts[v.severity]++;
      if (v.category) categoryCounts[v.category] = (categoryCounts[v.category] || 0) + 1;
      (v.tech || []).forEach(t => affectedTech.add(t));
    });

    const todaysCriticalAlerts = vulns.filter(v => v.severity === 'CRITICAL' && v.timestamp >= today);
    const trendingCategories = Object.entries(categoryCounts)
      .sort(([,a],[,b]) => b - a)
      .slice(0, 3)
      .map(([category, count]) => ({ category, count }));

    return {
      severityCounts,
      todaysCriticalAlerts,
      trendingCategories,
      affectedTech: Array.from(affectedTech)
    };
  }, [vulns]);
  
  if (isLoading) {
    return <div className="loading-container"><h2>Initializing Dashboard...</h2></div>;
  }

  return (
    <div className="feed-container">
      <header className="dashboard-header">
        <h1>üîê OWASP Top 10 Vulnerability Dashboard</h1>
        <div className="status-bar">
          <button onClick={refreshCVEs} disabled={fetchStatus.loading}>
            {fetchStatus.loading ? 'Refreshing...' : 'Refresh Now'}
          </button>
          {fetchStatus.error && <span className="error-toast">‚ö†Ô∏è {fetchStatus.error}</span>}
        </div>
      </header>

      <div className="metrics-grid">
        <div className="metric-card">
          <h3>Severity Meters</h3>
          <div className="severity-meters">
            {Object.entries(dashboardData.severityCounts).map(([level, count]) => (
              <div key={level} className="meter">
                <span className="meter-label">{level}</span>
                <span className={`meter-count severity-${level.toLowerCase()}`}>{count}</span>
              </div>
            ))}
          </div>
        </div>
        <div className="metric-card">
          <h3>üî• Trending Exploits</h3>
          <div className="trending-list">
            {dashboardData.trendingCategories.length > 0 ? (
              dashboardData.trendingCategories.map(item => (
                <div key={item.category}>{item.category} ({item.count} alerts)</div>
              ))
            ) : <p>Awaiting new trend data...</p>}
          </div>
        </div>
        <div className="metric-card">
          <h3>üõ† Affected Technologies</h3>
          <div className="tech-tags">
            {dashboardData.affectedTech.length > 0 ? dashboardData.affectedTech.map(t => <span key={t} className="tech-tag">{t}</span>) : 'None detected'}
          </div>
        </div>
      </div>
      <div className="critical-alerts">
        <h2>üî¥ Today's Critical Alerts</h2>
        <div className="vuln-list">
          {dashboardData.todaysCriticalAlerts.length > 0 ? (
            dashboardData.todaysCriticalAlerts.map(v => (
              <div key={v.docId || v.id} className={`vuln-box severity-critical`}>
                <h3>{v.category}: {v.id}</h3>
                <p>{v.description}</p>
              </div>
            ))
          ) : <p className="empty-state">No critical OWASP alerts published in the last 24 hours.</p>}
        </div>
      </div>
      <h2>Recent OWASP Vulnerability Feed</h2>
      <div className="vuln-list">
        {vulns.length > 0 ? (
          vulns.map((v) => (
            <div key={v.docId || v.id} className={`vuln-box severity-${(v.severity || 'unknown').toLowerCase()}`}>
              <h3>{v.category}: {v.id}</h3>
              <p>{v.description}</p>
              <p><strong>Severity:</strong> <span className={`severity-${(v.severity || 'unknown').toLowerCase()}`}>{v.severity}</span></p>
              <p><strong>Tech:</strong> {v.tech && v.tech.length ? v.tech.join(', ') : 'N/A'}</p>
              <p><em>Disclosed: {v.timestamp && v.timestamp.toLocaleString ? v.timestamp.toLocaleString() : String(v.timestamp)}</em></p>
            </div>
          ))
        ) : <p className="empty-state">No data available. The first automatic fetch is in progress...</p>}
      </div>
    </div>
  );
};

export default VulnerabilityFeed;
