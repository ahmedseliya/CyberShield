const admin = require('firebase-admin');
const axios = require('axios');
const cron = require('node-cron');
const fs = require('fs');
const path = require('path');

// Load environment variables from .env file
require('dotenv').config();

// Initialize Firebase Admin
const serviceAccount = require('./serviceAccountKey.json');
admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
  databaseURL: `https://${serviceAccount.project_id}.firebaseio.com`
});

// Gemini API Configuration
const GEMINI_API_KEY = process.env.GEMINI_API_KEY || 'AIzaSyBZw2qQJ8oGH9-OoRZnzuvWPaTtUlhomCc';
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent';

console.log('üîß Cybersecurity Quiz Generator - Local Version');
console.log('===============================================\n');

// Master list of cybersecurity topics organized by categories (25 categories)
const CYBERSECURITY_TOPICS_BY_CATEGORY = [
  // Category 1: Network Security
  [
    "Firewalls and their types", "Intrusion Detection Systems (IDS)", "Intrusion Prevention Systems (IPS)",
    "Network segmentation", "VPN technologies", "Wireless security (WPA2/WPA3)", "Network Access Control (NAC)",
    "DNS security", "Email security protocols", "VoIP security", "SD-WAN security", "Zero Trust Network Architecture",
    "Network traffic analysis", "Honeypots and honeynets", "DDoS protection mechanisms", "Network Address Translation (NAT)",
    "Port security", "Virtual LANs (VLANs)", "Quality of Service (QoS) security", "Network Time Protocol (NTP) security",
    "IPSec configuration", "Remote Access Service (RAS) security", "Network encryption protocols", "Load balancer security",
    "Proxy server security", "Network monitoring tools", "Bandwidth management security", "Network redundancy and failover",
    "Network authentication protocols", "Wireless intrusion prevention"
  ],
  
  // Category 2: Cryptography
  [
    "Symmetric encryption algorithms", "Asymmetric encryption algorithms", "Hash functions and their applications",
    "Digital signatures", "Public Key Infrastructure (PKI)", "SSL/TLS handshake process", "Cryptographic key management",
    "Quantum cryptography", "Post-quantum cryptography", "Cryptographic attacks", "Blockchain security",
    "Homomorphic encryption", "Steganography", "Cryptographic protocols", "Certificate authorities", "Key exchange protocols",
    "Cryptographic randomness", "Cryptographic hash collisions", "Elliptic Curve Cryptography (ECC)", "Digital certificates",
    "Certificate revocation", "Cryptographic API security", "Side-channel attacks", "Cryptographic agility",
    "Cryptographic implementation best practices", "Cryptographic protocol analysis", "Cryptographic hardware security",
    "Cryptographic algorithm selection", "Cryptographic performance optimization", "Cryptographic compliance standards"
  ],
  
  // Category 3: Web Security
  [
    "OWASP Top 10 vulnerabilities", "Cross-Site Scripting (XSS)", "Cross-Site Request Forgery (CSRF)",
    "SQL Injection prevention", "XML External Entity (XXE) attacks", "Security misconfigurations",
    "Insecure deserialization", "API security best practices", "Web Application Firewalls (WAF)",
    "Content Security Policy (CSP)", "Same-Origin Policy", "CORS implementation", "JWT security",
    "Session management security", "Clickjacking protection", "File inclusion vulnerabilities",
    "Command injection prevention", "Server-Side Request Forgery (SSRF)", "WebSockets security",
    "Browser security features", "HTTP security headers", "Subresource Integrity (SRI)", "Mixed content issues",
    "Web cache poisoning", "HTTP request smuggling", "DNS rebinding attacks", "Client-side storage security",
    "Progressive Web App (PWA) security", "WebAssembly security", "Third-party script security"
  ],
  
  // Category 4: Application Security
  [
    "Secure coding practices", "Static Application Security Testing (SAST)", "Dynamic Application Security Testing (DAST)",
    "Software composition analysis", "DevSecOps practices", "Container security", "Kubernetes security",
    "CI/CD pipeline security", "Threat modeling", "Secure SDLC", "Code review security", "Dependency management",
    "Secrets management", "Infrastructure as Code security", "API gateway security", "Input validation techniques",
    "Output encoding methods", "Error handling security", "Logging and monitoring in applications",
    "Memory management security", "Buffer overflow prevention", "Integer overflow vulnerabilities",
    "Race condition prevention", "Thread safety in applications", "Secure file upload handling",
    "Cryptography in applications", "Secure session handling", "Authentication bypass prevention",
    "Authorization enforcement", "Secure configuration management"
  ],
  
  // Category 5: Cloud Security
  [
    "Cloud security shared responsibility model", "Identity and Access Management (IAM) in cloud",
    "Cloud data encryption", "Cloud security posture management", "Cloud workload protection",
    "Serverless security", "Cloud-native security", "Multi-cloud security strategies",
    "Cloud compliance frameworks", "Cloud security monitoring", "Container security in cloud",
    "Cloud network security", "Cloud data loss prevention", "Cloud penetration testing", "CASB solutions",
    "Cloud security groups and NACLs", "Cloud logging and auditing", "Cloud key management services",
    "Cloud security automation", "Cloud vulnerability management", "Cloud incident response",
    "Cloud backup and recovery security", "Cloud migration security", "Cloud cost management security",
    "Cloud vendor risk management", "Cloud security architecture", "Cloud security policies",
    "Cloud security training", "Cloud security certifications", "Cloud security benchmarking"
  ],
  
  // Category 6: Incident Response & Forensics
  [
    "Incident response lifecycle", "Digital forensics process", "Malware analysis techniques",
    "Memory forensics", "Network forensics", "Incident containment strategies", "Threat intelligence utilization",
    "Security Information and Event Management (SIEM)", "Security Orchestration, Automation and Response (SOAR)",
    "Endpoint Detection and Response (EDR)", "Forensic data collection", "Chain of custody",
    "Incident reporting", "Post-incident analysis", "Cyber kill chain model", "Incident classification",
    "Digital evidence preservation", "Forensic timeline analysis", "Malware reverse engineering",
    "Network packet analysis", "Log analysis techniques", "Incident response team management",
    "Incident communication plans", "Forensic tool selection", "Evidence acquisition methods",
    "Legal considerations in forensics", "Regulatory reporting requirements", "Incident simulation exercises",
    "Forensic report writing", "Incident metrics and KPIs"
  ],
  
  // Category 7: Governance, Risk & Compliance
  [
    "NIST Cybersecurity Framework", "ISO 27001 standards", "GDPR compliance requirements",
    "HIPAA security rules", "PCI DSS compliance", "Risk assessment methodologies", "Security policies development",
    "Third-party risk management", "Business continuity planning", "Disaster recovery planning",
    "Security awareness training", "Compliance auditing", "Vendor security assessment", "Data classification",
    "Privacy by design principles", "SOX compliance", "GLBA requirements", "FISMA compliance",
    "CMMC certification", "Risk management frameworks", "Security control assessment",
    "Compliance monitoring", "Policy enforcement mechanisms", "Regulatory change management",
    "Compliance reporting", "Audit trail requirements", "Evidence of compliance", "Compliance automation",
    "Compliance training programs", "Compliance metrics and reporting"
  ],
  
  // Category 8: Emerging Technologies
  [
    "IoT security challenges", "Industrial Control Systems (ICS) security", "SCADA security",
    "Automotive cybersecurity", "Medical device security", "Smart city security", "5G network security",
    "Edge computing security", "AI/ML security concerns", "Quantum computing security implications",
    "Biometric authentication systems", "Blockchain security applications", "Augmented Reality security",
    "Virtual Reality security", "Space systems cybersecurity", "Robotics security",
    "Drone security considerations", "Wearable technology security", "Smart home security",
    "Connected vehicle security", "Digital twin security", "Extended Reality (XR) security",
    "Neuromorphic computing security", "DNA data storage security", "Smart grid security",
    "Industrial IoT security", "Agricultural technology security", "Maritime technology security",
    "Aviation technology security", "Satellite communication security"
  ],
  
  // Category 9: Social Engineering & Human Factors
  [
    "Phishing techniques and prevention", "Social engineering attack vectors", "Insider threat detection",
    "Security awareness training methods", "Human behavior in cybersecurity", "Psychological aspects of security",
    "Physical security measures", "Whistleblower protection", "Security culture development",
    "Human error in security breaches", "Biometric security systems", "Behavioral analytics",
    "User authentication psychology", "Security policy compliance", "Gamification in security training",
    "Social media security risks", "Pretexting attacks", "Baiting techniques", "Quid pro quo attacks",
    "Tailgating prevention", "Shoulder surfing protection", "Vishing (voice phishing)",
    "Smishing (SMS phishing)", "Watering hole attacks", "Influence and persuasion techniques",
    "Security awareness metrics", "Training effectiveness measurement", "Security champion programs",
    "Behavior change methodologies", "Security culture assessment"
  ],
  
  // Category 10: Mobile & Endpoint Security
  [
    "Mobile device management (MDM)", "Mobile application security", "Endpoint protection platforms",
    "Mobile threat defense", "BYOD security policies", "iOS vs Android security", "Mobile malware analysis",
    "Mobile encryption techniques", "Remote wipe capabilities", "Mobile VPN implementation",
    "Containerization for mobile security", "Mobile biometric authentication", "Mobile payment security",
    "IoT device security", "Wearable technology security", "Mobile browser security",
    "Mobile operating system hardening", "Mobile app store security", "Mobile device encryption",
    "Mobile backup security", "Mobile network security", "Mobile messaging security",
    "Mobile email security", "Mobile banking security", "Mobile health app security",
    "Mobile gaming security", "Mobile advertising security", "Mobile location privacy",
    "Mobile device forensics", "Mobile security testing"
  ],

  // Category 11: Data Security & Privacy
  [
    "Data classification schemes", "Data encryption at rest", "Data encryption in transit",
    "Data masking techniques", "Data anonymization methods", "Data retention policies",
    "Data destruction procedures", "Data loss prevention (DLP)", "Data privacy regulations",
    "Data sovereignty requirements", "Data backup security", "Data archiving security",
    "Database security best practices", "Big data security", "Data warehouse security",
    "Data lake security", "Data governance frameworks", "Data quality security",
    "Data lineage tracking", "Data catalog security", "Data sharing security",
    "Data monetization security", "Data analytics security", "Data science security",
    "Data pipeline security", "Data streaming security", "Data replication security",
    "Data synchronization security", "Data migration security", "Data compliance monitoring"
  ],

  // Category 12: Identity & Access Management
  [
    "Single Sign-On (SSO) implementation", "Multi-Factor Authentication (MFA)", "Privileged Access Management (PAM)",
    "Identity lifecycle management", "Role-Based Access Control (RBAC)", "Attribute-Based Access Control (ABAC)",
    "Identity federation standards", "Directory services security", "Identity proofing methods",
    "Authentication protocols comparison", "Authorization frameworks", "Identity governance",
    "Access certification processes", "Just-In-Time (JIT) access", "Zero Trust identity principles",
    "Password management policies", "Passwordless authentication", "Biometric authentication systems",
    "Behavioral authentication", "Context-aware authentication", "Risk-based authentication",
    "Identity analytics", "Identity threat detection", "Identity as a Service (IDaaS)",
    "Decentralized identity", "Self-sovereign identity", "Identity verification services",
    "Credential management", "Session management security", "Access revocation procedures"
  ],

  // Category 13: Threat Intelligence & Hunting
  [
    "Threat intelligence frameworks", "Threat hunting methodologies", "Indicators of Compromise (IOCs)",
    "Tactics, Techniques, and Procedures (TTPs)", "Threat intelligence platforms", "Open Source Intelligence (OSINT)",
    "Dark web monitoring", "Threat intelligence sharing", "Threat modeling techniques",
    "Adversary emulation", "Red team exercises", "Purple team operations",
    "Threat intelligence lifecycle", "Threat actor profiling", "Campaign analysis",
    "Malware analysis platforms", "Threat intelligence feeds", "Threat intelligence automation",
    "Strategic threat intelligence", "Operational threat intelligence", "Tactical threat intelligence",
    "Threat intelligence quality assessment", "Threat landscape analysis", "Emerging threat research",
    "Vulnerability intelligence", "Exploit intelligence", "Threat intelligence reporting",
    "Threat intelligence integration", "Threat prediction models", "Threat intelligence metrics"
  ],

  // Category 14: Vulnerability Management
  [
    "Vulnerability assessment tools", "Vulnerability scanning techniques", "Penetration testing methodologies",
    "Vulnerability prioritization frameworks", "Patch management processes", "Vulnerability disclosure programs",
    "Common Vulnerability Scoring System (CVSS)", "Vulnerability remediation strategies",
    "Vulnerability tracking systems", "Zero-day vulnerability management", "Vulnerability research",
    "Fuzzing techniques", "Source code analysis", "Binary analysis", "Web application scanning",
    "Network vulnerability scanning", "Mobile application scanning", "Container vulnerability scanning",
    "Cloud vulnerability assessment", "IoT vulnerability testing", "SCADA vulnerability assessment",
    "Vulnerability validation", "Exploit development", "Vulnerability mitigation controls",
    "Vulnerability reporting", "Vulnerability metrics", "Vulnerability management automation",
    "Vulnerability assessment reports", "Remediation verification", "Continuous vulnerability assessment"
  ],

  // Category 15: Security Architecture
  [
    "Security architecture frameworks", "Defense in depth principles", "Security design patterns",
    "Reference security architectures", "Security zoning concepts", "Network segmentation strategies",
    "Microsegmentation implementation", "Secure network design", "Secure system architecture",
    "Application security architecture", "Cloud security architecture", "Zero Trust architecture",
    "Software Defined Perimeter (SDP)", "Secure API architecture", "Identity architecture",
    "Data security architecture", "Endpoint security architecture", "Security service chaining",
    "Security orchestration architecture", "Security monitoring architecture", "Incident response architecture",
    "Disaster recovery architecture", "Business continuity architecture", "Compliance architecture",
    "Privacy by design architecture", "Security automation architecture", "Threat intelligence architecture",
    "Security analytics architecture", "Security governance architecture", "Security architecture review"
  ],

  // Category 16: Security Operations
  [
    "Security Operations Center (SOC) setup", "SOC team roles and responsibilities", "SOC processes and procedures",
    "Security monitoring tools", "Security alert triage", "Security incident ticketing",
    "Security workflow automation", "Security playbooks development", "Security runbooks creation",
    "Security metrics and reporting", "Security dashboard design", "Security operations analytics",
    "Security tool integration", "Security operations maturity", "SOC staffing models",
    "SOC shift management", "SOC training programs", "SOC technology stack",
    "SOC performance metrics", "SOC cost optimization", "SOC incident response coordination",
    "SOC threat hunting operations", "SOC vulnerability management coordination", "SOC compliance monitoring",
    "SOC reporting requirements", "SOC tool evaluation", "SOC process improvement",
    "SOC automation strategies", "SOC cloud operations", "SOC managed services"
  ],

  // Category 17: Physical Security
  [
    "Physical access control systems", "Surveillance system security", "Perimeter security measures",
    "Building security design", "Data center physical security", "Server room security",
    "Network closet security", "Equipment security measures", "Asset tracking systems",
    "Physical security audits", "Visitor management systems", "Employee access controls",
    "Security guard operations", "Physical security monitoring", "Environmental controls security",
    "Power supply security", "Cooling system security", "Fire suppression system security",
    "Physical intrusion detection", "Physical security policies", "Physical security training",
    "Physical security incident response", "Physical security risk assessment", "Physical security compliance",
    "Physical security technology", "Physical security integration", "Physical security maintenance",
    "Physical security testing", "Physical security metrics", "Physical security improvement"
  ],

  // Category 18: Business Continuity & Disaster Recovery
  [
    "Business Impact Analysis (BIA)", "Recovery Time Objective (RTO)", "Recovery Point Objective (RPO)",
    "Disaster recovery planning", "Business continuity planning", "Crisis management planning",
    "Emergency response procedures", "Disaster recovery testing", "Business continuity testing",
    "Backup strategies and solutions", "Data replication techniques", "Failover systems design",
    "High availability systems", "Disaster recovery sites", "Cloud disaster recovery",
    "Disaster recovery automation", "Business continuity coordination", "Crisis communication plans",
    "Disaster recovery metrics", "Business continuity metrics", "Recovery procedures documentation",
    "Disaster recovery team management", "Business continuity team roles", "Disaster recovery tools",
    "Business continuity software", "Disaster recovery compliance", "Business continuity regulations",
    "Disaster recovery budgets", "Business continuity costs", "Disaster recovery improvement"
  ],

  // Category 19: Security Awareness & Training
  [
    "Security awareness program development", "Security training curriculum design", "Phishing simulation programs",
    "Security awareness metrics", "Training effectiveness measurement", "Security culture assessment",
    "Role-based security training", "Executive security awareness", "Employee security training",
    "Contractor security training", "Vendor security training", "Security awareness campaigns",
    "Gamified security training", "Interactive security training", "Security training platforms",
    "Security awareness materials", "Security policy training", "Incident reporting training",
    "Social engineering defense training", "Password security training", "Data protection training",
    "Mobile security training", "Remote work security training", "Travel security training",
    "Physical security awareness", "Compliance training requirements", "Security training scheduling",
    "Training record management", "Security training evaluation", "Continuous security education"
  ],

  // Category 20: Risk Management
  [
    "Risk assessment methodologies", "Risk analysis techniques", "Risk evaluation criteria",
    "Risk treatment options", "Risk mitigation strategies", "Risk transfer methods",
    "Risk acceptance criteria", "Risk monitoring processes", "Risk reporting frameworks",
    "Risk management frameworks", "Enterprise Risk Management (ERM)", "Cybersecurity risk management",
    "Third-party risk management", "Supply chain risk management", "Cloud risk assessment",
    "IoT risk assessment", "AI/ML risk assessment", "Operational risk management",
    "Strategic risk management", "Compliance risk management", "Financial risk management",
    "Reputational risk management", "Risk quantification methods", "Risk appetite definition",
    "Risk tolerance levels", "Risk management tools", "Risk management automation",
    "Risk management metrics", "Risk management reporting", "Risk management improvement"
  ],

  // Category 21: Compliance & Auditing
  [
    "Compliance framework implementation", "Audit planning and preparation", "Audit evidence collection",
    "Audit finding documentation", "Remediation tracking", "Compliance monitoring",
    "Regulatory change tracking", "Compliance reporting", "Audit trail management",
    "Evidence of compliance", "Compliance automation tools", "Continuous compliance monitoring",
    "Compliance risk assessment", "Compliance training programs", "Compliance documentation",
    "Policy compliance monitoring", "Procedure compliance verification", "Control testing methodologies",
    "Compliance gap analysis", "Remediation planning", "Exception management",
    "Compliance dashboard development", "Compliance metrics definition", "Audit committee reporting",
    "Regulatory examination preparation", "Certification maintenance", "Compliance program assessment",
    "Compliance maturity assessment", "Compliance program improvement", "Compliance cost management"
  ],

  // Category 22: Security Testing
  [
    "Penetration testing methodologies", "Red team operations", "Blue team defense strategies",
    "Purple team collaboration", "Security assessment types", "Application security testing",
    "Network security testing", "Wireless security testing", "Social engineering testing",
    "Physical security testing", "Cloud security testing", "Mobile security testing",
    "IoT security testing", "API security testing", "Container security testing",
    "DevSecOps testing integration", "Continuous security testing", "Automated security testing",
    "Manual security testing", "Testing tool selection", "Testing scope definition",
    "Testing methodology selection", "Testing reporting standards", "Remediation verification testing",
    "Retesting procedures", "Testing frequency determination", "Testing team management",
    "Testing quality assurance", "Testing metrics collection", "Testing program improvement"
  ],

  // Category 23: Security Automation
  [
    "Security orchestration platforms", "Security automation tools", "Workflow automation design",
    "Playbook automation", "Incident response automation", "Threat hunting automation",
    "Vulnerability management automation", "Compliance automation", "Security reporting automation",
    "Alert correlation automation", "Threat intelligence automation", "Security tool integration",
    "API integration security", "Scripting for security automation", "No-code/low-code security automation",
    "Machine learning in security automation", "Automation testing procedures", "Automation deployment strategies",
    "Automation maintenance", "Automation documentation", "Automation risk assessment",
    "Automation error handling", "Automation monitoring", "Automation performance optimization",
    "Automation scalability", "Automation security", "Automation governance",
    "Automation cost analysis", "Automation ROI calculation", "Automation program management"
  ],

  // Category 24: Legal & Ethical Cybersecurity
  [
    "Cybersecurity laws and regulations", "Digital privacy laws", "Data protection regulations",
    "Intellectual property in cybersecurity", "Cybersecurity insurance", "Legal aspects of incident response",
    "Forensic evidence legality", "Electronic discovery (eDiscovery)", "Expert witness testimony",
    "Cybersecurity contracts", "Service Level Agreements (SLAs)", "Vendor contract security clauses",
    "Legal hold procedures", "Regulatory investigation response", "Law enforcement cooperation",
    "International cybersecurity laws", "Cross-border data transfer regulations", "Whistleblower protection laws",
    "Employee monitoring legality", "Background check regulations", "Non-disclosure agreements (NDAs)",
    "Security research legality", "Bug bounty program legality", "Responsible disclosure policies",
    "Ethical hacking guidelines", "Professional ethics in cybersecurity", "Conflict of interest management",
    "Compliance with ethical standards", "Legal risk management", "Cybersecurity litigation"
  ],

  // Category 25: Career Development in Cybersecurity
  [
    "Cybersecurity career paths", "Certification roadmaps", "Skill development strategies",
    "Cybersecurity education programs", "Training and certification options", "Career advancement strategies",
    "Networking in cybersecurity", "Professional organizations", "Conference participation",
    "Cybersecurity competitions", "Bug bounty programs", "Capture The Flag (CTF) competitions",
    "Mentorship programs", "Continuing education requirements", "Professional development planning",
    "Cybersecurity job market trends", "Salary negotiation in cybersecurity", "Interview preparation",
    "Resume building for cybersecurity", "Portfolio development", "Specialization options",
    "Leadership development in cybersecurity", "Management skills for security professionals",
    "Communication skills development", "Presentation skills for security professionals",
    "Writing skills for security documentation", "Team building in security teams",
    "Cross-functional collaboration", "Industry trend analysis", "Future skills in cybersecurity"
  ]
];

// History file to track used topics
const HISTORY_FILE = 'topic_history.json';

// Load topic usage history
function loadTopicHistory() {
  try {
    if (fs.existsSync(HISTORY_FILE)) {
      const history = JSON.parse(fs.readFileSync(HISTORY_FILE, 'utf8'));
      
      // Initialize categoryIndex if not present
      if (history.categoryIndex === undefined) {
        history.categoryIndex = Array(CYBERSECURITY_TOPICS_BY_CATEGORY.length).fill(0);
      }
      
      // Initialize totalRuns if not present
      if (history.totalRuns === undefined) {
        history.totalRuns = 0;
      }
      
      console.log(`üìö Loaded history: Run #${history.totalRuns || 0}`);
      console.log(`üìä Category indices: ${history.categoryIndex?.join(', ') || '0'.repeat(25).split('').join(',')}`);
      return history;
    }
  } catch (error) {
    console.log('üìö Starting fresh topic history');
  }
  return { 
    categoryIndex: Array(CYBERSECURITY_TOPICS_BY_CATEGORY.length).fill(0),
    totalRuns: 0 
  };
}

// Save topic history
function saveTopicHistory(history) {
  try {
    fs.writeFileSync(HISTORY_FILE, JSON.stringify(history, null, 2));
    console.log(`üíæ Saved history: Run #${history.totalRuns}`);
  } catch (error) {
    console.log('‚ö†Ô∏è Could not save topic history');
  }
}

// Reset topic history
function resetTopicHistory() {
  const freshHistory = {
    categoryIndex: Array(CYBERSECURITY_TOPICS_BY_CATEGORY.length).fill(0),
    totalRuns: 0
  };
  
  saveTopicHistory(freshHistory);
  console.log('‚úÖ Topic history reset to fresh start');
  console.log('üìä All category indices set to 0');
  console.log('üìä Total runs set to 0');
}

// Get next batch of topics (6 from 25 categories with specific rotation pattern)
function getNextTopicsBatch() {
  const history = loadTopicHistory();
  const selectedTopics = [];
  const runNumber = history.totalRuns || 0;
  
  console.log(`\nüîÑ Round-robin selection (Run #${runNumber})`);
  
  // Pattern logic:
  // Groups of 5 runs: 
  // - First 4 runs: 6 consecutive categories, first concept from each
  // - 5th run: category 25 (first concept) + categories 1-5 (second concept)
  
  const conceptLevel = Math.floor(runNumber / 5); // 0 = first concept, 1 = second concept, etc.
  const runInGroup = runNumber % 5; // 0-4 within each group of 5
  
  if (runInGroup < 4) {
    // First 4 runs in group: 6 consecutive categories
    const startCategory = (runInGroup * 6) % 25;
    
    console.log(`üìä Concept Level: ${conceptLevel + 1}`);
    console.log(`üìä Position in group: ${runInGroup + 1}/5`);
    console.log(`üìä Starting at category: ${startCategory + 1}`);
    
    // Get 6 topics from consecutive categories
    for (let i = 0; i < 6; i++) {
      const categoryIndex = (startCategory + i) % 25;
      const categoryTopics = CYBERSECURITY_TOPICS_BY_CATEGORY[categoryIndex];
      const currentTopicIndex = history.categoryIndex[categoryIndex] || 0;
      
      // Use concept level (0 = first, 1 = second, etc.)
      const topicIndex = (currentTopicIndex + conceptLevel) % categoryTopics.length;
      const selectedTopic = categoryTopics[topicIndex];
      
      selectedTopics.push({
        topic: selectedTopic,
        categoryIndex: categoryIndex,
        topicIndex: topicIndex,
        conceptLevel: conceptLevel
      });
      
      console.log(`  Category ${categoryIndex + 1}: ${selectedTopic} (Concept: ${conceptLevel + 1}, Index: ${topicIndex})`);
    }
  } else {
    // 5th run: category 25 + categories 1-5
    console.log(`üìä Concept Level: ${conceptLevel + 1} (Special 5th run pattern)`);
    console.log(`üìä Position in group: 5/5`);
    
    // Category 25 (index 24) - use conceptLevel
    const cat25Index = 24;
    const cat25Topics = CYBERSECURITY_TOPICS_BY_CATEGORY[cat25Index];
    const cat25CurrentIndex = history.categoryIndex[cat25Index] || 0;
    const cat25TopicIndex = (cat25CurrentIndex + conceptLevel) % cat25Topics.length;
    const cat25SelectedTopic = cat25Topics[cat25TopicIndex];
    
    selectedTopics.push({
      topic: cat25SelectedTopic,
      categoryIndex: cat25Index,
      topicIndex: cat25TopicIndex,
      conceptLevel: conceptLevel
    });
    
    console.log(`  Category 25: ${cat25SelectedTopic} (Concept: ${conceptLevel + 1}, Index: ${cat25TopicIndex})`);
    
    // Categories 1-5 (indices 0-4) - use conceptLevel + 1
    for (let i = 0; i < 5; i++) {
      const categoryIndex = i; // 0-4
      const categoryTopics = CYBERSECURITY_TOPICS_BY_CATEGORY[categoryIndex];
      const currentTopicIndex = history.categoryIndex[categoryIndex] || 0;
      
      // Use NEXT concept level for categories 1-5
      const topicIndex = (currentTopicIndex + conceptLevel + 1) % categoryTopics.length;
      const selectedTopic = categoryTopics[topicIndex];
      
      selectedTopics.push({
        topic: selectedTopic,
        categoryIndex: categoryIndex,
        topicIndex: topicIndex,
        conceptLevel: conceptLevel + 1
      });
      
      console.log(`  Category ${categoryIndex + 1}: ${selectedTopic} (Concept: ${conceptLevel + 2}, Index: ${topicIndex})`);
    }
  }
  
  console.log(`üéØ Selected ${selectedTopics.length} topics from 6 categories`);
  
  return {
    topics: selectedTopics.map(t => t.topic),
    categoryIndices: selectedTopics.map(t => t.categoryIndex),
    topicIndices: selectedTopics.map(t => t.topicIndex),
    conceptLevels: selectedTopics.map(t => t.conceptLevel),
    currentIndices: history.categoryIndex,
    runNumber: runNumber,
    runInGroup: runInGroup,
    conceptLevel: conceptLevel
  };
}

// Main function to generate quiz
async function generateQuiz() {
  let todaysTopics = [];
  let currentIndices = [];
  let selectedCategoryIndices = [];
  let selectionInfo = {};
  
  try {
   const today = new Date().toISOString().split('T')[0];
    console.log(`\nüöÄ Starting quiz generation for ${today}...`);
    
    const db = admin.firestore();
    
    // Check if quiz already exists for today - DELETE IT if exists
    const quizRef = db.collection('dailyQuizzes').doc(today);
    const existingQuiz = await quizRef.get();
    
    if (existingQuiz.exists) {
      console.log('üóëÔ∏è Deleting existing quiz for today...');
      await quizRef.delete();
    }
    
    // Get topics for today using rotation strategy
    const selection = getNextTopicsBatch();
    todaysTopics = selection.topics;
    currentIndices = selection.currentIndices;
    selectedCategoryIndices = selection.categoryIndices;
    selectionInfo = selection;
    
    console.log(`\nüìö Today's Topics:`);
    todaysTopics.forEach((topic, i) => {
      console.log(`  ${i + 1}. ${topic}`);
    });
    
    // Generate new quiz using Gemini API via axios
    console.log('\nüîÑ Generating new quiz with Gemini AI...');
    const questions = await generateQuizWithGemini(todaysTopics);
    
    if (questions.length >= 6) {
      console.log(`‚úÖ AI successfully generated ${questions.length} questions`);
    } else {
      console.log(`‚ö†Ô∏è AI only generated ${questions.length} questions, using fallback instead`);
      throw new Error(`AI only generated ${questions.length} questions, need 6`);
    }
    
    // Randomize options for each question
    const randomizedQuestions = questions.map(q => {
      const options = [...q.options];
      // Fisher-Yates shuffle
      for (let i = options.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [options[i], options[j]] = [options[j], options[i]];
      }
      
      // Find the new index of the correct answer after shuffling
      let originalCorrectIndex = -1;
      const originalCorrectOption = q.options.find(opt => opt.correct);
      if (originalCorrectOption) {
        originalCorrectIndex = q.options.indexOf(originalCorrectOption);
      }
      
      return {
        ...q,
        options: options,
        originalCorrectIndex: originalCorrectIndex,
        shuffled: true
      };
    });
    
    // Save to Firestore
    await quizRef.set({
      date: today,
      questions: randomizedQuestions,
      generatedAt: admin.firestore.FieldValue.serverTimestamp(),
      active: true,
      totalAttempts: 0,
      userAttempts: {},
      isAIgenerated: true,
      todaysTopics: todaysTopics,
      selectedCategoryIndices: selectedCategoryIndices,
      selectionRound: selection.runNumber,
      conceptLevel: selection.conceptLevel,
      runInGroup: selection.runInGroup
    });
    
    console.log(`\n‚úÖ Successfully generated quiz for ${today} with ${questions.length} questions`);
    
    // Update history AFTER successful quiz generation
    updateTopicHistory(selection);
    
    // Delete ALL old quizzes immediately (not wait 7 days)
    await deleteAllOldQuizzes(today);
    
    // Save a local backup copy
    await saveLocalBackup(today, randomizedQuestions);
    
    return {
      success: true,
      message: `Quiz generated for ${today}`,
      date: today,
      questionsCount: questions.length,
      topics: todaysTopics,
      selectionInfo: {
        runNumber: selection.runNumber,
        conceptLevel: selection.conceptLevel,
        runInGroup: selection.runInGroup
      },
      questions: randomizedQuestions.slice(0, 2),
      isAIgenerated: true
    };
    
  } catch (error) {
    console.error('\n‚ùå Error generating quiz:', error.message);
    
    // Try to create fallback quiz
    try {
      console.log('\nüîÑ Trying to create fallback quiz...');
      const fallbackResult = await createFallbackQuiz(todaysTopics, currentIndices, selectedCategoryIndices);
      
      // Update history for fallback too
      if (selectionInfo.runNumber !== undefined) {
        updateTopicHistory(selectionInfo);
      }
      
      return {
        success: true,
        message: 'Fallback quiz created',
        fallback: true,
        isAIgenerated: false
      };
    } catch (fallbackError) {
      console.error('\n‚ùå Fallback also failed:', fallbackError.message);
      return {
        success: false,
        error: error.message,
        fallbackError: fallbackError.message
      };
    }
  }
}

// Update topic history function
function updateTopicHistory(selection) {
  const history = loadTopicHistory();
  const newHistory = {
    categoryIndex: [...history.categoryIndex],
    totalRuns: (history.totalRuns || 0) + 1
  };
  
  const runNumber = history.totalRuns || 0;
  const runInGroup = runNumber % 5;
  const conceptLevel = Math.floor(runNumber / 5);
  
  console.log(`\nüìä Updating history for Run #${runNumber}...`);
  
  if (runInGroup < 4) {
    // Normal runs: 6 consecutive categories
    const startCategory = (runInGroup * 6) % 25;
    
    // Increment indices for the 6 categories used
    for (let i = 0; i < 6; i++) {
      const categoryIndex = (startCategory + i) % 25;
      // Only increment if we're using the FIRST concept level of a new concept
      // (i.e., when conceptLevel increments)
      if (conceptLevel > Math.floor((runNumber - 1) / 5)) {
        newHistory.categoryIndex[categoryIndex] = 
          (newHistory.categoryIndex[categoryIndex] + 1) % CYBERSECURITY_TOPICS_BY_CATEGORY[categoryIndex].length;
        console.log(`  Category ${categoryIndex + 1}: Index incremented to ${newHistory.categoryIndex[categoryIndex]}`);
      }
    }
  } else {
    // 5th run in group
    // Category 25: increment if moving to new concept level
    if (conceptLevel > Math.floor((runNumber - 1) / 5)) {
      const cat25Index = 24;
      newHistory.categoryIndex[cat25Index] = 
        (newHistory.categoryIndex[cat25Index] + 1) % CYBERSECURITY_TOPICS_BY_CATEGORY[cat25Index].length;
      console.log(`  Category 25: Index incremented to ${newHistory.categoryIndex[cat25Index]}`);
    }
    
    // Categories 1-5: they used conceptLevel + 1, so check if THEY need to increment
    // They increment when THEIR concept level changes (which happens every 5 runs for them)
    for (let i = 0; i < 5; i++) {
      const categoryIndex = i;
      // Check if this category has completed its current concept cycle
      // Categories 1-5 increment when (runNumber + 1) % 5 === 0
      if ((runNumber + 1) % 5 === 0) {
        newHistory.categoryIndex[categoryIndex] = 
          (newHistory.categoryIndex[categoryIndex] + 1) % CYBERSECURITY_TOPICS_BY_CATEGORY[categoryIndex].length;
        console.log(`  Category ${categoryIndex + 1}: Index incremented to ${newHistory.categoryIndex[categoryIndex]}`);
      }
    }
  }
  
  saveTopicHistory(newHistory);
  console.log(`üìä Total runs: ${newHistory.totalRuns}`);
  console.log(`üìä Category indices: ${newHistory.categoryIndex.join(', ')}`);
}

// SIMPLE TEXT-BASED PARSING - NO JSON REQUIRED
async function generateQuizWithGemini(todaysTopics) {
  try {
    console.log('üì° Calling Gemini API...');
    
    // STRICT prompt to force proper formatting - NOW FOR 6 QUESTIONS
    const promptText = `You are creating a cybersecurity quiz. You MUST follow this EXACT format for EACH of the 6 questions:

FOCUS AREAS FOR TODAY (One from each of 6 categories):
${todaysTopics.map((topic, i) => `${i + 1}. ${topic}`).join('\n')}

--- FORMAT FOR QUESTION 1 ---
Q1: [Write the question text here ending with a question mark?]
A) [Write option A here]
B) [Write option B here]
C) [Write option C here]
D) [Write option D here]
ANSWER: [Write ONLY the letter: A, B, C, or D]
EXPLANATION: [Write detailed explanation here]
CATEGORY: [Write the specific topic name: "${todaysTopics[0]}"]
DIFFICULTY: [Choose ONE: easy, medium, hard]

--- FORMAT FOR QUESTION 2 ---
Q2: [Next question...]
A) [Option A]
B) [Option B]
C) [Option C]
D) [Option D]
ANSWER: [Letter]
EXPLANATION: [Explanation]
CATEGORY: [Write the specific topic name: "${todaysTopics[1]}"]
DIFFICULTY: [Difficulty]

--- CONTINUE FOR Q3-Q6 ---
For Q3, use CATEGORY: "${todaysTopics[2]}"
For Q4, use CATEGORY: "${todaysTopics[3]}"
For Q5, use CATEGORY: "${todaysTopics[4]}"
For Q6, use CATEGORY: "${todaysTopics[5]}"

CRITICAL REQUIREMENTS:
1. Create EXACTLY 6 questions
2. Each question MUST have EXACTLY 4 options: A), B), C), D)
3. Only ONE correct answer per question
4. Question 1 must relate to: "${todaysTopics[0]}"
5. Question 2 must relate to: "${todaysTopics[1]}"
6. Question 3 must relate to: "${todaysTopics[2]}"
7. Question 4 must relate to: "${todaysTopics[3]}"
8. Question 5 must relate to: "${todaysTopics[4]}"
9. Question 6 must relate to: "${todaysTopics[5]}"
10. Difficulty mix: 2 easy, 3 medium, 1 hard
11. Use the EXACT format shown above - NO deviations
12. Put ONE blank line between questions

Now create 6 cybersecurity quiz questions following these EXACT instructions:`;

    const prompt = {
      contents: [{
        parts: [{
          text: promptText
        }]
      }],
      generationConfig: {
        temperature: 0.5,  // Lower temperature for more consistent formatting
        maxOutputTokens: 4000,
      }
    };

    const response = await axios.post(
      `${GEMINI_API_URL}?key=${GEMINI_API_KEY}`,
      prompt,
      {
        headers: {
          'Content-Type': 'application/json'
        },
        timeout: 30000
      }
    );

    console.log('üì• Received response from Gemini API');
    
    let generatedText;
    if (response.data.candidates && response.data.candidates[0] && response.data.candidates[0].content && response.data.candidates[0].content.parts && response.data.candidates[0].content.parts[0]) {
      generatedText = response.data.candidates[0].content.parts[0].text.trim();
    } else {
      throw new Error('Invalid API response');
    }
    
    // Save raw response - ALWAYS overwrite
    fs.writeFileSync('raw_response.txt', generatedText);
    console.log('üíæ Saved raw response to raw_response.txt');
    
    // Parse the text format
    const questions = parseTextQuestionsStrict(generatedText, todaysTopics);
    
    if (questions.length >= 6) {
      console.log(`‚úÖ Successfully parsed ${questions.length} questions`);
      return questions.slice(0, 6);
    } else {
      console.warn(`‚ö†Ô∏è Only parsed ${questions.length} questions, trying RETRY with better prompt...`);
      
      // RETRY with even stricter prompt
      const retryQuestions = await retryWithStricterPrompt(todaysTopics);
      if (retryQuestions.length >= 6) {
        console.log(`‚úÖ Retry successful: ${retryQuestions.length} questions`);
        return retryQuestions.slice(0, 6);
      } else {
        throw new Error(`AI generation failed: Only got ${questions.length} questions`);
      }
    }
    
  } catch (error) {
    console.error('‚ùå AI generation failed:', error.message);
    throw error; // Re-throw to be caught by main function
  }
}

// RETRY function with even stricter prompt
async function retryWithStricterPrompt(todaysTopics) {
  try {
    console.log('üîÑ Retrying with stricter prompt...');
    
    const retryPromptText = `CRITICAL: You MUST output EXACTLY 6 questions in this EXACT format:

Q1: Question about "${todaysTopics[0]}"?
A) Option A
B) Option B
C) Option C
D) Option D
ANSWER: A
EXPLANATION: Explanation text.
CATEGORY: ${todaysTopics[0]}
DIFFICULTY: easy

Q2: Question about "${todaysTopics[1]}"?
A) Option A
B) Option B
C) Option C
D) Option D
ANSWER: B
EXPLANATION: Explanation.
CATEGORY: ${todaysTopics[1]}
DIFFICULTY: medium

Q3: Question about "${todaysTopics[2]}"?
A) Option A
B) Option B
C) Option C
D) Option D
ANSWER: C
EXPLANATION: Explanation.
CATEGORY: ${todaysTopics[2]}
DIFFICULTY: hard

[Continue for Q4-Q6 with corresponding topics]

DO NOT add any other text. Start immediately with Q1:`;

    const retryPrompt = {
      contents: [{
        parts: [{
          text: retryPromptText
        }]
      }],
      generationConfig: {
        temperature: 0.3,  // Very low temperature for strict formatting
        maxOutputTokens: 4000,
      }
    };

    const response = await axios.post(
      `${GEMINI_API_URL}?key=${GEMINI_API_KEY}`,
      retryPrompt,
      {
        headers: {
          'Content-Type': 'application/json'
        },
        timeout: 30000
      }
    );

    let retryText;
    if (response.data.candidates && response.data.candidates[0] && response.data.candidates[0].content && response.data.candidates[0].content.parts && response.data.candidates[0].content.parts[0]) {
      retryText = response.data.candidates[0].content.parts[0].text.trim();
    } else {
      throw new Error('Invalid API response');
    }
    
    // Save retry response
    fs.writeFileSync('raw_response_retry.txt', retryText);
    console.log('üíæ Saved retry response to raw_response_retry.txt');
    
    return parseTextQuestionsStrict(retryText, todaysTopics);
    
  } catch (error) {
    console.error('‚ùå Retry failed:', error.message);
    return [];
  }
}

// STRICT Text-based parser - UPDATED FOR 6 QUESTIONS
function parseTextQuestionsStrict(text, expectedTopics) {
  const questions = [];
  const lines = text.split('\n');
  
  let currentQuestion = null;
  let options = [];
  let questionNumber = 0;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // Skip empty lines
    if (!line) continue;
    
    // Detect question - only accept Q1:, Q2:, etc.
    if (line.match(/^Q\d+:/)) {
      // Save previous question if exists and complete
      if (currentQuestion && options.length === 4) {
        currentQuestion.options = [...options];
        questions.push(currentQuestion);
        if (questions.length >= 6) break;
      }
      
      // Extract question number and text
      const match = line.match(/^Q(\d+):\s*(.+)/);
      if (match) {
        questionNumber = parseInt(match[1]);
        const questionText = match[2].trim();
        
        // Determine expected category based on question number
        let expectedCategory = 'Cybersecurity';
        if (questionNumber >= 1 && questionNumber <= expectedTopics.length) {
          expectedCategory = expectedTopics[questionNumber - 1];
        }
        
        currentQuestion = {
          id: questionNumber,
          question: questionText,
          options: [],
          explanation: '',
          category: expectedCategory, // Start with expected category
          difficulty: 'medium'
        };
        options = [];
      }
      continue;
    }
    
    // Parse options A-D - only accept A), B), C), D)
    if (currentQuestion && line.match(/^[A-D]\)/) && options.length < 4) {
      const optionText = line.substring(2).trim();
      options.push({
        text: optionText,
        correct: false
      });
      continue;
    }
    
    // Parse answer - only accept ANSWER: A/B/C/D
    if (currentQuestion && line.match(/^ANSWER:\s*[A-D]$/i)) {
      const answerMatch = line.match(/^ANSWER:\s*([A-D])/i);
      if (answerMatch && options.length === 4) {
        const correctIndex = answerMatch[1].toUpperCase().charCodeAt(0) - 65;
        if (correctIndex >= 0 && correctIndex < 4) {
          options[correctIndex].correct = true;
        }
      }
      continue;
    }
    
    // Parse explanation
    if (currentQuestion && line.match(/^EXPLANATION:/i)) {
      let explanation = line.replace(/^EXPLANATION:\s*/i, '');
      
      // Collect continuation lines
      for (let j = i + 1; j < lines.length; j++) {
        const nextLine = lines[j].trim();
        if (!nextLine || nextLine.match(/^(Q\d+:|CATEGORY:|DIFFICULTY:)/)) {
          i = j - 1;
          break;
        }
        explanation += ' ' + nextLine;
      }
      
      currentQuestion.explanation = explanation;
      continue;
    }
    
    // Parse category - use the parsed category, but validate
    if (currentQuestion && line.match(/^CATEGORY:/i)) {
      const parsedCategory = line.replace(/^CATEGORY:\s*/i, '').trim();
      // Keep the expected category rather than the parsed one to ensure consistency
      continue;
    }
    
    // Parse difficulty
    if (currentQuestion && line.match(/^DIFFICULTY:/i)) {
      const diff = line.replace(/^DIFFICULTY:\s*/i, '').trim().toLowerCase();
      if (['easy', 'medium', 'hard'].includes(diff)) {
        currentQuestion.difficulty = diff;
      }
      continue;
    }
  }
  
  // Add the last question if complete
  if (currentQuestion && options.length === 4) {
    currentQuestion.options = options;
    questions.push(currentQuestion);
  }
  
  console.log(`üîç Strict parser found ${questions.length} questions`);
  
  // Ensure each question has the correct category from expectedTopics
  questions.forEach((q, index) => {
    if (index < expectedTopics.length) {
      q.category = expectedTopics[index];
    }
  });
  
  // DEBUG: Log what we found
  if (questions.length > 0) {
    console.log(`üìä Questions found: ${questions.map(q => `Q${q.id} (${q.category})`).join(', ')}`);
  }
  
  return questions;
}

// Fallback questions - UPDATED FOR 6 QUESTIONS
function getFallbackQuestions(todaysTopics) {
  console.log('üîÑ Using fallback questions');
  
  // Create fallback questions based on today's topics (only 6)
  const fallbackQuestions = todaysTopics.slice(0, 6).map((topic, index) => {
    const questionNumber = index + 1;
    let questionText, options, explanation;
    
    // Generate appropriate question based on topic
    switch (topic) {
      case "Firewalls and their types":
        questionText = "Which type of firewall operates at the network layer and filters packets based on source/destination IP addresses and ports?";
        options = [
          { text: "Packet-filtering firewall", correct: true },
          { text: "Application-level gateway", correct: false },
          { text: "Stateful inspection firewall", correct: false },
          { text: "Next-generation firewall", correct: false }
        ];
        explanation = "Packet-filtering firewalls operate at the network layer (Layer 3) and make decisions based on packet headers (IP addresses, ports, protocols).";
        break;
        
      case "Symmetric encryption algorithms":
        questionText = "Which symmetric encryption algorithm uses a 128-bit block size and key lengths of 128, 192, or 256 bits?";
        options = [
          { text: "AES (Advanced Encryption Standard)", correct: true },
          { text: "RSA", correct: false },
          { text: "DES", correct: false },
          { text: "Blowfish", correct: false }
        ];
        explanation = "AES is a symmetric encryption standard that uses 128-bit blocks and supports key sizes of 128, 192, or 256 bits.";
        break;
        
      case "OWASP Top 10 vulnerabilities":
        questionText = "Which OWASP Top 10 vulnerability involves attackers manipulating input to execute unintended SQL commands?";
        options = [
          { text: "SQL Injection", correct: true },
          { text: "Cross-Site Scripting", correct: false },
          { text: "Broken Authentication", correct: false },
          { text: "Security Misconfiguration", correct: false }
        ];
        explanation = "SQL Injection occurs when untrusted data is sent to an interpreter as part of a command or query, tricking the interpreter into executing unintended commands.";
        break;
        
      default:
        // Generic fallback for other topics
        questionText = `What is a key consideration for ${topic.toLowerCase()}?`;
        options = [
          { text: "Implementing proper access controls", correct: true },
          { text: "Using default configurations", correct: false },
          { text: "Sharing credentials for efficiency", correct: false },
          { text: "Disabling logging to improve performance", correct: false }
        ];
        explanation = `For ${topic}, implementing proper access controls is essential to ensure only authorized users can access sensitive resources.`;
    }
    
    // Determine difficulty based on question number
    let difficulty = 'medium';
    if (questionNumber <= 2) difficulty = 'easy';
    if (questionNumber === 6) difficulty = 'hard';
    
    return {
      id: questionNumber,
      question: questionText,
      options: options,
      explanation: explanation,
      category: topic, // Use the specific topic name
      difficulty: difficulty
    };
  });
  
  return fallbackQuestions;
}

// Create fallback quiz
async function createFallbackQuiz(todaysTopics, currentIndices, selectedCategoryIndices) {
  const db = admin.firestore();
  const today = new Date().toISOString().split('T')[0];
  
  // If todaysTopics is not provided (from failed AI generation), get fresh topics
  if (!todaysTopics || todaysTopics.length === 0) {
    const selection = getNextTopicsBatch();
    todaysTopics = selection.topics;
    currentIndices = selection.currentIndices;
    selectedCategoryIndices = selection.categoryIndices;
  }
  
  const questions = getFallbackQuestions(todaysTopics);
  
  // Randomize options
  const randomizedQuestions = questions.map(q => {
    const options = [...q.options];
    for (let i = options.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [options[i], options[j]] = [options[j], options[i]];
    }
    
    let originalCorrectIndex = -1;
    const originalCorrectOption = q.options.find(opt => opt.correct);
    if (originalCorrectOption) {
      originalCorrectIndex = q.options.indexOf(originalCorrectOption);
    }
    
    return {
      ...q,
      options: options,
      originalCorrectIndex: originalCorrectIndex,
      shuffled: true
    };
  });
  
  const quizRef = db.collection('dailyQuizzes').doc(today);
  await quizRef.set({
    date: today,
    questions: randomizedQuestions,
    generatedAt: admin.firestore.FieldValue.serverTimestamp(),
    active: true,
    totalAttempts: 0,
    userAttempts: {},
    isFallback: true,
    isAIgenerated: false,
    todaysTopics: todaysTopics,
    selectedCategoryIndices: selectedCategoryIndices
  });
  
  console.log('‚úÖ Created fallback quiz for', today);
  return true;
}

// Delete ALL old quizzes (immediately, not wait 7 days)
async function deleteAllOldQuizzes(currentDate) {
  const db = admin.firestore();
  
  try {
    // Get ALL quizzes except today's
    const allQuizzes = await db.collection('dailyQuizzes')
      .where('date', '!=', currentDate)
      .get();
    
    const deletePromises = [];
    allQuizzes.forEach(doc => {
      deletePromises.push(doc.ref.delete());
    });
    
    await Promise.all(deletePromises);
    console.log(`üóëÔ∏è Deleted ${allQuizzes.size} old quizzes`);
    
  } catch (error) {
    console.error('Error deleting old quizzes:', error.message);
  }
}

// Save local backup
async function saveLocalBackup(date, questions) {
  try {
    const backupDir = path.join(__dirname, 'backups');
    if (!fs.existsSync(backupDir)) {
      fs.mkdirSync(backupDir, { recursive: true });
    }
    
    const backupFile = path.join(backupDir, `quiz_${date}.json`);
    const backupData = {
      date: date,
      generatedAt: new Date().toISOString(),
      questions: questions
    };
    
    fs.writeFileSync(backupFile, JSON.stringify(backupData, null, 2));
    console.log(`üíæ Saved local backup to: ${backupFile}`);
  } catch (error) {
    console.error('Failed to save backup:', error.message);
  }
}

// Check quiz status
// Check quiz status - UPDATED to check quiz date
async function checkQuizStatus() {
  const today = new Date().toISOString().split('T')[0];
  const db = admin.firestore();
  
  // Get the most recent quiz
  const quizzesRef = db.collection('dailyQuizzes');
  const snapshot = await quizzesRef.orderBy('date', 'desc').limit(1).get();
  
  let latestQuiz = null;
  let quizDate = null;
  
  if (!snapshot.empty) {
    latestQuiz = snapshot.docs[0].data();
    quizDate = latestQuiz.date;
  }
  
  // Check if the latest quiz is for today
  const isTodayQuiz = (quizDate === today);
  
  const status = {
    today: today,
    quizDate: quizDate,
    quizExists: !!latestQuiz,
    isTodayQuiz: isTodayQuiz,
    quizData: latestQuiz ? {
      date: latestQuiz.date,
      questionsCount: latestQuiz.questions?.length || 0,
      generatedAt: latestQuiz.generatedAt?.toDate?.() || latestQuiz.generatedAt,
      totalAttempts: latestQuiz.totalAttempts || 0,
      isFallback: latestQuiz.isFallback || false,
      isAIgenerated: latestQuiz.isAIgenerated || false,
      topics: latestQuiz.todaysTopics || []
    } : null,
    timestamp: new Date().toISOString(),
    status: isTodayQuiz ? "READY" : "NOT_AVAILABLE"
  };
  
  console.log('üìä Quiz Status:');
  console.log('---------------');
  console.log(`Today's Date: ${status.today}`);
  console.log(`Quiz Date: ${status.quizDate || 'No quiz found'}`);
  console.log(`Quiz Exists: ${status.quizExists ? '‚úÖ YES' : '‚ùå NO'}`);
  console.log(`Is Today's Quiz: ${status.isTodayQuiz ? '‚úÖ YES' : '‚ùå NO'}`);
  console.log(`Status: ${status.status}`);
  
  if (status.quizData && status.isTodayQuiz) {
    console.log(`Questions: ${status.quizData.questionsCount}`);
    console.log(`Total Attempts: ${status.quizData.totalAttempts}`);
    console.log(`Type: ${status.quizData.isAIgenerated ? 'AI Generated' : 'Fallback'}`);
    console.log(`Generated: ${status.quizData.generatedAt}`);
    if (status.quizData.topics && status.quizData.topics.length > 0) {
      console.log('\nüìö Today\'s Topics:');
      status.quizData.topics.forEach((topic, i) => {
        console.log(`  ${i + 1}. ${topic}`);
      });
    }
  } else if (status.quizData && !status.isTodayQuiz) {
    console.log(`‚ö†Ô∏è Found quiz for ${status.quizDate}, but today is ${status.today}`);
    console.log(`‚è≥ Waiting for today's quiz to be generated...`);
  }
  
  return status;
}
// Initialize first quiz
async function initializeQuiz() {
  const today = new Date().toISOString().split('T')[0];
  const db = admin.firestore();
  
  // Check if quiz exists
  const quizRef = db.collection('dailyQuizzes').doc(today);
  const existingQuiz = await quizRef.get();
  
  if (existingQuiz.exists) {
    console.log('‚úÖ Quiz already initialized');
    return {
      success: true,
      message: 'Quiz already initialized',
      date: today
    };
  }
  
  // Create first quiz
  console.log('üöÄ Initializing quiz system with fallback questions...');
  await createFallbackQuiz();
  
  console.log('‚úÖ Quiz system initialized with fallback questions');
  return {
    success: true,
    message: 'Quiz system initialized with fallback questions',
    date: today
  };
}

// Start scheduled generation (runs daily at midnight)
function startScheduler() {
  console.log('‚è∞ Starting daily scheduler (runs at midnight UTC)...');
  
  // Schedule to run every day at midnight UTC
  cron.schedule('0 0 * * *', async () => {
    console.log('\nüïõ Midnight UTC - Generating daily quiz...');
    const result = await generateQuiz();
    console.log('Result:', result.message);
  }, {
    scheduled: true,
    timezone: "UTC"
  });
  
  console.log('‚úÖ Scheduler started. It will run daily at 00:00 UTC.');
  console.log('Press Ctrl+C to stop.');
  
  // Keep the script running
  process.stdin.resume();
}

// Display help
function showHelp() {
  console.log(`
Usage: node quiz.js [command]

Commands:
  --generate    Generate today's quiz (delete old if exists)
  --manual      Same as generate (alias)
  --status      Check today's quiz status
  --schedule    Start scheduler to run daily at midnight
  --init        Initialize quiz system with fallback questions
  --reset       Reset topic history to fresh start
  --help        Show this help message

Examples:
  node quiz.js                   # Delete old & generate new quiz
  node quiz.js --status          # Check quiz status
  node quiz.js --schedule        # Start daily scheduler
  node quiz.js --init            # Initialize with fallback
  node quiz.js --reset           # Reset history and start fresh

Environment Variables:
  Create a .env file with:
  GEMINI_API_KEY=your_api_key_here

Files Required:
  serviceAccountKey.json         # Firebase service account
  .env                           # Environment variables (optional)
  
Round-Robin Topic Selection:
  - 25 categories, 30 topics each
  - Each run: 6 questions from 6 consecutive categories
  - Pattern: Run 0: categories 1-6, Run 1: categories 7-12, Run 2: categories 13-18, etc.
  - When indices reach 30, they reset to 0 for that category
  - History only updates when AI successfully generates 6 questions
  `);
}

// Manual generation (force new quiz) - same as generate now
async function manualGenerate() {
  console.log('üîß Generating new quiz (deleting old if exists)...');
  return await generateQuiz();
}

// Main function
async function main() {
  const args = process.argv.slice(2);
  const command = args[0] || '--generate';
  
  switch (command) {
    case '--generate':
    case '--manual':
      const result = await generateQuiz();
      console.log('\nüìã Result:', result.message);
      if (result.selectionInfo) {
        console.log(`\nüìä Selection Info:`);
        console.log(`  Run Number: ${result.selectionInfo.runNumber}`);
        console.log(`  Concept Level: ${result.selectionInfo.conceptLevel + 1}`);
        console.log(`  Position in Group: ${result.selectionInfo.runInGroup + 1}/5`);
      }
      if (result.topics) {
        console.log('\nüìö Today\'s Topics:');
        result.topics.forEach((topic, i) => {
          console.log(`  ${i + 1}. ${topic}`);
        });
      }
      if (result.questions) {
        console.log('\nüìù Sample Questions:');
        result.questions.forEach((q, i) => {
          console.log(`\n${i + 1}. ${q.question}`);
          console.log(`   Category: ${q.category}`);
          console.log(`   Difficulty: ${q.difficulty}`);
        });
      }
      break;
      
    case '--status':
      await checkQuizStatus();
      break;
      
    case '--schedule':
      startScheduler();
      break;
      
    case '--init':
      await initializeQuiz();
      break;

    case '--reset':
      resetTopicHistory();
      console.log('\n‚ú® History reset! Now you can run --generate for fresh start.');
      break;
      
    case '--help':
      showHelp();
      break;
      
    default:
      console.log(`Unknown command: ${command}`);
      showHelp();
      break;
  }
  
  // Exit after completion (unless scheduler is running)
  if (command !== '--schedule') {
    console.log('\n‚ú® Done!');
    process.exit(0);
  }
}

// Handle errors
process.on('unhandledRejection', (error) => {
  console.error('‚ùå Unhandled Promise Rejection:', error.message);
  process.exit(1);
});

// Run main function
main().catch(error => {
  console.error('‚ùå Fatal error:', error.message);
  process.exit(1);
}); 