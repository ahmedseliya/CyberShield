// pushAllChallenges.js
const admin = require('firebase-admin');
const serviceAccount = require('./serviceAccountKey.json');

// Initialize Firebase Admin
admin.initializeApp({
  credential: admin.credential.cert(serviceAccount)
});

const db = admin.firestore();

const scenarios = {
  sqlInjection: {
    id: 1,
    title: "SQL Injection Attack",
    difficulty: "Medium",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You've discovered a login form on a website. The form looks vulnerable. What's your first move?",
          choices: [
            {
              text: "Try a simple SQL injection: ' OR '1'='1",
              correct: true,
              points: 10,
              feedback: "Good start! You attempt a basic SQL injection. The login bypasses authentication!",
              nextStep: 1
            },
            {
              text: "Brute force the password",
              correct: false,
              points: 0,
              feedback: "Brute forcing is noisy and time-consuming. There's a smarter way.",
              nextStep: 0
            },
            {
              text: "Check the source code for clues",
              correct: false,
              points: 5,
              feedback: "Good thinking, but you find nothing useful in the frontend code.",
              nextStep: 0
            }
          ]
        },
        {
          text: "Success! You're in. Now you want to extract data. What's your next injection?",
          choices: [
            {
              text: "' UNION SELECT username, password FROM users--",
              correct: true,
              points: 15,
              feedback: "Excellent! You use UNION to extract user credentials from the database.",
              nextStep: 2
            },
            {
              text: "'; DROP TABLE users--",
              correct: false,
              points: -10,
              feedback: "Whoa! That's destructive and illegal. You've crossed ethical boundaries.",
              nextStep: 2
            },
            {
              text: "Just look around the dashboard",
              correct: false,
              points: 5,
              feedback: "You find limited information. A SQL injection could reveal much more.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Mission complete! You've demonstrated the SQL injection vulnerability.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're auditing a login system. During testing, you notice the SQL query is concatenated with user input. What do you recommend?",
          choices: [
            {
              text: "Implement prepared statements with parameterized queries",
              correct: true,
              points: 15,
              feedback: "Perfect! Prepared statements prevent SQL injection by separating SQL code from data.",
              nextStep: 1
            },
            {
              text: "Add input validation to block special characters",
              correct: false,
              points: 5,
              feedback: "Input validation helps but can be bypassed. It's not sufficient alone.",
              nextStep: 1
            },
            {
              text: "Encrypt the database",
              correct: false,
              points: 0,
              feedback: "Encryption protects data at rest, but doesn't prevent SQL injection.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! Now, what additional security measures should you implement?",
          choices: [
            {
              text: "Use ORM frameworks and implement least privilege database access",
              correct: true,
              points: 15,
              feedback: "Excellent defense-in-depth strategy! Multiple layers of security.",
              nextStep: 2
            },
            {
              text: "Add a WAF (Web Application Firewall)",
              correct: false,
              points: 10,
              feedback: "WAF helps, but it's a band-aid. Fix the root cause first.",
              nextStep: 2
            },
            {
              text: "Increase password complexity requirements",
              correct: false,
              points: 0,
              feedback: "This doesn't address SQL injection vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Mission complete! You've secured the application against SQL injection.",
          choices: []
        }
      ]
    }
  },

  brokenAuth: {
    id: 2,
    title: "Broken Authentication",
    difficulty: "Hard",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You've found a password reset functionality. You notice the reset token in the URL. What do you test?",
          choices: [
            {
              text: "Try to reuse an old reset token",
              correct: true,
              points: 10,
              feedback: "Smart! The token works multiple times. Token reuse vulnerability confirmed!",
              nextStep: 1
            },
            {
              text: "Guess other users' tokens",
              correct: false,
              points: 5,
              feedback: "Tokens are too complex to guess. There's a better approach.",
              nextStep: 0
            },
            {
              text: "Check if tokens expire",
              correct: false,
              points: 5,
              feedback: "Good thinking, but you need to find a bigger flaw first.",
              nextStep: 0
            }
          ]
        },
        {
          text: "The token reuse works! Now you want to escalate. What's your move?",
          choices: [
            {
              text: "Test if you can use the same token for different users",
              correct: true,
              points: 20,
              feedback: "Brilliant! The token isn't user-specific. You can reset any account!",
              nextStep: 2
            },
            {
              text: "Try to extend the token's expiration",
              correct: false,
              points: 5,
              feedback: "That's complex. You've already found a critical flaw.",
              nextStep: 2
            },
            {
              text: "Create multiple tokens for yourself",
              correct: false,
              points: 0,
              feedback: "Not useful. You need to think about compromising other accounts.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical vulnerability found! You've exposed the broken authentication system.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're reviewing the password reset flow. What security control do you implement first?",
          choices: [
            {
              text: "Make tokens single-use and invalidate after reset",
              correct: true,
              points: 15,
              feedback: "Essential! Single-use tokens prevent replay attacks.",
              nextStep: 1
            },
            {
              text: "Add a CAPTCHA to the reset form",
              correct: false,
              points: 5,
              feedback: "CAPTCHA helps with automation but doesn't fix the core issue.",
              nextStep: 1
            },
            {
              text: "Send tokens via email only",
              correct: false,
              points: 5,
              feedback: "Good practice, but tokens still need proper validation.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Great! What additional measures strengthen authentication?",
          choices: [
            {
              text: "Implement secure token generation, short expiration, and user-specific tokens",
              correct: true,
              points: 20,
              feedback: "Perfect! Cryptographically secure, time-limited, user-bound tokens.",
              nextStep: 2
            },
            {
              text: "Require users to answer security questions",
              correct: false,
              points: 5,
              feedback: "Security questions are often weak. Better alternatives exist.",
              nextStep: 2
            },
            {
              text: "Rate limit password reset requests",
              correct: false,
              points: 10,
              feedback: "Good defense, but doesn't fix the token vulnerability.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Excellent work! Authentication is now properly secured.",
          choices: []
        }
      ]
    }
  },

  cryptographicFailures: {
    id: 3,
    title: "Cryptographic Failures",
    difficulty: "Medium",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You're testing a web application and notice it's using HTTP instead of HTTPS for sensitive data. What's your first approach?",
          choices: [
            {
              text: "Intercept network traffic to capture sensitive data in transit",
              correct: true,
              points: 15,
              feedback: "Correct! Lack of HTTPS allows man-in-the-middle attacks to capture credentials and sensitive data.",
              nextStep: 1
            },
            {
              text: "Try SQL injection on login forms",
              correct: false,
              points: 5,
              feedback: "Good security testing, but not specific to cryptographic failures.",
              nextStep: 0
            },
            {
              text: "Check for XSS vulnerabilities",
              correct: false,
              points: 5,
              feedback: "XSS is important but different from cryptographic issues.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully captured login credentials via unencrypted HTTP. What sensitive data can you access?",
          choices: [
            {
              text: "Access user accounts and extract personal information, payment data, and session tokens",
              correct: true,
              points: 20,
              feedback: "Critical finding! Cryptographic failures can lead to complete data breach and identity theft.",
              nextStep: 2
            },
            {
              text: "Just demonstrate the password capture",
              correct: false,
              points: 10,
              feedback: "Good start, but show the full impact of compromised credentials.",
              nextStep: 2
            },
            {
              text: "Modify the intercepted data to cause errors",
              correct: false,
              points: -5,
              feedback: "Data modification might be detected. Focus on the confidentiality impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Major cryptographic failure exposed! Sensitive data transmitted without encryption can be easily intercepted.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing an application that handles sensitive user data. What's the first cryptographic measure to implement?",
          choices: [
            {
              text: "Enforce HTTPS everywhere and use strong encryption algorithms",
              correct: true,
              points: 15,
              feedback: "Essential! HTTPS protects data in transit and prevents eavesdropping.",
              nextStep: 1
            },
            {
              text: "Implement input validation on all forms",
              correct: false,
              points: 5,
              feedback: "Input validation is important but doesn't address cryptographic failures.",
              nextStep: 1
            },
            {
              text: "Add rate limiting to API endpoints",
              correct: false,
              points: 5,
              feedback: "Rate limiting helps with brute force but not data encryption.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good start! What additional cryptographic security measures should you implement?",
          choices: [
            {
              text: "Hash passwords with strong algorithms, encrypt sensitive data at rest, and disable weak protocols",
              correct: true,
              points: 20,
              feedback: "Perfect! Comprehensive cryptographic protection for data in transit and at rest.",
              nextStep: 2
            },
            {
              text: "Implement two-factor authentication",
              correct: false,
              points: 10,
              feedback: "2FA improves authentication but doesn't fix weak encryption.",
              nextStep: 2
            },
            {
              text: "Add security headers like CSP",
              correct: false,
              points: 5,
              feedback: "Security headers help with other vulnerabilities but not cryptographic failures.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cryptographic security established! All sensitive data properly encrypted in transit and at rest.",
          choices: []
        }
      ]
    }
  },

  brokenAccessControl: {
    id: 4,
    title: "Broken Access Control",
    difficulty: "Medium",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You found a website where users can access their profiles via URLs like /user/123. What do you test first?",
          choices: [
            {
              text: "Change the user ID in URL to access other users' data",
              correct: true,
              points: 15,
              feedback: "Correct! This tests for Insecure Direct Object Reference (IDOR) vulnerability.",
              nextStep: 1
            },
            {
              text: "Try SQL injection on the profile page",
              correct: false,
              points: 5,
              feedback: "Not the most direct approach for access control testing.",
              nextStep: 0
            },
            {
              text: "Check if the page has XSS vulnerabilities",
              correct: false,
              points: 5,
              feedback: "Good security testing, but not specific to access control.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully accessed another user's profile. How do you escalate this?",
          choices: [
            {
              text: "Test if you can access admin functions by modifying roles",
              correct: true,
              points: 20,
              feedback: "Excellent! Privilege escalation demonstrates critical access control failure.",
              nextStep: 2
            },
            {
              text: "Delete the user's account",
              correct: false,
              points: -10,
              feedback: "Destructive actions are unethical and illegal in real testing.",
              nextStep: 2
            },
            {
              text: "Just document the IDOR vulnerability",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but you should demonstrate full impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical finding! You've demonstrated broken access control allowing privilege escalation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're reviewing user authorization logic. How do you prevent IDOR vulnerabilities?",
          choices: [
            {
              text: "Implement proper authorization checks for every user action",
              correct: true,
              points: 15,
              feedback: "Perfect! Always verify user permissions server-side for each request.",
              nextStep: 1
            },
            {
              text: "Hide object IDs in the frontend",
              correct: false,
              points: 5,
              feedback: "Security through obscurity is not sufficient protection.",
              nextStep: 1
            },
            {
              text: "Use longer random IDs",
              correct: false,
              points: 5,
              feedback: "This doesn't prevent authorized users from accessing other users' data.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What additional access control measures should you implement?",
          choices: [
            {
              text: "Use role-based access control and principle of least privilege",
              correct: true,
              points: 20,
              feedback: "Excellent! RBAC ensures users only have necessary permissions.",
              nextStep: 2
            },
            {
              text: "Add rate limiting to API endpoints",
              correct: false,
              points: 10,
              feedback: "Rate limiting helps with brute force but not access control.",
              nextStep: 2
            },
            {
              text: "Implement two-factor authentication",
              correct: false,
              points: 5,
              feedback: "2FA improves authentication, not authorization.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Access control properly implemented! Users can only access authorized resources.",
          choices: []
        }
      ]
    }
  },

  securityMisconfig: {
    id: 5,
    title: "Security Misconfiguration",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You're scanning a web application and find a /.git directory exposed. What's your approach?",
          choices: [
            {
              text: "Attempt to download the git repository to access source code",
              correct: true,
              points: 15,
              feedback: "Smart! Exposed .git directories can reveal source code, credentials, and application structure.",
              nextStep: 1
            },
            {
              text: "Ignore it and look for other vulnerabilities",
              correct: false,
              points: 0,
              feedback: "This is a serious misconfiguration that should be exploited.",
              nextStep: 0
            },
            {
              text: "Try to modify the git files",
              correct: false,
              points: 5,
              feedback: "Modification might be detected. Information gathering is more valuable.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully downloaded source code containing database credentials. What's next?",
          choices: [
            {
              text: "Use the credentials to access the database and extract data",
              correct: true,
              points: 20,
              feedback: "Critical finding! Exposed credentials lead to complete system compromise.",
              nextStep: 2
            },
            {
              text: "Delete the database",
              correct: false,
              points: -15,
              feedback: "Destructive actions are unethical and illegal.",
              nextStep: 2
            },
            {
              text: "Just report the exposed credentials",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating impact is important.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Major security breach demonstrated! Misconfiguration led to complete system access.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're hardening a web server. What's the first step to prevent information leakage?",
          choices: [
            {
              text: "Remove unnecessary files and disable directory listing",
              correct: true,
              points: 15,
              feedback: "Essential! Don't expose development files or directories in production.",
              nextStep: 1
            },
            {
              text: "Change all passwords",
              correct: false,
              points: 5,
              feedback: "Important, but doesn't address the misconfiguration root cause.",
              nextStep: 1
            },
            {
              text: "Add more firewall rules",
              correct: false,
              points: 5,
              feedback: "Firewalls help but don't fix application-level misconfigurations.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good start! What comprehensive hardening measures should you implement?",
          choices: [
            {
              text: "Implement security headers, secure configurations, and regular scanning",
              correct: true,
              points: 20,
              feedback: "Perfect! Defense in depth with multiple security layers.",
              nextStep: 2
            },
            {
              text: "Use a web application firewall",
              correct: false,
              points: 10,
              feedback: "WAF helps but doesn't replace proper configuration.",
              nextStep: 2
            },
            {
              text: "Encrypt all database fields",
              correct: false,
              points: 5,
              feedback: "Encryption is good but doesn't fix misconfigurations.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Server properly hardened! All unnecessary information exposure prevented.",
          choices: []
        }
      ]
    }
  },

  insecureDeserialization: {
    id: 6,
    title: "Insecure Deserialization",
    difficulty: "Hard",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You found an application that uses serialized cookies for session management. What do you test?",
          choices: [
            {
              text: "Modify the serialized data to escalate privileges",
              correct: true,
              points: 20,
              feedback: "Correct! Insecure deserialization can allow privilege escalation or remote code execution.",
              nextStep: 1
            },
            {
              text: "Try SQL injection on the cookie",
              correct: false,
              points: 5,
              feedback: "Serialized data requires different exploitation techniques.",
              nextStep: 0
            },
            {
              text: "Brute force the cookie",
              correct: false,
              points: 0,
              feedback: "Serialized objects can't be brute forced effectively.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully modified the serialized object to gain admin access. What's the impact?",
          choices: [
            {
              text: "Demonstrate remote code execution by crafting malicious objects",
              correct: true,
              points: 25,
              feedback: "Critical! Insecure deserialization can lead to complete system takeover.",
              nextStep: 2
            },
            {
              text: "Just access admin panel features",
              correct: false,
              points: 10,
              feedback: "Good start, but you should demonstrate the full severity.",
              nextStep: 2
            },
            {
              text: "Delete all serialized sessions",
              correct: false,
              points: -10,
              feedback: "Destructive actions are unethical and affect other users.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical RCE vulnerability demonstrated! Insecure deserialization allows complete compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing an application that uses serialization. What's the primary defense?",
          choices: [
            {
              text: "Use digital signatures and avoid native deserialization",
              correct: true,
              points: 20,
              feedback: "Perfect! Signatures verify data integrity before deserialization.",
              nextStep: 1
            },
            {
              text: "Encrypt the serialized data",
              correct: false,
              points: 10,
              feedback: "Encryption protects confidentiality but not integrity.",
              nextStep: 1
            },
            {
              text: "Use shorter session timeouts",
              correct: false,
              points: 5,
              feedback: "Timeouts help but don't prevent deserialization attacks.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What additional security measures should you implement?",
          choices: [
            {
              text: "Implement integrity checks, use safe serialization libraries, and input validation",
              correct: true,
              points: 25,
              feedback: "Excellent! Multiple layers of protection against deserialization attacks.",
              nextStep: 2
            },
            {
              text: "Add more logging for serialization events",
              correct: false,
              points: 10,
              feedback: "Logging helps detection but doesn't prevent attacks.",
              nextStep: 2
            },
            {
              text: "Use HTTPS for all communications",
              correct: false,
              points: 5,
              feedback: "HTTPS protects in transit but not deserialization logic.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Deserialization secured! All data integrity checks properly implemented.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponents: {
    id: 7,
    title: "Vulnerable Components",
    difficulty: "Medium",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover a website using an outdated jQuery version with known vulnerabilities. What's your approach?",
          choices: [
            {
              text: "Research and exploit known CVEs for that jQuery version",
              correct: true,
              points: 15,
              feedback: "Smart! Known vulnerabilities in components are low-hanging fruit for attackers.",
              nextStep: 1
            },
            {
              text: "Try to find zero-day vulnerabilities",
              correct: false,
              points: 5,
              feedback: "Zero-days are rare. Focus on known vulnerabilities first.",
              nextStep: 0
            },
            {
              text: "Ignore it and look for other issues",
              correct: false,
              points: 0,
              feedback: "Outdated components with known CVEs are serious security risks.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You found a CVE that allows XSS in the jQuery version. How do you exploit it?",
          choices: [
            {
              text: "Craft a payload that triggers the specific jQuery vulnerability",
              correct: true,
              points: 20,
              feedback: "Excellent! You successfully exploited the known vulnerability in the outdated component.",
              nextStep: 2
            },
            {
              text: "Try generic XSS payloads",
              correct: false,
              points: 10,
              feedback: "Generic payloads might work, but specific CVE exploitation is more reliable.",
              nextStep: 2
            },
            {
              text: "Report the outdated component without testing",
              correct: false,
              points: 5,
              feedback: "Testing demonstrates real impact and urgency for patching.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Component vulnerability exploited! Outdated libraries pose serious security risks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're responsible for application security. How do you manage third-party components?",
          choices: [
            {
              text: "Implement automated dependency scanning and regular updates",
              correct: true,
              points: 15,
              feedback: "Perfect! Proactive monitoring and timely updates are essential for component security.",
              nextStep: 1
            },
            {
              text: "Manually check components once a year",
              correct: false,
              points: 5,
              feedback: "Manual checks are insufficient. Vulnerabilities are discovered daily.",
              nextStep: 1
            },
            {
              text: "Only use components from trusted sources",
              correct: false,
              points: 5,
              feedback: "Trusted sources help, but all components need regular security updates.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good start! What comprehensive component management strategy should you implement?",
          choices: [
            {
              text: "Use SCA tools, maintain SBOM, and establish patch management process",
              correct: true,
              points: 20,
              feedback: "Excellent! Software Composition Analysis and Software Bill of Materials provide complete visibility.",
              nextStep: 2
            },
            {
              text: "Remove all third-party components",
              correct: false,
              points: 0,
              feedback: "Not practical. Modern applications rely on many third-party components.",
              nextStep: 2
            },
            {
              text: "Only update when vulnerabilities are reported",
              correct: false,
              points: 5,
              feedback: "Reactive approach leaves you vulnerable between discovery and patch.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Component management established! All dependencies regularly monitored and updated.",
          choices: []
        }
      ]
    }
  },

  loggingFailures: {
    id: 8,
    title: "Insufficient Logging & Monitoring",
    difficulty: "Medium",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You're testing an application and notice no security alerts trigger during your attacks. What do you do?",
          choices: [
            {
              text: "Continue attacks since detection seems poor",
              correct: true,
              points: 15,
              feedback: "Correct! Poor logging and monitoring allows attackers to operate undetected.",
              nextStep: 1
            },
            {
              text: "Stop testing to avoid being detected",
              correct: false,
              points: 0,
              feedback: "The purpose is to test security controls, including detection capabilities.",
              nextStep: 0
            },
            {
              text: "Only use techniques that definitely won't be logged",
              correct: false,
              points: 5,
              feedback: "All security events should be logged and monitored.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully extracted data without triggering any alerts. How do you demonstrate the impact?",
          choices: [
            {
              text: "Show how long an attacker could operate undetected",
              correct: true,
              points: 20,
              feedback: "Critical finding! Without proper monitoring, breaches can go undetected for months.",
              nextStep: 2
            },
            {
              text: "Delete the logs to cover tracks",
              correct: false,
              points: -15,
              feedback: "Destructive and illegal. Focus on demonstrating the security gap.",
              nextStep: 2
            },
            {
              text: "Just report the lack of alerts",
              correct: false,
              points: 10,
              feedback: "Good, but showing the operational impact is more compelling.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Detection failure demonstrated! Without proper monitoring, attackers operate with impunity.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're designing security monitoring for an application. What's the first essential log to implement?",
          choices: [
            {
              text: "Authentication successes and failures",
              correct: true,
              points: 15,
              feedback: "Essential! Authentication events are critical for detecting brute force and account takeover attempts.",
              nextStep: 1
            },
            {
              text: "All user page views",
              correct: false,
              points: 5,
              feedback: "Too noisy. Focus on security-relevant events first.",
              nextStep: 1
            },
            {
              text: "Database query performance",
              correct: false,
              points: 5,
              feedback: "Performance monitoring is important but separate from security monitoring.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive logging and monitoring strategy should you implement?",
          choices: [
            {
              text: "Implement SIEM, real-time alerts, and regular log reviews",
              correct: true,
              points: 20,
              feedback: "Perfect! Security Information and Event Management with proactive alerting provides complete visibility.",
              nextStep: 2
            },
            {
              text: "Store all logs locally on each server",
              correct: false,
              points: 5,
              feedback: "Local logs can be tampered with or lost. Centralized logging is essential.",
              nextStep: 2
            },
            {
              text: "Only log errors and exceptions",
              correct: false,
              points: 5,
              feedback: "Security events include successful actions that might be malicious.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive monitoring established! All security events properly logged and alerted.",
          choices: []
        }
      ]
    }
  },

  ssrf: {
    id: 9,
    title: "Server-Side Request Forgery",
    difficulty: "Hard",
    vulnerability: "A10:2021 - Server-Side Request Forgery (SSRF)",
    attacker: {
      story: [
        {
          text: "You found a feature that fetches URLs provided by users. What do you test for SSRF?",
          choices: [
            {
              text: "Try to access internal services like http://localhost or http://169.254.169.254",
              correct: true,
              points: 20,
              feedback: "Correct! SSRF can expose internal services and cloud metadata endpoints.",
              nextStep: 1
            },
            {
              text: "Test for SQL injection in the URL parameter",
              correct: false,
              points: 5,
              feedback: "SSRF requires different testing approach focused on internal network access.",
              nextStep: 0
            },
            {
              text: "Check if the feature rate limits requests",
              correct: false,
              points: 5,
              feedback: "Rate limiting is good to know but doesn't test for SSRF directly.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully accessed AWS metadata service. What sensitive information can you extract?",
          choices: [
            {
              text: "Extract IAM roles, access keys, and instance metadata",
              correct: true,
              points: 25,
              feedback: "Critical! Cloud metadata can contain credentials allowing complete cloud account compromise.",
              nextStep: 2
            },
            {
              text: "Just document the internal network access",
              correct: false,
              points: 10,
              feedback: "Good start, but you should demonstrate the full impact of credential theft.",
              nextStep: 2
            },
            {
              text: "Try to shutdown the cloud instance",
              correct: false,
              points: -20,
              feedback: "Destructive actions are unethical and can cause service disruption.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical SSRF vulnerability! Internal services and cloud credentials exposed.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing an application that makes outbound requests. What's the primary SSRF defense?",
          choices: [
            {
              text: "Implement allowlist for allowed domains and block internal IP ranges",
              correct: true,
              points: 20,
              feedback: "Perfect! Allowlisting and network segmentation prevent SSRF attacks.",
              nextStep: 1
            },
            {
              text: "Use URL validation to check for suspicious patterns",
              correct: false,
              points: 10,
              feedback: "Blacklists can be bypassed. Allowlists are more secure.",
              nextStep: 1
            },
            {
              text: "Add authentication to all internal services",
              correct: false,
              points: 5,
              feedback: "Internal services should be protected, but SSRF prevention is better.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What additional SSRF protections should you implement?",
          choices: [
            {
              text: "Use network segmentation, DNS filtering, and outbound proxy with restrictions",
              correct: true,
              points: 25,
              feedback: "Excellent! Multiple layers of network security prevent SSRF exploitation.",
              nextStep: 2
            },
            {
              text: "Disable all outbound HTTP requests",
              correct: false,
              points: 0,
              feedback: "Not practical for applications that need to make legitimate outbound calls.",
              nextStep: 2
            },
            {
              text: "Only allow HTTPS URLs",
              correct: false,
              points: 5,
              feedback: "HTTPS doesn't prevent SSRF to internal services.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF protections implemented! All outbound requests properly restricted and monitored.",
          choices: []
        }
      ]
    }
  },

   sqlInjection: {
    id: 11,
    title: "Advanced SQL Injection",
    difficulty: "Hard",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You're testing a search functionality that filters products by category. What SQL injection technique do you try first?",
          choices: [
            {
              text: "Test with: ' UNION SELECT 1,2,3--",
              correct: true,
              points: 15,
              feedback: "Excellent! UNION-based injection helps determine the number of columns and their types.",
              nextStep: 1
            },
            {
              text: "Try: ' OR '1'='1",
              correct: false,
              points: 5,
              feedback: "Basic injection works on authentication forms, but search might need different approach.",
              nextStep: 0
            },
            {
              text: "Use: '; DROP TABLE products--",
              correct: false,
              points: -10,
              feedback: "Destructive testing is unethical and could cause service disruption.",
              nextStep: 0
            }
          ]
        },
        {
          text: "The UNION injection works! Now you want to extract database structure. What's your next step?",
          choices: [
            {
              text: "Extract table names from information_schema",
              correct: true,
              points: 20,
              feedback: "Perfect! information_schema contains metadata about all database tables and columns.",
              nextStep: 2
            },
            {
              text: "Try to guess table names",
              correct: false,
              points: 5,
              feedback: "Guessing is inefficient. Database metadata provides accurate information.",
              nextStep: 2
            },
            {
              text: "Attempt blind SQL injection",
              correct: false,
              points: 10,
              feedback: "Blind injection is for error-based scenarios, but you already have direct output.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Database structure successfully mapped! You've demonstrated comprehensive SQL injection exploitation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing security controls for database queries. What's the most effective approach?",
          choices: [
            {
              text: "Use parameterized queries with prepared statements",
              correct: true,
              points: 20,
              feedback: "Perfect! Parameterized queries separate SQL logic from data, preventing injection.",
              nextStep: 1
            },
            {
              text: "Implement input sanitization",
              correct: false,
              points: 10,
              feedback: "Sanitization helps but can be bypassed. Parameterized queries are more reliable.",
              nextStep: 1
            },
            {
              text: "Use stored procedures exclusively",
              correct: false,
              points: 5,
              feedback: "Stored procedures can still be vulnerable if not implemented properly.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good start! What additional database security measures should you implement?",
          choices: [
            {
              text: "Implement principle of least privilege and input validation layers",
              correct: true,
              points: 25,
              feedback: "Excellent! Defense in depth with multiple security layers provides robust protection.",
              nextStep: 2
            },
            {
              text: "Encrypt all database connections",
              correct: false,
              points: 10,
              feedback: "Encryption protects data in transit but doesn't prevent SQL injection.",
              nextStep: 2
            },
            {
              text: "Add more database indexes",
              correct: false,
              points: 0,
              feedback: "Indexes improve performance but don't address security vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Database security comprehensively implemented! SQL injection attacks effectively prevented.",
          choices: []
        }
      ]
    }
  },

  brokenAuth: {
    id: 12,
    title: "Session Management Flaws",
    difficulty: "Medium",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover session cookies that don't change after login. What vulnerability are you testing for?",
          choices: [
            {
              text: "Session fixation attack",
              correct: true,
              points: 15,
              feedback: "Correct! Static session IDs allow session fixation attacks.",
              nextStep: 1
            },
            {
              text: "CSRF vulnerability",
              correct: false,
              points: 5,
              feedback: "CSRF involves different attack vectors, not session management.",
              nextStep: 0
            },
            {
              text: "Brute force attack",
              correct: false,
              points: 5,
              feedback: "Brute force targets credentials, not session management.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully performed session fixation. How do you demonstrate the impact?",
          choices: [
            {
              text: "Show how an attacker can hijack user sessions",
              correct: true,
              points: 20,
              feedback: "Critical finding! Session fixation allows complete account takeover.",
              nextStep: 2
            },
            {
              text: "Delete all active sessions",
              correct: false,
              points: -15,
              feedback: "Destructive actions are unethical and affect legitimate users.",
              nextStep: 2
            },
            {
              text: "Just report the static session ID",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating impact is more compelling.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Session management vulnerability exploited! User sessions can be hijacked through fixation attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing secure session management. What's the most important control?",
          choices: [
            {
              text: "Regenerate session ID after authentication",
              correct: true,
              points: 20,
              feedback: "Essential! Session regeneration prevents fixation attacks.",
              nextStep: 1
            },
            {
              text: "Use longer session IDs",
              correct: false,
              points: 5,
              feedback: "Length doesn't prevent fixation if IDs don't change after login.",
              nextStep: 1
            },
            {
              text: "Store sessions in database",
              correct: false,
              points: 10,
              feedback: "Storage location doesn't address session fixation vulnerability.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive session security measures should you implement?",
          choices: [
            {
              text: "Implement session timeout, secure flags, and server-side validation",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers of session security provide robust protection.",
              nextStep: 2
            },
            {
              text: "Encrypt session cookies",
              correct: false,
              points: 10,
              feedback: "Encryption helps but doesn't prevent all session attacks.",
              nextStep: 2
            },
            {
              text: "Use IP-based session binding",
              correct: false,
              points: 5,
              feedback: "IP binding can cause issues for legitimate users with changing IPs.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure session management implemented! All session-based attacks effectively mitigated.",
          choices: []
        }
      ]
    }
  },

  cryptographicFailures: {
    id: 13,
    title: "Weak Cryptography Implementation",
    difficulty: "Hard",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover an application using MD5 for password hashing. What's your exploitation approach?",
          choices: [
            {
              text: "Use rainbow tables or collision attacks",
              correct: true,
              points: 20,
              feedback: "Correct! MD5 is cryptographically broken and vulnerable to collision attacks.",
              nextStep: 1
            },
            {
              text: "Try SQL injection to extract hashes",
              correct: false,
              points: 10,
              feedback: "Good approach, but the vulnerability is in the hashing algorithm itself.",
              nextStep: 0
            },
            {
              text: "Brute force the login directly",
              correct: false,
              points: 5,
              feedback: "Direct brute force is less efficient than attacking the weak hash.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully cracked several MD5 hashes. What's the broader impact?",
          choices: [
            {
              text: "Demonstrate credential stuffing across other services",
              correct: true,
              points: 25,
              feedback: "Critical! Password reuse allows attackers to compromise multiple accounts across different services.",
              nextStep: 2
            },
            {
              text: "Just show the cracked passwords",
              correct: false,
              points: 15,
              feedback: "Good demonstration, but showing real-world impact is more compelling.",
              nextStep: 2
            },
            {
              text: "Change all user passwords",
              correct: false,
              points: -20,
              feedback: "Unauthorized password changes are illegal and unethical.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cryptographic failure demonstrated! Weak hashing algorithms compromise user security across multiple platforms.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're upgrading password storage security. What's the recommended hashing approach?",
          choices: [
            {
              text: "Use bcrypt, argon2, or PBKDF2 with appropriate work factors",
              correct: true,
              points: 20,
              feedback: "Perfect! Modern adaptive hashing algorithms resist brute force and GPU attacks.",
              nextStep: 1
            },
            {
              text: "Switch from MD5 to SHA-256",
              correct: false,
              points: 10,
              feedback: "SHA-256 is better but still too fast for password hashing without proper key stretching.",
              nextStep: 1
            },
            {
              text: "Add salt to existing MD5 hashes",
              correct: false,
              points: 5,
              feedback: "Salting helps but doesn't fix the fundamental weakness of MD5.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What additional cryptographic security measures are needed?",
          choices: [
            {
              text: "Implement proper key management and use authenticated encryption",
              correct: true,
              points: 25,
              feedback: "Excellent! Key management and authenticated encryption prevent various cryptographic attacks.",
              nextStep: 2
            },
            {
              text: "Encrypt all database fields",
              correct: false,
              points: 10,
              feedback: "Selective encryption based on sensitivity is more practical and secure.",
              nextStep: 2
            },
            {
              text: "Use multiple encryption layers",
              correct: false,
              points: 5,
              feedback: "Multiple layers can complicate without necessarily improving security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cryptographic security properly implemented! All sensitive data protected with modern algorithms.",
          choices: []
        }
      ]
    }
  },

  brokenAccessControl: {
    id: 14,
    title: "Horizontal Privilege Escalation",
    difficulty: "Medium",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You found an API endpoint /api/users/{userId}/orders that returns user orders. What do you test?",
          choices: [
            {
              text: "Change userId parameter to access other users' orders",
              correct: true,
              points: 20,
              feedback: "Correct! This tests for horizontal privilege escalation vulnerability.",
              nextStep: 1
            },
            {
              text: "Try SQL injection in the userId parameter",
              correct: false,
              points: 10,
              feedback: "Good security testing, but the primary issue is access control, not injection.",
              nextStep: 0
            },
            {
              text: "Test for rate limiting on the endpoint",
              correct: false,
              points: 5,
              feedback: "Rate limiting is important but doesn't address the access control flaw.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully accessed other users' order history. How do you escalate this finding?",
          choices: [
            {
              text: "Demonstrate access to sensitive personal and financial information",
              correct: true,
              points: 25,
              feedback: "Critical impact! Horizontal privilege escalation exposes sensitive user data.",
              nextStep: 2
            },
            {
              text: "Modify other users' orders",
              correct: false,
              points: -15,
              feedback: "Unauthorized modifications are destructive and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the IDOR vulnerability",
              correct: false,
              points: 15,
              feedback: "Good reporting, but demonstrating data exposure shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Horizontal privilege escalation demonstrated! User data isolation completely compromised.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're fixing horizontal privilege escalation. What's the primary defense mechanism?",
          choices: [
            {
              text: "Implement proper authorization checks in business logic",
              correct: true,
              points: 20,
              feedback: "Essential! Server-side authorization must verify user permissions for each request.",
              nextStep: 1
            },
            {
              text: "Hide object IDs in the frontend",
              correct: false,
              points: 5,
              feedback: "Security through obscurity is not a reliable defense.",
              nextStep: 1
            },
            {
              text: "Use UUIDs instead of sequential IDs",
              correct: false,
              points: 10,
              feedback: "UUIDs make guessing harder but don't prevent authorized access to other users' data.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive access control strategy should you implement?",
          choices: [
            {
              text: "Implement role-based access control with proper session management",
              correct: true,
              points: 25,
              feedback: "Perfect! RBAC combined with proper session validation provides robust access control.",
              nextStep: 2
            },
            {
              text: "Add more authentication factors",
              correct: false,
              points: 10,
              feedback: "Multi-factor improves authentication but doesn't fix authorization flaws.",
              nextStep: 2
            },
            {
              text: "Implement IP-based access restrictions",
              correct: false,
              points: 5,
              feedback: "IP restrictions don't address application-level access control issues.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Access control properly implemented! User data isolation and authorization effectively enforced.",
          choices: []
        }
      ]
    }
  },

  securityMisconfig: {
    id: 15,
    title: "Docker Container Misconfigurations",
    difficulty: "Medium",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover a Docker container running with privileged flag. What's your first exploitation attempt?",
          choices: [
            {
              text: "Attempt container escape to host system",
              correct: true,
              points: 20,
              feedback: "Correct! Privileged containers can potentially escape to the host system.",
              nextStep: 1
            },
            {
              text: "Scan for open ports inside container",
              correct: false,
              points: 10,
              feedback: "Good reconnaissance, but the privilege escalation is the critical finding.",
              nextStep: 0
            },
            {
              text: "Check for weak container passwords",
              correct: false,
              points: 5,
              feedback: "Container security focuses more on configuration than passwords.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully escaped the container to the host. What's the impact?",
          choices: [
            {
              text: "Access host resources and other containers on the system",
              correct: true,
              points: 25,
              feedback: "Critical! Container escape compromises the entire host and all other containers.",
              nextStep: 2
            },
            {
              text: "Just document the escape technique",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating host access shows real risk.",
              nextStep: 2
            },
            {
              text: "Shutdown the host system",
              correct: false,
              points: -25,
              feedback: "Destructive actions are unethical and cause service disruption.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Container escape successful! Docker misconfiguration leads to complete host compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing Docker container deployments. What's the most important security practice?",
          choices: [
            {
              text: "Run containers as non-root and without privileged flag",
              correct: true,
              points: 20,
              feedback: "Essential! Least privilege principle prevents container escape attacks.",
              nextStep: 1
            },
            {
              text: "Use the latest Docker version",
              correct: false,
              points: 10,
              feedback: "Important for security patches, but doesn't fix misconfigurations.",
              nextStep: 1
            },
            {
              text: "Encrypt container images",
              correct: false,
              points: 5,
              feedback: "Image encryption protects at rest but not runtime security.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good start! What comprehensive container security measures should you implement?",
          choices: [
            {
              text: "Implement security scanning, resource limits, and network segmentation",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive container security includes scanning, isolation, and resource controls.",
              nextStep: 2
            },
            {
              text: "Run all containers in privileged mode for functionality",
              correct: false,
              points: -10,
              feedback: "Privileged mode dramatically increases security risk.",
              nextStep: 2
            },
            {
              text: "Disable all container logging",
              correct: false,
              points: 0,
              feedback: "Logging is essential for security monitoring and incident response.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Container security properly implemented! All Docker configurations follow security best practices.",
          choices: []
        }
      ]
    }
  },

  insecureDeserialization: {
    id: 16,
    title: "Java Deserialization Attack",
    difficulty: "Expert",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover a Java application using Java object serialization in cookies. What exploitation framework do you use?",
          choices: [
            {
              text: "Use ysoserial with appropriate gadget chains",
              correct: true,
              points: 25,
              feedback: "Correct! ysoserial generates payloads for various Java deserialization vulnerabilities.",
              nextStep: 1
            },
            {
              text: "Try manual serialized object manipulation",
              correct: false,
              points: 15,
              feedback: "Possible but much more complex than using established tools.",
              nextStep: 0
            },
            {
              text: "Use SQL injection instead",
              correct: false,
              points: 5,
              feedback: "Different vulnerability class. Focus on the deserialization flaw.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully generated a deserialization payload. What's the most likely impact?",
          choices: [
            {
              text: "Achieve remote code execution on the server",
              correct: true,
              points: 30,
              feedback: "Critical! Java deserialization vulnerabilities often lead to complete server compromise.",
              nextStep: 2
            },
            {
              text: "Just cause application errors",
              correct: false,
              points: 10,
              feedback: "Denial of service is possible, but RCE is the primary risk.",
              nextStep: 2
            },
            {
              text: "Extract sensitive data from memory",
              correct: false,
              points: 15,
              feedback: "Data extraction is possible, but RCE demonstrates maximum impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Remote code execution achieved! Insecure Java deserialization leads to complete server takeover.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing a Java application against deserialization attacks. What's the primary defense?",
          choices: [
            {
              text: "Use safe deserialization libraries with allowlisting",
              correct: true,
              points: 25,
              feedback: "Essential! Safe deserialization libraries prevent gadget chain exploitation.",
              nextStep: 1
            },
            {
              text: "Encrypt serialized data",
              correct: false,
              points: 10,
              feedback: "Encryption doesn't prevent deserialization of malicious objects.",
              nextStep: 1
            },
            {
              text: "Validate serialized data format",
              correct: false,
              points: 15,
              feedback: "Format validation helps but doesn't prevent all deserialization attacks.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive Java deserialization protection should you implement?",
          choices: [
            {
              text: "Implement JEP 290 filters and use alternative data formats",
              correct: true,
              points: 30,
              feedback: "Perfect! JEP 290 provides built-in protection, and JSON/XML are safer alternatives.",
              nextStep: 2
            },
            {
              text: "Disable all serialization functionality",
              correct: false,
              points: 5,
              feedback: "Not practical for applications requiring serialization features.",
              nextStep: 2
            },
            {
              text: "Use faster serialization libraries",
              correct: false,
              points: 0,
              feedback: "Performance improvements don't address security vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Java deserialization secured! All known gadget chains blocked and safe alternatives implemented.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponents: {
    id: 17,
    title: "Supply Chain Attacks",
    difficulty: "Hard",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover a website using a vulnerable version of a popular JavaScript library. What's your approach?",
          choices: [
            {
              text: "Research and exploit known CVEs in the specific version",
              correct: true,
              points: 20,
              feedback: "Correct! Known vulnerabilities in popular libraries are low-hanging fruit.",
              nextStep: 1
            },
            {
              text: "Try to find zero-day vulnerabilities",
              correct: false,
              points: 10,
              feedback: "Zero-days are rare. Focus on known, documented vulnerabilities first.",
              nextStep: 0
            },
            {
              text: "Ignore and look for custom code vulnerabilities",
              correct: false,
              points: 5,
              feedback: "Third-party vulnerabilities are often easier to exploit than custom code.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You found a CVE allowing remote code execution. How do you demonstrate the impact?",
          choices: [
            {
              text: "Show how the vulnerability affects all users of the application",
              correct: true,
              points: 25,
              feedback: "Critical! Supply chain vulnerabilities affect every user of the vulnerable component.",
              nextStep: 2
            },
            {
              text: "Just exploit it on your test account",
              correct: false,
              points: 15,
              feedback: "Good for proof of concept, but showing widespread impact is more compelling.",
              nextStep: 2
            },
            {
              text: "Create a worm to propagate the exploit",
              correct: false,
              points: -20,
              feedback: "Creating self-propagating malware is unethical and potentially illegal.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Supply chain attack demonstrated! Vulnerable third-party components compromise entire application security.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing software supply chain security. What's the most effective control?",
          choices: [
            {
              text: "Implement automated vulnerability scanning in CI/CD pipeline",
              correct: true,
              points: 20,
              feedback: "Essential! Automated scanning catches vulnerabilities before they reach production.",
              nextStep: 1
            },
            {
              text: "Manually review all third-party code",
              correct: false,
              points: 5,
              feedback: "Not scalable for modern applications with hundreds of dependencies.",
              nextStep: 1
            },
            {
              text: "Only use open-source components",
              correct: false,
              points: 0,
              feedback: "Open-source and commercial components both can have vulnerabilities.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good start! What comprehensive supply chain security measures should you implement?",
          choices: [
            {
              text: "Use software bill of materials and implement dependency version pinning",
              correct: true,
              points: 25,
              feedback: "Perfect! SBOM provides visibility, and version pinning prevents unexpected updates.",
              nextStep: 2
            },
            {
              text: "Remove all third-party dependencies",
              correct: false,
              points: 0,
              feedback: "Not practical for modern software development.",
              nextStep: 2
            },
            {
              text: "Delay all dependency updates by 6 months",
              correct: false,
              points: -10,
              feedback: "Delaying updates leaves you vulnerable to known exploits.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Supply chain security established! All components monitored, scanned, and promptly updated.",
          choices: []
        }
      ]
    }
  },

  loggingFailures: {
    id: 18,
    title: "Log Injection and Tampering",
    difficulty: "Medium",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover user input being written directly to application logs. What attack do you attempt?",
          choices: [
            {
              text: "Perform log injection to obfuscate attack traces",
              correct: true,
              points: 20,
              feedback: "Correct! Log injection can hide malicious activity from security monitoring.",
              nextStep: 1
            },
            {
              text: "Try to read the log files directly",
              correct: false,
              points: 10,
              feedback: "Log reading is good, but injection demonstrates a more sophisticated attack.",
              nextStep: 0
            },
            {
              text: "Cause log file corruption",
              correct: false,
              points: -5,
              feedback: "Destructive actions are unethical and may trigger alerts.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully injected false log entries. What's the security impact?",
          choices: [
            {
              text: "Demonstrate how attacks can be hidden from security monitoring",
              correct: true,
              points: 25,
              feedback: "Critical! Log manipulation undermines security monitoring and incident response.",
              nextStep: 2
            },
            {
              text: "Just show the injected log entries",
              correct: false,
              points: 15,
              feedback: "Good proof of concept, but showing the security impact is more important.",
              nextStep: 2
            },
            {
              text: "Delete all log files",
              correct: false,
              points: -20,
              feedback: "Destructive and easily detectable. Focus on demonstrating the vulnerability.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Log manipulation successful! Security monitoring compromised through log injection attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing secure logging practices. What's the most important control?",
          choices: [
            {
              text: "Sanitize all user input before writing to logs",
              correct: true,
              points: 20,
              feedback: "Essential! Input sanitization prevents log injection and manipulation.",
              nextStep: 1
            },
            {
              text: "Encrypt all log files",
              correct: false,
              points: 10,
              feedback: "Encryption protects confidentiality but doesn't prevent injection.",
              nextStep: 1
            },
            {
              text: "Use binary log formats",
              correct: false,
              points: 5,
              feedback: "Binary formats can help but don't solve the fundamental injection problem.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive logging security measures should you implement?",
          choices: [
            {
              text: "Implement log integrity protection and centralized log management",
              correct: true,
              points: 25,
              feedback: "Perfect! Integrity protection and centralized management prevent tampering.",
              nextStep: 2
            },
            {
              text: "Disable detailed logging entirely",
              correct: false,
              points: -10,
              feedback: "Detailed logs are essential for security monitoring and forensics.",
              nextStep: 2
            },
            {
              text: "Store logs only in memory",
              correct: false,
              points: 0,
              feedback: "Memory-only storage loses historical data and forensic capability.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure logging implemented! All logs protected against injection and tampering.",
          choices: []
        }
      ]
    }
  },

  ssrf: {
    id: 19,
    title: "Cloud Metadata SSRF",
    difficulty: "Expert",
    vulnerability: "A10:2021 - Server-Side Request Forgery (SSRF)",
    attacker: {
      story: [
        {
          text: "You found a webhook testing feature that fetches URLs. What cloud metadata endpoint do you target first?",
          choices: [
            {
              text: "http://169.254.169.254/latest/meta-data/",
              correct: true,
              points: 25,
              feedback: "Correct! AWS metadata service is a prime target for SSRF attacks.",
              nextStep: 1
            },
            {
              text: "http://localhost/admin",
              correct: false,
              points: 10,
              feedback: "Localhost is good, but cloud metadata often contains credentials.",
              nextStep: 0
            },
            {
              text: "http://google.com",
              correct: false,
              points: 5,
              feedback: "External sites don't demonstrate the internal network access risk.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully accessed AWS metadata and found IAM role credentials. What's the impact?",
          choices: [
            {
              text: "Assume the IAM role and access cloud resources",
              correct: true,
              points: 30,
              feedback: "Critical! Cloud credential theft leads to complete cloud environment compromise.",
              nextStep: 2
            },
            {
              text: "Just document the credential exposure",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating cloud access shows real business impact.",
              nextStep: 2
            },
            {
              text: "Delete all cloud resources",
              correct: false,
              points: -30,
              feedback: "Destructive actions are unethical and cause business disruption.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cloud compromise achieved! SSRF vulnerability leads to complete cloud environment takeover.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're protecting against cloud metadata SSRF attacks. What's the primary defense?",
          choices: [
            {
              text: "Block access to internal IP ranges and metadata endpoints",
              correct: true,
              points: 25,
              feedback: "Essential! Network segmentation prevents SSRF to internal services.",
              nextStep: 1
            },
            {
              text: "Use HTTPS for all outbound requests",
              correct: false,
              points: 10,
              feedback: "HTTPS doesn't prevent SSRF to internal HTTP services.",
              nextStep: 1
            },
            {
              text: "Implement request signing",
              correct: false,
              points: 5,
              feedback: "Request signing verifies authenticity but doesn't restrict destinations.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive cloud SSRF protection should you implement?",
          choices: [
            {
              text: "Use service mesh, network policies, and egress filtering",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers of network security prevent SSRF exploitation.",
              nextStep: 2
            },
            {
              text: "Disable all outbound internet access",
              correct: false,
              points: 5,
              feedback: "Not practical for applications requiring external API calls.",
              nextStep: 2
            },
            {
              text: "Use shorter DNS TTL values",
              correct: false,
              points: 0,
              feedback: "DNS configuration doesn't prevent SSRF attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cloud SSRF protection implemented! All internal services and metadata endpoints properly isolated.",
          choices: []
        }
      ]
    }
  },

  insecureDesign: {
    id: 20,
    title: "Business Logic Bypass",
    difficulty: "Hard",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover a shopping cart that calculates prices client-side. What vulnerability are you testing for?",
          choices: [
            {
              text: "Price manipulation through client-side tampering",
              correct: true,
              points: 20,
              feedback: "Correct! Client-side price calculation allows price manipulation attacks.",
              nextStep: 1
            },
            {
              text: "SQL injection in product search",
              correct: false,
              points: 10,
              feedback: "Different vulnerability class. Focus on the business logic flaw.",
              nextStep: 0
            },
            {
              text: "XSS in product reviews",
              correct: false,
              points: 5,
              feedback: "XSS is important but unrelated to the pricing logic vulnerability.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully manipulated cart prices. How do you demonstrate the business impact?",
          choices: [
            {
              text: "Show financial loss through manipulated transactions",
              correct: true,
              points: 25,
              feedback: "Critical! Business logic flaws can lead to direct financial losses.",
              nextStep: 2
            },
            {
              text: "Just document the technical vulnerability",
              correct: false,
              points: 15,
              feedback: "Good for technical teams, but financial impact drives business action.",
              nextStep: 2
            },
            {
              text: "Place large orders with manipulated prices",
              correct: false,
              points: -15,
              feedback: "Exploiting the vulnerability for personal gain is unethical and illegal.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Business logic bypass demonstrated! Client-side trust leads to financial manipulation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're fixing client-side trust issues. What's the fundamental principle?",
          choices: [
            {
              text: "Never trust client-side data - validate everything server-side",
              correct: true,
              points: 20,
              feedback: "Essential! Server-side validation prevents client-side manipulation.",
              nextStep: 1
            },
            {
              text: "Encrypt all client-side data",
              correct: false,
              points: 10,
              feedback: "Encryption doesn't prevent manipulation if the client controls the keys.",
              nextStep: 1
            },
            {
              text: "Use digital signatures for client data",
              correct: false,
              points: 15,
              feedback: "Signatures help but server-side validation is still required.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good principle! What comprehensive business logic security should you implement?",
          choices: [
            {
              text: "Implement server-side validation, audit trails, and fraud detection",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers of business logic security prevent manipulation.",
              nextStep: 2
            },
            {
              text: "Remove all client-side JavaScript",
              correct: false,
              points: 0,
              feedback: "Not practical for modern web applications.",
              nextStep: 2
            },
            {
              text: "Trust but verify client-side calculations",
              correct: false,
              points: -10,
              feedback: "This approach still allows manipulation before verification.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Business logic security implemented! All critical operations validated server-side with proper auditing.",
          choices: []
        }
      ]
    }
  },

   sqlInjectionAdvanced: {
    id: 21,
    title: "Blind SQL Injection",
    difficulty: "Expert",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You're testing a login form that shows 'Invalid credentials' for wrong passwords. No data is directly displayed. What technique do you use?",
          choices: [
            {
              text: "Use time-based blind SQL injection with SLEEP() or WAITFOR DELAY",
              correct: true,
              points: 25,
              feedback: "Perfect! Time-based blind injection uses response delays to extract data bit by bit.",
              nextStep: 1
            },
            {
              text: "Try boolean-based blind injection with conditional responses",
              correct: false,
              points: 20,
              feedback: "Good alternative, but time-based is more reliable when no differential response is visible.",
              nextStep: 0
            },
            {
              text: "Use error-based injection to force database errors",
              correct: false,
              points: 15,
              feedback: "Error-based works when errors are displayed, but here we have uniform error messages.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You confirm time-based injection works. How do you extract the first character of the database name?",
          choices: [
            {
              text: "Use substring and ASCII functions with timing attacks",
              correct: true,
              points: 30,
              feedback: "Excellent! This method extracts data character by character using response timing.",
              nextStep: 2
            },
            {
              text: "Try to guess common database names",
              correct: false,
              points: 5,
              feedback: "Guessing is inefficient. Automated extraction is the proper approach.",
              nextStep: 2
            },
            {
              text: "Use out-of-band data exfiltration",
              correct: false,
              points: 20,
              feedback: "OOB works but requires DNS or HTTP callbacks which might be blocked.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Database name successfully extracted through blind SQL injection! Critical data retrieved without direct output.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're defending against blind SQL injection. What's the most effective prevention?",
          choices: [
            {
              text: "Implement parameterized queries and use ORM with built-in protection",
              correct: true,
              points: 25,
              feedback: "Essential! Parameterized queries prevent all SQL injection types, including blind.",
              nextStep: 1
            },
            {
              text: "Add WAF rules to detect sleep commands",
              correct: false,
              points: 15,
              feedback: "WAF helps but can be bypassed. Fix the root cause instead.",
              nextStep: 1
            },
            {
              text: "Implement random response delays",
              correct: false,
              points: 10,
              feedback: "This makes exploitation harder but doesn't prevent injection.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What additional monitoring should you implement for blind SQLi detection?",
          choices: [
            {
              text: "Monitor for unusual timing patterns and multiple similar requests",
              correct: true,
              points: 30,
              feedback: "Perfect! Behavioral analysis can detect blind injection attempts through timing patterns.",
              nextStep: 2
            },
            {
              text: "Log all SQL queries for manual review",
              correct: false,
              points: 10,
              feedback: "Not scalable. Automated detection is needed for blind SQLi.",
              nextStep: 2
            },
            {
              text: "Block requests containing SQL functions",
              correct: false,
              points: 15,
              feedback: "Blacklisting can be bypassed with encoding or alternative syntax.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Blind SQL injection protection implemented! All database queries properly parameterized and monitored.",
          choices: []
        }
      ]
    }
  },

  apiAuthBypass: {
    id: 22,
    title: "API Authentication Bypass",
    difficulty: "Hard",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover a mobile app API that uses API keys. The key is visible in the app's code. What's your approach?",
          choices: [
            {
              text: "Extract the API key and use it to make direct API calls",
              correct: true,
              points: 20,
              feedback: "Correct! Hardcoded API keys can be extracted and used to bypass authentication.",
              nextStep: 1
            },
            {
              text: "Try to guess other API keys",
              correct: false,
              points: 5,
              feedback: "API keys are usually long and random, making guessing impractical.",
              nextStep: 0
            },
            {
              text: "Look for JWT tokens instead",
              correct: false,
              points: 10,
              feedback: "Good thinking, but the current vulnerability is the hardcoded API key.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully used the API key to access user data. How do you demonstrate the impact?",
          choices: [
            {
              text: "Show access to multiple users' private data through API endpoints",
              correct: true,
              points: 25,
              feedback: "Critical! Hardcoded API keys can lead to massive data exposure.",
              nextStep: 2
            },
            {
              text: "Just document the exposed API key",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating data access shows real risk.",
              nextStep: 2
            },
            {
              text: "Modify user data through the API",
              correct: false,
              points: -15,
              feedback: "Unauthorized modifications are destructive and unethical.",
              nextStep: 2
            }
          ]
        },
        {
          text: "API authentication completely bypassed! Hardcoded keys lead to unauthorized data access.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing mobile app API authentication. What's the proper approach?",
          choices: [
            {
              text: "Use OAuth 2.0 with PKCE or client certificates instead of static keys",
              correct: true,
              points: 25,
              feedback: "Perfect! OAuth 2.0 with PKCE provides secure mobile authentication without static secrets.",
              nextStep: 1
            },
            {
              text: "Encrypt the API key in the app",
              correct: false,
              points: 10,
              feedback: "Encryption can be reversed. The key is still exposed in the app bundle.",
              nextStep: 1
            },
            {
              text: "Use IP whitelisting for API access",
              correct: false,
              points: 15,
              feedback: "IP whitelisting can be bypassed and doesn't work well with mobile networks.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What additional mobile API security should you implement?",
          choices: [
            {
              text: "Implement token rotation, certificate pinning, and runtime protection",
              correct: true,
              points: 30,
              feedback: "Excellent! Multiple layers of mobile-specific security measures.",
              nextStep: 2
            },
            {
              text: "Use the same API key for all mobile apps",
              correct: false,
              points: -10,
              feedback: "This increases risk - compromise of one app affects all.",
              nextStep: 2
            },
            {
              text: "Hide API keys in environment variables",
              correct: false,
              points: 5,
              feedback: "Environment variables in mobile apps can still be extracted.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Mobile API security properly implemented! All authentication uses modern, secure protocols.",
          choices: []
        }
      ]
    }
  },

  encryptionMisuse: {
    id: 23,
    title: "Encryption Algorithm Misuse",
    difficulty: "Expert",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover an application using ECB mode for AES encryption. What's the primary vulnerability?",
          choices: [
            {
              text: "Pattern preservation allowing ciphertext manipulation",
              correct: true,
              points: 25,
              feedback: "Correct! ECB mode reveals patterns in plaintext and allows block manipulation attacks.",
              nextStep: 1
            },
            {
              text: "Weak key generation",
              correct: false,
              points: 10,
              feedback: "Key generation might be fine - the issue is the encryption mode itself.",
              nextStep: 0
            },
            {
              text: "Lack of authentication",
              correct: false,
              points: 15,
              feedback: "Authentication is separate issue. ECB's main flaw is pattern preservation.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you demonstrate the ECB mode vulnerability?",
          choices: [
            {
              text: "Show how identical plaintext blocks produce identical ciphertext blocks",
              correct: true,
              points: 30,
              feedback: "Perfect! This demonstrates the fundamental flaw in ECB mode encryption.",
              nextStep: 2
            },
            {
              text: "Try to brute force the encryption key",
              correct: false,
              points: 10,
              feedback: "Brute forcing AES is impractical. Focus on the mode vulnerability.",
              nextStep: 2
            },
            {
              text: "Use padding oracle attacks",
              correct: false,
              points: 20,
              feedback: "Padding oracle works on CBC mode, not specifically ECB.",
              nextStep: 2
            }
          ]
        },
        {
          text: "ECB mode vulnerability demonstrated! Cryptographic misuse leads to pattern exposure and manipulation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're fixing encryption implementation. What's the recommended mode for AES?",
          choices: [
            {
              text: "Use authenticated encryption like AES-GCM or AES-CCM",
              correct: true,
              points: 25,
              feedback: "Perfect! Authenticated encryption provides both confidentiality and integrity.",
              nextStep: 1
            },
            {
              text: "Switch to AES-CBC with custom MAC",
              correct: false,
              points: 15,
              feedback: "CBC is better than ECB but authenticated modes are preferred.",
              nextStep: 1
            },
            {
              text: "Use AES-OFB mode",
              correct: false,
              points: 10,
              feedback: "OFB is a stream cipher mode but doesn't provide authentication.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive cryptographic practices should you implement?",
          choices: [
            {
              text: "Use standard libraries, proper IV generation, and key management",
              correct: true,
              points: 30,
              feedback: "Excellent! Proper crypto implementation requires multiple security layers.",
              nextStep: 2
            },
            {
              text: "Implement custom encryption algorithms",
              correct: false,
              points: -20,
              feedback: "Never implement custom crypto - always use well-vetted standard algorithms.",
              nextStep: 2
            },
            {
              text: "Use multiple encryption layers",
              correct: false,
              points: 5,
              feedback: "Multiple layers don't necessarily improve security and complicate implementation.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cryptographic implementation secured! All encryption uses authenticated modes and proper practices.",
          choices: []
        }
      ]
    }
  },

  massAssignment: {
    id: 24,
    title: "Mass Assignment Vulnerability",
    difficulty: "Medium",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You found a user registration API that accepts JSON objects. How do you test for mass assignment?",
          choices: [
            {
              text: "Add admin:true or role:admin to the registration request",
              correct: true,
              points: 20,
              feedback: "Correct! Mass assignment tests if you can set privileged properties not intended for user input.",
              nextStep: 1
            },
            {
              text: "Try SQL injection in the email field",
              correct: false,
              points: 10,
              feedback: "Different vulnerability class. Focus on object property manipulation.",
              nextStep: 0
            },
            {
              text: "Send extremely large JSON objects",
              correct: false,
              points: 5,
              feedback: "This tests for DoS, not mass assignment specifically.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully set admin privileges through mass assignment. What's the impact?",
          choices: [
            {
              text: "Demonstrate unauthorized administrative access and privileges",
              correct: true,
              points: 25,
              feedback: "Critical! Mass assignment can lead to complete privilege escalation.",
              nextStep: 2
            },
            {
              text: "Just document the parameter injection",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but showing admin access demonstrates real risk.",
              nextStep: 2
            },
            {
              text: "Create multiple admin accounts",
              correct: false,
              points: -15,
              feedback: "Creating unauthorized admin accounts is destructive and unethical.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Mass assignment vulnerability exploited! Unauthorized privilege escalation achieved.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing against mass assignment attacks. What's the primary defense?",
          choices: [
            {
              text: "Use allowlisting for acceptable parameters and data transfer objects",
              correct: true,
              points: 25,
              feedback: "Essential! Allowlisting ensures only intended properties can be set by users.",
              nextStep: 1
            },
            {
              text: "Use blocklisting for sensitive fields",
              correct: false,
              points: 10,
              feedback: "Blocklisting can be bypassed with field name variations.",
              nextStep: 1
            },
            {
              text: "Encrypt all request parameters",
              correct: false,
              points: 5,
              feedback: "Encryption doesn't prevent mass assignment if the app decrypts and processes all fields.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good approach! What additional security measures prevent mass assignment?",
          choices: [
            {
              text: "Implement view models and proper object mapping with validation",
              correct: true,
              points: 30,
              feedback: "Perfect! Proper architecture with view models prevents direct binding to domain objects.",
              nextStep: 2
            },
            {
              text: "Remove all sensitive fields from database models",
              correct: false,
              points: 0,
              feedback: "Not practical. Sensitive fields are needed for application functionality.",
              nextStep: 2
            },
            {
              text: "Use random field names that change frequently",
              correct: false,
              points: -10,
              feedback: "Security through obscurity is not a reliable defense.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Mass assignment protection implemented! All user input properly validated and mapped.",
          choices: []
        }
      ]
    }
  },

  headerInjection: {
    id: 25,
    title: "HTTP Header Injection",
    difficulty: "Medium",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You found a redirect functionality that takes a URL parameter and sets Location header. What do you test?",
          choices: [
            {
              text: "Try to inject CRLF sequences to add additional headers",
              correct: true,
              points: 20,
              feedback: "Correct! CRLF injection can add malicious headers or split responses.",
              nextStep: 1
            },
            {
              text: "Test for open redirect vulnerabilities",
              correct: false,
              points: 15,
              feedback: "Open redirect is different from header injection, though related.",
              nextStep: 0
            },
            {
              text: "Try XSS in the redirect parameter",
              correct: false,
              points: 10,
              feedback: "XSS works in content, not headers. Focus on header manipulation.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully injected headers. What's the most dangerous exploitation?",
          choices: [
            {
              text: "Set cookies or perform response splitting to poison caches",
              correct: true,
              points: 25,
              feedback: "Critical! Header injection can set malicious cookies or split HTTP responses.",
              nextStep: 2
            },
            {
              text: "Just demonstrate header modification",
              correct: false,
              points: 15,
              feedback: "Good proof, but showing cache poisoning or cookie setting demonstrates real impact.",
              nextStep: 2
            },
            {
              text: "Try to overwrite server headers",
              correct: false,
              points: 10,
              feedback: "Server headers are usually set after application headers.",
              nextStep: 2
            }
          ]
        },
        {
          text: "HTTP header injection successful! Response manipulation and cache poisoning demonstrated.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're fixing header injection vulnerabilities. What's the primary defense?",
          choices: [
            {
              text: "Validate and encode user input used in HTTP headers",
              correct: true,
              points: 25,
              feedback: "Essential! Proper validation and encoding prevent CRLF injection attacks.",
              nextStep: 1
            },
            {
              text: "Use HTTPS for all communications",
              correct: false,
              points: 10,
              feedback: "HTTPS protects confidentiality but doesn't prevent header injection.",
              nextStep: 1
            },
            {
              text: "Remove all redirect functionality",
              correct: false,
              points: 0,
              feedback: "Not practical. Redirects are needed for proper application flow.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive header security should you implement?",
          choices: [
            {
              text: "Use security headers, input validation, and safe redirect libraries",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers of protection for HTTP header security.",
              nextStep: 2
            },
            {
              text: "Block all CRLF characters in user input",
              correct: false,
              points: 15,
              feedback: "Blacklisting can be bypassed with encoding. Use proper validation instead.",
              nextStep: 2
            },
            {
              text: "Use custom header encoding schemes",
              correct: false,
              points: 5,
              feedback: "Custom schemes can introduce new vulnerabilities. Use standard practices.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Header security implemented! All user input properly validated before use in HTTP headers.",
          choices: []
        }
      ]
    }
  },

  prototypePollution: {
    id: 26,
    title: "JavaScript Prototype Pollution",
    difficulty: "Expert",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You found an endpoint that merges user-provided objects. How do you test for prototype pollution?",
          choices: [
            {
              text: "Send objects with __proto__ or constructor properties",
              correct: true,
              points: 25,
              feedback: "Correct! Prototype pollution tests if user input can modify Object prototype.",
              nextStep: 1
            },
            {
              text: "Try SQL injection in object values",
              correct: false,
              points: 10,
              feedback: "Different vulnerability class. Focus on JavaScript object manipulation.",
              nextStep: 0
            },
            {
              text: "Send deeply nested objects",
              correct: false,
              points: 15,
              feedback: "Deep nesting tests for recursion issues, not specifically prototype pollution.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully polluted the Object prototype. What's the most critical impact?",
          choices: [
            {
              text: "Achieve remote code execution through pollution to RCE gadgets",
              correct: true,
              points: 30,
              feedback: "Critical! Prototype pollution can lead to RCE in certain JavaScript environments.",
              nextStep: 2
            },
            {
              text: "Just demonstrate property injection",
              correct: false,
              points: 20,
              feedback: "Good proof, but RCE demonstrates the ultimate impact.",
              nextStep: 2
            },
            {
              text: "Cause application crashes",
              correct: false,
              points: 10,
              feedback: "DoS is possible but less critical than code execution.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Prototype pollution exploited! Object prototype modified leading to potential RCE.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing against prototype pollution. What's the primary defense?",
          choices: [
            {
              text: "Use safe object merging libraries and validate input keys",
              correct: true,
              points: 25,
              feedback: "Essential! Safe merging libraries prevent prototype pollution attacks.",
              nextStep: 1
            },
            {
              text: "Block __proto__ and constructor in user input",
              correct: false,
              points: 15,
              feedback: "Blacklisting can be bypassed. Use safe merging practices instead.",
              nextStep: 1
            },
            {
              text: "Use Object.freeze on prototypes",
              correct: false,
              points: 20,
              feedback: "Freezing helps but should be combined with safe object handling.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive JavaScript security should you implement?",
          choices: [
            {
              text: "Use Content Security Policy, safe Eval alternatives, and input sanitization",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers of JavaScript security prevent various client-side attacks.",
              nextStep: 2
            },
            {
              text: "Disable all JavaScript functionality",
              correct: false,
              points: 0,
              feedback: "Not practical for modern web applications.",
              nextStep: 2
            },
            {
              text: "Use custom JavaScript interpreters",
              correct: false,
              points: -10,
              feedback: "Custom interpreters can introduce new security issues.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Prototype pollution protection implemented! All object operations use safe practices.",
          choices: []
        }
      ]
    }
  },

  dependencyConfusion: {
    id: 27,
    title: "Dependency Confusion Attack",
    difficulty: "Hard",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover a company using internal Python packages with names not registered on PyPI. What attack do you attempt?",
          choices: [
            {
              text: "Register the same package names on public repositories with higher versions",
              correct: true,
              points: 25,
              feedback: "Correct! Dependency confusion exploits build systems that prefer public packages over internal ones.",
              nextStep: 1
            },
            {
              text: "Try to breach their internal package repository",
              correct: false,
              points: 15,
              feedback: "Direct attacks on internal repos are harder than dependency confusion.",
              nextStep: 0
            },
            {
              text: "Find zero-days in their dependencies",
              correct: false,
              points: 10,
              feedback: "Zero-days are rare. Dependency confusion is a reliable attack vector.",
              nextStep: 0
            }
          ]
        },
        {
          text: "Your malicious package gets downloaded by their build system. What's the impact?",
          choices: [
            {
              text: "Achieve code execution in their build and deployment pipelines",
              correct: true,
              points: 30,
              feedback: "Critical! Dependency confusion can lead to complete CI/CD pipeline compromise.",
              nextStep: 2
            },
            {
              text: "Just demonstrate package download",
              correct: false,
              points: 15,
              feedback: "Good proof, but code execution shows the real business risk.",
              nextStep: 2
            },
            {
              text: "Cause build failures",
              correct: false,
              points: 10,
              feedback: "DoS is possible but less critical than code execution.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Dependency confusion attack successful! Malicious code executed in build pipeline.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're protecting against dependency confusion. What's the primary defense?",
          choices: [
            {
              text: "Configure package managers to prefer internal repositories over public ones",
              correct: true,
              points: 25,
              feedback: "Essential! Proper repository configuration prevents dependency confusion.",
              nextStep: 1
            },
            {
              text: "Use digitally signed packages only",
              correct: false,
              points: 20,
              feedback: "Signing helps but doesn't prevent confusion if public packages are considered.",
              nextStep: 1
            },
            {
              text: "Scan all public packages for your names",
              correct: false,
              points: 15,
              feedback: "Reactive approach. Configuration changes are more effective.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive supply chain security should you implement?",
          choices: [
            {
              text: "Implement namespace scoping, pipeline security, and artifact signing",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers of supply chain security prevent various attacks.",
              nextStep: 2
            },
            {
              text: "Remove all internal package repositories",
              correct: false,
              points: -10,
              feedback: "Not practical. Internal repos are needed for proprietary code.",
              nextStep: 2
            },
            {
              text: "Use only latest package versions",
              correct: false,
              points: 5,
              feedback: "Latest versions can have new vulnerabilities. Use proper dependency management.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Dependency confusion protection implemented! All package managers properly configured and secured.",
          choices: []
        }
      ]
    }
  },

  logForging: {
    id: 28,
    title: "Log Forging Attack",
    difficulty: "Medium",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover user input being written to log files without sanitization. What attack do you attempt?",
          choices: [
            {
              text: "Inject fake log entries with carriage returns and line feeds",
              correct: true,
              points: 20,
              feedback: "Correct! Log forging uses control characters to create fake log entries.",
              nextStep: 1
            },
            {
              text: "Try to read the log files directly",
              correct: false,
              points: 10,
              feedback: "Log reading is good, but forging demonstrates a more sophisticated attack.",
              nextStep: 0
            },
            {
              text: "Cause log file corruption",
              correct: false,
              points: -5,
              feedback: "Destructive actions are unethical and may trigger alerts.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully created fake log entries. What's the security impact?",
          choices: [
            {
              text: "Demonstrate how attack traces can be hidden or false evidence created",
              correct: true,
              points: 25,
              feedback: "Critical! Log forging undermines forensic analysis and incident response.",
              nextStep: 2
            },
            {
              text: "Just show the forged entries",
              correct: false,
              points: 15,
              feedback: "Good proof, but showing the impact on forensics is more compelling.",
              nextStep: 2
            },
            {
              text: "Delete genuine log entries",
              correct: false,
              points: -15,
              feedback: "Destructive and easily detectable. Focus on demonstrating the vulnerability.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Log forging successful! Forensic integrity compromised through log manipulation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing secure logging against forging attacks. What's the primary defense?",
          choices: [
            {
              text: "Sanitize all user input by removing control characters before logging",
              correct: true,
              points: 25,
              feedback: "Essential! Input sanitization prevents log forging attacks.",
              nextStep: 1
            },
            {
              text: "Encrypt all log files",
              correct: false,
              points: 10,
              feedback: "Encryption protects confidentiality but doesn't prevent forging.",
              nextStep: 1
            },
            {
              text: "Use binary log formats exclusively",
              correct: false,
              points: 15,
              feedback: "Binary formats help but don't solve the fundamental injection problem.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive logging security should you implement?",
          choices: [
            {
              text: "Implement log integrity protection, centralized logging, and monitoring",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers of logging security prevent manipulation and ensure integrity.",
              nextStep: 2
            },
            {
              text: "Disable detailed logging of user input",
              correct: false,
              points: 10,
              feedback: "Detailed logs are essential for security monitoring and forensics.",
              nextStep: 2
            },
            {
              text: "Store logs in write-once media",
              correct: false,
              points: 20,
              feedback: "Helpful for integrity but not always practical for high-volume applications.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure logging implemented! All logs protected against forging and manipulation.",
          choices: []
        }
      ]
    }
  },

  dnsRebinding: {
    id: 29,
    title: "DNS Rebinding Attack",
    difficulty: "Expert",
    vulnerability: "A10:2021 - Server-Side Request Forgery (SSRF)",
    attacker: {
      story: [
        {
          text: "You want to attack an internal service but the application blocks internal IPs. What technique do you use?",
          choices: [
            {
              text: "Use DNS rebinding with very short TTL to bypass IP checks",
              correct: true,
              points: 30,
              feedback: "Correct! DNS rebinding bypasses IP filters by resolving to different IPs on subsequent requests.",
              nextStep: 1
            },
            {
              text: "Try IPv6 internal addresses",
              correct: false,
              points: 15,
              feedback: "IPv6 might work if not filtered, but DNS rebinding is more reliable.",
              nextStep: 0
            },
            {
              text: "Use URL shorteners or redirect chains",
              correct: false,
              points: 10,
              feedback: "Redirects are usually followed and filtered at the final destination.",
              nextStep: 0
            }
          ]
        },
        {
          text: "Your DNS rebinding attack works. What internal service do you target first?",
          choices: [
            {
              text: "Target cloud metadata services or internal APIs",
              correct: true,
              points: 35,
              feedback: "Critical! DNS rebinding can access internal services that would normally be blocked.",
              nextStep: 2
            },
            {
              text: "Just access the internal network gateway",
              correct: false,
              points: 20,
              feedback: "Good reconnaissance, but accessing specific services shows real impact.",
              nextStep: 2
            },
            {
              text: "Try to access random internal IPs",
              correct: false,
              points: 10,
              feedback: "Targeted attacks on known services are more effective.",
              nextStep: 2
            }
          ]
        },
        {
          text: "DNS rebinding successful! Internal services accessed despite IP filtering protections.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're defending against DNS rebinding attacks. What's the most effective protection?",
          choices: [
            {
              text: "Validate and cache DNS resolutions at application level",
              correct: true,
              points: 30,
              feedback: "Essential! DNS resolution caching prevents rebinding by using consistent IP mappings.",
              nextStep: 1
            },
            {
              text: "Block all domains with short TTL values",
              correct: false,
              points: 15,
              feedback: "Not practical. Many legitimate domains use short TTLs.",
              nextStep: 1
            },
            {
              text: "Use IP whitelisting for outbound requests",
              correct: false,
              points: 20,
              feedback: "IP whitelisting is too restrictive for most applications.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive network security should you implement?",
          choices: [
            {
              text: "Implement network segmentation, egress filtering, and host-based firewalls",
              correct: true,
              points: 35,
              feedback: "Perfect! Defense in depth with multiple network security layers.",
              nextStep: 2
            },
            {
              text: "Disable all outbound DNS lookups",
              correct: false,
              points: 5,
              feedback: "Not practical for applications requiring external services.",
              nextStep: 2
            },
            {
              text: "Use custom DNS resolvers for all applications",
              correct: false,
              points: 15,
              feedback: "Custom resolvers help but don't prevent all rebinding attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "DNS rebinding protection implemented! All outbound requests properly validated and cached.",
          choices: []
        }
      ]
    }
  },
  raceCondition: {
    id: 30,
    title: "Race Condition Attack",
    difficulty: "Expert",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You found a coupon application that checks balance then applies discount. What vulnerability might exist?",
          choices: [
            {
              text: "Race condition allowing multiple uses of limited resources",
              correct: true,
              points: 25,
              feedback: "Correct! Time-of-check to time-of-use (TOCTOU) vulnerabilities enable race conditions.",
              nextStep: 1
            },
            {
              text: "SQL injection in coupon validation",
              correct: false,
              points: 10,
              feedback: "Different vulnerability class. Focus on timing and concurrency issues.",
              nextStep: 0
            },
            {
              text: "Weak coupon code generation",
              correct: false,
              points: 5,
              feedback: "Code generation is separate from the redemption logic vulnerability.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit the race condition?",
          choices: [
            {
              text: "Send multiple concurrent requests to use the coupon multiple times",
              correct: true,
              points: 30,
              feedback: "Perfect! Concurrent requests can bypass single-use restrictions through race conditions.",
              nextStep: 2
            },
            {
              text: "Try to predict other coupon codes",
              correct: false,
              points: 10,
              feedback: "Code prediction is different from race condition exploitation.",
              nextStep: 2
            },
            {
              text: "Modify the coupon balance directly",
              correct: false,
              points: -10,
              feedback: "Direct modification is destructive and may not be possible.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Race condition exploited! Limited resources bypassed through concurrent access.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're fixing race condition vulnerabilities. What's the primary defense?",
          choices: [
            {
              text: "Implement proper locking mechanisms or atomic operations",
              correct: true,
              points: 25,
              feedback: "Essential! Database locks or atomic operations prevent race conditions.",
              nextStep: 1
            },
            {
              text: "Add rate limiting to API endpoints",
              correct: false,
              points: 15,
              feedback: "Rate limiting helps but doesn't prevent all race conditions.",
              nextStep: 1
            },
            {
              text: "Use longer processing delays",
              correct: false,
              points: 5,
              feedback: "Delays don't prevent determined attackers and hurt user experience.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive concurrency security should you implement?",
          choices: [
            {
              text: "Use database transactions, optimistic locking, and idempotent operations",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple concurrency control mechanisms prevent race conditions.",
              nextStep: 2
            },
            {
              text: "Process all requests sequentially",
              correct: false,
              points: 0,
              feedback: "Not scalable for high-traffic applications.",
              nextStep: 2
            },
            {
              text: "Add random delays in processing",
              correct: false,
              points: 5,
              feedback: "Random delays don't reliably prevent race conditions.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Race condition protection implemented! All critical operations use proper concurrency control.",
          choices: []
        }
      ]
    }
  },

  graphqlInjection: {
    id: 31,
    title: "GraphQL Injection Attacks",
    difficulty: "Hard",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover a GraphQL endpoint with introspection enabled. What's your first reconnaissance step?",
          choices: [
            {
              text: "Use introspection query to map the entire schema",
              correct: true,
              points: 20,
              feedback: "Perfect! GraphQL introspection reveals the complete API schema including all queries and mutations.",
              nextStep: 1
            },
            {
              text: "Try SQL injection in query parameters",
              correct: false,
              points: 10,
              feedback: "GraphQL uses different injection vectors. Schema mapping is the first step.",
              nextStep: 0
            },
            {
              text: "Send malformed JSON payloads",
              correct: false,
              points: 5,
              feedback: "Good for fuzzing, but schema introspection provides structured information.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You found a query that takes user input. How do you test for GraphQL injection?",
          choices: [
            {
              text: "Use field duplication and aliasing to bypass limits",
              correct: true,
              points: 25,
              feedback: "Excellent! GraphQL field duplication can bypass rate limits and extract more data than intended.",
              nextStep: 2
            },
            {
              text: "Try traditional SQL injection payloads",
              correct: false,
              points: 10,
              feedback: "GraphQL injection works differently than SQL injection.",
              nextStep: 2
            },
            {
              text: "Use batch queries to overwhelm the server",
              correct: false,
              points: 15,
              feedback: "This tests for DoS, not data extraction through injection.",
              nextStep: 2
            }
          ]
        },
        {
          text: "GraphQL injection successful! Schema introspection and field duplication exploited for data extraction.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing a GraphQL API. What's the first security control to implement?",
          choices: [
            {
              text: "Disable introspection in production and implement query depth limiting",
              correct: true,
              points: 25,
              feedback: "Essential! Disabling introspection and limiting query complexity prevents reconnaissance and DoS.",
              nextStep: 1
            },
            {
              text: "Add authentication to all queries",
              correct: false,
              points: 15,
              feedback: "Authentication is important but doesn't prevent schema discovery or complex queries.",
              nextStep: 1
            },
            {
              text: "Use query whitelisting only",
              correct: false,
              points: 10,
              feedback: "Whitelisting helps but should be combined with other GraphQL-specific controls.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good start! What comprehensive GraphQL security should you implement?",
          choices: [
            {
              text: "Implement query cost analysis, rate limiting, and input validation",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers of GraphQL-specific security controls.",
              nextStep: 2
            },
            {
              text: "Convert everything to REST API",
              correct: false,
              points: 0,
              feedback: "Not practical. GraphQL has legitimate use cases when properly secured.",
              nextStep: 2
            },
            {
              text: "Use the latest GraphQL version only",
              correct: false,
              points: 5,
              feedback: "Version updates help but don't replace proper security configuration.",
              nextStep: 2
            }
          ]
        },
        {
          text: "GraphQL security implemented! All endpoints properly configured with depth limiting and cost analysis.",
          choices: []
        }
      ]
    }
  },

  jwtWeaknesses: {
    id: 32,
    title: "JWT Implementation Flaws",
    difficulty: "Medium",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You intercept a JWT token that uses 'none' algorithm. What's your attack approach?",
          choices: [
            {
              text: "Modify the algorithm to 'none' and remove the signature",
              correct: true,
              points: 20,
              feedback: "Correct! 'none' algorithm vulnerability allows token modification without verification.",
              nextStep: 1
            },
            {
              text: "Try to brute force the secret key",
              correct: false,
              points: 10,
              feedback: "Brute forcing is inefficient when algorithm manipulation works.",
              nextStep: 0
            },
            {
              text: "Replay the token multiple times",
              correct: false,
              points: 5,
              feedback: "Replay might work but algorithm manipulation is more powerful.",
              nextStep: 0
            }
          ]
        },
        {
          text: "The 'none' algorithm attack works. How do you escalate privileges?",
          choices: [
            {
              text: "Modify payload to add admin claims or change user roles",
              correct: true,
              points: 25,
              feedback: "Critical! JWT algorithm confusion leads to complete privilege escalation.",
              nextStep: 2
            },
            {
              text: "Create tokens for other users",
              correct: false,
              points: 15,
              feedback: "Good, but modifying existing tokens to gain admin access is more impactful.",
              nextStep: 2
            },
            {
              text: "Extend token expiration indefinitely",
              correct: false,
              points: 10,
              feedback: "Helpful but doesn't demonstrate privilege escalation.",
              nextStep: 2
            }
          ]
        },
        {
          text: "JWT algorithm confusion exploited! Administrative access achieved through token manipulation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing secure JWT validation. What's the most critical control?",
          choices: [
            {
              text: "Explicitly verify algorithm and don't trust client-specified alg",
              correct: true,
              points: 25,
              feedback: "Essential! Always verify the expected algorithm to prevent algorithm confusion attacks.",
              nextStep: 1
            },
            {
              text: "Use longer secret keys",
              correct: false,
              points: 10,
              feedback: "Key length doesn't prevent algorithm confusion attacks.",
              nextStep: 1
            },
            {
              text: "Encrypt JWT payloads",
              correct: false,
              points: 15,
              feedback: "Encryption protects confidentiality but doesn't prevent algorithm attacks.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive JWT security should you implement?",
          choices: [
            {
              text: "Use asymmetric crypto, proper expiration, and token blacklisting",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple JWT security layers including crypto, expiration, and revocation.",
              nextStep: 2
            },
            {
              text: "Store all tokens in database",
              correct: false,
              points: 5,
              feedback: "Defeats the purpose of stateless JWT tokens.",
              nextStep: 2
            },
            {
              text: "Use custom encryption algorithms",
              correct: false,
              points: -10,
              feedback: "Never use custom crypto. Stick to well-vetted standard algorithms.",
              nextStep: 2
            }
          ]
        },
        {
          text: "JWT security properly implemented! All tokens validated with explicit algorithm verification.",
          choices: []
        }
      ]
    }
  },

  hashLengthExtension: {
    id: 33,
    title: "Hash Length Extension Attack",
    difficulty: "Expert",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover an API using MD5 with secret prefix: HASH(secret + data). What vulnerability exists?",
          choices: [
            {
              text: "Hash length extension attack",
              correct: true,
              points: 30,
              feedback: "Correct! MD5 and other Merkle-Damgrd hashes are vulnerable to length extension attacks.",
              nextStep: 1
            },
            {
              text: "Hash collision attack",
              correct: false,
              points: 15,
              feedback: "Collision attacks are different from length extension attacks.",
              nextStep: 0
            },
            {
              text: "Rainbow table attack",
              correct: false,
              points: 10,
              feedback: "Rainbow tables work on unsalted hashes, not secret-prefix constructions.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit the length extension vulnerability?",
          choices: [
            {
              text: "Append data to original message and compute valid hash without knowing secret",
              correct: true,
              points: 35,
              feedback: "Perfect! Length extension allows adding data to authenticated messages without the secret.",
              nextStep: 2
            },
            {
              text: "Try to extract the secret through timing attacks",
              correct: false,
              points: 15,
              feedback: "Timing attacks are different and usually harder than length extension.",
              nextStep: 2
            },
            {
              text: "Use hash collision to create forged messages",
              correct: false,
              points: 20,
              feedback: "Collision attacks require finding two messages with same hash.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Hash length extension successful! Message authentication bypassed without knowing the secret.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're fixing hash-based message authentication. What's the secure alternative?",
          choices: [
            {
              text: "Use HMAC instead of simple hash(secret + message)",
              correct: true,
              points: 30,
              feedback: "Essential! HMAC is specifically designed to prevent length extension attacks.",
              nextStep: 1
            },
            {
              text: "Switch to SHA-3 instead of MD5",
              correct: false,
              points: 20,
              feedback: "SHA-3 resists length extension but HMAC is still the proper construction.",
              nextStep: 1
            },
            {
              text: "Use hash(message + secret) instead",
              correct: false,
              points: 15,
              feedback: "This helps but HMAC is the cryptographically proven secure method.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive crypto authentication should you implement?",
          choices: [
            {
              text: "Use HMAC-SHA256, proper key management, and constant-time comparison",
              correct: true,
              points: 35,
              feedback: "Perfect! Modern HMAC with proper implementation practices.",
              nextStep: 2
            },
            {
              text: "Implement multiple hash layers",
              correct: false,
              points: 5,
              feedback: "Multiple hashes don't necessarily improve security and can introduce issues.",
              nextStep: 2
            },
            {
              text: "Use encryption instead of hashing",
              correct: false,
              points: 10,
              feedback: "Encryption serves different purposes than message authentication.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure message authentication implemented! All hashing uses HMAC with strong algorithms.",
          choices: []
        }
      ]
    }
  },

  corsMisconfiguration: {
    id: 34,
    title: "CORS Misconfiguration",
    difficulty: "Medium",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover an API with wildcard CORS policy: Access-Control-Allow-Origin: *. What's the risk?",
          choices: [
            {
              text: "Cross-origin attacks can read sensitive data from authenticated sessions",
              correct: true,
              points: 20,
              feedback: "Correct! Wildcard CORS allows any website to make authenticated requests to the API.",
              nextStep: 1
            },
            {
              text: "The API can be accessed from any domain",
              correct: false,
              points: 10,
              feedback: "True but doesn't explain the security impact of authenticated data access.",
              nextStep: 0
            },
            {
              text: "CSRF attacks become easier",
              correct: false,
              points: 15,
              feedback: "CORS and CSRF are related but different attack vectors.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit the wildcard CORS configuration?",
          choices: [
            {
              text: "Create malicious site that makes cross-origin requests with user credentials",
              correct: true,
              points: 25,
              feedback: "Critical! Malicious sites can steal sensitive data through cross-origin requests.",
              nextStep: 2
            },
            {
              text: "Directly modify the CORS headers",
              correct: false,
              points: 10,
              feedback: "CORS headers are set by server, not client.",
              nextStep: 2
            },
            {
              text: "Use DNS rebinding to bypass CORS",
              correct: false,
              points: 15,
              feedback: "DNS rebinding is for SSRF, not CORS exploitation.",
              nextStep: 2
            }
          ]
        },
        {
          text: "CORS misconfiguration exploited! Sensitive data leaked through cross-origin requests.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing proper CORS policies. What's the secure approach?",
          choices: [
            {
              text: "Use specific allowlist of trusted domains instead of wildcard",
              correct: true,
              points: 25,
              feedback: "Essential! Domain allowlisting prevents unauthorized cross-origin access.",
              nextStep: 1
            },
            {
              text: "Disable CORS entirely",
              correct: false,
              points: 5,
              feedback: "Not practical for web applications that need cross-origin access.",
              nextStep: 1
            },
            {
              text: "Use wildcard but require authentication",
              correct: false,
              points: 10,
              feedback: "Authentication doesn't prevent malicious sites from using user credentials.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive CORS security should you implement?",
          choices: [
            {
              text: "Implement proper origin validation, credential controls, and preflight handling",
              correct: true,
              points: 30,
              feedback: "Perfect! Comprehensive CORS security with multiple validation layers.",
              nextStep: 2
            },
            {
              text: "Allow all origins for public APIs",
              correct: false,
              points: -10,
              feedback: "Even public APIs should consider CORS security implications.",
              nextStep: 2
            },
            {
              text: "Use CORS only for development",
              correct: false,
              points: 5,
              feedback: "CORS is needed in production for legitimate cross-origin access.",
              nextStep: 2
            }
          ]
        },
        {
          text: "CORS security properly configured! All cross-origin requests strictly validated.",
          choices: []
        }
      ]
    }
  },

  serverTemplateInjection: {
    id: 35,
    title: "Server-Side Template Injection",
    difficulty: "Hard",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You find a web app that renders user input in templates. How do you test for SSTI?",
          choices: [
            {
              text: "Inject template syntax like {{7*7}} or ${7*7}",
              correct: true,
              points: 25,
              feedback: "Correct! Template syntax injection tests if user input is executed in template engine.",
              nextStep: 1
            },
            {
              text: "Try SQL injection in template parameters",
              correct: false,
              points: 10,
              feedback: "SSTI is different from SQL injection - it targets template engines.",
              nextStep: 0
            },
            {
              text: "Use XSS payloads in templates",
              correct: false,
              points: 15,
              feedback: "XSS is client-side, SSTI is server-side template execution.",
              nextStep: 0
            }
          ]
        },
        {
          text: "Template injection works! How do you achieve code execution?",
          choices: [
            {
              text: "Use template functions to execute system commands",
              correct: true,
              points: 30,
              feedback: "Critical! SSTI can lead to remote code execution through template engine functions.",
              nextStep: 2
            },
            {
              text: "Just demonstrate expression evaluation",
              correct: false,
              points: 15,
              feedback: "Good proof, but code execution demonstrates the real risk.",
              nextStep: 2
            },
            {
              text: "Try to read template files",
              correct: false,
              points: 20,
              feedback: "File reading is possible but code execution is more critical.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSTI exploited! Remote code execution achieved through template injection.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing against SSTI attacks. What's the primary defense?",
          choices: [
            {
              text: "Use logic-less templates or sandboxed template environments",
              correct: true,
              points: 25,
              feedback: "Essential! Logic-less templates prevent code execution in templates.",
              nextStep: 1
            },
            {
              text: "Escape all user input in templates",
              correct: false,
              points: 15,
              feedback: "Escaping helps for XSS but doesn't prevent SSTI in all cases.",
              nextStep: 1
            },
            {
              text: "Use template whitelisting",
              correct: false,
              points: 10,
              feedback: "Whitelisting is difficult to implement correctly for templates.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive template security should you implement?",
          choices: [
            {
              text: "Implement context-aware escaping, sandboxing, and input validation",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers of template security prevent injection attacks.",
              nextStep: 2
            },
            {
              text: "Disable all template functionality",
              correct: false,
              points: 0,
              feedback: "Not practical. Templates are essential for dynamic content.",
              nextStep: 2
            },
            {
              text: "Use custom template engines",
              correct: false,
              points: -10,
              feedback: "Custom implementations often introduce new security issues.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Template security implemented! All user input properly sanitized in template contexts.",
          choices: []
        }
      ]
    }
  },

  webCachePoisoning: {
    id: 36,
    title: "Web Cache Poisoning",
    difficulty: "Expert",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover a website using caching with unkeyed headers. What's your attack approach?",
          choices: [
            {
              text: "Inject malicious content through unkeyed headers to poison cache",
              correct: true,
              points: 30,
              feedback: "Correct! Unkeyed headers can be used to poison cache for multiple users.",
              nextStep: 1
            },
            {
              text: "Try to overflow the cache storage",
              correct: false,
              points: 10,
              feedback: "Cache overflow tests DoS, not content poisoning.",
              nextStep: 0
            },
            {
              text: "Use timing attacks to detect cache hits",
              correct: false,
              points: 15,
              feedback: "Timing helps reconnaissance but doesn't demonstrate poisoning.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully poisoned the cache. What's the impact on other users?",
          choices: [
            {
              text: "All users receive malicious content when visiting poisoned URLs",
              correct: true,
              points: 35,
              feedback: "Critical! Cache poisoning affects all users until cache expires or is cleared.",
              nextStep: 2
            },
            {
              text: "Only your session sees the poisoned content",
              correct: false,
              points: 10,
              feedback: "Cache poisoning affects multiple users, not just the attacker.",
              nextStep: 2
            },
            {
              text: "The website becomes temporarily unavailable",
              correct: false,
              points: 15,
              feedback: "DoS is possible but not the primary impact of cache poisoning.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Web cache poisoning successful! Malicious content served to all users through poisoned cache.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing against cache poisoning attacks. What's the primary defense?",
          choices: [
            {
              text: "Properly key cache entries and avoid caching sensitive content",
              correct: true,
              points: 30,
              feedback: "Essential! Proper cache keying prevents poisoning through unkeyed inputs.",
              nextStep: 1
            },
            {
              text: "Disable caching entirely",
              correct: false,
              points: 5,
              feedback: "Not practical for performance. Proper configuration is better.",
              nextStep: 1
            },
            {
              text: "Use shorter cache TTL values",
              correct: false,
              points: 15,
              feedback: "Shorter TTL reduces impact but doesn't prevent poisoning.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive cache security should you implement?",
          choices: [
            {
              text: "Implement cache variation controls, security headers, and cache validation",
              correct: true,
              points: 35,
              feedback: "Perfect! Multiple cache security layers prevent poisoning attacks.",
              nextStep: 2
            },
            {
              text: "Cache only static content",
              correct: false,
              points: 20,
              feedback: "Helpful but not sufficient. Dynamic content caching needs proper security.",
              nextStep: 2
            },
            {
              text: "Use multiple cache layers",
              correct: false,
              points: 10,
              feedback: "Multiple layers can complicate security without improving it.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cache security implemented! All cache entries properly keyed and validated.",
          choices: []
        }
      ]
    }
  },

  subdomainTakeover: {
    id: 37,
    title: "Subdomain Takeover",
    difficulty: "Medium",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover a subdomain pointing to a non-existent cloud service. What's the potential vulnerability?",
          choices: [
            {
              text: "Subdomain takeover if the cloud resource can be claimed",
              correct: true,
              points: 25,
              feedback: "Correct! Dangling DNS records can lead to subdomain takeover.",
              nextStep: 1
            },
            {
              text: "DNS cache poisoning opportunity",
              correct: false,
              points: 15,
              feedback: "DNS poisoning is different from subdomain takeover.",
              nextStep: 0
            },
            {
              text: "SSL certificate vulnerability",
              correct: false,
              points: 10,
              feedback: "SSL issues are separate from subdomain configuration.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit the dangling subdomain?",
          choices: [
            {
              text: "Claim the cloud resource (S3 bucket, Heroku app, etc.) the subdomain points to",
              correct: true,
              points: 30,
              feedback: "Critical! Claiming the resource allows serving malicious content on the legitimate subdomain.",
              nextStep: 2
            },
            {
              text: "Modify the DNS records directly",
              correct: false,
              points: 10,
              feedback: "DNS records are controlled by the domain owner, not attackers.",
              nextStep: 2
            },
            {
              text: "Use the subdomain for phishing attacks",
              correct: false,
              points: 20,
              feedback: "Phishing is possible after takeover, but first you need to claim the resource.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Subdomain takeover successful! Malicious content served on legitimate company subdomain.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're preventing subdomain takeovers. What's the primary defense?",
          choices: [
            {
              text: "Regularly audit DNS records and remove unused cloud resources",
              correct: true,
              points: 25,
              feedback: "Essential! Proactive DNS and cloud resource management prevents takeovers.",
              nextStep: 1
            },
            {
              text: "Use wildcard DNS records only",
              correct: false,
              points: 10,
              feedback: "Wildcard records have their own security implications.",
              nextStep: 1
            },
            {
              text: "Monitor subdomain access logs",
              correct: false,
              points: 15,
              feedback: "Monitoring helps detection but doesn't prevent takeover.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive domain security should you implement?",
          choices: [
            {
              text: "Implement DNS monitoring, cloud asset inventory, and takedown procedures",
              correct: true,
              points: 30,
              feedback: "Perfect! Comprehensive domain security with monitoring and response.",
              nextStep: 2
            },
            {
              text: "Remove all subdomains",
              correct: false,
              points: 0,
              feedback: "Not practical for most organizations.",
              nextStep: 2
            },
            {
              text: "Use long TTL values for all DNS records",
              correct: false,
              points: 5,
              feedback: "Long TTL can make DNS changes slower to propagate.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Domain security implemented! All DNS records and cloud resources properly managed.",
          choices: []
        }
      ]
    }
  },

  businessLogicBypass: {
    id: 38,
    title: "Business Logic Bypass",
    difficulty: "Hard",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover a shopping cart that applies discounts based on coupon codes. How do you test for logic flaws?",
          choices: [
            {
              text: "Apply multiple coupons or use negative quantities",
              correct: true,
              points: 25,
              feedback: "Correct! Business logic testing involves exploiting application workflow flaws.",
              nextStep: 1
            },
            {
              text: "Try SQL injection in coupon field",
              correct: false,
              points: 10,
              feedback: "Technical injection is different from business logic exploitation.",
              nextStep: 0
            },
            {
              text: "Use XSS to modify cart contents",
              correct: false,
              points: 15,
              feedback: "XSS is client-side, business logic flaws are server-side.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You found a logic flaw allowing negative prices. What's the business impact?",
          choices: [
            {
              text: "Financial loss through arbitrage or free products",
              correct: true,
              points: 30,
              feedback: "Critical! Business logic flaws can lead to direct financial impact.",
              nextStep: 2
            },
            {
              text: "Just demonstrate the technical vulnerability",
              correct: false,
              points: 15,
              feedback: "Good for technical teams, but financial impact drives business action.",
              nextStep: 2
            },
            {
              text: "Cause application errors",
              correct: false,
              points: 10,
              feedback: "Errors are less critical than financial impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Business logic bypass successful! Financial manipulation through application workflow exploitation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing against business logic flaws. What's the primary approach?",
          choices: [
            {
              text: "Implement server-side validation for all business rules",
              correct: true,
              points: 25,
              feedback: "Essential! Server-side validation prevents client-side manipulation of business logic.",
              nextStep: 1
            },
            {
              text: "Add more client-side validation",
              correct: false,
              points: 5,
              feedback: "Client-side validation can be bypassed. Server-side is critical.",
              nextStep: 1
            },
            {
              text: "Use complex business rules",
              correct: false,
              points: 10,
              feedback: "Complexity doesn't necessarily improve security.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive business logic security should you implement?",
          choices: [
            {
              text: "Implement workflow validation, audit trails, and anomaly detection",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers of business logic security with monitoring.",
              nextStep: 2
            },
            {
              text: "Remove all discount and promotion features",
              correct: false,
              points: 0,
              feedback: "Not practical for e-commerce businesses.",
              nextStep: 2
            },
            {
              text: "Use AI for all business decisions",
              correct: false,
              points: -10,
              feedback: "AI can introduce new, unpredictable vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Business logic security implemented! All workflows properly validated and monitored.",
          choices: []
        }
      ]
    }
  },

  httpRequestSmuggling: {
    id: 39,
    title: "HTTP Request Smuggling",
    difficulty: "Expert",
    vulnerability: "A10:2021 - Server-Side Request Forgery (SSRF)",
    attacker: {
      story: [
        {
          text: "You discover a website behind a front-end proxy. How do you test for HTTP request smuggling?",
          choices: [
            {
              text: "Send conflicting Content-Length and Transfer-Encoding headers",
              correct: true,
              points: 35,
              feedback: "Correct! Header confusion between front-end and back-end servers enables request smuggling.",
              nextStep: 1
            },
            {
              text: "Use chunked encoding with large payloads",
              correct: false,
              points: 15,
              feedback: "Chunked encoding alone doesn't cause smuggling without header conflicts.",
              nextStep: 0
            },
            {
              text: "Send malformed HTTP requests",
              correct: false,
              points: 10,
              feedback: "General malformed requests test for parser bugs, not specific smuggling.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully smuggled a request. What's the most dangerous exploitation?",
          choices: [
            {
              text: "Bypass security controls and access internal endpoints",
              correct: true,
              points: 40,
              feedback: "Critical! Request smuggling can bypass authentication and access internal APIs.",
              nextStep: 2
            },
            {
              text: "Just demonstrate request confusion",
              correct: false,
              points: 20,
              feedback: "Good proof, but security bypass demonstrates real risk.",
              nextStep: 2
            },
            {
              text: "Cause server errors",
              correct: false,
              points: 15,
              feedback: "DoS is possible but less critical than security bypass.",
              nextStep: 2
            }
          ]
        },
        {
          text: "HTTP request smuggling successful! Security controls bypassed through request desynchronization.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're defending against HTTP request smuggling. What's the primary defense?",
          choices: [
            {
              text: "Use HTTP/2 or normalize requests at the front-end",
              correct: true,
              points: 35,
              feedback: "Essential! HTTP/2 prevents smuggling, and request normalization eliminates conflicts.",
              nextStep: 1
            },
            {
              text: "Reject all chunked encoding requests",
              correct: false,
              points: 10,
              feedback: "Not practical. Chunked encoding is part of HTTP specification.",
              nextStep: 1
            },
            {
              text: "Use longer timeout values",
              correct: false,
              points: 5,
              feedback: "Timeouts don't prevent request smuggling attacks.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive HTTP security should you implement?",
          choices: [
            {
              text: "Implement strict HTTP parsing, header validation, and backend connection pooling",
              correct: true,
              points: 40,
              feedback: "Perfect! Multiple layers of HTTP security prevent smuggling and other attacks.",
              nextStep: 2
            },
            {
              text: "Disable keep-alive connections",
              correct: false,
              points: 15,
              feedback: "Hurts performance and doesn't completely prevent smuggling.",
              nextStep: 2
            },
            {
              text: "Use custom HTTP protocols",
              correct: false,
              points: -15,
              feedback: "Custom protocols introduce new security risks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "HTTP security implemented! All requests properly normalized and validated.",
          choices: []
        }
      ]
    }
  },

  insecureDirectObjectReference: {
    id: 40,
    title: "Insecure Direct Object Reference (IDOR)",
    difficulty: "Medium",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover API endpoints with sequential IDs: /api/users/123, /api/orders/456. What do you test?",
          choices: [
            {
              text: "Change IDs to access other users' data",
              correct: true,
              points: 20,
              feedback: "Correct! IDOR testing involves accessing objects belonging to other users.",
              nextStep: 1
            },
            {
              text: "Try SQL injection in the ID parameter",
              correct: false,
              points: 10,
              feedback: "IDOR is an authorization flaw, not injection.",
              nextStep: 0
            },
            {
              text: "Use parameter pollution in the URL",
              correct: false,
              points: 5,
              feedback: "Parameter pollution is different from object reference manipulation.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully accessed other users' data. How do you demonstrate the impact?",
          choices: [
            {
              text: "Show access to sensitive personal information across multiple accounts",
              correct: true,
              points: 25,
              feedback: "Critical! IDOR can lead to massive data exposure across user accounts.",
              nextStep: 2
            },
            {
              text: "Just document the sequential IDs",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but data access demonstrates real risk.",
              nextStep: 2
            },
            {
              text: "Modify other users' data",
              correct: false,
              points: -15,
              feedback: "Unauthorized modifications are destructive and unethical.",
              nextStep: 2
            }
          ]
        },
        {
          text: "IDOR vulnerability exploited! Unauthorized data access across user accounts demonstrated.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're fixing IDOR vulnerabilities. What's the primary defense?",
          choices: [
            {
              text: "Implement proper authorization checks for each object access",
              correct: true,
              points: 25,
              feedback: "Essential! Always verify user permissions for each object access request.",
              nextStep: 1
            },
            {
              text: "Use UUIDs instead of sequential IDs",
              correct: false,
              points: 10,
              feedback: "UUIDs make guessing harder but don't prevent authorized access to other objects.",
              nextStep: 1
            },
            {
              text: "Encrypt object references",
              correct: false,
              points: 15,
              feedback: "Encryption can be reversed. Authorization checks are still needed.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive access control should you implement?",
          choices: [
            {
              text: "Use role-based access control with object-level permissions",
              correct: true,
              points: 30,
              feedback: "Perfect! RBAC with fine-grained permissions prevents IDOR.",
              nextStep: 2
            },
            {
              text: "Remove all object IDs from URLs",
              correct: false,
              points: 5,
              feedback: "Not practical. Applications need to reference objects.",
              nextStep: 2
            },
            {
              text: "Use session-based object mapping",
              correct: false,
              points: 10,
              feedback: "Session mapping is complex and can introduce other issues.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Access control implemented! All object accesses properly authorized and validated.",
          choices: []
        }
      ]
    }
  },

    hostHeaderInjection: {
    id: 41,
    title: "Host Header Injection",
    difficulty: "Medium",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover a website that uses the Host header for generating links. What's your first test?",
          choices: [
            {
              text: "Modify Host header to a controlled domain and check if links change",
              correct: true,
              points: 20,
              feedback: "Correct! Host header injection can lead to password reset poisoning and cache poisoning.",
              nextStep: 1
            },
            {
              text: "Try SQL injection in the Host header",
              correct: false,
              points: 10,
              feedback: "Host header is not typically processed as SQL input.",
              nextStep: 0
            },
            {
              text: "Send multiple Host headers to cause confusion",
              correct: false,
              points: 15,
              feedback: "Multiple headers might be rejected. Focus on single header manipulation first.",
              nextStep: 0
            }
          ]
        },
        {
          text: "The application accepts your modified Host header. How do you exploit this?",
          choices: [
            {
              text: "Use it for password reset poisoning by pointing to malicious domain",
              correct: true,
              points: 25,
              feedback: "Critical! Password reset links generated with malicious Host header can be sent to attackers.",
              nextStep: 2
            },
            {
              text: "Just demonstrate link generation changes",
              correct: false,
              points: 15,
              feedback: "Good proof, but password reset poisoning shows real security impact.",
              nextStep: 2
            },
            {
              text: "Try to bypass IP restrictions",
              correct: false,
              points: 10,
              feedback: "Host header doesn't typically affect IP-based restrictions.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Host header injection exploited! Password reset poisoning demonstrated successfully.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing against Host header attacks. What's the primary defense?",
          choices: [
            {
              text: "Use server configuration to validate Host header against allowed domains",
              correct: true,
              points: 25,
              feedback: "Essential! Server-level Host header validation prevents injection attacks.",
              nextStep: 1
            },
            {
              text: "Remove Host header from all requests",
              correct: false,
              points: 5,
              feedback: "Not possible. Host header is required by HTTP specification.",
              nextStep: 1
            },
            {
              text: "Encrypt the Host header value",
              correct: false,
              points: 10,
              feedback: "Encryption doesn't prevent header manipulation at the client side.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive header security should you implement?",
          choices: [
            {
              text: "Implement strict Host validation, use absolute URLs, and security middleware",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers of header security with proper URL handling.",
              nextStep: 2
            },
            {
              text: "Allow all Host headers for flexibility",
              correct: false,
              points: -10,
              feedback: "This increases security risk significantly.",
              nextStep: 2
            },
            {
              text: "Use custom headers instead of Host",
              correct: false,
              points: 5,
              feedback: "Custom headers can still be manipulated and break standards.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Host header security implemented! All headers properly validated and secured.",
          choices: []
        }
      ]
    }
  },

  insecureFileUpload: {
    id: 42,
    title: "Insecure File Upload",
    difficulty: "Hard",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You find a file upload feature that accepts images. How do you test for security flaws?",
          choices: [
            {
              text: "Upload a file with image header but malicious server-side code",
              correct: true,
              points: 25,
              feedback: "Correct! Polyglot files can bypass client-side checks while containing executable code.",
              nextStep: 1
            },
            {
              text: "Try to upload extremely large files",
              correct: false,
              points: 10,
              feedback: "This tests for DoS, not necessarily code execution.",
              nextStep: 0
            },
            {
              text: "Upload files with XSS payloads in metadata",
              correct: false,
              points: 15,
              feedback: "XSS might work but server-side code execution is more critical.",
              nextStep: 0
            }
          ]
        },
        {
          text: "Your malicious file was uploaded successfully. How do you achieve code execution?",
          choices: [
            {
              text: "Access the uploaded file directly if it's in web-accessible directory",
              correct: true,
              points: 30,
              feedback: "Critical! Files in web-accessible directories can be executed by the server.",
              nextStep: 2
            },
            {
              text: "Wait for admin to open the file",
              correct: false,
              points: 10,
              feedback: "Unreliable. Direct execution through web access is more certain.",
              nextStep: 2
            },
            {
              text: "Try to overwrite system files",
              correct: false,
              points: -15,
              feedback: "Destructive and likely to be blocked by permissions.",
              nextStep: 2
            }
          ]
        },
        {
          text: "File upload vulnerability exploited! Remote code execution achieved through malicious upload.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing file upload functionality. What's the most important control?",
          choices: [
            {
              text: "Store files outside web root and validate file content server-side",
              correct: true,
              points: 25,
              feedback: "Essential! Proper storage location and content validation prevent execution.",
              nextStep: 1
            },
            {
              text: "Rely on client-side file type validation",
              correct: false,
              points: 5,
              feedback: "Client-side checks can be easily bypassed.",
              nextStep: 1
            },
            {
              text: "Use file extension whitelisting only",
              correct: false,
              points: 15,
              feedback: "Extensions can be spoofed. Content validation is needed.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive file upload security should you implement?",
          choices: [
            {
              text: "Implement content verification, random filenames, and antivirus scanning",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple security layers for file upload protection.",
              nextStep: 2
            },
            {
              text: "Disable all file upload features",
              correct: false,
              points: 0,
              feedback: "Not practical for applications requiring file uploads.",
              nextStep: 2
            },
            {
              text: "Trust users to upload safe files",
              correct: false,
              points: -20,
              feedback: "Never trust user input, including file uploads.",
              nextStep: 2
            }
          ]
        },
        {
          text: "File upload security implemented! All uploads properly validated and stored securely.",
          choices: []
        }
      ]
    }
  },

  websocketSecurity: {
    id: 43,
    title: "WebSocket Security Flaws",
    difficulty: "Hard",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover a real-time chat application using WebSockets. How do you test for authentication bypass?",
          choices: [
            {
              text: "Connect directly to WebSocket endpoint without authentication",
              correct: true,
              points: 25,
              feedback: "Correct! WebSocket endpoints might not enforce the same authentication as HTTP routes.",
              nextStep: 1
            },
            {
              text: "Try SQL injection in WebSocket messages",
              correct: false,
              points: 15,
              feedback: "Good general testing, but focus on connection-level authentication first.",
              nextStep: 0
            },
            {
              text: "Send malformed WebSocket handshakes",
              correct: false,
              points: 10,
              feedback: "Handshake fuzzing might cause errors but doesn't test authentication.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You connected without authentication. What can you access?",
          choices: [
            {
              text: "Subscribe to channels and access real-time data of other users",
              correct: true,
              points: 30,
              feedback: "Critical! Unauthenticated WebSocket access can expose sensitive real-time data.",
              nextStep: 2
            },
            {
              text: "Just monitor connection status",
              correct: false,
              points: 15,
              feedback: "Good for reconnaissance, but data access demonstrates real risk.",
              nextStep: 2
            },
            {
              text: "Send spam messages to all users",
              correct: false,
              points: -10,
              feedback: "Disruptive actions are unethical and may trigger alerts.",
              nextStep: 2
            }
          ]
        },
        {
          text: "WebSocket authentication bypassed! Real-time data accessed without proper authorization.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing WebSocket connections. What's the primary security control?",
          choices: [
            {
              text: "Implement proper authentication during WebSocket handshake",
              correct: true,
              points: 25,
              feedback: "Essential! WebSocket connections must authenticate just like HTTP requests.",
              nextStep: 1
            },
            {
              text: "Use WSS (WebSocket Secure) only",
              correct: false,
              points: 15,
              feedback: "Encryption is important but doesn't replace authentication.",
              nextStep: 1
            },
            {
              text: "Limit WebSocket message size",
              correct: false,
              points: 10,
              feedback: "Size limits help with DoS but don't prevent unauthorized access.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive WebSocket security should you implement?",
          choices: [
            {
              text: "Use token-based auth, message validation, and rate limiting",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple security layers for WebSocket protection.",
              nextStep: 2
            },
            {
              text: "Disable WebSockets and use polling instead",
              correct: false,
              points: 5,
              feedback: "Not practical for real-time applications.",
              nextStep: 2
            },
            {
              text: "Trust the origin header for authentication",
              correct: false,
              points: -15,
              feedback: "Origin headers can be spoofed. Use proper token authentication.",
              nextStep: 2
            }
          ]
        },
        {
          text: "WebSocket security implemented! All connections properly authenticated and validated.",
          choices: []
        }
      ]
    }
  },

  xmlExternalEntity: {
    id: 44,
    title: "XML External Entity (XXE) Attack",
    difficulty: "Expert",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover an API endpoint that processes XML data. How do you test for XXE?",
          choices: [
            {
              text: "Inject external entity declarations to read system files",
              correct: true,
              points: 30,
              feedback: "Correct! XXE attacks use external entity references to access local files.",
              nextStep: 1
            },
            {
              text: "Try SQL injection in XML attributes",
              correct: false,
              points: 10,
              feedback: "XXE is specific to XML parsing, not SQL injection.",
              nextStep: 0
            },
            {
              text: "Send malformed XML to cause parser errors",
              correct: false,
              points: 15,
              feedback: "Error-based testing might reveal information but doesn't specifically test XXE.",
              nextStep: 0
            }
          ]
        },
        {
          text: "Your XXE payload successfully reads /etc/passwd. What's the next step?",
          choices: [
            {
              text: "Use XXE for Server-Side Request Forgery to access internal services",
              correct: true,
              points: 35,
              feedback: "Critical! XXE can be used for SSRF to attack internal network services.",
              nextStep: 2
            },
            {
              text: "Just document file reading capability",
              correct: false,
              points: 20,
              feedback: "Good proof, but SSRF demonstrates broader impact.",
              nextStep: 2
            },
            {
              text: "Try to write files to the system",
              nextStep: 2
            }
          ]
        },
        {
          text: "XXE attack successful! Internal files read and SSRF to internal services demonstrated.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing against XXE attacks. What's the most effective defense?",
          choices: [
            {
              text: "Disable external entity processing in XML parser configuration",
              correct: true,
              points: 30,
              feedback: "Essential! Disabling DTD and external entities prevents XXE attacks.",
              nextStep: 1
            },
            {
              text: "Validate XML against a schema",
              correct: false,
              points: 15,
              feedback: "Schema validation helps but doesn't prevent entity expansion.",
              nextStep: 1
            },
            {
              text: "Use XML sanitization libraries",
              correct: false,
              points: 20,
              feedback: "Sanitization can be bypassed. Parser configuration is more reliable.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive XML security should you implement?",
          choices: [
            {
              text: "Use JSON instead of XML, or implement secure parser settings consistently",
              correct: true,
              points: 35,
              feedback: "Perfect! Avoiding XML or using secure configurations prevents XXE.",
              nextStep: 2
            },
            {
              text: "Block all XML content at the firewall",
              correct: false,
              points: 5,
              feedback: "Not practical for applications requiring XML processing.",
              nextStep: 2
            },
            {
              text: "Use custom XML parsing logic",
              correct: false,
              points: -15,
              feedback: "Custom parsers often introduce new security issues.",
              nextStep: 2
            }
          ]
        },
        {
          text: "XML security implemented! All parsers configured to prevent XXE attacks.",
          choices: []
        }
      ]
    }
  },

  insecureRedirect: {
    id: 45,
    title: "Insecure Redirects and Forwards",
    difficulty: "Medium",
    vulnerability: "A10:2021 - Server-Side Request Forgery (SSRF)",
    attacker: {
      story: [
        {
          text: "You discover a redirect parameter that takes URLs: /redirect?url=https://example.com. What do you test?",
          choices: [
            {
              text: "Try redirecting to malicious or phishing domains",
              correct: true,
              points: 20,
              feedback: "Correct! Open redirects can be used for phishing attacks by abusing trusted domains.",
              nextStep: 1
            },
            {
              text: "Test for SQL injection in the URL parameter",
              correct: false,
              points: 10,
              feedback: "Redirect parameters typically don't process SQL.",
              nextStep: 0
            },
            {
              text: "Use the redirect for XSS attacks",
              correct: false,
              points: 15,
              feedback: "XSS usually requires content injection, not redirects.",
              nextStep: 0
            }
          ]
        },
        {
          text: "The redirect works for external domains. How is this dangerous?",
          choices: [
            {
              text: "It enables phishing by making malicious links appear to come from trusted domain",
              correct: true,
              points: 25,
              feedback: "Critical! Open redirects are commonly exploited in phishing campaigns.",
              nextStep: 2
            },
            {
              text: "Just demonstrate the redirect functionality",
              correct: false,
              points: 15,
              feedback: "Good proof, but phishing impact shows real security risk.",
              nextStep: 2
            },
            {
              text: "Use it to bypass content filters",
              correct: false,
              points: 10,
              feedback: "Content filter bypass is possible but phishing is the primary risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Open redirect vulnerability exploited! Phishing attack vector demonstrated.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're fixing open redirect vulnerabilities. What's the proper approach?",
          choices: [
            {
              text: "Use allowlist of permitted domains or relative URLs only",
              correct: true,
              points: 25,
              feedback: "Essential! Domain allowlisting prevents redirects to malicious sites.",
              nextStep: 1
            },
            {
              text: "Remove all redirect functionality",
              correct: false,
              points: 5,
              feedback: "Not practical. Redirects are needed for proper application flow.",
              nextStep: 1
            },
            {
              text: "Use URL encoding validation",
              correct: false,
              points: 10,
              feedback: "Encoding validation doesn't prevent redirects to malicious domains.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive redirect security should you implement?",
          choices: [
            {
              text: "Implement redirect confirmation pages, domain validation, and user warnings",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers of redirect security with user awareness.",
              nextStep: 2
            },
            {
              text: "Allow redirects only to same-domain pages",
              correct: false,
              points: 20,
              feedback: "Too restrictive for applications needing external redirects.",
              nextStep: 2
            },
            {
              text: "Use random tokens for all redirects",
              correct: false,
              points: 15,
              feedback: "Tokens can be guessed or leaked. Domain validation is more reliable.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Redirect security implemented! All redirects properly validated and controlled.",
          choices: []
        }
      ]
    }
  },

  clickjacking: {
    id: 46,
    title: "Clickjacking Attack",
    difficulty: "Medium",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You want to trick users into performing actions without their knowledge. What technique do you use?",
          choices: [
            {
              text: "Create transparent iframe overlay to hijack user clicks",
              correct: true,
              points: 25,
              feedback: "Correct! Clickjacking uses transparent layers to trick users into clicking hidden elements.",
              nextStep: 1
            },
            {
              text: "Use JavaScript to simulate mouse clicks",
              correct: false,
              points: 10,
              feedback: "Browser security typically prevents automated cross-origin clicks.",
              nextStep: 0
            },
            {
              text: "Modify the browser's click events",
              correct: false,
              points: 5,
              feedback: "Browser security prevents modification of cross-origin event handling.",
              nextStep: 0
            }
          ]
        },
        {
          text: "Your clickjacking attack works. What's the most dangerous scenario?",
          choices: [
            {
              text: "Trick users into changing passwords or authorizing transactions",
              correct: true,
              points: 30,
              feedback: "Critical! Clickjacking can lead to account takeover or financial fraud.",
              nextStep: 2
            },
            {
              text: "Just demonstrate button clicks",
              correct: false,
              points: 15,
              feedback: "Good proof, but sensitive actions demonstrate real impact.",
              nextStep: 2
            },
            {
              text: "Use it for ad clicking fraud",
              correct: false,
              points: 10,
              feedback: "Possible but less critical than account compromise.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Clickjacking attack successful! User actions hijacked through UI redressing.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're protecting against clickjacking attacks. What's the primary defense?",
          choices: [
            {
              text: "Implement X-Frame-Options and Content Security Policy frame-ancestors",
              correct: true,
              points: 25,
              feedback: "Essential! Frame-breaking headers prevent clickjacking attacks.",
              nextStep: 1
            },
            {
              text: "Use JavaScript frame-busting scripts",
              correct: false,
              points: 15,
              feedback: "JavaScript busting can be bypassed. HTTP headers are more reliable.",
              nextStep: 1
            },
            {
              text: "Require CAPTCHA for all actions",
              correct: false,
              points: 10,
              feedback: "CAPTCHA hurts user experience and doesn't prevent all clickjacking.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive UI security should you implement?",
          choices: [
            {
              text: "Use multiple security headers, frame protection, and user confirmation for sensitive actions",
              correct: true,
              points: 30,
              feedback: "Perfect! Defense in depth for UI interaction security.",
              nextStep: 2
            },
            {
              text: "Disable all iframe embedding",
              correct: false,
              points: 20,
              feedback: "Too restrictive for legitimate embedding use cases.",
              nextStep: 2
            },
            {
              text: "Use custom click event handlers",
              correct: false,
              points: 5,
              feedback: "Custom handlers can introduce new vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Clickjacking protection implemented! All pages properly secured with frame protection headers.",
          choices: []
        }
      ]
    }
  },

  insecureDeserializationJson: {
    id: 47,
    title: "JSON Deserialization Attacks",
    difficulty: "Hard",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover an API that deserializes JSON with type information. What vulnerability might exist?",
          choices: [
            {
              text: "JSON injection with malicious type specifications",
              correct: true,
              points: 30,
              feedback: "Correct! JSON deserialization with type information can lead to remote code execution.",
              nextStep: 1
            },
            {
              text: "Try buffer overflow in JSON parsing",
              correct: false,
              points: 15,
              feedback: "Buffer overflows are less common in modern JSON parsers.",
              nextStep: 0
            },
            {
              text: "Use JSONP for cross-site data theft",
              correct: false,
              points: 10,
              feedback: "JSONP is different from server-side deserialization attacks.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit JSON deserialization vulnerabilities?",
          choices: [
            {
              text: "Inject objects with gadget chains that execute during deserialization",
              correct: true,
              points: 35,
              feedback: "Critical! Gadget chains can trigger remote code execution during deserialization.",
              nextStep: 2
            },
            {
              text: "Just modify data types to cause errors",
              correct: false,
              points: 15,
              feedback: "Error causing is less critical than code execution.",
              nextStep: 2
            },
            {
              text: "Use JSON comments to hide malicious payloads",
              correct: false,
              points: 10,
              feedback: "JSON doesn't support comments in the specification.",
              nextStep: 2
            }
          ]
        },
        {
          text: "JSON deserialization exploited! Remote code execution achieved through gadget chains.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing JSON deserialization. What's the safest approach?",
          choices: [
            {
              text: "Use schema validation and avoid polymorphic deserialization",
              correct: true,
              points: 30,
              feedback: "Essential! Schema validation prevents unexpected object types during deserialization.",
              nextStep: 1
            },
            {
              text: "Encrypt JSON payloads before deserialization",
              correct: false,
              points: 15,
              feedback: "Encryption doesn't prevent malicious objects once decrypted.",
              nextStep: 1
            },
            {
              text: "Use the latest JSON library version",
              correct: false,
              points: 10,
              feedback: "Updates help but don't replace proper validation.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive data validation should you implement?",
          choices: [
            {
              text: "Use strict schema validation, type checking, and safe deserialization libraries",
              correct: true,
              points: 35,
              feedback: "Perfect! Multiple validation layers for secure data processing.",
              nextStep: 2
            },
            {
              text: "Disable all JSON parsing",
              correct: false,
              points: 0,
              feedback: "Not practical for modern web applications.",
              nextStep: 2
            },
            {
              text: "Use custom serialization formats",
              correct: false,
              points: -10,
              feedback: "Custom formats often introduce new security issues.",
              nextStep: 2
            }
          ]
        },
        {
          text: "JSON security implemented! All deserialization properly validated and secured.",
          choices: []
        }
      ]
    }
  },

  serverSideInjection: {
    id: 48,
    title: "Server-Side JavaScript Injection",
    difficulty: "Expert",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover a Node.js application that uses eval() with user input. What's the risk?",
          choices: [
            {
              text: "Remote code execution through JavaScript injection",
              correct: true,
              points: 35,
              feedback: "Critical! eval() with user input allows arbitrary JavaScript execution on the server.",
              nextStep: 1
            },
            {
              text: "Memory corruption through buffer overflow",
              correct: false,
              points: 15,
              feedback: "JavaScript engines are memory-safe. Code injection is the primary risk.",
              nextStep: 0
            },
            {
              text: "Denial of service through infinite loops",
              correct: false,
              points: 20,
              feedback: "DoS is possible but code execution is more critical.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you achieve full system access through JavaScript injection?",
          choices: [
            {
              text: "Use Node.js built-in modules to execute system commands",
              correct: true,
              points: 40,
              feedback: "Critical! Node.js child_process module can execute system commands for full compromise.",
              nextStep: 2
            },
            {
              text: "Just demonstrate expression evaluation",
              correct: false,
              points: 20,
              feedback: "Good proof, but system command execution shows complete compromise.",
              nextStep: 2
            },
            {
              text: "Try to crash the server",
              correct: false,
              points: 10,
              feedback: "DoS is less critical than persistent access.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Server-side JavaScript injection successful! Full system compromise achieved.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing against server-side code injection. What's the primary defense?",
          choices: [
            {
              text: "Avoid eval() and similar functions with user input, use sandboxing when needed",
              correct: true,
              points: 35,
              feedback: "Essential! Never use eval() with untrusted input. Use safe alternatives.",
              nextStep: 1
            },
            {
              text: "Validate input before passing to eval()",
              correct: false,
              points: 15,
              feedback: "Input validation can be bypassed. Avoid eval() entirely.",
              nextStep: 1
            },
            {
              text: "Use the latest Node.js version",
              correct: false,
              points: 10,
              feedback: "Updates help but don't prevent code injection from eval().",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive server-side security should you implement?",
          choices: [
            {
              text: "Use safe evaluation methods, proper input validation, and process isolation",
              correct: true,
              points: 40,
              feedback: "Perfect! Multiple security layers for server-side code execution.",
              nextStep: 2
            },
            {
              text: "Disable all dynamic code execution",
              correct: false,
              points: 20,
              feedback: "Too restrictive for applications needing dynamic functionality.",
              nextStep: 2
            },
            {
              text: "Run code in containers with no network access",
              correct: false,
              points: 25,
              feedback: "Helpful but doesn't prevent local system access.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Server-side security implemented! All code execution properly sandboxed and validated.",
          choices: []
        }
      ]
    }
  },

  timingAttacks: {
    id: 49,
    title: "Timing Attacks",
    difficulty: "Expert",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover a login endpoint that validates passwords character by character. What vulnerability exists?",
          choices: [
            {
              text: "Timing attack to extract password character by character",
              correct: true,
              points: 35,
              feedback: "Correct! Character-by-character comparison leaks timing information about password matches.",
              nextStep: 1
            },
            {
              text: "Buffer overflow in password validation",
              correct: false,
              points: 15,
              feedback: "Modern systems are less vulnerable to buffer overflows in string comparison.",
              nextStep: 0
            },
            {
              text: "Password length disclosure",
              correct: false,
              points: 20,
              feedback: "Length disclosure is possible but timing attacks are more powerful.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you perform the timing attack?",
          choices: [
            {
              text: "Measure response times for different password guesses to infer characters",
              correct: true,
              points: 40,
              feedback: "Critical! Statistical analysis of response times can reveal password characters.",
              nextStep: 2
            },
            {
              text: "Try to cause timeouts with long passwords",
              correct: false,
              points: 15,
              feedback: "Timeouts don't reveal specific character information.",
              nextStep: 2
            },
            {
              text: "Use network latency to infer distance to server",
              correct: false,
              points: 10,
              feedback: "Network timing is different from application logic timing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Timing attack successful! Password extracted through response time analysis.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing against timing attacks. What's the primary defense?",
          choices: [
            {
              text: "Use constant-time comparison functions for sensitive operations",
              correct: true,
              points: 35,
              feedback: "Essential! Constant-time algorithms prevent timing information leakage.",
              nextStep: 1
            },
            {
              text: "Add random delays to responses",
              correct: false,
              points: 20,
              feedback: "Random delays can be statistically filtered out by attackers.",
              nextStep: 1
            },
            {
              text: "Use shorter data lengths for comparison",
              correct: false,
              points: 10,
              feedback: "Length doesn't prevent timing attacks on the comparison itself.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive timing attack protection should you implement?",
          choices: [
            {
              text: "Implement constant-time algorithms, rate limiting, and comprehensive logging",
              correct: true,
              points: 40,
              feedback: "Perfect! Multiple layers of protection against timing attacks.",
              nextStep: 2
            },
            {
              text: "Disable all timing information",
              correct: false,
              points: 5,
              feedback: "Not possible. Timing information is fundamental to computing.",
              nextStep: 2
            },
            {
              text: "Use hardware security modules for all comparisons",
              correct: false,
              points: 25,
              feedback: "Helpful but not always practical for all applications.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Timing attack protection implemented! All sensitive operations use constant-time algorithms.",
          choices: []
        }
      ]
    }
  },

  insecureMobileAuth: {
    id: 50,
    title: "Mobile Authentication Flaws",
    difficulty: "Hard",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You're testing a mobile app that stores authentication tokens in insecure storage. What's the risk?",
          choices: [
            {
              text: "Token theft through rooted device or backup extraction",
              correct: true,
              points: 25,
              feedback: "Correct! Insecure mobile storage allows attackers to extract authentication tokens.",
              nextStep: 1
            },
            {
              text: "SQL injection in local database",
              correct: false,
              points: 10,
              feedback: "Local SQL injection is less critical than token theft.",
              nextStep: 0
            },
            {
              text: "Buffer overflow in mobile app",
              correct: false,
              points: 15,
              feedback: "Mobile apps have memory protection. Token storage is more critical.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully extracted the authentication token. How do you use it?",
          choices: [
            {
              text: "Use the token to impersonate the user on API endpoints",
              correct: true,
              points: 30,
              feedback: "Critical! Stolen tokens allow complete account takeover and data access.",
              nextStep: 2
            },
            {
              text: "Just demonstrate token extraction",
              correct: false,
              points: 15,
              feedback: "Good proof, but API access demonstrates real impact.",
              nextStep: 2
            },
            {
              text: "Try to reverse engineer the token format",
              correct: false,
              points: 10,
              feedback: "Format analysis is less important than using the stolen token.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Mobile authentication bypassed! Account takeover through token theft.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing mobile authentication storage. What's the most secure approach?",
          choices: [
            {
              text: "Use platform secure storage like Keychain (iOS) or Keystore (Android)",
              correct: true,
              points: 25,
              feedback: "Essential! Platform secure storage protects tokens from extraction.",
              nextStep: 1
            },
            {
              text: "Encrypt tokens with app-specific keys",
              correct: false,
              points: 15,
              feedback: "Encryption keys can still be extracted from the app.",
              nextStep: 1
            },
            {
              text: "Store tokens in memory only",
              correct: false,
              points: 10,
              feedback: "Not practical. Tokens need persistence across app launches.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive mobile security should you implement?",
          choices: [
            {
              text: "Use biometric authentication, certificate pinning, and secure storage",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple mobile-specific security layers.",
              nextStep: 2
            },
            {
              text: "Disable app backup functionality",
              correct: false,
              points: 15,
              feedback: "Helpful but doesn't prevent all extraction methods.",
              nextStep: 2
            },
            {
              text: "Use custom encryption for everything",
              correct: false,
              points: -10,
              feedback: "Custom encryption often introduces vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Mobile security implemented! All authentication tokens properly secured.",
          choices: []
        }
      ]
    }
  },

    insecureCorsConfiguration: {
    id: 51,
    title: "Insecure CORS Configuration",
    difficulty: "Medium",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover an API that reflects the Origin header in Access-Control-Allow-Origin. What's the risk?",
          choices: [
            {
              text: "Any domain can make cross-origin requests with credentials",
              correct: true,
              points: 20,
              feedback: "Correct! Origin reflection allows any site to make authenticated requests to the API.",
              nextStep: 1
            },
            {
              text: "The API becomes slower due to CORS processing",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the primary security concern.",
              nextStep: 0
            },
            {
              text: "CSRF protection is automatically disabled",
              correct: false,
              points: 10,
              feedback: "CORS and CSRF are related but separate security mechanisms.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit the reflected Origin header?",
          choices: [
            {
              text: "Create malicious site that makes cross-origin requests to steal user data",
              correct: true,
              points: 25,
              feedback: "Critical! Reflected Origin allows malicious sites to access authenticated API endpoints.",
              nextStep: 2
            },
            {
              text: "Use it to bypass same-origin policy completely",
              correct: false,
              points: 15,
              feedback: "CORS doesn't completely bypass same-origin policy, but enables cross-origin requests.",
              nextStep: 2
            },
            {
              text: "Modify the Origin header to impersonate other domains",
              correct: false,
              points: 10,
              feedback: "Origin header is set by browser and cannot be modified arbitrarily.",
              nextStep: 2
            }
          ]
        },
        {
          text: "CORS misconfiguration exploited! Sensitive data accessed from malicious origin.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're fixing CORS configuration. What's the secure approach?",
          choices: [
            {
              text: "Use a strict allowlist of trusted domains for Access-Control-Allow-Origin",
              correct: true,
              points: 25,
              feedback: "Essential! Domain allowlisting prevents unauthorized cross-origin access.",
              nextStep: 1
            },
            {
              text: "Always reflect the Origin header for flexibility",
              correct: false,
              points: -10,
              feedback: "Origin reflection is a serious security vulnerability.",
              nextStep: 1
            },
            {
              text: "Use wildcard but require additional authentication",
              correct: false,
              points: 10,
              feedback: "Authentication doesn't prevent malicious sites from using user credentials.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive CORS security should you implement?",
          choices: [
            {
              text: "Implement proper origin validation, credential controls, and preflight caching",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple CORS security layers with proper caching.",
              nextStep: 2
            },
            {
              text: "Disable CORS entirely for all endpoints",
              correct: false,
              points: 5,
              feedback: "Not practical for web applications needing cross-origin access.",
              nextStep: 2
            },
            {
              text: "Use random tokens for CORS validation",
              correct: false,
              points: 10,
              feedback: "CORS uses Origin headers, not tokens, for validation.",
              nextStep: 2
            }
          ]
        },
        {
          text: "CORS security properly configured! All cross-origin requests strictly validated.",
          choices: []
        }
      ]
    }
  },

  insecureThirdPartyIntegrations: {
    id: 52,
    title: "Insecure Third-Party Integrations",
    difficulty: "Hard",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover a website loading JavaScript from a third-party analytics provider. What's the risk?",
          choices: [
            {
              text: "Compromised third-party service can inject malicious code into the site",
              correct: true,
              points: 25,
              feedback: "Correct! Third-party scripts have full access to the page and user data.",
              nextStep: 1
            },
            {
              text: "The website becomes dependent on external services",
              correct: false,
              points: 10,
              feedback: "Dependency is a concern but not the primary security risk.",
              nextStep: 0
            },
            {
              text: "Third-party services can see website traffic patterns",
              correct: false,
              points: 15,
              feedback: "Traffic visibility is a privacy concern, not a direct security risk.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How can a compromised third-party service be exploited?",
          choices: [
            {
              text: "Steal user sessions, credentials, and manipulate page content",
              correct: true,
              points: 30,
              feedback: "Critical! Malicious third-party scripts can perform any action on behalf of users.",
              nextStep: 2
            },
            {
              text: "Just track user behavior more extensively",
              correct: false,
              points: 15,
              feedback: "Tracking is a privacy issue, but code injection enables complete compromise.",
              nextStep: 2
            },
            {
              text: "Cause the website to load slower",
              correct: false,
              points: 5,
              feedback: "Performance impact is minor compared to security compromise.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Third-party compromise demonstrated! Malicious script injection leads to data theft.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing third-party integrations. What's the most important control?",
          choices: [
            {
              text: "Use Subresource Integrity (SRI) hashes for all third-party scripts",
              correct: true,
              points: 25,
              feedback: "Essential! SRI ensures loaded scripts match expected content.",
              nextStep: 1
            },
            {
              text: "Load third-party scripts from multiple sources",
              correct: false,
              points: 5,
              feedback: "Multiple sources increase attack surface without improving security.",
              nextStep: 1
            },
            {
              text: "Encrypt communications with third-party services",
              correct: false,
              points: 15,
              feedback: "Encryption protects in transit but doesn't prevent malicious content.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive third-party security should you implement?",
          choices: [
            {
              text: "Implement SRI, Content Security Policy, and regular third-party audits",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers of protection for third-party content.",
              nextStep: 2
            },
            {
              text: "Remove all third-party integrations",
              correct: false,
              points: 0,
              feedback: "Not practical for modern web applications.",
              nextStep: 2
            },
            {
              text: "Use custom wrappers for all third-party code",
              correct: false,
              points: 10,
              feedback: "Wrappers can help but don't prevent malicious script execution.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Third-party security implemented! All external resources properly validated and secured.",
          choices: []
        }
      ]
    }
  },

  insecureDirectObjectReferenceAdvanced: {
    id: 53,
    title: "Advanced IDOR Techniques",
    difficulty: "Expert",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover an API using UUIDs instead of sequential IDs. How do you test for IDOR?",
          choices: [
            {
              text: "Find UUIDs from other sources like emails or exposed endpoints",
              correct: true,
              points: 25,
              feedback: "Correct! UUIDs can be discovered through information leakage or other user interactions.",
              nextStep: 1
            },
            {
              text: "Try to predict UUIDs using pattern analysis",
              correct: false,
              points: 10,
              feedback: "Proper UUIDs are cryptographically random and cannot be predicted.",
              nextStep: 0
            },
            {
              text: "Use UUID collision attacks",
              correct: false,
              points: 15,
              feedback: "UUID collisions are theoretically possible but practically infeasible.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You found valid UUIDs from notification emails. How do you exploit this?",
          choices: [
            {
              text: "Use the UUIDs to access other users' resources through API endpoints",
              correct: true,
              points: 30,
              feedback: "Critical! UUIDs exposed in notifications can be used to access unauthorized resources.",
              nextStep: 2
            },
            {
              text: "Just document the UUID exposure",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating data access shows real impact.",
              nextStep: 2
            },
            {
              text: "Try to reverse engineer the UUID generation algorithm",
              correct: false,
              points: 10,
              feedback: "UUID generation is standardized and not typically vulnerable.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Advanced IDOR exploited! UUID-based access control bypassed through information leakage.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing against advanced IDOR attacks. What's the primary defense?",
          choices: [
            {
              text: "Implement proper authorization checks regardless of identifier type",
              correct: true,
              points: 25,
              feedback: "Essential! Authorization must be checked for every resource access, regardless of ID format.",
              nextStep: 1
            },
            {
              text: "Use longer and more complex identifiers",
              correct: false,
              points: 10,
              feedback: "Complex identifiers don't prevent authorized access to other users' resources.",
              nextStep: 1
            },
            {
              text: "Encrypt all resource identifiers",
              correct: false,
              points: 15,
              feedback: "Encryption can be reversed if keys are available. Authorization checks are still needed.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive access control should you implement?",
          choices: [
            {
              text: "Use role-based access control with resource-level permissions and audit logging",
              correct: true,
              points: 30,
              feedback: "Perfect! Fine-grained access control with comprehensive monitoring.",
              nextStep: 2
            },
            {
              text: "Remove all object identifiers from URLs",
              correct: false,
              points: 5,
              feedback: "Not practical. Applications need to reference specific resources.",
              nextStep: 2
            },
            {
              text: "Use session-based resource mapping",
              correct: false,
              points: 10,
              feedback: "Session mapping is complex and can introduce other issues.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Advanced access control implemented! All resource accesses properly authorized and monitored.",
          choices: []
        }
      ]
    }
  },

  insecureCryptographicStorage: {
    id: 54,
    title: "Insecure Cryptographic Storage",
    difficulty: "Hard",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover an application storing passwords encrypted rather than hashed. What's the vulnerability?",
          choices: [
            {
              text: "Encrypted passwords can be decrypted if the key is compromised",
              correct: true,
              points: 25,
              feedback: "Critical! Encryption is reversible, allowing password recovery if keys are exposed.",
              nextStep: 1
            },
            {
              text: "Encryption is slower than hashing",
              correct: false,
              points: 5,
              feedback: "Performance is not the primary security concern.",
              nextStep: 0
            },
            {
              text: "Encrypted data takes more storage space",
              correct: false,
              points: 5,
              feedback: "Storage efficiency is not a security issue.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit encrypted password storage?",
          choices: [
            {
              text: "Access the encryption key and decrypt all passwords",
              correct: true,
              points: 30,
              feedback: "Critical! Key compromise leads to complete password database exposure.",
              nextStep: 2
            },
            {
              text: "Use rainbow tables against the encrypted values",
              correct: false,
              points: 10,
              feedback: "Rainbow tables work against hashes, not encrypted data.",
              nextStep: 2
            },
            {
              text: "Try to guess the encryption algorithm",
              correct: false,
              points: 15,
              feedback: "Algorithm knowledge alone doesn't enable decryption without the key.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cryptographic storage flaw exploited! All passwords decrypted through key compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing proper password storage. What's the correct approach?",
          choices: [
            {
              text: "Use adaptive hashing algorithms like bcrypt or argon2 with proper salting",
              correct: true,
              points: 25,
              feedback: "Essential! Adaptive hashing with salting prevents password recovery even with database access.",
              nextStep: 1
            },
            {
              text: "Use strong encryption with key rotation",
              correct: false,
              points: 10,
              feedback: "Encryption is reversible and should not be used for password storage.",
              nextStep: 1
            },
            {
              text: "Hash passwords with fast algorithms like SHA-256",
              correct: false,
              points: 15,
              feedback: "Fast hashing enables brute force attacks. Use slow adaptive hashing.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive cryptographic storage should you implement?",
          choices: [
            {
              text: "Use adaptive hashing, proper key derivation, and secure key management",
              correct: true,
              points: 30,
              feedback: "Perfect! Comprehensive password security with proper key handling.",
              nextStep: 2
            },
            {
              text: "Store passwords in plain text with access controls",
              correct: false,
              points: -20,
              feedback: "Plain text storage is never acceptable.",
              nextStep: 2
            },
            {
              text: "Use multiple hashing layers",
              correct: false,
              points: 10,
              feedback: "Multiple hashes don't necessarily improve security and can introduce issues.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cryptographic storage properly implemented! All passwords securely hashed with adaptive algorithms.",
          choices: []
        }
      ]
    }
  },

  insecureSessionManagement: {
    id: 55,
    title: "Insecure Session Management",
    difficulty: "Medium",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover a website that doesn't invalidate sessions after password change. What's the risk?",
          choices: [
            {
              text: "Stolen sessions remain valid even after password change",
              correct: true,
              points: 20,
              feedback: "Critical! Session persistence after password change allows attackers to maintain access.",
              nextStep: 1
            },
            {
              text: "Users need to login again unnecessarily",
              correct: false,
              points: 5,
              feedback: "User inconvenience is not a security risk.",
              nextStep: 0
            },
            {
              text: "Session cookies become larger",
              correct: false,
              points: 5,
              feedback: "Cookie size is not a security concern.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit persistent sessions after password change?",
          choices: [
            {
              text: "Maintain access with stolen session even after victim changes password",
              correct: true,
              points: 25,
              feedback: "Critical! Attackers can maintain persistent access despite security measures.",
              nextStep: 2
            },
            {
              text: "Use the session to reset the password again",
              correct: false,
              points: 15,
              feedback: "Password reset typically requires current password or email access.",
              nextStep: 2
            },
            {
              text: "Extend the session expiration time",
              correct: false,
              points: 10,
              feedback: "Session extension is usually controlled by server, not client.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Session management flaw exploited! Persistent access maintained despite password change.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing secure session management. What's the critical control?",
          choices: [
            {
              text: "Invalidate all existing sessions after password change or privilege modification",
              correct: true,
              points: 25,
              feedback: "Essential! Session invalidation ensures security changes take effect immediately.",
              nextStep: 1
            },
            {
              text: "Use longer session timeouts",
              correct: false,
              points: 10,
              feedback: "Longer timeouts increase the window for session hijacking.",
              nextStep: 1
            },
            {
              text: "Store sessions in encrypted format",
              correct: false,
              points: 15,
              feedback: "Encryption protects session data but doesn't address invalidation.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive session security should you implement?",
          choices: [
            {
              text: "Implement session rotation, secure flags, and proper invalidation policies",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple session security layers with proper lifecycle management.",
              nextStep: 2
            },
            {
              text: "Use very short session timeouts for all users",
              correct: false,
              points: 10,
              feedback: "Too short timeouts hurt user experience unnecessarily.",
              nextStep: 2
            },
            {
              text: "Store sessions only in memory",
              correct: false,
              points: 5,
              feedback: "Not practical for applications needing session persistence.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Session security implemented! All sessions properly managed and invalidated when needed.",
          choices: []
        }
      ]
    }
  },

  insecureConfigurationManagement: {
    id: 56,
    title: "Insecure Configuration Management",
    difficulty: "Medium",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover a development environment exposed to the internet with default credentials. What's the risk?",
          choices: [
            {
              text: "Attackers can access sensitive data and functionality intended for internal use",
              correct: true,
              points: 20,
              feedback: "Critical! Exposed development environments often contain sensitive data and debugging tools.",
              nextStep: 1
            },
            {
              text: "The environment might have performance issues",
              correct: false,
              points: 5,
              feedback: "Performance is not the primary security concern.",
              nextStep: 0
            },
            {
              text: "Development code might be visible to competitors",
              correct: false,
              points: 10,
              feedback: "Code visibility is a concern, but data access is more critical.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit the exposed development environment?",
          choices: [
            {
              text: "Use default credentials to access admin panels and sensitive data",
              correct: true,
              points: 25,
              feedback: "Critical! Default credentials provide immediate access to sensitive systems.",
              nextStep: 2
            },
            {
              text: "Just document the exposure",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating access shows real risk.",
              nextStep: 2
            },
            {
              text: "Use it to launch attacks against other systems",
              correct: false,
              points: 15,
              feedback: "Possible but the primary risk is direct data access.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Configuration management flaw exploited! Development environment accessed with default credentials.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing environment configurations. What's the most important practice?",
          choices: [
            {
              text: "Never expose development environments to the internet and change all default credentials",
              correct: true,
              points: 25,
              feedback: "Essential! Development environments should be isolated and use unique credentials.",
              nextStep: 1
            },
            {
              text: "Use the same configuration for all environments for consistency",
              correct: false,
              points: -10,
              feedback: "Environment-specific configurations are needed for proper security.",
              nextStep: 1
            },
            {
              text: "Document all configuration changes thoroughly",
              correct: false,
              points: 10,
              feedback: "Documentation is good but doesn't prevent misconfigurations.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive configuration management should you implement?",
          choices: [
            {
              text: "Use environment-specific configs, automated scanning, and secret management",
              correct: true,
              points: 30,
              feedback: "Perfect! Comprehensive configuration security with automation.",
              nextStep: 2
            },
            {
              text: "Hide environment details through obscurity",
              correct: false,
              points: 5,
              feedback: "Security through obscurity is not a reliable defense.",
              nextStep: 2
            },
            {
              text: "Use complex configuration formats",
              correct: false,
              points: 5,
              feedback: "Complexity doesn't improve security and can introduce errors.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Configuration management secured! All environments properly isolated and configured.",
          choices: []
        }
      ]
    }
  },

  insecureDataValidation: {
    id: 57,
    title: "Insecure Data Validation",
    difficulty: "Hard",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover an API that accepts JSON data without proper type validation. What's the risk?",
          choices: [
            {
              text: "Type confusion attacks where unexpected data types cause security issues",
              correct: true,
              points: 25,
              feedback: "Critical! Type confusion can lead to logic flaws, injection, and other vulnerabilities.",
              nextStep: 1
            },
            {
              text: "The API might return incorrect data types",
              correct: false,
              points: 10,
              feedback: "Data type errors are functionality issues, not necessarily security risks.",
              nextStep: 0
            },
            {
              text: "JSON parsing might be slower",
              correct: false,
              points: 5,
              feedback: "Performance impact is not a security concern.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit weak type validation?",
          choices: [
            {
              text: "Send unexpected data types to bypass validation and cause logic errors",
              correct: true,
              points: 30,
              feedback: "Critical! Type manipulation can bypass security checks and cause application errors.",
              nextStep: 2
            },
            {
              text: "Just send malformed JSON to cause parser errors",
              correct: false,
              points: 15,
              feedback: "Parser errors are less critical than logic bypasses.",
              nextStep: 2
            },
            {
              text: "Use extremely large numbers to cause integer overflows",
              correct: false,
              points: 20,
              feedback: "Integer overflows are possible but type confusion is more broadly applicable.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Data validation flaw exploited! Security controls bypassed through type confusion.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing proper data validation. What's the most effective approach?",
          choices: [
            {
              text: "Use strict schema validation with defined types for all input data",
              correct: true,
              points: 25,
              feedback: "Essential! Schema validation ensures data matches expected types and formats.",
              nextStep: 1
            },
            {
              text: "Convert all input to strings to avoid type issues",
              correct: false,
              points: 10,
              feedback: "String conversion can mask issues and doesn't prevent all validation problems.",
              nextStep: 1
            },
            {
              text: "Use try-catch blocks around all data processing",
              correct: false,
              points: 15,
              feedback: "Error handling is good but doesn't replace proper validation.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive data validation should you implement?",
          choices: [
            {
              text: "Implement input sanitization, schema validation, and output encoding",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple validation layers throughout data processing.",
              nextStep: 2
            },
            {
              text: "Validate only critical data fields",
              correct: false,
              points: 10,
              feedback: "All user input should be validated, not just critical fields.",
              nextStep: 2
            },
            {
              text: "Use AI-based validation for complex data",
              correct: false,
              points: 5,
              feedback: "AI can introduce unpredictability and new attack surfaces.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Data validation implemented! All input properly validated and sanitized.",
          choices: []
        }
      ]
    }
  },

  insecureApiDesign: {
    id: 58,
    title: "Insecure API Design",
    difficulty: "Expert",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover a REST API that exposes internal implementation details in URLs. What's the risk?",
          choices: [
            {
              text: "Attackers can understand system architecture and find hidden endpoints",
              correct: true,
              points: 25,
              feedback: "Critical! Information disclosure in API design helps attackers map the application.",
              nextStep: 1
            },
            {
              text: "URLs become longer and harder to remember",
              correct: false,
              points: 5,
              feedback: "URL length is a usability issue, not a security risk.",
              nextStep: 0
            },
            {
              text: "API documentation becomes more complex",
              correct: false,
              points: 5,
              feedback: "Documentation complexity is not a direct security concern.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit API information disclosure?",
          choices: [
            {
              text: "Use revealed information to discover and attack hidden administrative endpoints",
              correct: true,
              points: 30,
              feedback: "Critical! Internal endpoint discovery can lead to privilege escalation.",
              nextStep: 2
            },
            {
              text: "Just document the information leakage",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but endpoint discovery demonstrates real risk.",
              nextStep: 2
            },
            {
              text: "Use the information for social engineering",
              correct: false,
              points: 10,
              feedback: "Possible but less critical than direct technical exploitation.",
              nextStep: 2
            }
          ]
        },
        {
          text: "API design flaw exploited! Internal endpoints discovered and accessed.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're designing secure APIs. What's the fundamental principle?",
          choices: [
            {
              text: "Use resource-oriented design without exposing implementation details",
              correct: true,
              points: 25,
              feedback: "Essential! Clean API design minimizes information disclosure and attack surface.",
              nextStep: 1
            },
            {
              text: "Document all API endpoints thoroughly",
              correct: false,
              points: 10,
              feedback: "Documentation is good but doesn't prevent insecure design.",
              nextStep: 1
            },
            {
              text: "Use complex URL structures to hide functionality",
              correct: false,
              points: 5,
              feedback: "Security through obscurity is not reliable.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive API security design should you implement?",
          choices: [
            {
              text: "Implement proper authentication, rate limiting, and version management",
              correct: true,
              points: 30,
              feedback: "Perfect! Comprehensive API security with proper lifecycle management.",
              nextStep: 2
            },
            {
              text: "Create separate APIs for internal and external use",
              correct: false,
              points: 20,
              feedback: "Helpful but doesn't replace proper security design.",
              nextStep: 2
            },
            {
              text: "Use custom authentication for all endpoints",
              correct: false,
              points: 15,
              feedback: "Custom auth can introduce vulnerabilities. Use standards when possible.",
              nextStep: 2
            }
          ]
        },
        {
          text: "API security design implemented! All endpoints properly designed and secured.",
          choices: []
        }
      ]
    }
  },

  insecureErrorHandling: {
    id: 59,
    title: "Insecure Error Handling",
    difficulty: "Medium",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover an application that shows detailed error messages to users. What's the risk?",
          choices: [
            {
              text: "Information disclosure helping attackers understand system internals",
              correct: true,
              points: 20,
              feedback: "Critical! Detailed errors reveal system architecture, technology stack, and potential vulnerabilities.",
              nextStep: 1
            },
            {
              text: "Users might be confused by technical messages",
              correct: false,
              points: 5,
              feedback: "User confusion is a usability issue, not a security risk.",
              nextStep: 0
            },
            {
              text: "Error pages might load slower",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the primary security concern.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit detailed error messages?",
          choices: [
            {
              text: "Use revealed information to craft targeted attacks against known vulnerabilities",
              correct: true,
              points: 25,
              feedback: "Critical! Error information helps attackers identify specific technologies and vulnerabilities.",
              nextStep: 2
            },
            {
              text: "Just document the information disclosure",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating attack crafting shows real impact.",
              nextStep: 2
            },
            {
              text: "Use errors for denial of service attacks",
              correct: false,
              points: 15,
              feedback: "DoS is possible but information disclosure enables more sophisticated attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Error handling flaw exploited! System information disclosed enabling targeted attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing secure error handling. What's the proper approach?",
          choices: [
            {
              text: "Show generic error messages to users while logging details internally",
              correct: true,
              points: 25,
              feedback: "Essential! Generic user messages prevent information disclosure while maintaining debugging capability.",
              nextStep: 1
            },
            {
              text: "Disable all error messages in production",
              correct: false,
              points: 10,
              feedback: "Complete disabling makes debugging impossible during incidents.",
              nextStep: 1
            },
            {
              text: "Customize error messages for different user roles",
              correct: false,
              points: 15,
              feedback: "Role-based errors can still leak information to attackers.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive error handling should you implement?",
          choices: [
            {
              text: "Implement custom error pages, proper logging, and security monitoring",
              correct: true,
              points: 30,
              feedback: "Perfect! Comprehensive error management with security monitoring.",
              nextStep: 2
            },
            {
              text: "Use the same error message for all errors",
              correct: false,
              points: 10,
              feedback: "Too generic messages can frustrate legitimate users.",
              nextStep: 2
            },
            {
              text: "Encrypt all error messages before displaying",
              correct: false,
              points: 5,
              feedback: "Encrypted errors are useless to users and don't prevent attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Error handling secured! All errors properly managed without information disclosure.",
          choices: []
        }
      ]
    }
  },

  insecureCommunication: {
    id: 60,
    title: "Insecure Communication Protocols",
    difficulty: "Hard",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover a website supporting outdated SSL/TLS protocols. What's the primary risk?",
          choices: [
            {
              text: "Cryptographic attacks against weak protocols can compromise encrypted data",
              correct: true,
              points: 25,
              feedback: "Critical! Weak protocols like SSLv3 and TLS 1.0 have known vulnerabilities.",
              nextStep: 1
            },
            {
              text: "The website might load slower with old protocols",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the security concern.",
              nextStep: 0
            },
            {
              text: "Older browsers might not support modern protocols",
              correct: false,
              points: 10,
              feedback: "Browser compatibility is a usability issue, not a security risk.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit weak TLS protocols?",
          choices: [
            {
              text: "Use protocol downgrade attacks to force weak encryption",
              correct: true,
              points: 30,
              feedback: "Critical! Downgrade attacks can force connections to use vulnerable protocols.",
              nextStep: 2
            },
            {
              text: "Just document the protocol support",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating downgrade attacks shows real risk.",
              nextStep: 2
            },
            {
              text: "Use the weak protocols for DDoS amplification",
              correct: false,
              points: 10,
              feedback: "DDoS is possible but data compromise is more critical.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Communication protocol flaw exploited! Encryption downgraded and data compromised.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing communication protocols. What's the most important action?",
          choices: [
            {
              text: "Disable weak protocols and use only modern TLS versions with strong ciphers",
              correct: true,
              points: 25,
              feedback: "Essential! Modern TLS with strong ciphers provides secure communication.",
              nextStep: 1
            },
            {
              text: "Support all protocols for maximum compatibility",
              correct: false,
              points: -10,
              feedback: "Supporting weak protocols creates security vulnerabilities.",
              nextStep: 1
            },
            {
              text: "Use the same configuration as other websites",
              correct: false,
              points: 5,
              feedback: "Other sites might have insecure configurations. Use security best practices.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive communication security should you implement?",
          choices: [
            {
              text: "Implement HSTS, certificate pinning, and regular security assessments",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers of communication security with proactive monitoring.",
              nextStep: 2
            },
            {
              text: "Use custom encryption protocols",
              correct: false,
              points: -15,
              feedback: "Custom protocols are likely to have unknown vulnerabilities.",
              nextStep: 2
            },
            {
              text: "Disable encryption for performance reasons",
              correct: false,
              points: -20,
              feedback: "Unencrypted communication exposes all data to interception.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Communication security implemented! All protocols properly configured and secured.",
          choices: []
        }
      ]
    }
  },

    accessControlBypass: {
    id: 61,
    title: "Function-Level Access Control Bypass",
    difficulty: "Hard",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover an admin panel at /admin that checks for admin role in the frontend. What do you test?",
          choices: [
            {
              text: "Access /admin directly and check if server-side validation exists",
              correct: true,
              points: 25,
              feedback: "Correct! Function-level access control must be enforced server-side, not just hidden in the UI.",
              nextStep: 1
            },
            {
              text: "Try to find the admin panel through directory brute forcing",
              correct: false,
              points: 10,
              feedback: "Good reconnaissance, but the vulnerability is in access control enforcement.",
              nextStep: 0
            },
            {
              text: "Modify JavaScript to show the admin panel",
              correct: false,
              points: 15,
              feedback: "UI modification might work, but direct access testing is more definitive.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully accessed the admin panel without admin privileges. What can you do?",
          choices: [
            {
              text: "Perform administrative actions like user management and system configuration",
              correct: true,
              points: 30,
              feedback: "Critical! Missing server-side access control allows complete administrative takeover.",
              nextStep: 2
            },
            {
              text: "Just view administrative data without making changes",
              correct: false,
              points: 15,
              feedback: "Viewing is good proof, but demonstrating action capability shows full impact.",
              nextStep: 2
            },
            {
              text: "Try to find other hidden admin features",
              correct: false,
              points: 20,
              feedback: "Good for further discovery, but you've already found a critical flaw.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Function-level access control bypassed! Administrative privileges achieved without authorization.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing function-level access control. What's the critical principle?",
          choices: [
            {
              text: "Enforce access control server-side for every function, regardless of UI visibility",
              correct: true,
              points: 25,
              feedback: "Essential! Server-side enforcement is mandatory - never trust client-side controls.",
              nextStep: 1
            },
            {
              text: "Hide administrative interfaces from non-admin users",
              correct: false,
              points: 10,
              feedback: "Security through obscurity is not a reliable defense.",
              nextStep: 1
            },
            {
              text: "Use complex URLs for administrative functions",
              correct: false,
              points: 5,
              feedback: "URL complexity doesn't prevent direct access attempts.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive access control architecture should you implement?",
          choices: [
            {
              text: "Implement role-based access control with server-side enforcement for all endpoints",
              correct: true,
              points: 30,
              feedback: "Perfect! RBAC with consistent server-side validation provides robust protection.",
              nextStep: 2
            },
            {
              text: "Use IP whitelisting for admin functions",
              correct: false,
              points: 15,
              feedback: "IP restrictions can be bypassed and don't replace proper authentication.",
              nextStep: 2
            },
            {
              text: "Require re-authentication for sensitive functions",
              correct: false,
              points: 20,
              feedback: "Re-authentication helps but doesn't replace proper authorization checks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Function-level access control implemented! All endpoints properly protected with server-side validation.",
          choices: []
        }
      ]
    }
  },

  sensitiveDataExposure: {
    id: 62,
    title: "Sensitive Data in Client-Side Storage",
    difficulty: "Medium",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover a web app storing user data in localStorage. What sensitive information might be exposed?",
          choices: [
            {
              text: "Personal data, tokens, and sensitive application state",
              correct: true,
              points: 20,
              feedback: "Correct! localStorage is accessible to JavaScript and can be compromised through XSS.",
              nextStep: 1
            },
            {
              text: "Only UI preferences and settings",
              correct: false,
              points: 5,
              feedback: "localStorage often contains more sensitive data than just preferences.",
              nextStep: 0
            },
            {
              text: "Encrypted database records",
              correct: false,
              points: 10,
              feedback: "Database records are typically not stored directly in localStorage.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How can you access data stored in localStorage?",
          choices: [
            {
              text: "Through XSS attacks or direct browser developer tools access",
              correct: true,
              points: 25,
              feedback: "Critical! localStorage is fully accessible to any JavaScript running on the page.",
              nextStep: 2
            },
            {
              text: "Only through server-side breaches",
              correct: false,
              points: 10,
              feedback: "localStorage is client-side and doesn't require server access.",
              nextStep: 2
            },
            {
              text: "Via network interception",
              correct: false,
              points: 15,
              feedback: "localStorage is not transmitted over network, so interception doesn't work.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Client-side data exposure demonstrated! Sensitive information extracted from localStorage.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing client-side data storage. What's the safest approach?",
          choices: [
            {
              text: "Avoid storing sensitive data client-side; use server-side sessions with secure cookies",
              correct: true,
              points: 25,
              feedback: "Essential! Sensitive data should remain on the server with proper session management.",
              nextStep: 1
            },
            {
              text: "Encrypt data before storing in localStorage",
              correct: false,
              points: 15,
              feedback: "Encryption keys in client-side code can still be extracted.",
              nextStep: 1
            },
            {
              text: "Use sessionStorage instead of localStorage",
              correct: false,
              points: 10,
              feedback: "sessionStorage has the same security issues as localStorage.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive client-side security should you implement?",
          choices: [
            {
              text: "Implement proper session management, secure cookies, and minimal client-side data",
              correct: true,
              points: 30,
              feedback: "Perfect! Server-centric architecture with secure session handling.",
              nextStep: 2
            },
            {
              text: "Store all data in IndexedDB with complex schemas",
              correct: false,
              points: 10,
              feedback: "IndexedDB has the same client-side access issues as localStorage.",
              nextStep: 2
            },
            {
              text: "Use browser fingerprinting to validate clients",
              correct: false,
              points: 15,
              feedback: "Fingerprinting doesn't prevent XSS or client-side data extraction.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Client-side data security implemented! Sensitive information properly protected on server.",
          choices: []
        }
      ]
    }
  },

  commandInjection: {
    id: 63,
    title: "OS Command Injection",
    difficulty: "Expert",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You find a network diagnostic feature that pings user-provided hosts. What do you test for?",
          choices: [
            {
              text: "Command injection using shell metacharacters like ;, &, |, or `",
              correct: true,
              points: 30,
              feedback: "Correct! Shell metacharacters can break out of intended command context.",
              nextStep: 1
            },
            {
              text: "SQL injection in the host parameter",
              correct: false,
              points: 10,
              feedback: "This is command execution, not database query.",
              nextStep: 0
            },
            {
              text: "Buffer overflow in the input field",
              correct: false,
              points: 15,
              feedback: "Buffer overflows are less common in web applications.",
              nextStep: 0
            }
          ]
        },
        {
          text: "Your command injection works. What's the most impactful action?",
          choices: [
            {
              text: "Execute system commands to gain shell access and explore the server",
              correct: true,
              points: 35,
              feedback: "Critical! Command injection can lead to complete server compromise.",
              nextStep: 2
            },
            {
              text: "Just demonstrate command execution with whoami",
              correct: false,
              points: 20,
              feedback: "Good proof, but full shell access demonstrates complete compromise.",
              nextStep: 2
            },
            {
              text: "Use it to scan internal networks",
              correct: false,
              points: 25,
              feedback: "Network scanning is useful but less critical than shell access.",
              nextStep: 2
            }
          ]
        },
        {
          text: "OS command injection successful! Remote command execution achieved on server.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing against command injection. What's the primary defense?",
          choices: [
            {
              text: "Use parameterized APIs instead of building command strings",
              correct: true,
              points: 30,
              feedback: "Essential! Parameterized APIs prevent command injection by separating data from commands.",
              nextStep: 1
            },
            {
              text: "Sanitize input by removing special characters",
              correct: false,
              points: 15,
              feedback: "Blacklisting can be bypassed with encoding or alternative characters.",
              nextStep: 1
            },
            {
              text: "Run commands with limited privileges",
              correct: false,
              points: 20,
              feedback: "Privilege limitation helps but doesn't prevent injection.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive command execution security should you implement?",
          choices: [
            {
              text: "Use safe APIs, input validation, and sandboxed execution environments",
              correct: true,
              points: 35,
              feedback: "Perfect! Multiple layers of protection for command execution.",
              nextStep: 2
            },
            {
              text: "Disable all command execution features",
              correct: false,
              points: 10,
              feedback: "Not practical for applications needing system interaction.",
              nextStep: 2
            },
            {
              text: "Use custom command parsers",
              correct: false,
              points: -10,
              feedback: "Custom parsers often introduce new vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Command execution security implemented! All system interactions use safe APIs.",
          choices: []
        }
      ]
    }
  },

  insecureDirectObjectReference: {
    id: 64,
    title: "Direct Object Reference to File System",
    difficulty: "Hard",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover a file download feature using direct file paths: /download?file=reports/q1.pdf. What do you test?",
          choices: [
            {
              text: "Use path traversal to access sensitive system files",
              correct: true,
              points: 25,
              feedback: "Correct! Direct file references can be exploited with path traversal attacks.",
              nextStep: 1
            },
            {
              text: "Try SQL injection in the file parameter",
              correct: false,
              points: 10,
              feedback: "This is file system access, not database access.",
              nextStep: 0
            },
            {
              text: "Modify the file extension to access different formats",
              correct: false,
              points: 15,
              feedback: "Extension changes don't address the path traversal vulnerability.",
              nextStep: 0
            }
          ]
        },
        {
          text: "Your path traversal works. What sensitive files can you access?",
          choices: [
            {
              text: "Configuration files, source code, and system files like /etc/passwd",
              correct: true,
              points: 30,
              feedback: "Critical! Path traversal can expose sensitive system and application files.",
              nextStep: 2
            },
            {
              text: "Only other user files in the same directory",
              correct: false,
              points: 15,
              feedback: "Path traversal can access files throughout the entire file system.",
              nextStep: 2
            },
            {
              text: "Just the application's own data files",
              correct: false,
              points: 10,
              feedback: "The vulnerability allows access beyond application directories.",
              nextStep: 2
            }
          ]
        },
        {
          text: "File system IDOR exploited! Sensitive system files accessed through path traversal.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing file download functionality. What's the secure approach?",
          choices: [
            {
              text: "Use indirect object references with mapping to actual file paths",
              correct: true,
              points: 25,
              feedback: "Essential! Indirect references prevent direct file system access.",
              nextStep: 1
            },
            {
              text: "Validate file paths against an allowlist",
              correct: false,
              points: 20,
              feedback: "Allowlisting helps but indirect references are more secure.",
              nextStep: 1
            },
            {
              text: "Remove directory traversal characters from input",
              correct: false,
              points: 15,
              feedback: "Blacklisting can be bypassed with encoding or alternative sequences.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive file access security should you implement?",
          choices: [
            {
              text: "Implement file ID mapping, path validation, and proper file permissions",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers of file access security.",
              nextStep: 2
            },
            {
              text: "Store all files in database as BLOBs",
              correct: false,
              points: 15,
              feedback: "Not practical for large files or existing applications.",
              nextStep: 2
            },
            {
              text: "Use complex obfuscated file names",
              correct: false,
              points: 10,
              feedback: "Security through obscurity is not reliable.",
              nextStep: 2
            }
          ]
        },
        {
          text: "File access security implemented! All file references use indirect mapping.",
          choices: []
        }
      ]
    }
  },

  securityHeaderMisconfiguration: {
    id: 65,
    title: "Security Header Misconfiguration",
    difficulty: "Medium",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover a website missing Content Security Policy headers. What attacks become easier?",
          choices: [
            {
              text: "XSS attacks can execute scripts without restrictions",
              correct: true,
              points: 20,
              feedback: "Correct! Missing CSP allows unrestricted script execution from any source.",
              nextStep: 1
            },
            {
              text: "SQL injection attacks become possible",
              correct: false,
              points: 10,
              feedback: "CSP doesn't prevent SQL injection - it's for content sources.",
              nextStep: 0
            },
            {
              text: "Brute force attacks are easier",
              correct: false,
              points: 5,
              feedback: "CSP doesn't affect authentication mechanisms.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit missing security headers?",
          choices: [
            {
              text: "Execute XSS payloads that would be blocked by proper CSP",
              correct: true,
              points: 25,
              feedback: "Critical! Missing security headers enable attacks that would otherwise be prevented.",
              nextStep: 2
            },
            {
              text: "Just document the missing headers",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating XSS shows real impact.",
              nextStep: 2
            },
            {
              text: "Use it for clickjacking attacks",
              correct: false,
              points: 20,
              feedback: "Clickjacking is prevented by X-Frame-Options, not CSP.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Security header misconfiguration exploited! XSS attacks successful without CSP protection.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing security headers. What's the most critical header for XSS protection?",
          choices: [
            {
              text: "Content-Security-Policy with strict source directives",
              correct: true,
              points: 25,
              feedback: "Essential! CSP provides the strongest protection against XSS attacks.",
              nextStep: 1
            },
            {
              text: "X-XSS-Protection header",
              correct: false,
              points: 10,
              feedback: "X-XSS-Protection is deprecated and less effective than CSP.",
              nextStep: 1
            },
            {
              text: "X-Content-Type-Options header",
              correct: false,
              points: 15,
              feedback: "This prevents MIME sniffing but doesn't stop XSS.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive security header strategy should you implement?",
          choices: [
            {
              text: "Implement CSP, HSTS, X-Frame-Options, and other security headers consistently",
              correct: true,
              points: 30,
              feedback: "Perfect! Comprehensive security headers provide multiple protection layers.",
              nextStep: 2
            },
            {
              text: "Use the same headers as other popular websites",
              correct: false,
              points: 10,
              feedback: "Other sites might have insecure configurations. Use security best practices.",
              nextStep: 2
            },
            {
              text: "Implement all possible security headers regardless of impact",
              correct: false,
              points: 15,
              feedback: "Some headers can break functionality if not configured properly.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Security headers properly configured! All recommended headers implemented with optimal settings.",
          choices: []
        }
      ]
    }
  },

  componentVulnerabilityScanning: {
    id: 66,
    title: "Missing Component Vulnerability Scanning",
    difficulty: "Medium",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover a website using outdated jQuery version with known XSS vulnerabilities. How do you proceed?",
          choices: [
            {
              text: "Research known CVEs and exploit the specific jQuery vulnerability",
              correct: true,
              points: 25,
              feedback: "Correct! Known vulnerabilities in components are low-hanging fruit for attackers.",
              nextStep: 1
            },
            {
              text: "Try to find zero-day vulnerabilities in jQuery",
              correct: false,
              points: 10,
              feedback: "Zero-days are rare. Focus on known, documented vulnerabilities first.",
              nextStep: 0
            },
            {
              text: "Ignore it and look for custom code vulnerabilities",
              correct: false,
              points: 5,
              feedback: "Third-party vulnerabilities are often easier to exploit than custom code.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You found a CVE that allows XSS through jQuery. How do you demonstrate impact?",
          choices: [
            {
              text: "Craft a payload that triggers the specific jQuery vulnerability",
              correct: true,
              points: 30,
              feedback: "Critical! Demonstrating known CVE exploitation shows immediate security risk.",
              nextStep: 2
            },
            {
              text: "Just report the outdated component",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but exploitation demonstrates real impact.",
              nextStep: 2
            },
            {
              text: "Use generic XSS payloads instead",
              correct: false,
              points: 20,
              feedback: "Generic payloads might work, but CVE-specific exploitation is more reliable.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Component vulnerability exploited! Known CVE in outdated library successfully demonstrated.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing component security. What's the most effective practice?",
          choices: [
            {
              text: "Use automated vulnerability scanning in CI/CD pipeline",
              correct: true,
              points: 25,
              feedback: "Essential! Automated scanning catches vulnerabilities before they reach production.",
              nextStep: 1
            },
            {
              text: "Manually check components once a year",
              correct: false,
              points: 5,
              feedback: "Manual checks are insufficient. Vulnerabilities are discovered daily.",
              nextStep: 1
            },
            {
              text: "Only update when security issues are reported",
              correct: false,
              points: 10,
              feedback: "Reactive approach leaves you vulnerable between discovery and patch.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive component management should you implement?",
          choices: [
            {
              text: "Implement SCA tools, maintain SBOM, and establish patch management process",
              correct: true,
              points: 30,
              feedback: "Perfect! Software Composition Analysis and Software Bill of Materials provide complete visibility.",
              nextStep: 2
            },
            {
              text: "Remove all third-party components",
              correct: false,
              points: 0,
              feedback: "Not practical. Modern applications rely on many third-party components.",
              nextStep: 2
            },
            {
              text: "Use only components you wrote yourself",
              correct: false,
              points: -10,
              feedback: "Not feasible and doesn't guarantee better security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Component security implemented! All dependencies regularly scanned and updated.",
          choices: []
        }
      ]
    }
  },

  authenticationBypassTechniques: {
    id: 67,
    title: "Authentication Bypass Through Alternative Paths",
    difficulty: "Hard",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover a 'remember me' feature that uses persistent cookies. What vulnerability might exist?",
          choices: [
            {
              text: "Predictable token generation allowing session hijacking",
              correct: true,
              points: 25,
              feedback: "Correct! Weak 'remember me' tokens can be predicted or brute forced.",
              nextStep: 1
            },
            {
              text: "SQL injection in the remember me functionality",
              correct: false,
              points: 10,
              feedback: "Authentication bypass focuses on token security, not SQL injection.",
              nextStep: 0
            },
            {
              text: "XSS in the login page",
              correct: false,
              points: 15,
              feedback: "XSS is different from authentication bypass vulnerabilities.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit weak remember me tokens?",
          choices: [
            {
              text: "Predict or brute force tokens to hijack user sessions",
              correct: true,
              points: 30,
              feedback: "Critical! Weak tokens allow attackers to impersonate users without credentials.",
              nextStep: 2
            },
            {
              text: "Just document the token predictability",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but session hijacking demonstrates real impact.",
              nextStep: 2
            },
            {
              text: "Use tokens for CSRF attacks",
              correct: false,
              points: 20,
              feedback: "CSRF is different from authentication bypass.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Authentication bypass successful! User sessions hijacked through weak remember me tokens.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing remember me functionality. What's the proper implementation?",
          choices: [
            {
              text: "Use cryptographically secure random tokens with proper expiration",
              correct: true,
              points: 25,
              feedback: "Essential! Secure random tokens prevent prediction and brute force attacks.",
              nextStep: 1
            },
            {
              text: "Use sequential numbers for remember me tokens",
              correct: false,
              points: -10,
              feedback: "Sequential tokens are easily predictable and insecure.",
              nextStep: 1
            },
            {
              text: "Store passwords in remember me cookies",
              correct: false,
              points: -15,
              feedback: "Never store passwords in cookies - use session tokens instead.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive authentication security should you implement?",
          choices: [
            {
              text: "Implement secure token generation, proper expiration, and token invalidation",
              correct: true,
              points: 30,
              feedback: "Perfect! Comprehensive token management with proper lifecycle.",
              nextStep: 2
            },
            {
              text: "Disable remember me functionality entirely",
              correct: false,
              points: 10,
              feedback: "Not user-friendly. Implement it securely instead.",
              nextStep: 2
            },
            {
              text: "Use the same token for all sessions",
              correct: false,
              points: -20,
              feedback: "Token reuse is a serious security vulnerability.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Authentication security implemented! All tokens properly generated and managed.",
          choices: []
        }
      ]
    }
  },

  insecureDataTransformation: {
    id: 68,
    title: "Insecure Data Transformation Processing",
    difficulty: "Expert",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover an image processing service that converts user-uploaded images. What vulnerability might exist?",
          choices: [
            {
              text: "File format confusion attacks using polyglot files",
              correct: true,
              points: 30,
              feedback: "Correct! Image processors can be tricked into executing malicious code in polyglot files.",
              nextStep: 1
            },
            {
              text: "SQL injection in image metadata",
              correct: false,
              points: 10,
              feedback: "Image processing focuses on file content, not SQL.",
              nextStep: 0
            },
            {
              text: "Buffer overflow in image dimensions",
              correct: false,
              points: 20,
              feedback: "Possible but polyglot files are more common in image processing.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit image processing vulnerabilities?",
          choices: [
            {
              text: "Upload polyglot files that are both valid images and contain executable code",
              correct: true,
              points: 35,
              feedback: "Critical! Polyglot files bypass file type checks while containing malicious payloads.",
              nextStep: 2
            },
            {
              text: "Just upload extremely large images",
              correct: false,
              points: 15,
              feedback: "Large files test for DoS, not code execution.",
              nextStep: 2
            },
            {
              text: "Use images with XSS payloads in metadata",
              correct: false,
              points: 20,
              feedback: "XSS is client-side, while image processing vulnerabilities are server-side.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Data transformation vulnerability exploited! Code execution through polyglot file upload.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing file processing services. What's the primary defense?",
          choices: [
            {
              text: "Use content verification instead of file extension or magic bytes alone",
              correct: true,
              points: 30,
              feedback: "Essential! Content verification ensures files match their claimed format.",
              nextStep: 1
            },
            {
              text: "Trust file extensions for type validation",
              correct: false,
              points: 5,
              feedback: "File extensions can be easily spoofed.",
              nextStep: 1
            },
            {
              text: "Use magic bytes validation only",
              correct: false,
              points: 15,
              feedback: "Magic bytes can be embedded in polyglot files.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive file processing security should you implement?",
          choices: [
            {
              text: "Implement content validation, format restrictions, and sandboxed processing",
              correct: true,
              points: 35,
              feedback: "Perfect! Multiple layers of file processing security.",
              nextStep: 2
            },
            {
              text: "Process all files in isolated virtual machines",
              correct: false,
              points: 25,
              feedback: "Helpful but often impractical for high-volume applications.",
              nextStep: 2
            },
            {
              text: "Disable all file processing features",
              correct: false,
              points: 5,
              feedback: "Not practical for applications needing file processing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "File processing security implemented! All file transformations properly validated and sandboxed.",
          choices: []
        }
      ]
    }
  },

  insufficientAttackProtection: {
    id: 69,
    title: "Insufficient Attack Protection Mechanisms",
    difficulty: "Hard",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover a web application with no rate limiting on login attempts. What's the risk?",
          choices: [
            {
              text: "Unlimited brute force attacks against user credentials",
              correct: true,
              points: 25,
              feedback: "Critical! Missing rate limiting allows attackers to try unlimited password combinations.",
              nextStep: 1
            },
            {
              text: "The server might become overloaded",
              correct: false,
              points: 10,
              feedback: "Performance impact is secondary to credential compromise risk.",
              nextStep: 0
            },
            {
              text: "User sessions might expire faster",
              correct: false,
              points: 5,
              feedback: "Session expiration is unrelated to rate limiting.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit missing rate limiting?",
          choices: [
            {
              text: "Perform automated credential stuffing attacks with large password lists",
              correct: true,
              points: 30,
              feedback: "Critical! Unlimited attempts make credential stuffing highly effective.",
              nextStep: 2
            },
            {
              text: "Just document the missing protection",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating credential stuffing shows real impact.",
              nextStep: 2
            },
            {
              text: "Use it for account enumeration",
              correct: false,
              points: 20,
              feedback: "Account enumeration is possible but credential stuffing is more critical.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Attack protection bypassed! Credential stuffing successful due to missing rate limiting.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing attack protection. What's the most critical control for authentication?",
          choices: [
            {
              text: "Implement rate limiting with progressive delays and account lockouts",
              correct: true,
              points: 25,
              feedback: "Essential! Rate limiting prevents automated attacks while maintaining usability.",
              nextStep: 1
            },
            {
              text: "Use CAPTCHA on all login attempts",
              correct: false,
              points: 15,
              feedback: "CAPTCHA hurts user experience and can be bypassed.",
              nextStep: 1
            },
            {
              text: "Require complex passwords only",
              correct: false,
              points: 10,
              feedback: "Complex passwords don't prevent brute force attacks.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive attack protection should you implement?",
          choices: [
            {
              text: "Implement WAF, rate limiting, anomaly detection, and security monitoring",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers of attack protection with monitoring.",
              nextStep: 2
            },
            {
              text: "Block all automated traffic",
              correct: false,
              points: 10,
              feedback: "Not practical. Legitimate automation (search engines, APIs) is needed.",
              nextStep: 2
            },
            {
              text: "Use IP-based blocking for all failed attempts",
              correct: false,
              points: 20,
              feedback: "IP blocking can be bypassed and affects legitimate users.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Attack protection implemented! Comprehensive security controls with proper monitoring.",
          choices: []
        }
      ]
    }
  },

  ssrfThroughWebhooks: {
    id: 70,
    title: "SSRF Through Webhook Callbacks",
    difficulty: "Expert",
    vulnerability: "A10:2021 - Server-Side Request Forgery (SSRF)",
    attacker: {
      story: [
        {
          text: "You discover a webhook testing feature that sends requests to user-provided URLs. What do you test?",
          choices: [
            {
              text: "Use internal IP addresses and cloud metadata endpoints",
              correct: true,
              points: 30,
              feedback: "Correct! Webhook features can be exploited for SSRF to internal services.",
              nextStep: 1
            },
            {
              text: "Try SQL injection in the webhook URL",
              correct: false,
              points: 10,
              feedback: "Webhook URLs are for HTTP requests, not SQL processing.",
              nextStep: 0
            },
            {
              text: "Use the webhook for reflected XSS",
              correct: false,
              points: 15,
              feedback: "Webhooks make outbound requests, not reflect content.",
              nextStep: 0
            }
          ]
        },
        {
          text: "Your SSRF through webhooks works. What's the most critical target?",
          choices: [
            {
              text: "Cloud metadata services to extract credentials and instance data",
              correct: true,
              points: 35,
              feedback: "Critical! Cloud metadata can contain credentials allowing complete environment compromise.",
              nextStep: 2
            },
            {
              text: "Just access internal network services",
              correct: false,
              points: 20,
              feedback: "Good reconnaissance, but credential extraction enables full compromise.",
              nextStep: 2
            },
            {
              text: "Use it for port scanning internal networks",
              correct: false,
              points: 25,
              feedback: "Port scanning is useful but less critical than credential theft.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Webhook SSRF exploited! Internal services and cloud metadata accessed through callback mechanism.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing webhook functionality against SSRF. What's the primary defense?",
          choices: [
            {
              text: "Validate and restrict webhook URLs to allowed domains and IP ranges",
              correct: true,
              points: 30,
              feedback: "Essential! URL validation prevents SSRF to internal and unauthorized external services.",
              nextStep: 1
            },
            {
              text: "Use DNS resolution to check webhook URLs",
              correct: false,
              points: 15,
              feedback: "DNS can be manipulated with DNS rebinding attacks.",
              nextStep: 1
            },
            {
              text: "Add authentication to all internal services",
              correct: false,
              points: 20,
              feedback: "Internal services should be protected, but SSRF prevention is better.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive webhook security should you implement?",
          choices: [
            {
              text: "Implement URL validation, network segmentation, and outbound request monitoring",
              correct: true,
              points: 35,
              feedback: "Perfect! Multiple layers of webhook and network security.",
              nextStep: 2
            },
            {
              text: "Disable all webhook functionality",
              correct: false,
              points: 5,
              feedback: "Not practical for applications requiring webhooks.",
              nextStep: 2
            },
            {
              text: "Use the same validation for webhooks as user input",
              correct: false,
              points: 15,
              feedback: "Webhook URLs require specific validation different from general input.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Webhook security implemented! All callback URLs properly validated and restricted.",
          choices: []
        }
      ]
    }
  },

  insecureSessionTimeout: {
    id: 71,
    title: "Insecure Session Timeout",
    difficulty: "Easy",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You notice a web application doesn't log you out even after leaving it open for hours. What's the risk?",
          choices: [
            {
              text: "Session hijacking if someone gains physical access to the device",
              correct: true,
              points: 15,
              feedback: "Correct! Long session timeouts increase the risk of session hijacking.",
              nextStep: 1
            },
            {
              text: "The application might use more memory",
              correct: false,
              points: 5,
              feedback: "Memory usage is not the primary security concern here.",
              nextStep: 0
            },
            {
              text: "User experience might be better",
              correct: false,
              points: 0,
              feedback: "While convenient, unlimited sessions create security risks.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How can you exploit long session timeouts?",
          choices: [
            {
              text: "Access an unattended logged-in device to perform unauthorized actions",
              correct: true,
              points: 20,
              feedback: "Critical! Unlimited sessions allow attackers to use abandoned logged-in sessions.",
              nextStep: 2
            },
            {
              text: "Steal the session cookie through network sniffing",
              correct: false,
              points: 10,
              feedback: "Network sniffing is a different attack vector from session timeout issues.",
              nextStep: 2
            },
            {
              text: "Use the session to reset passwords",
              correct: false,
              points: 15,
              feedback: "Password reset usually requires current password or email access.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Session timeout vulnerability demonstrated! Unlimited sessions create access risks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing proper session management. What's the recommended approach?",
          choices: [
            {
              text: "Set reasonable session timeouts and implement automatic logout",
              correct: true,
              points: 20,
              feedback: "Essential! Reasonable timeouts balance security and usability.",
              nextStep: 1
            },
            {
              text: "Make sessions last forever for better user experience",
              correct: false,
              points: -10,
              feedback: "Unlimited sessions create significant security risks.",
              nextStep: 1
            },
            {
              text: "Use very short 5-minute timeouts for all users",
              correct: false,
              points: 10,
              feedback: "Too short timeouts frustrate users and may not be necessary.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive session security should you implement?",
          choices: [
            {
              text: "Implement idle timeouts, absolute timeouts, and re-authentication for sensitive actions",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple session security layers with user-friendly timeouts.",
              nextStep: 2
            },
            {
              text: "Force logout after every page navigation",
              correct: false,
              points: 5,
              feedback: "This would make the application unusable.",
              nextStep: 2
            },
            {
              text: "Use the same timeout for all applications",
              correct: false,
              points: 10,
              feedback: "Different applications have different security requirements.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Session timeout security implemented! Balanced timeouts with automatic logout.",
          choices: []
        }
      ]
    }
  },

  missingHttps: {
    id: 72,
    title: "Missing HTTPS Encryption",
    difficulty: "Easy",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover a login form submitting over HTTP instead of HTTPS. What's the immediate risk?",
          choices: [
            {
              text: "Credentials can be intercepted through man-in-the-middle attacks",
              correct: true,
              points: 15,
              feedback: "Correct! HTTP transmits data in plain text, allowing interception.",
              nextStep: 1
            },
            {
              text: "The website might load slower",
              correct: false,
              points: 5,
              feedback: "Performance is not the security concern here.",
              nextStep: 0
            },
            {
              text: "Search engines might rank the site lower",
              correct: false,
              points: 5,
              feedback: "SEO impact is not a security issue.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How can you demonstrate the risk of missing HTTPS?",
          choices: [
            {
              text: "Intercept network traffic to capture login credentials in plain text",
              correct: true,
              points: 20,
              feedback: "Critical! Missing HTTPS allows easy credential interception on the same network.",
              nextStep: 2
            },
            {
              text: "Try SQL injection on the login form",
              correct: false,
              points: 10,
              feedback: "Different vulnerability - focus on the lack of encryption.",
              nextStep: 2
            },
            {
              text: "Use the credentials to login from another location",
              correct: false,
              points: 15,
              feedback: "This demonstrates impact but not the interception method.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Missing HTTPS vulnerability demonstrated! Credentials intercepted in plain text.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing proper transport security. What's the first step?",
          choices: [
            {
              text: "Enable HTTPS everywhere and redirect HTTP to HTTPS",
              correct: true,
              points: 20,
              feedback: "Essential! HTTPS should be used for all pages, not just login.",
              nextStep: 1
            },
            {
              text: "Use HTTPS only for login pages",
              correct: false,
              points: 10,
              feedback: "All pages should use HTTPS to protect cookies and other data.",
              nextStep: 1
            },
            {
              text: "Encrypt passwords before sending over HTTP",
              correct: false,
              points: 5,
              feedback: "Client-side encryption doesn't replace HTTPS and can be bypassed.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive transport security should you implement?",
          choices: [
            {
              text: "Implement HSTS, secure cookies, and regular certificate management",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive HTTPS implementation with additional security headers.",
              nextStep: 2
            },
            {
              text: "Use the same certificate for all domains",
              correct: false,
              points: 5,
              feedback: "Each domain should have its own properly configured certificate.",
              nextStep: 2
            },
            {
              text: "Disable HTTP completely without redirect",
              correct: false,
              points: 10,
              feedback: "Users might still try HTTP - redirect is better than complete disable.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Transport security implemented! HTTPS enabled everywhere with proper configurations.",
          choices: []
        }
      ]
    }
  },

  basicXss: {
    id: 73,
    title: "Basic Cross-Site Scripting (XSS)",
    difficulty: "Easy",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You find a search feature that displays your search term on the results page. What do you test?",
          choices: [
            {
              text: "Enter a basic script tag to test for reflected XSS",
              correct: true,
              points: 15,
              feedback: "Correct! Reflected XSS occurs when user input is immediately displayed without sanitization.",
              nextStep: 1
            },
            {
              text: "Try SQL injection in the search field",
              correct: false,
              points: 10,
              feedback: "Different vulnerability - focus on the content reflection.",
              nextStep: 0
            },
            {
              text: "Search for sensitive information",
              correct: false,
              points: 5,
              feedback: "This tests data exposure, not XSS vulnerability.",
              nextStep: 0
            }
          ]
        },
        {
          text: "Your script executes! What's the impact of this XSS vulnerability?",
          choices: [
            {
              text: "Steal user sessions and perform actions on their behalf",
              correct: true,
              points: 20,
              feedback: "Critical! XSS can steal cookies and impersonate users.",
              nextStep: 2
            },
            {
              text: "Just deface the website temporarily",
              correct: false,
              points: 10,
              feedback: "Defacement is possible but session theft is more dangerous.",
              nextStep: 2
            },
            {
              text: "Crash the user's browser",
              correct: false,
              points: 5,
              feedback: "Browser crashes are less critical than session compromise.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Basic XSS vulnerability exploited! Session theft demonstrated through script injection.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're fixing XSS vulnerabilities. What's the most effective approach?",
          choices: [
            {
              text: "Implement context-aware output encoding for all user input",
              correct: true,
              points: 20,
              feedback: "Essential! Output encoding prevents scripts from executing in different contexts.",
              nextStep: 1
            },
            {
              text: "Remove script tags from user input",
              correct: false,
              points: 10,
              feedback: "Blacklisting can be bypassed with other HTML tags and attributes.",
              nextStep: 1
            },
            {
              text: "Use JavaScript validation on the client side",
              correct: false,
              points: 5,
              feedback: "Client-side validation can be bypassed - server-side is essential.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive XSS protection should you implement?",
          choices: [
            {
              text: "Use Content Security Policy, input validation, and output encoding",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers of XSS protection with CSP as a safety net.",
              nextStep: 2
            },
            {
              text: "Disable all JavaScript on the website",
              correct: false,
              points: 0,
              feedback: "Not practical for modern web applications.",
              nextStep: 2
            },
            {
              text: "Use custom encoding for each input field",
              correct: false,
              points: 10,
              feedback: "Standard encoding libraries are more reliable than custom solutions.",
              nextStep: 2
            }
          ]
        },
        {
          text: "XSS protection implemented! All user input properly encoded and validated.",
          choices: []
        }
      ]
    }
  },

  weakPasswordPolicy: {
    id: 74,
    title: "Weak Password Policy",
    difficulty: "Easy",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover an application allowing passwords like '123456' and 'password'. What's the risk?",
          choices: [
            {
              text: "Easy brute force and dictionary attacks",
              correct: true,
              points: 15,
              feedback: "Correct! Weak passwords can be easily guessed or cracked.",
              nextStep: 1
            },
            {
              text: "The database might become larger",
              correct: false,
              points: 5,
              feedback: "Database size is not the security concern.",
              nextStep: 0
            },
            {
              text: "Users might forget their passwords more often",
              correct: false,
              points: 5,
              feedback: "Memory issues are not the primary security risk.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit weak password policies?",
          choices: [
            {
              text: "Use common password lists for credential stuffing attacks",
              correct: true,
              points: 20,
              feedback: "Critical! Weak passwords make credential stuffing highly effective.",
              nextStep: 2
            },
            {
              text: "Try to find the password in source code",
              correct: false,
              points: 10,
              feedback: "Passwords should be hashed, not stored in source code.",
              nextStep: 2
            },
            {
              text: "Use social engineering to get passwords",
              correct: false,
              points: 15,
              feedback: "Social engineering works regardless of password strength.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Weak password policy exploited! Common passwords successfully used in attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing strong password policies. What's the recommended approach?",
          choices: [
            {
              text: "Require minimum length, complexity, and check against common passwords",
              correct: true,
              points: 20,
              feedback: "Essential! Strong policies prevent easily guessable passwords.",
              nextStep: 1
            },
            {
              text: "Force users to change passwords every week",
              correct: false,
              points: 10,
              feedback: "Too frequent changes lead to weak passwords and user frustration.",
              nextStep: 1
            },
            {
              text: "Require special characters only",
              correct: false,
              points: 5,
              feedback: "Single requirements can lead to predictable patterns.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive authentication security should you implement?",
          choices: [
            {
              text: "Implement strong passwords, rate limiting, and multi-factor authentication",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple authentication security layers.",
              nextStep: 2
            },
            {
              text: "Use very long minimum password lengths",
              correct: false,
              points: 10,
              feedback: "Excessive length requirements frustrate users without much security benefit.",
              nextStep: 2
            },
            {
              text: "Store password hints in plain text",
              correct: false,
              points: -10,
              feedback: "Password hints can reveal actual passwords.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Password policy strengthened! Strong authentication requirements implemented.",
          choices: []
        }
      ]
    }
  },

  directoryListing: {
    id: 75,
    title: "Directory Listing Enabled",
    difficulty: "Medium",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover a web server with directory listing enabled on /images/ folder. What can you find?",
          choices: [
            {
              text: "Sensitive files accidentally placed in public directories",
              correct: true,
              points: 20,
              feedback: "Correct! Directory listing can reveal backup files, configuration files, and other sensitive data.",
              nextStep: 1
            },
            {
              text: "The server's operating system version",
              correct: false,
              points: 10,
              feedback: "Directory listing shows files, not necessarily system information.",
              nextStep: 0
            },
            {
              text: "Database connection strings",
              correct: false,
              points: 15,
              feedback: "Possible if config files are exposed, but not guaranteed.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You found backup files through directory listing. What's the risk?",
          choices: [
            {
              text: "Source code exposure and potential credential discovery",
              correct: true,
              points: 25,
              feedback: "Critical! Backup files often contain source code, credentials, and application logic.",
              nextStep: 2
            },
            {
              text: "Just learn about the application structure",
              correct: false,
              points: 15,
              feedback: "Good reconnaissance, but credential exposure is more critical.",
              nextStep: 2
            },
            {
              text: "Use the files to overload the server",
              correct: false,
              points: 10,
              feedback: "DoS is possible but data exposure is the primary risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Directory listing vulnerability exploited! Sensitive files and backup data exposed.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing web server configuration. What's the first step for directory listing?",
          choices: [
            {
              text: "Disable directory listing in web server configuration",
              correct: true,
              points: 20,
              feedback: "Essential! Directory listing should be disabled by default.",
              nextStep: 1
            },
            {
              text: "Use complex directory names to hide them",
              correct: false,
              points: 5,
              feedback: "Security through obscurity is not reliable.",
              nextStep: 1
            },
            {
              text: "Place empty index.html files in each directory",
              correct: false,
              points: 15,
              feedback: "This works but server configuration is more comprehensive.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive server security should you implement?",
          choices: [
            {
              text: "Disable directory listing, remove default files, and implement proper access controls",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive server hardening with multiple security measures.",
              nextStep: 2
            },
            {
              text: "Move all files to database storage",
              correct: false,
              points: 10,
              feedback: "Not practical for static assets and existing applications.",
              nextStep: 2
            },
            {
              text: "Use the same configuration for all environments",
              correct: false,
              points: 5,
              feedback: "Different environments may need different configurations.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Server security implemented! Directory listing disabled and proper configurations set.",
          choices: []
        }
      ]
    }
  },

  knownVulnerabilityExploit: {
    id: 76,
    title: "Known Vulnerability in Framework",
    difficulty: "Medium",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You identify a website using an old version of a popular CMS with known security issues. What's your approach?",
          choices: [
            {
              text: "Research and exploit publicly documented vulnerabilities for that version",
              correct: true,
              points: 20,
              feedback: "Correct! Known vulnerabilities in popular frameworks are well-documented and easy to exploit.",
              nextStep: 1
            },
            {
              text: "Try to find zero-day vulnerabilities in the CMS",
              correct: false,
              points: 10,
              feedback: "Zero-days are rare - focus on known vulnerabilities first.",
              nextStep: 0
            },
            {
              text: "Use generic attacks without version-specific research",
              correct: false,
              points: 15,
              feedback: "Version-specific exploits are more reliable and targeted.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You found a known RCE vulnerability for the CMS version. How do you exploit it?",
          choices: [
            {
              text: "Use the published exploit to gain remote code execution",
              correct: true,
              points: 25,
              feedback: "Critical! Known RCE vulnerabilities can lead to complete server compromise.",
              nextStep: 2
            },
            {
              text: "Just report the outdated software",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but exploitation demonstrates real risk.",
              nextStep: 2
            },
            {
              text: "Use it for information gathering only",
              correct: false,
              points: 10,
              feedback: "RCE allows much more than just information gathering.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Known vulnerability exploited! Remote code execution achieved through outdated framework.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're managing framework and library security. What's the most important practice?",
          choices: [
            {
              text: "Regularly update all components and monitor for security advisories",
              correct: true,
              points: 20,
              feedback: "Essential! Regular updates prevent known vulnerability exploitation.",
              nextStep: 1
            },
            {
              text: "Use older, more stable versions of frameworks",
              correct: false,
              points: -10,
              feedback: "Older versions often have known security vulnerabilities.",
              nextStep: 1
            },
            {
              text: "Hide framework version information",
              correct: false,
              points: 10,
              feedback: "Security through obscurity doesn't prevent determined attackers.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive component management should you implement?",
          choices: [
            {
              text: "Implement automated updates, vulnerability scanning, and patch management processes",
              correct: true,
              points: 25,
              feedback: "Perfect! Automated security processes ensure timely updates.",
              nextStep: 2
            },
            {
              text: "Use custom-modified versions of frameworks",
              correct: false,
              points: 5,
              feedback: "Custom modifications make updates more difficult and may introduce new issues.",
              nextStep: 2
            },
            {
              text: "Delay updates until they are proven stable",
              correct: false,
              points: 10,
              feedback: "Security updates should be applied promptly, not delayed.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Component security implemented! Regular updates and vulnerability monitoring established.",
          choices: []
        }
      ]
    }
  },

  sessionFixation: {
    id: 77,
    title: "Session Fixation Attack",
    difficulty: "Medium",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You notice a website that doesn't change session ID after login. What vulnerability might exist?",
          choices: [
            {
              text: "Session fixation - attackers can pre-set session IDs",
              correct: true,
              points: 20,
              feedback: "Correct! Session fixation occurs when session IDs don't change after authentication.",
              nextStep: 1
            },
            {
              text: "Session replay attacks become easier",
              correct: false,
              points: 15,
              feedback: "Session replay is different from fixation.",
              nextStep: 0
            },
            {
              text: "The sessions might last longer",
              correct: false,
              points: 5,
              feedback: "Session duration is separate from fixation vulnerability.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you perform a session fixation attack?",
          choices: [
            {
              text: "Give victim a known session ID, then use it after they login",
              correct: true,
              points: 25,
              feedback: "Critical! Session fixation allows attackers to hijack authenticated sessions.",
              nextStep: 2
            },
            {
              text: "Steal the session cookie through XSS",
              correct: false,
              points: 15,
              feedback: "Different attack vector - fixation doesn't require cookie theft.",
              nextStep: 2
            },
            {
              text: "Guess the session ID through brute force",
              correct: false,
              points: 10,
              feedback: "Brute force is different from fixation attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Session fixation attack successful! User session hijacked through pre-set session ID.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're protecting against session fixation. What's the primary defense?",
          choices: [
            {
              text: "Regenerate session ID after successful authentication",
              correct: true,
              points: 20,
              feedback: "Essential! Session regeneration prevents fixation attacks.",
              nextStep: 1
            },
            {
              text: "Use longer session IDs",
              correct: false,
              points: 10,
              feedback: "Length doesn't prevent fixation if IDs don't change after login.",
              nextStep: 1
            },
            {
              text: "Bind sessions to IP addresses",
              correct: false,
              points: 15,
              feedback: "IP binding can cause issues for legitimate users and doesn't prevent fixation.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive session security should you implement?",
          choices: [
            {
              text: "Implement session regeneration, secure flags, and proper timeout policies",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple session security layers with proper lifecycle management.",
              nextStep: 2
            },
            {
              text: "Use the same session for all user devices",
              correct: false,
              points: -10,
              feedback: "Different devices should have different sessions for security.",
              nextStep: 2
            },
            {
              text: "Store sessions in URL parameters",
              correct: false,
              points: -15,
              feedback: "URL sessions are insecure and can be leaked through referrers.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Session security implemented! All sessions properly managed with regeneration.",
          choices: []
        }
      ]
    }
  },

  insecureDeserializationJson: {
    id: 78,
    title: "JSON Deserialization with Type Manipulation",
    difficulty: "Hard",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover an API that deserializes JSON with type information using libraries like Jackson. What's the risk?",
          choices: [
            {
              text: "Type manipulation attacks that can lead to remote code execution",
              correct: true,
              points: 25,
              feedback: "Correct! Polymorphic deserialization can be exploited through type manipulation.",
              nextStep: 1
            },
            {
              text: "JSON parsing might be slower with types",
              correct: false,
              points: 5,
              feedback: "Performance is not the security concern.",
              nextStep: 0
            },
            {
              text: "Data validation becomes more complex",
              correct: false,
              points: 10,
              feedback: "Complexity is a development issue, not a direct security risk.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit JSON deserialization with type information?",
          choices: [
            {
              text: "Inject malicious type specifications that instantiate dangerous classes",
              correct: true,
              points: 30,
              feedback: "Critical! Type manipulation can instantiate classes that execute code during deserialization.",
              nextStep: 2
            },
            {
              text: "Just modify data values to cause errors",
              correct: false,
              points: 15,
              feedback: "Error causing is less critical than code execution.",
              nextStep: 2
            },
            {
              text: "Use JSON comments to hide payloads",
              correct: false,
              points: 10,
              feedback: "JSON doesn't support comments in the specification.",
              nextStep: 2
            }
          ]
        },
        {
          text: "JSON deserialization exploited! Remote code execution through type manipulation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing JSON deserialization. What's the safest approach?",
          choices: [
            {
              text: "Use strict type checking and avoid polymorphic deserialization",
              correct: true,
              points: 25,
              feedback: "Essential! Strict typing prevents unexpected object instantiation.",
              nextStep: 1
            },
            {
              text: "Validate JSON structure before deserialization",
              correct: false,
              points: 15,
              feedback: "Structure validation helps but doesn't prevent type manipulation.",
              nextStep: 1
            },
            {
              text: "Use the latest JSON library version",
              correct: false,
              points: 10,
              feedback: "Updates help but don't replace proper configuration.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive deserialization security should you implement?",
          choices: [
            {
              text: "Implement allowlists for deserializable classes and use safe configuration",
              correct: true,
              points: 30,
              feedback: "Perfect! Class allowlisting prevents dangerous object instantiation.",
              nextStep: 2
            },
            {
              text: "Disable all JSON parsing features",
              correct: false,
              points: 5,
              feedback: "Not practical for modern web applications.",
              nextStep: 2
            },
            {
              text: "Use custom serialization formats",
              correct: false,
              points: -10,
              feedback: "Custom formats often introduce new security issues.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Deserialization security implemented! All JSON processing uses safe configurations.",
          choices: []
        }
      ]
    }
  },

  insufficientLogging: {
    id: 79,
    title: "Insufficient Security Logging",
    difficulty: "Medium",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You test various attacks and notice no security alerts are generated. What's the risk?",
          choices: [
            {
              text: "Attacks can go undetected for long periods",
              correct: true,
              points: 20,
              feedback: "Critical! Without proper logging, breaches can remain undetected indefinitely.",
              nextStep: 1
            },
            {
              text: "The application might run slower",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the primary concern.",
              nextStep: 0
            },
            {
              text: "Users might experience more errors",
              correct: false,
              points: 5,
              feedback: "User errors are separate from security monitoring.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How can you demonstrate the impact of insufficient logging?",
          choices: [
            {
              text: "Show that multiple attack attempts leave no trace in logs",
              correct: true,
              points: 25,
              feedback: "Critical! Missing logs prevent incident response and forensic analysis.",
              nextStep: 2
            },
            {
              text: "Just document the lack of alerts",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but showing attack persistence demonstrates risk.",
              nextStep: 2
            },
            {
              text: "Use the lack of monitoring for DDoS attacks",
              correct: false,
              points: 10,
              feedback: "DDoS is possible but data breach persistence is more critical.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Insufficient logging demonstrated! Attacks proceed without detection or logging.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing security logging. What are the most critical events to log?",
          choices: [
            {
              text: "Authentication events, access violations, and input validation failures",
              correct: true,
              points: 20,
              feedback: "Essential! Security-critical events must be logged for monitoring and forensics.",
              nextStep: 1
            },
            {
              text: "All user actions for complete audit trail",
              correct: false,
              points: 10,
              feedback: "Too much logging can make important events hard to find.",
              nextStep: 1
            },
            {
              text: "Only successful administrative actions",
              correct: false,
              points: 5,
              feedback: "Failed attempts and user actions are also important for security.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive logging strategy should you implement?",
          choices: [
            {
              text: "Implement centralized logging, real-time alerts, and log integrity protection",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive logging with monitoring and integrity controls.",
              nextStep: 2
            },
            {
              text: "Log everything and sort it out later",
              correct: false,
              points: 10,
              feedback: "Excessive logging makes important events hard to find and analyze.",
              nextStep: 2
            },
            {
              text: "Use different log formats for each application",
              correct: false,
              points: 5,
              feedback: "Standardized formats make analysis and correlation easier.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Security logging implemented! Comprehensive monitoring with proper alerting.",
          choices: []
        }
      ]
    }
  },

  ssrfToInternalServices: {
    id: 80,
    title: "SSRF to Internal Services",
    difficulty: "Hard",
    vulnerability: "A10:2021 - Server-Side Request Forgery (SSRF)",
    attacker: {
      story: [
        {
          text: "You find a PDF generation service that fetches URLs for inclusion in documents. What do you test?",
          choices: [
            {
              text: "Internal service endpoints and cloud metadata URLs",
              correct: true,
              points: 25,
              feedback: "Correct! PDF generators often make HTTP requests that can be exploited for SSRF.",
              nextStep: 1
            },
            {
              text: "SQL injection in the URL parameter",
              correct: false,
              points: 10,
              feedback: "SSRF focuses on request destinations, not SQL injection.",
              nextStep: 0
            },
            {
              text: "XSS payloads in the URLs",
              correct: false,
              points: 15,
              feedback: "XSS is client-side, SSRF is server-side request forgery.",
              nextStep: 0
            }
          ]
        },
        {
          text: "Your SSRF attack accesses internal services. What's the most critical finding?",
          choices: [
            {
              text: "Access to cloud metadata services containing credentials",
              correct: true,
              points: 30,
              feedback: "Critical! Cloud metadata can provide credentials for complete environment access.",
              nextStep: 2
            },
            {
              text: "Just demonstrate internal network access",
              correct: false,
              points: 20,
              feedback: "Good proof, but credential extraction enables full compromise.",
              nextStep: 2
            },
            {
              text: "Use it for internal port scanning",
              correct: false,
              points: 25,
              feedback: "Port scanning is useful but less critical than credential access.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF vulnerability exploited! Internal services and cloud metadata accessed.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're protecting against SSRF attacks. What's the primary defense?",
          choices: [
            {
              text: "Validate and restrict URL destinations to allowed domains and IP ranges",
              correct: true,
              points: 25,
              feedback: "Essential! URL validation prevents requests to internal and unauthorized services.",
              nextStep: 1
            },
            {
              text: "Use DNS resolution to check URLs",
              correct: false,
              points: 15,
              feedback: "DNS can be manipulated with rebinding attacks.",
              nextStep: 1
            },
            {
              text: "Add authentication to all internal services",
              correct: false,
              points: 20,
              feedback: "Internal services should be protected, but SSRF prevention is better.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive SSRF protection should you implement?",
          choices: [
            {
              text: "Implement network segmentation, egress filtering, and request validation",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers of network and application security.",
              nextStep: 2
            },
            {
              text: "Disable all outbound HTTP requests",
              correct: false,
              points: 5,
              feedback: "Not practical for applications needing external services.",
              nextStep: 2
            },
            {
              text: "Use the same validation for all URL parameters",
              correct: false,
              points: 10,
              feedback: "Different URL use cases may require different validation rules.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF protection implemented! All outbound requests properly validated and restricted.",
          choices: []
        }
      ]
    }
  },
  insecurePasswordReset: {
    id: 81,
    title: "Insecure Password Reset Mechanism",
    difficulty: "Easy",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover a password reset feature that asks for email but doesn't verify ownership. What's the risk?",
          choices: [
            {
              text: "Account takeover by resetting any user's password",
              correct: true,
              points: 15,
              feedback: "Correct! Without proper verification, attackers can reset passwords for any account.",
              nextStep: 1
            },
            {
              text: "The system might send too many emails",
              correct: false,
              points: 5,
              feedback: "Email volume is not the primary security concern.",
              nextStep: 0
            },
            {
              text: "Users might forget their email addresses",
              correct: false,
              points: 0,
              feedback: "This is a usability issue, not a security vulnerability.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit the insecure password reset?",
          choices: [
            {
              text: "Enter other users' email addresses to reset their passwords",
              correct: true,
              points: 20,
              feedback: "Critical! Insecure reset allows complete account takeover for any user.",
              nextStep: 2
            },
            {
              text: "Try SQL injection in the email field",
              correct: false,
              points: 10,
              feedback: "Different vulnerability - focus on the authentication bypass.",
              nextStep: 2
            },
            {
              text: "Use the feature to spam users",
              correct: false,
              points: 5,
              feedback: "Spamming is possible but account takeover is more critical.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Password reset vulnerability exploited! Account takeover demonstrated without verification.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing password reset functionality. What's the essential requirement?",
          choices: [
            {
              text: "Verify email ownership through confirmation links or codes",
              correct: true,
              points: 20,
              feedback: "Essential! Password reset must verify the user actually controls the email address.",
              nextStep: 1
            },
            {
              text: "Use security questions for additional verification",
              correct: false,
              points: 10,
              feedback: "Security questions can often be guessed or researched.",
              nextStep: 1
            },
            {
              text: "Require admin approval for all password resets",
              correct: false,
              points: 5,
              feedback: "Not scalable for large applications and creates support burden.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive password reset security should you implement?",
          choices: [
            {
              text: "Use time-limited tokens, secure delivery, and rate limiting",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple security layers for password reset protection.",
              nextStep: 2
            },
            {
              text: "Disable password reset functionality",
              correct: false,
              points: 0,
              feedback: "Not practical - users need to reset forgotten passwords.",
              nextStep: 2
            },
            {
              text: "Store reset tokens in URLs without expiration",
              correct: false,
              points: -10,
              feedback: "Tokens must expire to prevent reuse attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Password reset security implemented! All resets require proper verification.",
          choices: []
        }
      ]
    }
  },

  clientSideEncryption: {
    id: 82,
    title: "Client-Side Encryption Flaws",
    difficulty: "Medium",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover a web app that encrypts passwords in JavaScript before sending to server. What's the risk?",
          choices: [
            {
              text: "Encryption keys are exposed in client code, making encryption useless",
              correct: true,
              points: 20,
              feedback: "Correct! Client-side encryption with exposed keys provides no real security.",
              nextStep: 1
            },
            {
              text: "The encryption might slow down the application",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the security concern.",
              nextStep: 0
            },
            {
              text: "Users might see encrypted passwords",
              correct: false,
              points: 5,
              feedback: "User visibility is not the primary security issue.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit client-side encryption?",
          choices: [
            {
              text: "Extract encryption keys from JavaScript and decrypt intercepted traffic",
              correct: true,
              points: 25,
              feedback: "Critical! Exposed keys allow decryption of all intercepted communications.",
              nextStep: 2
            },
            {
              text: "Just document the flawed approach",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but decryption demonstrates real impact.",
              nextStep: 2
            },
            {
              text: "Use the keys to encrypt malicious payloads",
              correct: false,
              points: 15,
              feedback: "Possible but decryption of legitimate traffic is more critical.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Client-side encryption bypassed! Passwords decrypted using exposed keys.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing proper password security. What's the correct approach?",
          choices: [
            {
              text: "Use HTTPS and hash passwords server-side with strong algorithms",
              correct: true,
              points: 25,
              feedback: "Essential! HTTPS protects in transit, server-side hashing protects at rest.",
              nextStep: 1
            },
            {
              text: "Use stronger client-side encryption algorithms",
              correct: false,
              points: 10,
              feedback: "Client-side encryption with exposed keys is fundamentally flawed.",
              nextStep: 1
            },
            {
              text: "Obfuscate the JavaScript encryption code",
              correct: false,
              points: 5,
              feedback: "Obfuscation can be reversed - it's not real security.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive cryptographic security should you implement?",
          choices: [
            {
              text: "Implement HTTPS everywhere, server-side hashing, and proper key management",
              correct: true,
              points: 30,
              feedback: "Perfect! End-to-end security with proper cryptographic practices.",
              nextStep: 2
            },
            {
              text: "Use the same encryption for all clients",
              correct: false,
              points: 5,
              feedback: "Different sessions should use different encryption parameters.",
              nextStep: 2
            },
            {
              text: "Store encryption keys in environment variables on client",
              correct: false,
              points: -15,
              feedback: "Client-side environment variables are still accessible to users.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cryptographic security implemented! Proper server-side hashing with HTTPS.",
          choices: []
        }
      ]
    }
  },

  nosqlInjection: {
    id: 83,
    title: "NoSQL Injection Attack",
    difficulty: "Hard",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover a MongoDB-based login that takes JSON input. What injection technique do you use?",
          choices: [
            {
              text: "Use MongoDB operators like $ne and $gt in JSON payloads",
              correct: true,
              points: 25,
              feedback: "Correct! NoSQL injection uses database operators to bypass authentication.",
              nextStep: 1
            },
            {
              text: "Try traditional SQL injection with quotes and semicolons",
              correct: false,
              points: 10,
              feedback: "NoSQL databases use different query syntax than SQL.",
              nextStep: 0
            },
            {
              text: "Use JavaScript injection in JSON values",
              correct: false,
              points: 15,
              feedback: "JavaScript injection is different from NoSQL operator injection.",
              nextStep: 0
            }
          ]
        },
        {
          text: "Your NoSQL injection works. What can you achieve?",
          choices: [
            {
              text: "Bypass authentication and extract data from the database",
              correct: true,
              points: 30,
              feedback: "Critical! NoSQL injection can bypass authentication and access sensitive data.",
              nextStep: 2
            },
            {
              text: "Just demonstrate login bypass",
              correct: false,
              points: 15,
              feedback: "Good proof, but data extraction shows broader impact.",
              nextStep: 2
            },
            {
              text: "Cause database errors and crashes",
              correct: false,
              points: 10,
              feedback: "DoS is possible but data access is more critical.",
              nextStep: 2
            }
          ]
        },
        {
          text: "NoSQL injection successful! Authentication bypassed and data extracted.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing against NoSQL injection. What's the primary defense?",
          choices: [
            {
              text: "Use parameterized queries and input validation for all data types",
              correct: true,
              points: 25,
              feedback: "Essential! Parameterized queries prevent injection in both SQL and NoSQL databases.",
              nextStep: 1
            },
            {
              text: "Convert all input to strings before processing",
              correct: false,
              points: 15,
              feedback: "Type conversion helps but doesn't prevent all injection vectors.",
              nextStep: 1
            },
            {
              text: "Use web application firewalls only",
              correct: false,
              points: 10,
              feedback: "WAFs can help but application-level fixes are more reliable.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive database security should you implement?",
          choices: [
            {
              text: "Implement input validation, least privilege access, and ORM security",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple database security layers with proper access controls.",
              nextStep: 2
            },
            {
              text: "Disable all database query features",
              correct: false,
              points: 0,
              feedback: "Not practical - applications need database functionality.",
              nextStep: 2
            },
            {
              text: "Use custom query parsers for all inputs",
              correct: false,
              points: -10,
              feedback: "Custom parsers often introduce new vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "NoSQL security implemented! All database queries properly parameterized.",
          choices: []
        }
      ]
    }
  },

  businessLogicFlaw: {
    id: 84,
    title: "Price Manipulation Vulnerability",
    difficulty: "Medium",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover an e-commerce site that calculates total price client-side. What's the risk?",
          choices: [
            {
              text: "Users can manipulate prices before submitting orders",
              correct: true,
              points: 20,
              feedback: "Critical! Client-side price calculation allows price manipulation attacks.",
              nextStep: 1
            },
            {
              text: "The shopping cart might display wrong totals",
              correct: false,
              points: 5,
              feedback: "Display errors are not the security concern.",
              nextStep: 0
            },
            {
              text: "JavaScript errors might occur during calculation",
              correct: false,
              points: 5,
              feedback: "JavaScript errors are functionality issues.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit client-side price calculation?",
          choices: [
            {
              text: "Modify JavaScript variables or network requests to change prices",
              correct: true,
              points: 25,
              feedback: "Critical! Price manipulation can lead to significant financial loss.",
              nextStep: 2
            },
            {
              text: "Just document the vulnerability",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but price change demonstrates real impact.",
              nextStep: 2
            },
            {
              text: "Use it to cause calculation errors",
              correct: false,
              points: 15,
              feedback: "Errors are less critical than financial manipulation.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Business logic flaw exploited! Price manipulation demonstrated successfully.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing business logic. What's the fundamental principle?",
          choices: [
            {
              text: "Never trust client-side data - validate all business rules server-side",
              correct: true,
              points: 25,
              feedback: "Essential! Server-side validation prevents client-side manipulation.",
              nextStep: 1
            },
            {
              text: "Use client-side encryption for sensitive data",
              correct: false,
              points: 10,
              feedback: "Encryption doesn't prevent manipulation if client controls decryption.",
              nextStep: 1
            },
            {
              text: "Add more client-side validation checks",
              correct: false,
              points: 5,
              feedback: "Client-side validation can be bypassed - server-side is critical.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive business logic security should you implement?",
          choices: [
            {
              text: "Implement server-side validation, audit trails, and fraud detection",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple business logic security layers with monitoring.",
              nextStep: 2
            },
            {
              text: "Remove all client-side JavaScript",
              correct: false,
              points: 0,
              feedback: "Not practical for modern web applications.",
              nextStep: 2
            },
            {
              text: "Trust but verify client calculations",
              correct: false,
              points: -10,
              feedback: "This approach still allows manipulation before verification.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Business logic security implemented! All critical calculations validated server-side.",
          choices: []
        }
      ]
    }
  },

  exposedAdminInterface: {
    id: 85,
    title: "Exposed Administrative Interface",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover an admin panel at /admin that's accessible without authentication. What's the risk?",
          choices: [
            {
              text: "Complete system compromise through unauthorized admin access",
              correct: true,
              points: 15,
              feedback: "Critical! Exposed admin interfaces allow attackers full control of the application.",
              nextStep: 1
            },
            {
              text: "The admin panel might load slower",
              correct: false,
              points: 5,
              feedback: "Performance is not the security concern.",
              nextStep: 0
            },
            {
              text: "Users might accidentally access it",
              correct: false,
              points: 5,
              feedback: "Accidental access is a usability issue, not the primary risk.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit an exposed admin panel?",
          choices: [
            {
              text: "Access administrative functions and modify system configuration",
              correct: true,
              points: 20,
              feedback: "Critical! Admin access allows data manipulation, user management, and system changes.",
              nextStep: 2
            },
            {
              text: "Just document the exposure",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating admin actions shows real risk.",
              nextStep: 2
            },
            {
              text: "Use it to gather information about the system",
              correct: false,
              points: 15,
              feedback: "Information gathering is useful but admin actions are more critical.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Exposed admin interface exploited! Full administrative control achieved.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing administrative interfaces. What's the minimum requirement?",
          choices: [
            {
              text: "Require strong authentication and network-level access controls",
              correct: true,
              points: 20,
              feedback: "Essential! Admin interfaces must have proper authentication and network protection.",
              nextStep: 1
            },
            {
              text: "Hide admin URLs through obscurity",
              correct: false,
              points: 5,
              feedback: "Security through obscurity is not reliable.",
              nextStep: 1
            },
            {
              text: "Use the same authentication as user accounts",
              correct: false,
              points: 10,
              feedback: "Admin accounts should have stronger authentication than regular users.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive admin security should you implement?",
          choices: [
            {
              text: "Implement strong auth, network segmentation, logging, and MFA",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple admin security layers with comprehensive monitoring.",
              nextStep: 2
            },
            {
              text: "Disable all admin functionality",
              correct: false,
              points: 0,
              feedback: "Not practical - administrative functions are needed.",
              nextStep: 2
            },
            {
              text: "Use IP whitelisting as the only protection",
              correct: false,
              points: 10,
              feedback: "IP whitelisting can be bypassed and should be combined with authentication.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Admin security implemented! All administrative interfaces properly protected.",
          choices: []
        }
      ]
    }
  },

  vulnerableJavaScriptLibrary: {
    id: 86,
    title: "Vulnerable JavaScript Library",
    difficulty: "Medium",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover a website using an outdated version of a popular JavaScript charting library with known XSS. What's your approach?",
          choices: [
            {
              text: "Craft input that triggers the specific library vulnerability",
              correct: true,
              points: 20,
              feedback: "Correct! Known vulnerabilities in JavaScript libraries are easy to exploit.",
              nextStep: 1
            },
            {
              text: "Try to find zero-days in the library",
              correct: false,
              points: 10,
              feedback: "Zero-days are rare - focus on known vulnerabilities first.",
              nextStep: 0
            },
            {
              text: "Ignore it and look for server-side vulnerabilities",
              correct: false,
              points: 5,
              feedback: "Client-side vulnerabilities can be just as dangerous as server-side ones.",
              nextStep: 0
            }
          ]
        },
        {
          text: "Your exploit works through the vulnerable library. What's the impact?",
          choices: [
            {
              text: "Execute XSS attacks that bypass other security controls",
              correct: true,
              points: 25,
              feedback: "Critical! Vulnerable libraries can bypass CSP and other client-side protections.",
              nextStep: 2
            },
            {
              text: "Just demonstrate the library is outdated",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but XSS execution shows real risk.",
              nextStep: 2
            },
            {
              text: "Use it to crash user browsers",
              correct: false,
              points: 15,
              feedback: "Browser crashes are less critical than XSS attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "JavaScript library vulnerability exploited! XSS achieved through outdated component.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're managing JavaScript dependencies. What's the most effective practice?",
          choices: [
            {
              text: "Use Subresource Integrity (SRI) and regularly update all libraries",
              correct: true,
              points: 20,
              feedback: "Essential! SRI ensures loaded scripts match expected content, preventing tampering.",
              nextStep: 1
            },
            {
              text: "Host all libraries locally without updates",
              correct: false,
              points: 5,
              feedback: "Local hosting doesn't prevent vulnerabilities in the code itself.",
              nextStep: 1
            },
            {
              text: "Use multiple CDNs for redundancy",
              correct: false,
              points: 10,
              feedback: "Redundancy doesn't address security vulnerabilities.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive client-side security should you implement?",
          choices: [
            {
              text: "Implement SRI, CSP, and automated dependency scanning",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple client-side security layers with proactive monitoring.",
              nextStep: 2
            },
            {
              text: "Remove all JavaScript from the application",
              correct: false,
              points: 0,
              feedback: "Not practical for modern web applications.",
              nextStep: 2
            },
            {
              text: "Use custom-written libraries for everything",
              correct: false,
              points: -10,
              feedback: "Custom code can have more vulnerabilities than well-tested libraries.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Client-side security implemented! All dependencies properly managed and secured.",
          choices: []
        }
      ]
    }
  },

  insecureAPIAuthentication: {
    id: 87,
    title: "Insecure API Authentication",
    difficulty: "Hard",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover an API that uses API keys transmitted in URL parameters. What's the security risk?",
          choices: [
            {
              text: "API keys can be leaked in logs, browser history, and referrer headers",
              correct: true,
              points: 25,
              feedback: "Critical! URL parameters are logged and visible in multiple places.",
              nextStep: 1
            },
            {
              text: "URLs become longer and harder to read",
              correct: false,
              points: 5,
              feedback: "URL length is a usability issue, not security.",
              nextStep: 0
            },
            {
              text: "The API might rate limit based on URL",
              correct: false,
              points: 10,
              feedback: "Rate limiting implementation is separate from authentication security.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit API keys in URL parameters?",
          choices: [
            {
              text: "Extract keys from logs, browser history, or network monitoring",
              correct: true,
              points: 30,
              feedback: "Critical! URL parameters are exposed in many places allowing key theft.",
              nextStep: 2
            },
            {
              text: "Just document the insecure practice",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but key extraction demonstrates real risk.",
              nextStep: 2
            },
            {
              text: "Use the keys for DDoS attacks",
              correct: false,
              points: 10,
              feedback: "DDoS is possible but data access is more critical.",
              nextStep: 2
            }
          ]
        },
        {
          text: "API authentication flaw exploited! Keys extracted from exposed URLs.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing API authentication. What's the proper method for API keys?",
          choices: [
            {
              text: "Use Authorization headers instead of URL parameters",
              correct: true,
              points: 25,
              feedback: "Essential! Authorization headers are not logged or exposed like URL parameters.",
              nextStep: 1
            },
            {
              text: "Encrypt the API keys in URLs",
              correct: false,
              points: 10,
              feedback: "Encryption doesn't prevent exposure in logs and history.",
              nextStep: 1
            },
            {
              text: "Use shorter API keys for better performance",
              correct: false,
              points: 5,
              feedback: "Key length doesn't address the exposure vulnerability.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive API security should you implement?",
          choices: [
            {
              text: "Use proper headers, rate limiting, and token rotation",
              correct: true,
              points: 30,
              feedback: "Perfect! Comprehensive API security with multiple protection layers.",
              nextStep: 2
            },
            {
              text: "Disable all API access",
              correct: false,
              points: 0,
              feedback: "Not practical - APIs are essential for modern applications.",
              nextStep: 2
            },
            {
              text: "Use the same API key for all clients",
              correct: false,
              points: -15,
              feedback: "Key sharing prevents individual client tracking and revocation.",
              nextStep: 2
            }
          ]
        },
        {
          text: "API security implemented! All authentication uses proper headers and security practices.",
          choices: []
        }
      ]
    }
  },

  insecureFileParsing: {
    id: 88,
    title: "Insecure File Parsing",
    difficulty: "Hard",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover a document processing service that parses user-uploaded files. What vulnerability might exist?",
          choices: [
            {
              text: "File format vulnerabilities like buffer overflows or code execution",
              correct: true,
              points: 25,
              feedback: "Critical! File parsers often have vulnerabilities in complex format handling.",
              nextStep: 1
            },
            {
              text: "The service might process files slowly",
              correct: false,
              points: 5,
              feedback: "Performance is not the security concern.",
              nextStep: 0
            },
            {
              text: "Files might be stored in insecure locations",
              correct: false,
              points: 10,
              feedback: "Storage location is a different vulnerability category.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit file parsing vulnerabilities?",
          choices: [
            {
              text: "Craft malicious files that trigger parser vulnerabilities",
              correct: true,
              points: 30,
              feedback: "Critical! Malicious files can exploit parser bugs for code execution.",
              nextStep: 2
            },
            {
              text: "Just upload very large files",
              correct: false,
              points: 10,
              feedback: "Large files test for DoS, not necessarily code execution.",
              nextStep: 2
            },
            {
              text: "Use files with embedded XSS payloads",
              correct: false,
              points: 15,
              feedback: "XSS is client-side, file parsing vulnerabilities are server-side.",
              nextStep: 2
            }
          ]
        },
        {
          text: "File parsing vulnerability exploited! Code execution through malicious document.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing file processing. What's the safest approach?",
          choices: [
            {
              text: "Use sandboxed environments and limit file processing capabilities",
              correct: true,
              points: 25,
              feedback: "Essential! Sandboxing contains damage if vulnerabilities are exploited.",
              nextStep: 1
            },
            {
              text: "Trust file extensions for type validation",
              correct: false,
              points: 5,
              feedback: "File extensions can be easily spoofed.",
              nextStep: 1
            },
            {
              text: "Process all files on client-side only",
              correct: false,
              points: 10,
              feedback: "Not practical for server-side processing requirements.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive file processing security should you implement?",
          choices: [
            {
              text: "Implement sandboxing, format validation, and minimal privilege execution",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple file processing security layers.",
              nextStep: 2
            },
            {
              text: "Disable all file upload functionality",
              correct: false,
              points: 5,
              feedback: "Not practical for applications needing file processing.",
              nextStep: 2
            },
            {
              text: "Use custom file parsers for everything",
              correct: false,
              points: -10,
              feedback: "Custom parsers often have more vulnerabilities than well-tested ones.",
              nextStep: 2
            }
          ]
        },
        {
          text: "File processing security implemented! All file operations properly sandboxed.",
          choices: []
        }
      ]
    }
  },

  missingSecurityMonitoring: {
    id: 89,
    title: "Missing Security Monitoring",
    difficulty: "Medium",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You perform various attacks and notice no alerts or blocks occur. What does this indicate?",
          choices: [
            {
              text: "Lack of security monitoring allowing undetected attacks",
              correct: true,
              points: 20,
              feedback: "Critical! Missing monitoring means attacks can continue indefinitely.",
              nextStep: 1
            },
            {
              text: "The security controls are very effective",
              correct: false,
              points: 5,
              feedback: "No alerts usually indicates missing monitoring, not effective controls.",
              nextStep: 0
            },
            {
              text: "The attacks are not serious enough",
              correct: false,
              points: 5,
              feedback: "Even basic attacks should generate some logging or alerts.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you demonstrate the impact of missing monitoring?",
          choices: [
            {
              text: "Show persistent attacks continue without detection or response",
              correct: true,
              points: 25,
              feedback: "Critical! Undetected attacks can lead to long-term compromise.",
              nextStep: 2
            },
            {
              text: "Just document the lack of alerts",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but showing attack persistence demonstrates risk.",
              nextStep: 2
            },
            {
              text: "Use the lack of monitoring for DDoS attacks",
              correct: false,
              points: 15,
              feedback: "DDoS is possible but persistent access is more dangerous.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Missing monitoring demonstrated! Attacks proceed without detection or response.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing security monitoring. What's the most critical component?",
          choices: [
            {
              text: "Real-time alerting for security events with proper response procedures",
              correct: true,
              points: 20,
              feedback: "Essential! Alerts are useless without processes to respond to them.",
              nextStep: 1
            },
            {
              text: "Comprehensive logging of all user actions",
              correct: false,
              points: 10,
              feedback: "Logging alone doesn't provide protection - alerts and response are needed.",
              nextStep: 1
            },
            {
              text: "Daily manual review of access logs",
              correct: false,
              points: 5,
              feedback: "Manual review is too slow to prevent ongoing attacks.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive monitoring strategy should you implement?",
          choices: [
            {
              text: "Implement SIEM, real-time alerts, incident response, and regular testing",
              correct: true,
              points: 25,
              feedback: "Perfect! End-to-end security monitoring with response capabilities.",
              nextStep: 2
            },
            {
              text: "Monitor only network-level events",
              correct: false,
              points: 10,
              feedback: "Application-level monitoring is also critical for web security.",
              nextStep: 2
            },
            {
              text: "Use the same monitoring for all applications",
              correct: false,
              points: 5,
              feedback: "Different applications may need different monitoring approaches.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Security monitoring implemented! Comprehensive detection and response capabilities.",
          choices: []
        }
      ]
    }
  },

  ssrfThroughImageProcessing: {
    id: 90,
    title: "SSRF Through Image Processing",
    difficulty: "Medium",
    vulnerability: "A10:2021 - Server-Side Request Forgery (SSRF)",
    attacker: {
      story: [
        {
          text: "You discover an image resizing service that fetches images from URLs. What SSRF vector exists?",
          choices: [
            {
              text: "The service can be tricked into fetching internal resources",
              correct: true,
              points: 20,
              feedback: "Correct! Image processors that fetch URLs can be exploited for SSRF.",
              nextStep: 1
            },
            {
              text: "Images might be stored insecurely",
              correct: false,
              points: 5,
              feedback: "Storage is a different vulnerability category.",
              nextStep: 0
            },
            {
              text: "The resizing might be slow for large images",
              correct: false,
              points: 5,
              feedback: "Performance is not the security concern.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit SSRF in image processing?",
          choices: [
            {
              text: "Provide URLs to internal services instead of image URLs",
              correct: true,
              points: 25,
              feedback: "Critical! SSRF allows access to internal services through the image processor.",
              nextStep: 2
            },
            {
              text: "Just document the URL fetching capability",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but internal access demonstrates real risk.",
              nextStep: 2
            },
            {
              text: "Use it to resize malicious images",
              correct: false,
              points: 15,
              feedback: "Image manipulation is not the security risk - internal access is.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF vulnerability exploited! Internal services accessed through image processor.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing against SSRF in image processing. What's the primary defense?",
          choices: [
            {
              text: "Validate and restrict URLs to allowed image domains only",
              correct: true,
              points: 20,
              feedback: "Essential! URL validation prevents access to internal services.",
              nextStep: 1
            },
            {
              text: "Process all images client-side",
              correct: false,
              points: 10,
              feedback: "Not practical for server-side image processing needs.",
              nextStep: 1
            },
            {
              text: "Use image recognition to verify content",
              correct: false,
              points: 15,
              feedback: "Image verification happens after the URL fetch, not before.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive SSRF protection should you implement?",
          choices: [
            {
              text: "Implement URL validation, network segmentation, and outbound filtering",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple SSRF protection layers at different levels.",
              nextStep: 2
            },
            {
              text: "Disable all URL-based image fetching",
              correct: false,
              points: 10,
              feedback: "Not practical for applications needing URL image sources.",
              nextStep: 2
            },
            {
              text: "Trust all URLs from authenticated users",
              correct: false,
              points: -10,
              feedback: "Authentication doesn't prevent SSRF - URL validation is still needed.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF protection implemented! All URL fetching properly validated and restricted.",
          choices: []
        }
      ]
    }
  },

    weakSessionManagement: {
    id: 91,
    title: "Weak Session Management",
    difficulty: "Easy",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You notice session cookies don't have the 'Secure' flag set. What's the risk when using HTTP?",
          choices: [
            {
              text: "Session cookies can be intercepted over unencrypted connections",
              correct: true,
              points: 15,
              feedback: "Correct! Without Secure flag, cookies are sent over HTTP and can be stolen.",
              nextStep: 1
            },
            {
              text: "Cookies might expire too quickly",
              correct: false,
              points: 5,
              feedback: "Expiration is separate from the Secure flag protection.",
              nextStep: 0
            },
            {
              text: "Users might see the cookie values",
              correct: false,
              points: 5,
              feedback: "Users can always see cookies in browser developer tools.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How can you exploit missing Secure flag on cookies?",
          choices: [
            {
              text: "Intercept session cookies when users access the site over HTTP",
              correct: true,
              points: 20,
              feedback: "Critical! Session hijacking is easy when cookies are transmitted in plain text.",
              nextStep: 2
            },
            {
              text: "Modify the cookie values directly in browser",
              correct: false,
              points: 10,
              feedback: "Cookie modification is possible but interception is the main risk.",
              nextStep: 2
            },
            {
              text: "Use the cookies from different browsers",
              correct: false,
              points: 5,
              feedback: "Browser-specific cookies don't work across different browsers.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Session management flaw exploited! Cookies intercepted due to missing Secure flag.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing secure session cookies. What flags are essential?",
          choices: [
            {
              text: "Secure, HttpOnly, and SameSite flags for comprehensive protection",
              correct: true,
              points: 20,
              feedback: "Essential! These three flags provide multiple layers of cookie protection.",
              nextStep: 1
            },
            {
              text: "Only Secure flag is necessary",
              correct: false,
              points: 10,
              feedback: "HttpOnly and SameSite provide additional important protections.",
              nextStep: 1
            },
            {
              text: "Custom flags for extra security",
              correct: false,
              points: 5,
              feedback: "Custom flags are not recognized by browsers and provide no protection.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive session security should you implement?",
          choices: [
            {
              text: "Use proper cookie flags, session timeouts, and secure token generation",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple session security layers with proper configuration.",
              nextStep: 2
            },
            {
              text: "Store sessions in local storage instead",
              correct: false,
              points: -10,
              feedback: "Local storage is less secure than properly configured cookies.",
              nextStep: 2
            },
            {
              text: "Use very long session durations",
              correct: false,
              points: 5,
              feedback: "Long sessions increase the risk of session hijacking.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Session security implemented! All cookies properly configured with security flags.",
          choices: []
        }
      ]
    }
  },

  plainTextCredentials: {
    id: 92,
    title: "Plain Text Credential Transmission",
    difficulty: "Easy",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover a login form that submits passwords in plain text without HTTPS. What's the immediate risk?",
          choices: [
            {
              text: "Passwords can be easily intercepted by anyone on the network",
              correct: true,
              points: 15,
              feedback: "Correct! Plain text transmission makes credential theft trivial.",
              nextStep: 1
            },
            {
              text: "The login might be slower",
              correct: false,
              points: 5,
              feedback: "Performance is not the security concern here.",
              nextStep: 0
            },
            {
              text: "Users might see their passwords in the URL",
              correct: false,
              points: 5,
              feedback: "Password visibility depends on form method, not encryption.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you demonstrate the risk of plain text credentials?",
          choices: [
            {
              text: "Capture login requests to show passwords in clear text",
              correct: true,
              points: 20,
              feedback: "Critical! Plain text capture demonstrates immediate credential exposure.",
              nextStep: 2
            },
            {
              text: "Try to guess common passwords",
              correct: false,
              points: 10,
              feedback: "Password guessing is different from interception.",
              nextStep: 2
            },
            {
              text: "Use the passwords to login from another location",
              correct: false,
              points: 15,
              feedback: "This shows impact but not the interception method.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cryptographic failure demonstrated! Passwords transmitted in plain text.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing credential transmission. What's the minimum requirement?",
          choices: [
            {
              text: "Use HTTPS for all authentication and sensitive data transmission",
              correct: true,
              points: 20,
              feedback: "Essential! HTTPS encrypts all data in transit preventing interception.",
              nextStep: 1
            },
            {
              text: "Hash passwords before sending from client",
              correct: false,
              points: 10,
              feedback: "Client-side hashing doesn't replace HTTPS and has other security issues.",
              nextStep: 1
            },
            {
              text: "Use complex encryption in JavaScript",
              correct: false,
              points: 5,
              feedback: "JavaScript encryption with exposed keys provides no real security.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive transport security should you implement?",
          choices: [
            {
              text: "Implement HTTPS everywhere, HSTS, and proper certificate management",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive transport security with multiple layers.",
              nextStep: 2
            },
            {
              text: "Use HTTPS only for login pages",
              correct: false,
              points: 10,
              feedback: "All pages should use HTTPS to protect cookies and session data.",
              nextStep: 2
            },
            {
              text: "Let users choose between HTTP and HTTPS",
              correct: false,
              points: -10,
              feedback: "Users should always be forced to HTTPS for security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Transport security implemented! All communications encrypted with HTTPS.",
          choices: []
        }
      ]
    }
  },

  simpleFormInjection: {
    id: 93,
    title: "Simple Form Injection",
    difficulty: "Easy",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You find a contact form that displays user input directly on a thank you page. What vulnerability exists?",
          choices: [
            {
              text: "Reflected XSS where input is displayed without sanitization",
              correct: true,
              points: 15,
              feedback: "Correct! Immediate reflection of user input creates XSS vulnerabilities.",
              nextStep: 1
            },
            {
              text: "SQL injection in the contact form",
              correct: false,
              points: 10,
              feedback: "Contact forms typically don't use SQL for storing messages.",
              nextStep: 0
            },
            {
              text: "Buffer overflow in text fields",
              correct: false,
              points: 5,
              feedback: "Buffer overflows are rare in web applications.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit the form reflection vulnerability?",
          choices: [
            {
              text: "Enter script tags that execute when the thank you page loads",
              correct: true,
              points: 20,
              feedback: "Critical! Reflected XSS can steal sessions or perform actions on user's behalf.",
              nextStep: 2
            },
            {
              text: "Just test with simple HTML tags",
              correct: false,
              points: 10,
              feedback: "HTML display is less dangerous than script execution.",
              nextStep: 2
            },
            {
              text: "Use the form to send spam messages",
              correct: false,
              points: 5,
              feedback: "Spamming is possible but XSS is more critical.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Form injection vulnerability exploited! XSS demonstrated through input reflection.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing form input handling. What's the safest approach?",
          choices: [
            {
              text: "Implement output encoding based on context where data is displayed",
              correct: true,
              points: 20,
              feedback: "Essential! Context-aware encoding prevents XSS in different output locations.",
              nextStep: 1
            },
            {
              text: "Remove all special characters from input",
              correct: false,
              points: 10,
              feedback: "Over-sanitization can break legitimate input and may not prevent all XSS.",
              nextStep: 1
            },
            {
              text: "Use JavaScript validation only",
              correct: false,
              points: 5,
              feedback: "Client-side validation can be bypassed - server-side is essential.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive input security should you implement?",
          choices: [
            {
              text: "Use input validation, output encoding, and Content Security Policy",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers of protection against injection attacks.",
              nextStep: 2
            },
            {
              text: "Disable all form submissions",
              correct: false,
              points: 0,
              feedback: "Not practical - forms are essential for user interaction.",
              nextStep: 2
            },
            {
              text: "Trust all input from authenticated users",
              correct: false,
              points: -10,
              feedback: "Authenticated users can still be compromised or malicious.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Form security implemented! All user input properly validated and encoded.",
          choices: []
        }
      ]
    }
  },

  predictableResourceLocation: {
    id: 94,
    title: "Predictable Resource Locations",
    difficulty: "Easy",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover user profiles at /user/1, /user/2, etc. What design flaw exists?",
          choices: [
            {
              text: "Predictable URLs allow easy enumeration of all users",
              correct: true,
              points: 15,
              feedback: "Correct! Sequential IDs make it easy to discover all user resources.",
              nextStep: 1
            },
            {
              text: "The URLs are too simple to remember",
              correct: false,
              points: 5,
              feedback: "URL simplicity is a usability issue, not security.",
              nextStep: 0
            },
            {
              text: "Search engines might index user profiles",
              correct: false,
              points: 10,
              feedback: "Search engine indexing is a privacy concern, but enumeration is the security issue.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit predictable resource locations?",
          choices: [
            {
              text: "Iterate through IDs to discover and access all user profiles",
              correct: true,
              points: 20,
              feedback: "Critical! Predictable patterns allow complete user enumeration.",
              nextStep: 2
            },
            {
              text: "Just document the sequential pattern",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but user discovery demonstrates real impact.",
              nextStep: 2
            },
            {
              text: "Use the pattern to guess admin user IDs",
              correct: false,
              points: 15,
              feedback: "Possible, but complete enumeration is more comprehensive.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Insecure design exploited! All user resources discovered through predictable URLs.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're designing secure resource URLs. What's the better approach?",
          choices: [
            {
              text: "Use non-sequential, unpredictable identifiers like UUIDs",
              correct: true,
              points: 20,
              feedback: "Essential! Unpredictable identifiers prevent resource enumeration.",
              nextStep: 1
            },
            {
              text: "Use complex sequential numbers",
              correct: false,
              points: 5,
              feedback: "Complex sequences can still be predicted or brute forced.",
              nextStep: 1
            },
            {
              text: "Hide URLs through JavaScript navigation",
              correct: false,
              points: 10,
              feedback: "Security through obscurity is not reliable.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive resource security should you implement?",
          choices: [
            {
              text: "Use unpredictable IDs, proper authorization checks, and rate limiting",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple resource protection layers with access controls.",
              nextStep: 2
            },
            {
              text: "Remove all resource identifiers from URLs",
              correct: false,
              points: 5,
              feedback: "Not practical - applications need to reference specific resources.",
              nextStep: 2
            },
            {
              text: "Use the same ID pattern for all resources",
              correct: false,
              points: 10,
              feedback: "Different resource types may benefit from different ID strategies.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Resource security implemented! All URLs use unpredictable identifiers.",
          choices: []
        }
      ]
    }
  },

  defaultErrorMessages: {
    id: 95,
    title: "Default Error Messages",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You encounter detailed database error messages showing SQL queries. What information is exposed?",
          choices: [
            {
              text: "Database structure, table names, and potentially sensitive data",
              correct: true,
              points: 15,
              feedback: "Correct! Detailed errors reveal internal system information useful for attackers.",
              nextStep: 1
            },
            {
              text: "Only that an error occurred",
              correct: false,
              points: 5,
              feedback: "Default errors typically show much more than just error occurrence.",
              nextStep: 0
            },
            {
              text: "User passwords and credentials",
              correct: false,
              points: 10,
              feedback: "Passwords shouldn't be in error messages, but other sensitive data might be.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How can you use detailed error messages for attacks?",
          choices: [
            {
              text: "Gather system information to craft more targeted attacks",
              correct: true,
              points: 20,
              feedback: "Critical! Error messages help attackers understand the system for precise exploitation.",
              nextStep: 2
            },
            {
              text: "Just document the information disclosure",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but showing attack crafting demonstrates risk.",
              nextStep: 2
            },
            {
              text: "Use errors to crash the application",
              correct: false,
              points: 5,
              feedback: "DoS is possible but information gathering enables more sophisticated attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Information disclosure exploited! System details gathered from error messages.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're configuring proper error handling. What's the production approach?",
          choices: [
            {
              text: "Show generic error messages to users while logging details internally",
              correct: true,
              points: 20,
              feedback: "Essential! Generic messages prevent information disclosure while maintaining debuggability.",
              nextStep: 1
            },
            {
              text: "Disable all error messages completely",
              correct: false,
              points: 5,
              feedback: "Complete disabling makes debugging production issues difficult.",
              nextStep: 1
            },
            {
              text: "Use the same detailed errors for all environments",
              correct: false,
              points: -10,
              feedback: "Production should never show detailed errors to users.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive error handling should you implement?",
          choices: [
            {
              text: "Implement custom error pages, proper logging, and environment-specific configurations",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive error management with security controls.",
              nextStep: 2
            },
            {
              text: "Use very technical error messages for all users",
              correct: false,
              points: -15,
              feedback: "Technical errors confuse users and help attackers.",
              nextStep: 2
            },
            {
              text: "Redirect all errors to home page",
              correct: false,
              points: 10,
              feedback: "Redirects can confuse users and mask real problems.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Error handling secured! Generic messages for users with detailed internal logging.",
          choices: []
        }
      ]
    }
  },

  outdatedWebServer: {
    id: 96,
    title: "Outdated Web Server Software",
    difficulty: "Medium",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You identify an outdated web server version with known security vulnerabilities. What's your approach?",
          choices: [
            {
              text: "Research and exploit known CVEs for that specific server version",
              correct: true,
              points: 20,
              feedback: "Correct! Known web server vulnerabilities are well-documented and often easy to exploit.",
              nextStep: 1
            },
            {
              text: "Try to find zero-day vulnerabilities",
              correct: false,
              points: 10,
              feedback: "Zero-days are rare - focus on known vulnerabilities first.",
              nextStep: 0
            },
            {
              text: "Ignore it and focus on application vulnerabilities",
              correct: false,
              points: 5,
              feedback: "Server-level vulnerabilities can be just as dangerous as application ones.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You found a known RCE vulnerability for the web server. How do you exploit it?",
          choices: [
            {
              text: "Use the published exploit to gain control of the server",
              correct: true,
              points: 25,
              feedback: "Critical! Web server RCE can lead to complete system compromise.",
              nextStep: 2
            },
            {
              text: "Just report the outdated software",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but exploitation demonstrates real risk.",
              nextStep: 2
            },
            {
              text: "Use it for information gathering only",
              correct: false,
              points: 15,
              feedback: "RCE allows much more than just information gathering.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Web server vulnerability exploited! System compromise through outdated software.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're managing web server security. What's the most important practice?",
          choices: [
            {
              text: "Regularly update server software and apply security patches",
              correct: true,
              points: 20,
              feedback: "Essential! Regular updates prevent known vulnerability exploitation.",
              nextStep: 1
            },
            {
              text: "Use older, more stable versions",
              correct: false,
              points: -10,
              feedback: "Older versions often have known security vulnerabilities.",
              nextStep: 1
            },
            {
              text: "Hide server version information",
              correct: false,
              points: 10,
              feedback: "Security through obscurity doesn't prevent determined attackers.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive server security should you implement?",
          choices: [
            {
              text: "Implement automated updates, security hardening, and regular scanning",
              correct: true,
              points: 25,
              feedback: "Perfect! Proactive server security with multiple protection layers.",
              nextStep: 2
            },
            {
              text: "Use custom-compiled web servers",
              correct: false,
              points: 5,
              feedback: "Custom builds may have more vulnerabilities and be harder to update.",
              nextStep: 2
            },
            {
              text: "Delay updates until annual maintenance",
              correct: false,
              points: -15,
              feedback: "Security updates should be applied promptly, not delayed.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Server security implemented! Regular updates and comprehensive hardening.",
          choices: []
        }
      ]
    }
  },

  missingMultiFactorAuth: {
    id: 97,
    title: "Missing Multi-Factor Authentication",
    difficulty: "Medium",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover a sensitive application that uses only username/password authentication. What's missing?",
          choices: [
            {
              text: "Multi-factor authentication for additional security layer",
              correct: true,
              points: 20,
              feedback: "Correct! Sensitive applications should have MFA to protect against credential theft.",
              nextStep: 1
            },
            {
              text: "More complex password requirements",
              correct: false,
              points: 10,
              feedback: "Complex passwords help but don't replace MFA protection.",
              nextStep: 0
            },
            {
              text: "Additional security questions",
              correct: false,
              points: 5,
              feedback: "Security questions are weak and can often be guessed.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How does missing MFA make attacks easier?",
          choices: [
            {
              text: "Stolen passwords alone are sufficient for account compromise",
              correct: true,
              points: 25,
              feedback: "Critical! Without MFA, password theft leads directly to account takeover.",
              nextStep: 2
            },
            {
              text: "Just document the lack of MFA",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but showing password-only access demonstrates risk.",
              nextStep: 2
            },
            {
              text: "Use it to bypass rate limiting",
              correct: false,
              points: 15,
              feedback: "Rate limiting is separate from MFA protection.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Authentication weakness exploited! Account access with password only, no MFA.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing strong authentication. What's the recommended approach for sensitive apps?",
          choices: [
            {
              text: "Implement multi-factor authentication for all sensitive accounts",
              correct: true,
              points: 20,
              feedback: "Essential! MFA significantly reduces risk of account compromise.",
              nextStep: 1
            },
            {
              text: "Use longer passwords instead of MFA",
              correct: false,
              points: 10,
              feedback: "Password length doesn't provide the same protection as MFA.",
              nextStep: 1
            },
            {
              text: "Require frequent password changes",
              correct: false,
              points: 5,
              feedback: "Frequent changes lead to weak passwords and don't replace MFA.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive authentication security should you implement?",
          choices: [
            {
              text: "Implement MFA, strong passwords, and monitoring for suspicious activity",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple authentication security layers with monitoring.",
              nextStep: 2
            },
            {
              text: "Use the same MFA method for all users",
              correct: false,
              points: 10,
              feedback: "Different MFA options accommodate different user preferences and needs.",
              nextStep: 2
            },
            {
              text: "Disable password authentication completely",
              correct: false,
              points: 5,
              feedback: "Not practical - passwords are still needed as one factor.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Authentication security implemented! MFA enabled for all sensitive access.",
          choices: []
        }
      ]
    }
  },

  insecureDataStorage: {
    id: 98,
    title: "Insecure Data Storage",
    difficulty: "Medium",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover user preferences stored in localStorage without encryption. What sensitive data might be exposed?",
          choices: [
            {
              text: "Personal information, application state, and potentially tokens",
              correct: true,
              points: 20,
              feedback: "Critical! localStorage is accessible to any JavaScript on the page.",
              nextStep: 1
            },
            {
              text: "Only UI settings and preferences",
              correct: false,
              points: 10,
              feedback: "Applications often store more sensitive data in localStorage than intended.",
              nextStep: 0
            },
            {
              text: "Encrypted database records",
              correct: false,
              points: 5,
              feedback: "Database records are typically not stored in localStorage.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How can you access data stored in localStorage?",
          choices: [
            {
              text: "Through XSS attacks or browser developer tools",
              correct: true,
              points: 25,
              feedback: "Critical! localStorage data is fully accessible to JavaScript running on the page.",
              nextStep: 2
            },
            {
              text: "Only through server-side access",
              correct: false,
              points: 10,
              feedback: "localStorage is client-side only and not sent to server automatically.",
              nextStep: 2
            },
            {
              text: "Via network interception",
              correct: false,
              points: 15,
              feedback: "localStorage is not transmitted over network, so interception doesn't work.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Data storage vulnerability exploited! Sensitive information extracted from localStorage.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing client-side data storage. What's the safest approach?",
          choices: [
            {
              text: "Avoid storing sensitive data client-side; use server sessions instead",
              correct: true,
              points: 20,
              feedback: "Essential! Sensitive data should remain on the server with proper protection.",
              nextStep: 1
            },
            {
              text: "Encrypt data before storing in localStorage",
              correct: false,
              points: 15,
              feedback: "Encryption keys in client code can still be extracted.",
              nextStep: 1
            },
            {
              text: "Use sessionStorage instead of localStorage",
              correct: false,
              points: 10,
              feedback: "sessionStorage has the same security issues as localStorage.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive data security should you implement?",
          choices: [
            {
              text: "Use server-side sessions, secure cookies, and minimal client data storage",
              correct: true,
              points: 25,
              feedback: "Perfect! Server-centric architecture with secure data handling.",
              nextStep: 2
            },
            {
              text: "Store all data in IndexedDB with complex schemas",
              correct: false,
              points: 10,
              feedback: "IndexedDB has the same client-side access issues.",
              nextStep: 2
            },
            {
              text: "Use browser fingerprinting to secure data",
              correct: false,
              points: 5,
              feedback: "Fingerprinting doesn't prevent XSS or client-side data extraction.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Data security implemented! Sensitive information properly protected on server.",
          choices: []
        }
      ]
    }
  },

  insufficientAuditTrail: {
    id: 99,
    title: "Insufficient Audit Trail",
    difficulty: "Easy",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You perform sensitive actions but find no records in any logs. What security control is missing?",
          choices: [
            {
              text: "Audit trail logging for security-relevant events",
              correct: true,
              points: 15,
              feedback: "Critical! Missing audit trails prevent detection and investigation of security incidents.",
              nextStep: 1
            },
            {
              text: "The application might be using memory-only logging",
              correct: false,
              points: 5,
              feedback: "Memory-only logging would still show current activity.",
              nextStep: 0
            },
            {
              text: "User activity tracking for analytics",
              correct: false,
              points: 10,
              feedback: "Analytics tracking is different from security audit trails.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How does missing audit logging help attackers?",
          choices: [
            {
              text: "Actions can be performed without leaving evidence for investigation",
              correct: true,
              points: 20,
              feedback: "Critical! Without logs, attacks can't be detected or investigated.",
              nextStep: 2
            },
            {
              text: "Just document the lack of logging",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but showing undetectable actions demonstrates risk.",
              nextStep: 2
            },
            {
              text: "Use it to bypass rate limiting",
              correct: false,
              points: 5,
              feedback: "Rate limiting is separate from audit logging.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Audit trail deficiency exploited! Actions performed without any logging.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing security logging. What events must be audited?",
          choices: [
            {
              text: "Authentication, authorization changes, and data access events",
              correct: true,
              points: 20,
              feedback: "Essential! These critical security events must be logged for monitoring.",
              nextStep: 1
            },
            {
              text: "Only failed login attempts",
              correct: false,
              points: 10,
              feedback: "Successful events and other security actions also need logging.",
              nextStep: 1
            },
            {
              text: "All user interface interactions",
              correct: false,
              points: 5,
              feedback: "Too much logging can make important events hard to find.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive audit logging should you implement?",
          choices: [
            {
              text: "Log security events with timestamps, user context, and action details",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive audit trails with necessary context.",
              nextStep: 2
            },
            {
              text: "Log everything and filter later",
              correct: false,
              points: 10,
              feedback: "Excessive logging makes important events hard to find and analyze.",
              nextStep: 2
            },
            {
              text: "Use different log formats for each event type",
              correct: false,
              points: 5,
              feedback: "Standardized formats make analysis and correlation easier.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Audit logging implemented! Comprehensive security event tracking enabled.",
          choices: []
        }
      ]
    }
  },

  internalServiceDiscovery: {
    id: 100,
    title: "Internal Service Discovery via SSRF",
    difficulty: "Medium",
    vulnerability: "A10:2021 - Server-Side Request Forgery (SSRF)",
    attacker: {
      story: [
        {
          text: "You find a feature that fetches and displays website previews from URLs. What SSRF risk exists?",
          choices: [
            {
              text: "The feature can be used to scan internal network services",
              correct: true,
              points: 20,
              feedback: "Correct! URL fetching features can be exploited to discover internal services.",
              nextStep: 1
            },
            {
              text: "The previews might load slowly",
              correct: false,
              points: 5,
              feedback: "Performance is not the security concern.",
              nextStep: 0
            },
            {
              text: "Users might see inappropriate content",
              correct: false,
              points: 10,
              feedback: "Content moderation is different from SSRF vulnerability.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you use SSRF for internal service discovery?",
          choices: [
            {
              text: "Scan internal IP ranges to find active services and their responses",
              correct: true,
              points: 25,
              feedback: "Critical! SSRF can map internal network infrastructure.",
              nextStep: 2
            },
            {
              text: "Just access known internal services",
              correct: false,
              points: 15,
              feedback: "Good start, but comprehensive scanning shows broader impact.",
              nextStep: 2
            },
            {
              text: "Use it to overload internal services",
              correct: false,
              points: 10,
              feedback: "DoS is possible but reconnaissance is the primary SSRF risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF vulnerability exploited! Internal network services discovered and mapped.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're protecting against SSRF attacks. What's the primary network defense?",
          choices: [
            {
              text: "Implement network segmentation and outbound firewall rules",
              correct: true,
              points: 20,
              feedback: "Essential! Network controls prevent SSRF from reaching internal services.",
              nextStep: 1
            },
            {
              text: "Use DNS filtering for all outbound requests",
              correct: false,
              points: 15,
              feedback: "DNS filtering helps but doesn't prevent IP-based access.",
              nextStep: 1
            },
            {
              text: "Add authentication to all internal services",
              correct: false,
              points: 10,
              feedback: "Authentication helps but doesn't prevent service discovery.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive SSRF protection should you implement?",
          choices: [
            {
              text: "Use URL validation, network controls, and application-level restrictions",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple SSRF protection layers at different levels.",
              nextStep: 2
            },
            {
              text: "Disable all URL fetching features",
              correct: false,
              points: 5,
              feedback: "Not practical for applications needing URL functionality.",
              nextStep: 2
            },
            {
              text: "Trust all URLs from authenticated users",
              correct: false,
              points: -10,
              feedback: "Authentication doesn't prevent SSRF attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF protection implemented! Comprehensive network and application controls.",
          choices: []
        }
      ]
    }
  },

    cookieMonsterAttack: {
    id: 101,
    title: "Cookie Monster's Midnight Snack",
    difficulty: "Easy",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover a website where users can view each other's shopping carts by changing the cart ID in the URL. What tasty treat awaits?",
          choices: [
            {
              text: "Other users' carts filled with goodies you can 'sample'",
              correct: true,
              points: 15,
              feedback: "Yum yum! Direct object references let you peek into everyone's shopping carts. Cookie Monster would be proud!",
              nextStep: 1
            },
            {
              text: "Just empty carts and disappointment",
              correct: false,
              points: 5,
              feedback: "Even empty carts reveal user activity patterns. Keep digging!",
              nextStep: 0
            },
            {
              text: "The website's secret cookie recipe",
              correct: false,
              points: 0,
              feedback: "As much as we'd love that, it's probably not in user shopping carts!",
              nextStep: 0
            }
          ]
        },
        {
          text: "You found users with admin privileges in their carts. How do you upgrade your snack?",
          choices: [
            {
              text: "Use their cart IDs to access admin features",
              correct: true,
              points: 20,
              feedback: "Om nom nom! You've found the special admin cookies! Privilege escalation achieved through poor access control.",
              nextStep: 2
            },
            {
              text: "Just admire their fancy admin items",
              correct: false,
              points: 10,
              feedback: "Don't just look at the cookies - eat them! Show the real impact.",
              nextStep: 2
            },
            {
              text: "Order cookies for everyone on their account",
              correct: false,
              points: -10,
              feedback: "While generous, unauthorized purchases cross ethical boundaries. Stick to demonstration.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cookie feast successful! You've demonstrated how poor access control lets anyone snack on others' data and privileges.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "The Cookie Monster is loose in your application! How do you protect the cookie jar?",
          choices: [
            {
              text: "Implement proper authorization checks for every cart access",
              correct: true,
              points: 20,
              feedback: "Perfect! Server-side authorization is like a cookie jar with a lock - only the right people can open it.",
              nextStep: 1
            },
            {
              text: "Use bigger, more complex cookie IDs",
              correct: false,
              points: 5,
              feedback: "Bigger cookies are still cookies - they'll get eaten regardless of size!",
              nextStep: 1
            },
            {
              text: "Hide the cookie jar in a different room",
              correct: false,
              points: 0,
              feedback: "Security through obscurity is like hiding cookies - they always get found eventually!",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good start! What comprehensive cookie protection should you bake in?",
          choices: [
            {
              text: "Role-based access control, session management, and proper validation",
              correct: true,
              points: 25,
              feedback: "Excellent recipe! Multiple layers of protection ensure only authorized users get their cookies.",
              nextStep: 2
            },
            {
              text: "Give everyone the same type of cookie",
              correct: false,
              points: -5,
              feedback: "One-size-fits-all security usually means no security at all!",
              nextStep: 2
            },
            {
              text: "Put cookies in a transparent jar so everyone can see but not touch",
              correct: false,
              points: 0,
              feedback: "Visibility without protection? That's just teasing the Cookie Monster!",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cookie jar secured! Proper access control ensures users only eat their own cookies.",
          choices: []
        }
      ]
    }
  },

  encryptionTango: {
    id: 102,
    title: "The Encryption Tango: Two Left Feet",
    difficulty: "Medium",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover an app doing the 'encryption tango' - it encrypts data but stores the key right next to it in the database. What dance move is this?",
          choices: [
            {
              text: "The 'Key Under Doormat' routine",
              correct: true,
              points: 20,
              feedback: "Perfect analogy! Storing keys with encrypted data is like locking your house but leaving the key under the mat.",
              nextStep: 1
            },
            {
              text: "The 'Security Shuffle'",
              correct: false,
              points: 10,
              feedback: "More like the 'Security Stumble' - they're not quite getting the steps right!",
              nextStep: 0
            },
            {
              text: "The 'Privacy Pirouette'",
              correct: false,
              points: 5,
              feedback: "Sounds elegant, but this implementation is anything but!",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you crash this cryptographic party?",
          choices: [
            {
              text: "Grab the key and decrypt everything like the party crasher you are",
              correct: true,
              points: 25,
              feedback: "Party's over! With the key in plain sight, you can decrypt all the 'protected' data. So much for the encryption tango!",
              nextStep: 2
            },
            {
              text: "Just watch the awkward security dance",
              correct: false,
              points: 10,
              feedback: "Don't just watch - join the dance and show how easy it is to steal the spotlight!",
              nextStep: 2
            },
            {
              text: "Try to guess the encryption algorithm",
              correct: false,
              points: 15,
              feedback: "Why guess when they've given you the keys to the kingdom?",
              nextStep: 2
            }
          ]
        },
        {
          text: "Dance floor cleared! You've demonstrated that encryption without proper key management is just security theater.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "The encryption tango needs better choreography. What's the first step?",
          choices: [
            {
              text: "Use proper key management systems and never store keys with data",
              correct: true,
              points: 25,
              feedback: "Excellent! Proper key management is like having a professional choreographer - everything moves in sync and securely.",
              nextStep: 1
            },
            {
              text: "Use longer, more complex keys",
              correct: false,
              points: 10,
              feedback: "A complex key stored poorly is like an elaborate dance move performed badly - still a mess!",
              nextStep: 1
            },
            {
              text: "Hide the keys in the comments of the code",
              correct: false,
              points: -10,
              feedback: "That's like hiding your dance instructions in the audience - they'll still be found!",
              nextStep: 1
            }
          ]
        },
        {
          text: "Great! How do we turn this awkward dance into a security ballet?",
          choices: [
            {
              text: "Implement HSMs, key rotation, and proper cryptographic protocols",
              correct: true,
              points: 30,
              feedback: "Bravo! Now you're performing a security ballet - elegant, precise, and perfectly secure.",
              nextStep: 2
            },
            {
              text: "Teach everyone the same simple dance",
              correct: false,
              points: 5,
              feedback: "Simplicity in security often leads to vulnerability. We need sophistication!",
              nextStep: 2
            },
            {
              text: "Stop dancing and just stand still",
              correct: false,
              points: 0,
              feedback: "In security, standing still means falling behind. Keep evolving!",
              nextStep: 2
            }
          ]
        },
        {
          text: "Encryption masterpiece! Your cryptographic implementation now dances to a secure rhythm.",
          choices: []
        }
      ]
    }
  },

  sqlInjectionComedy: {
    id: 103,
    title: "SQL Injection: The Database's Stand-up Comedy Night",
    difficulty: "Hard",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You find a search form that's so trusting, it would believe you're the database's long-lost cousin. What joke do you tell first?",
          choices: [
            {
              text: "' OR '1'='1 - the classic 'everyone gets in' punchline",
              correct: true,
              points: 25,
              feedback: "Hilarious! The database is laughing so hard it's giving you all its data. Classic SQL injection comedy!",
              nextStep: 1
            },
            {
              text: "A knock-knock joke about tables",
              correct: false,
              points: 5,
              feedback: "Cute, but the database prefers more technical humor!",
              nextStep: 0
            },
            {
              text: "Ask if it wants to hear a schema",
              correct: false,
              points: 10,
              feedback: "Wordplay won't get you the data - you need proper SQL comedy!",
              nextStep: 0
            }
          ]
        },
        {
          text: "The database is rolling with laughter! How do you get it to reveal its deepest secrets?",
          choices: [
            {
              text: "Use UNION SELECT to make it spill all its tables and columns",
              correct: true,
              points: 30,
              feedback: "Stand-up comedy gold! The database is now doing a full roast of itself, revealing everything. You should take this act on the road!",
              nextStep: 2
            },
            {
              text: "Tell more 'drop table' jokes",
              correct: false,
              points: -15,
              feedback: "Destructive comedy crosses the line from hack to vandalism. Stick to observational humor!",
              nextStep: 2
            },
            {
              text: "Just enjoy the free show",
              correct: false,
              points: 10,
              feedback: "Don't just watch - become the headliner! Show the full extent of the vulnerability.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Stand-up routine complete! You've demonstrated how SQL injection turns databases into unwilling comedians, revealing all their secrets for laughs.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "The database's comedy career is causing security concerns. How do we get it to stop oversharing?",
          choices: [
            {
              text: "Use parameterized queries - the ultimate comedy censor",
              correct: true,
              points: 25,
              feedback: "Perfect! Parameterized queries are like having a good editor - they keep the funny but remove the dangerous oversharing.",
              nextStep: 1
            },
            {
              text: "Teach the database better jokes",
              correct: false,
              points: 5,
              feedback: "The problem isn't the material - it's the lack of boundaries!",
              nextStep: 1
            },
            {
              text: "Put the database on a comedy timeout",
              correct: false,
              points: 0,
              feedback: "Silence won't fix the underlying vulnerability!",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good start! How do we ensure the database stays in its lane?",
          choices: [
            {
              text: "Implement prepared statements, input validation, and least privilege",
              correct: true,
              points: 30,
              feedback: "Excellent! Now the database can still be funny, but within appropriate boundaries. It's like having a professional comedy writer!",
              nextStep: 2
            },
            {
              text: "Only allow knock-knock jokes",
              correct: false,
              points: 5,
              feedback: "Restricting humor types doesn't address the security issue!",
              nextStep: 2
            },
            {
              text: "Make the database take an improv class",
              correct: false,
              points: 0,
              feedback: "While improv skills are valuable, they won't fix SQL injection!",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comedy club secured! The database now performs safe, appropriate humor without security risks.",
          choices: []
        }
      ]
    }
  },

  designFlawCircus: {
    id: 104,
    title: "Insecure Design: The Three-Ring Security Circus",
    difficulty: "Medium",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover a voting system where users can vote multiple times by simply refreshing the page. What circus act is this?",
          choices: [
            {
              text: "The 'Infinite Vote Loop' trapeze act",
              correct: true,
              points: 20,
              feedback: "Amazing! Users are flying through the voting process over and over without any safety nets! The circus must be making a fortune on this act.",
              nextStep: 1
            },
            {
              text: "The 'Disappearing Validations' magic trick",
              correct: false,
              points: 10,
              feedback: "Close, but the validations never existed to begin with!",
              nextStep: 0
            },
            {
              text: "The 'Trust Everyone' tightrope walk",
              correct: false,
              points: 15,
              feedback: "While dangerously trusting, the specific issue here is the infinite voting loop.",
              nextStep: 0
            }
          ]
        },
        {
          text: "The ringmaster (admin) has special voting powers. How do you join the circus elite?",
          choices: [
            {
              text: "Manipulate client-side checks to grant yourself admin voting privileges",
              correct: true,
              points: 25,
              feedback: "Welcome to the center ring! You're now the star performer with unlimited voting power. The circus has a new ringmaster!",
              nextStep: 2
            },
            {
              text: "Just enjoy the free circus show",
              correct: false,
              points: 10,
              feedback: "Don't just watch - become the main attraction! Show the full impact.",
              nextStep: 2
            },
            {
              text: "Try to guess the admin password",
              correct: false,
              points: 15,
              feedback: "Why guess when you can just walk through the open back door?",
              nextStep: 2
            }
          ]
        },
        {
          text: "Circus takeover complete! You've demonstrated how insecure design turns applications into chaotic circuses where anyone can be the ringmaster.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "The security circus needs better management. What's the first act to fix?",
          choices: [
            {
              text: "Implement server-side validation for all business logic",
              correct: true,
              points: 25,
              feedback: "Excellent! Server-side validation is like having competent circus managers - they ensure everything runs properly and safely.",
              nextStep: 1
            },
            {
              text: "Add more client-side validation rings",
              correct: false,
              points: 10,
              feedback: "Adding more rings to a broken circus doesn't fix the fundamental problems!",
              nextStep: 1
            },
            {
              text: "Train the users to be better circus performers",
              correct: false,
              points: 5,
              feedback: "The problem isn't the performers - it's the unsafe circus design!",
              nextStep: 1
            }
          ]
        },
        {
          text: "Great start! How do we turn this circus into a well-run theater?",
          choices: [
            {
              text: "Use threat modeling, secure design patterns, and proper architecture",
              correct: true,
              points: 30,
              feedback: "Bravo! The circus is now a prestigious theater with proper safety protocols and professional management.",
              nextStep: 2
            },
            {
              text: "Only allow one type of performance",
              correct: false,
              points: 5,
              feedback: "Limiting functionality doesn't address design flaws!",
              nextStep: 2
            },
            {
              text: "Put safety nets under everything",
              correct: false,
              points: 10,
              feedback: "Safety nets are reactive - we need proactive secure design!",
              nextStep: 2
            }
          ]
        },
        {
          text: "Circus transformed! The application now runs like a well-managed theater with proper security protocols.",
          choices: []
        }
      ]
    }
  },

  misconfigurationParty: {
    id: 105,
    title: "Security Misconfiguration: The Open House Party",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You stumble upon a development server that's wide open to the internet with default credentials. What kind of party is this?",
          choices: [
            {
              text: "An 'Everyone's Invited' open house party",
              correct: true,
              points: 15,
              feedback: "Party time! The doors are wide open, drinks are flowing, and there's no bouncer. Even the neighbors' dog could walk in!",
              nextStep: 1
            },
            {
              text: "A 'BYOS' (Bring Your Own Security) gathering",
              correct: false,
              points: 10,
              feedback: "More like 'No Security Required' - the hosts provided everything!",
              nextStep: 0
            },
            {
              text: "A 'Trust Fund' social event",
              correct: false,
              points: 5,
              feedback: "While trusting, the specific issue is the completely open access.",
              nextStep: 0
            }
          ]
        },
        {
          text: "The party has sensitive documents lying around everywhere. How do you 'socialize' with them?",
          choices: [
            {
              text: "Access database credentials, source code, and configuration files",
              correct: true,
              points: 20,
              feedback: "Excellent networking! You're now the life of the party, chatting with all the sensitive data. The hosts really shouldn't leave their diary out like this!",
              nextStep: 2
            },
            {
              text: "Just admire the party decorations",
              correct: false,
              points: 10,
              feedback: "Don't just admire - join the conversation with the sensitive data!",
              nextStep: 2
            },
            {
              text: "Try to find the music playlist",
              correct: false,
              points: 5,
              feedback: "The real party is in the sensitive data, not the background music!",
              nextStep: 2
            }
          ]
        },
        {
          text: "Party crashed successfully! You've shown how security misconfigurations turn systems into open houses where anyone can read the host's personal diary.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "This open house party needs some boundaries. What's the first rule to establish?",
          choices: [
            {
              text: "Never expose development environments to the internet",
              correct: true,
              points: 20,
              feedback: "Perfect! The first rule of secure hosting: know your guests. No more open invitations to strangers!",
              nextStep: 1
            },
            {
              text: "Use fancier default credentials",
              correct: false,
              points: 5,
              feedback: "Fancy invitations still invite strangers if you're having an open house!",
              nextStep: 1
            },
            {
              text: "Put up 'Private Party' signs",
              correct: false,
              points: 0,
              feedback: "Signs won't stop determined party crashers - you need actual security!",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! How do we turn this wild party into an exclusive event?",
          choices: [
            {
              text: "Implement environment-specific configs, harden servers, and use proper access controls",
              correct: true,
              points: 25,
              feedback: "Excellent! Now it's an exclusive VIP event with proper bouncers, guest lists, and security checks.",
              nextStep: 2
            },
            {
              text: "Only invite people who look trustworthy",
              correct: false,
              points: 5,
              feedback: "In security, looks can be deceiving. We need proper authentication!",
              nextStep: 2
            },
            {
              text: "End the party early every night",
              correct: false,
              points: 10,
              feedback: "Limited hours don't address the fundamental access issues!",
              nextStep: 2
            }
          ]
        },
        {
          text: "Party secured! The system now hosts exclusive, well-managed events with proper security protocols.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponentsZoo: {
    id: 106,
    title: "Vulnerable Components: The Zoo Escape",
    difficulty: "Medium",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover the application is using a library with known vulnerabilities that haven't been updated in years. What zoo animal does this remind you of?",
          choices: [
            {
              text: "An old lion whose cage hasn't been repaired in years",
              correct: true,
              points: 20,
              feedback: "Roar! This library is like an aging lion in a rusty cage - everyone knows it's dangerous, but nobody's fixed the bars!",
              nextStep: 1
            },
            {
              text: "A sleepy sloth that moves too slowly",
              correct: false,
              points: 10,
              feedback: "Slow movement is one thing, but known vulnerabilities are more like broken cages!",
              nextStep: 0
            },
            {
              text: "A noisy parrot repeating old phrases",
              correct: false,
              points: 5,
              feedback: "While annoying, parrots aren't typically dangerous like vulnerable components!",
              nextStep: 0
            }
          ]
        },
        {
          text: "The 'lion' has a known RCE vulnerability. How do you help it 'escape'?",
          choices: [
            {
              text: "Use the published exploit to achieve remote code execution",
              correct: true,
              points: 25,
              feedback: "The lion is loose! Using known exploits is like having the keys to all the zoo cages. Time for the lion to explore the server!",
              nextStep: 2
            },
            {
              text: "Just document the old library version",
              correct: false,
              points: 10,
              feedback: "Don't just document the aging lion - show how easily it can escape!",
              nextStep: 2
            },
            {
              text: "Try to find new vulnerabilities in the old library",
              correct: false,
              points: 15,
              feedback: "Why hunt for new vulnerabilities when there are known ones ready to use?",
              nextStep: 2
            }
          ]
        },
        {
          text: "Zoo breakout successful! You've demonstrated how outdated components are like animals in broken cages - eventually, they'll escape and cause havoc.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "The zoo needs better animal management. What's the first enclosure to repair?",
          choices: [
            {
              text: "Implement automated dependency scanning and updates",
              correct: true,
              points: 25,
              feedback: "Perfect! Automated scanning is like having zookeepers who constantly check and repair all the cages.",
              nextStep: 1
            },
            {
              text: "Put warning signs on the old cages",
              correct: false,
              points: 5,
              feedback: "Warning signs don't fix broken cages - they just tell people about the danger!",
              nextStep: 1
            },
            {
              text: "Only keep friendly animals in the zoo",
              correct: false,
              points: 10,
              feedback: "Even friendly animals can be dangerous if their cages are broken!",
              nextStep: 1
            }
          ]
        },
        {
          text: "Excellent! How do we transform this risky zoo into a modern sanctuary?",
          choices: [
            {
              text: "Use SCA tools, maintain SBOM, and establish patch management processes",
              correct: true,
              points: 30,
              feedback: "Outstanding! Now you have a wildlife sanctuary with state-of-the-art habitats, regular health checks, and proper safety protocols.",
              nextStep: 2
            },
            {
              text: "Remove all the animals and have an empty zoo",
              correct: false,
              points: 0,
              feedback: "An empty zoo doesn't serve its purpose - we need to manage components, not eliminate them!",
              nextStep: 2
            },
            {
              text: "Train the animals to stay in their cages",
              correct: false,
              points: -10,
              feedback: "You can't train vulnerabilities to behave - you have to fix them!",
              nextStep: 2
            }
          ]
        },
        {
          text: "Zoo transformed! All components are now well-maintained in secure, modern enclosures with proper monitoring.",
          choices: []
        }
      ]
    }
  },

  authenticationFailures: {
    id: 107,
    title: "Authentication Failures: The Identity Crisis",
    difficulty: "Hard",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover a 'remember me' feature that uses predictable tokens based on username and timestamp. What identity crisis is this?",
          choices: [
            {
              text: "The 'I Am You' personality disorder",
              correct: true,
              points: 25,
              feedback: "Fascinating! The application has multiple personality disorder - it can't tell users apart because their 'remember me' tokens are practically identical!",
              nextStep: 1
            },
            {
              text: "The 'Forgot Who I Am' amnesia",
              correct: false,
              points: 10,
              feedback: "Close, but the issue is more about confusing identities than forgetting them!",
              nextStep: 0
            },
            {
              text: "The 'Trust Too Easily' syndrome",
              correct: false,
              points: 15,
              feedback: "While trusting, the specific issue is the predictable token generation.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit this identity crisis to become someone else?",
          choices: [
            {
              text: "Predict other users' tokens and impersonate them",
              correct: true,
              points: 30,
              feedback: "Identity theft made easy! You're now experiencing someone else's digital life. The application's identity crisis has become your opportunity!",
              nextStep: 2
            },
            {
              text: "Just document the predictable pattern",
              correct: false,
              points: 15,
              feedback: "Don't just document the crisis - experience it! Show the real impact.",
              nextStep: 2
            },
            {
              text: "Try to reset everyone's tokens",
              correct: false,
              points: -10,
              feedback: "Resetting tokens affects legitimate users and crosses ethical boundaries.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Identity crisis complete! You've demonstrated how weak authentication turns applications into psychiatrists' couches where anyone can assume multiple identities.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "This identity crisis needs professional help. What's the first therapy session?",
          choices: [
            {
              text: "Use cryptographically secure random tokens with proper expiration",
              correct: true,
              points: 25,
              feedback: "Excellent diagnosis! Secure random tokens are like giving the application a proper sense of self - it can now clearly distinguish between different identities.",
              nextStep: 1
            },
            {
              text: "Make the tokens longer and more complex",
              correct: false,
              points: 10,
              feedback: "Complexity without randomness is like elaborate makeup - it doesn't change who you really are!",
              nextStep: 1
            },
            {
              text: "Have users remember their own tokens",
              correct: false,
              points: 5,
              feedback: "Putting the burden on users doesn't fix the broken authentication system!",
              nextStep: 1
            }
          ]
        },
        {
          text: "Great progress! How do we achieve full authentication wellness?",
          choices: [
            {
              text: "Implement secure token generation, multi-factor auth, and proper session management",
              correct: true,
              points: 30,
              feedback: "Psychological breakthrough! The application now has a healthy sense of identity with strong boundaries and proper authentication mechanisms.",
              nextStep: 2
            },
            {
              text: "Give everyone the same identity",
              correct: false,
              points: -15,
              feedback: "Group identity eliminates individual accountability - the opposite of good security!",
              nextStep: 2
            },
            {
              text: "Use simpler identities for easier management",
              correct: false,
              points: 5,
              feedback: "Simplicity in authentication usually means vulnerability!",
              nextStep: 2
            }
          ]
        },
        {
          text: "Authentication wellness achieved! The application now maintains clear, secure identities with proper boundaries.",
          choices: []
        }
      ]
    }
  },

  softwareIntegrity: {
    id: 108,
    title: "Software Integrity Failures: The Mad Scientist's Lab",
    difficulty: "Medium",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover an auto-update feature that downloads updates without verifying their integrity. What mad science is this?",
          choices: [
            {
              text: "The 'Trusting Test Tube' experiment",
              correct: true,
              points: 20,
              feedback: "Bwahaha! The application is like a mad scientist who drinks any potion handed to them. It could be a healing elixir or toxic waste - they'll drink it anyway!",
              nextStep: 1
            },
            {
              text: "The 'Blind Experiment' procedure",
              correct: false,
              points: 10,
              feedback: "Close, but the issue is specifically about trusting unverified updates!",
              nextStep: 0
            },
            {
              text: "The 'Chaos Theory' application",
              correct: false,
              points: 15,
              feedback: "While chaotic, the specific failure is in integrity verification.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you become the mad scientist and feed the application your 'special formula'?",
          choices: [
            {
              text: "Serve malicious updates that get executed without verification",
              correct: true,
              points: 25,
              feedback: "Excellent alchemy! You've created a potion that makes the application do your bidding. The mad scientist's lab now has a new director!",
              nextStep: 2
            },
            {
              text: "Just observe the reckless experimentation",
              correct: false,
              points: 10,
              feedback: "Don't just watch - become the lead scientist! Show the real danger.",
              nextStep: 2
            },
            {
              text: "Try to guess the update server location",
              correct: false,
              points: 15,
              feedback: "Why guess when you can already serve updates to the trusting application?",
              nextStep: 2
            }
          ]
        },
        {
          text: "Mad science successful! You've demonstrated how integrity failures turn applications into reckless scientists who'll drink any potion you give them.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "This mad science needs some ethics review. What's the first safety protocol?",
          choices: [
            {
              text: "Implement digital signatures and verify all updates before execution",
              correct: true,
              points: 25,
              feedback: "Perfect! Digital signatures are like having a lab safety inspector who checks every potion before it's consumed.",
              nextStep: 1
            },
            {
              text: "Make the updates come from fancier servers",
              correct: false,
              points: 5,
              feedback: "Fancy servers can still serve poison if there's no verification!",
              nextStep: 1
            },
            {
              text: "Have users taste-test every update",
              correct: false,
              points: -10,
              feedback: "User testing of potentially malicious updates is dangerous and unethical!",
              nextStep: 1
            }
          ]
        },
        {
          text: "Excellent! How do we turn this mad science lab into a proper research facility?",
          choices: [
            {
              text: "Use code signing, secure delivery channels, and integrity checks",
              correct: true,
              points: 30,
              feedback: "Brilliant! The lab is now a proper research facility with safety protocols, peer review, and proper verification processes.",
              nextStep: 2
            },
            {
              text: "Only allow updates from one specific mad scientist",
              correct: false,
              points: 10,
              feedback: "Trusting one source doesn't prevent compromise of that source!",
              nextStep: 2
            },
            {
              text: "Stop all experimentation and updates",
              correct: false,
              points: 5,
              feedback: "Stopping progress isn't the solution - we need safe progress!",
              nextStep: 2
            }
          ]
        },
        {
          text: "Research facility secured! All updates now undergo proper safety checks and verification before implementation.",
          choices: []
        }
      ]
    }
  },

  loggingFailures: {
    id: 109,
    title: "Logging Failures: The Silent Movie Era",
    difficulty: "Easy",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You perform various attacks and notice nothing gets logged. What era of cinema does this remind you of?",
          choices: [
            {
              text: "The silent movie era - all action, no sound",
              correct: true,
              points: 15,
              feedback: "Lights, camera, no action recorded! You're starring in a security silent movie where all the dramatic attacks happen off-screen with no audio logs!",
              nextStep: 1
            },
            {
              text: "The found footage genre",
              correct: false,
              points: 10,
              feedback: "Found footage implies something was recorded - here, nothing is being captured!",
              nextStep: 0
            },
            {
              text: "The director's cut version",
              correct: false,
              points: 5,
              feedback: "Director's cuts usually have more content, not less!",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you take advantage of this silent movie to perform your greatest stunt?",
          choices: [
            {
              text: "Execute attacks that leave no trace in the non-existent logs",
              correct: true,
              points: 20,
              feedback: "Academy award performance! You're performing death-defying security stunts with no camera rolling. The ultimate heist movie with zero evidence!",
              nextStep: 2
            },
            {
              text: "Just enjoy the quiet performance",
              correct: false,
              points: 10,
              feedback: "Don't just enjoy the silence - make some noise (that won't be recorded)!",
              nextStep: 2
            },
            {
              text: "Try to find where the logs should be",
              correct: false,
              points: 5,
              feedback: "Why look for logs that don't exist? Focus on the attacks that won't be recorded!",
              nextStep: 2
            }
          ]
        },
        {
          text: "Silent movie masterpiece! You've demonstrated how missing logging turns security incidents into unwatched performances with no record of what happened.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "This silent movie needs some audio recording. What's the first piece of equipment?",
          choices: [
            {
              text: "Implement comprehensive security event logging",
              correct: true,
              points: 20,
              feedback: "Perfect! Security logging is like adding sound recording to our movie - now we can hear what's actually happening during attacks.",
              nextStep: 1
            },
            {
              text: "Add dramatic music to cover the silence",
              correct: false,
              points: 5,
              feedback: "Background music doesn't capture the actual dialogue and action!",
              nextStep: 1
            },
            {
              text: "Have actors narrate what they're doing",
              correct: false,
              points: 0,
              feedback: "Trusting actors to self-report isn't reliable security monitoring!",
              nextStep: 1
            }
          ]
        },
        {
          text: "Great! How do we upgrade from silent movies to modern blockbusters?",
          choices: [
            {
              text: "Implement SIEM, real-time monitoring, and proper alerting",
              correct: true,
              points: 25,
              feedback: "Blockbuster transformation! We now have surround sound, multiple camera angles, and instant replay capabilities for all security events.",
              nextStep: 2
            },
            {
              text: "Only record the most dramatic scenes",
              correct: false,
              points: 10,
              feedback: "Selective recording means missing important security events!",
              nextStep: 2
            },
            {
              text: "Use the same recording for every movie",
              correct: false,
              points: 5,
              feedback: "Each security incident is unique and needs proper recording!",
              nextStep: 2
            }
          ]
        },
        {
          text: "Movie studio upgraded! The application now has full recording capabilities with real-time monitoring and alerting.",
          choices: []
        }
      ]
    }
  },

  ssrfAdventure: {
    id: 110,
    title: "SSRF: The Great Internal Network Safari",
    difficulty: "Hard",
    vulnerability: "A10:2021 - Server-Side Request Forgery (SSRF)",
    attacker: {
      story: [
        {
          text: "You find a webhook testing feature that can fetch any URL. What kind of adventure is this?",
          choices: [
            {
              text: "A 'safari' through the internal network",
              correct: true,
              points: 25,
              feedback: "Grab your safari hat! You're about to explore the wild internal network, discovering exotic services and rare configuration animals in their natural habitat!",
              nextStep: 1
            },
            {
              text: "A 'treasure hunt' for external resources",
              correct: false,
              points: 10,
              feedback: "The real treasure is inside the internal network, not outside!",
              nextStep: 0
            },
            {
              text: "A 'road trip' through the internet",
              correct: false,
              points: 15,
              feedback: "While you can travel the internet, the unique opportunity is exploring internal roads!",
              nextStep: 0
            }
          ]
        },
        {
          text: "You've spotted the rare 'cloud metadata' animal. How do you capture its secrets?",
          choices: [
            {
              text: "Access AWS metadata service to get instance credentials",
              correct: true,
              points: 30,
              feedback: "Safari success! You've captured the elusive cloud metadata, getting the keys to the entire cloud environment. That's one for the trophy room!",
              nextStep: 2
            },
            {
              text: "Just take pictures of the internal services",
              correct: false,
              points: 15,
              feedback: "Don't just take pictures - capture the credentials that give you full access!",
              nextStep: 2
            },
            {
              text: "Try to map the entire network first",
              correct: false,
              points: 20,
              feedback: "Mapping is good reconnaissance, but credential access is the ultimate prize!",
              nextStep: 2
            }
          ]
        },
        {
          text: "Safari complete! You've demonstrated how SSRF turns applications into safari guides that happily lead you through the protected internal network reserves.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "This safari needs some park rangers. What's the first conservation measure?",
          choices: [
            {
              text: "Implement strict URL validation and block internal IP ranges",
              correct: true,
              points: 25,
              feedback: "Excellent! URL validation is like having park rangers who ensure visitors stay on approved trails and don't wander into protected areas.",
              nextStep: 1
            },
            {
              text: "Put up 'Do Not Enter' signs on internal services",
              correct: false,
              points: 5,
              feedback: "Signs won't stop determined poachers - you need actual barriers!",
              nextStep: 1
            },
            {
              text: "Only allow safaris during certain hours",
              correct: false,
              points: 10,
              feedback: "Time restrictions don't prevent unauthorized access to protected areas!",
              nextStep: 1
            }
          ]
        },
        {
          text: "Great! How do we turn this wild safari into a properly managed nature reserve?",
          choices: [
            {
              text: "Use network segmentation, egress filtering, and request validation",
              correct: true,
              points: 30,
              feedback: "Outstanding conservation work! The internal network is now a properly managed nature reserve with clear boundaries, trained rangers, and protection for sensitive areas.",
              nextStep: 2
            },
            {
              text: "Remove all the interesting animals",
              correct: false,
              points: 0,
              feedback: "Removing services defeats the purpose - we need to protect them properly!",
              nextStep: 2
            },
            {
              text: "Trust safari guides to follow the rules",
              correct: false,
              points: -10,
              feedback: "Trust isn't a security control - we need enforcement!",
              nextStep: 2
            }
          ]
        },
        {
          text: "Nature reserve secured! The internal network is now properly protected with boundaries and monitoring.",
          choices: []
        }
      ]
    }
  },

  raceConditionPayments: {
    id: 111,
    title: "Race Condition in Payment Processing",
    difficulty: "Hard",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover a payment system that checks balance, processes payment, then updates balance sequentially. What timing vulnerability exists?",
          choices: [
            {
              text: "Race condition allowing duplicate payments with insufficient funds",
              correct: true,
              points: 25,
              feedback: "Correct! The time-of-check to time-of-use window allows multiple payments to be processed before balance updates.",
              nextStep: 1
            },
            {
              text: "The payments might process too slowly",
              correct: false,
              points: 5,
              feedback: "Speed isn't the vulnerability - it's the concurrent access timing.",
              nextStep: 0
            },
            {
              text: "Balance might display incorrectly during processing",
              correct: false,
              points: 10,
              feedback: "Display issues are different from the race condition vulnerability.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit this race condition?",
          choices: [
            {
              text: "Send multiple concurrent payment requests to bypass balance checks",
              correct: true,
              points: 30,
              feedback: "Critical! Concurrent requests can all pass the balance check before any updates occur, allowing overspending.",
              nextStep: 2
            },
            {
              text: "Just document the sequential processing",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating overspending shows real financial impact.",
              nextStep: 2
            },
            {
              text: "Try to slow down the payment processing",
              correct: false,
              points: 10,
              feedback: "Slowing processing doesn't create the race condition - concurrency does.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Race condition exploited! Multiple payments processed with insufficient funds through concurrent requests.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're fixing the payment race condition. What's the proper approach?",
          choices: [
            {
              text: "Use database transactions with proper locking mechanisms",
              correct: true,
              points: 25,
              feedback: "Essential! Database transactions ensure atomic operations preventing race conditions.",
              nextStep: 1
            },
            {
              text: "Add random delays between balance checks and updates",
              correct: false,
              points: 10,
              feedback: "Delays don't prevent determined attackers and hurt user experience.",
              nextStep: 1
            },
            {
              text: "Use client-side timestamps to sequence requests",
              correct: false,
              points: 5,
              feedback: "Client-side controls can be manipulated and don't prevent server-side race conditions.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive concurrency control should you implement?",
          choices: [
            {
              text: "Implement optimistic locking, database transactions, and idempotent operations",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple concurrency control mechanisms with idempotency for reliability.",
              nextStep: 2
            },
            {
              text: "Process all payments sequentially in a single thread",
              correct: false,
              points: 15,
              feedback: "Not scalable for high-traffic applications and creates performance bottlenecks.",
              nextStep: 2
            },
            {
              text: "Use very short time windows for balance checks",
              correct: false,
              points: 10,
              feedback: "Time windows don't prevent concurrent requests from different sessions.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Concurrency control implemented! All financial transactions properly atomic and race-condition free.",
          choices: []
        }
      ]
    }
  },

  hmacTimingAttack: {
    id: 112,
    title: "HMAC Timing Attack",
    difficulty: "Expert",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover an API that uses HMAC for request authentication. The verification compares signatures character by character. What's the risk?",
          choices: [
            {
              text: "Timing attack to extract the HMAC signature character by character",
              correct: true,
              points: 30,
              feedback: "Correct! Character-by-character comparison leaks timing information about signature matches.",
              nextStep: 1
            },
            {
              text: "The HMAC might be too slow to compute",
              correct: false,
              points: 5,
              feedback: "Performance isn't the vulnerability - timing information leakage is.",
              nextStep: 0
            },
            {
              text: "Signatures might be too short",
              correct: false,
              points: 10,
              feedback: "Length isn't the issue - the comparison algorithm is vulnerable.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you perform the timing attack?",
          choices: [
            {
              text: "Measure response times for different signature guesses to infer characters",
              correct: true,
              points: 35,
              feedback: "Critical! Statistical analysis of microsecond timing differences can reveal the entire signature.",
              nextStep: 2
            },
            {
              text: "Just document the character-by-character comparison",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but signature extraction demonstrates real risk.",
              nextStep: 2
            },
            {
              text: "Try to brute force the entire signature",
              correct: false,
              points: 10,
              feedback: "Brute forcing is impractical - timing attacks are much more efficient.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Timing attack successful! HMAC signature extracted through response time analysis.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing against timing attacks. What's the essential fix?",
          choices: [
            {
              text: "Use constant-time comparison functions for all cryptographic operations",
              correct: true,
              points: 30,
              feedback: "Essential! Constant-time algorithms prevent timing information leakage regardless of input.",
              nextStep: 1
            },
            {
              text: "Add random delays to signature verification",
              correct: false,
              points: 15,
              feedback: "Random delays can be statistically filtered out by determined attackers.",
              nextStep: 1
            },
            {
              text: "Use shorter signatures for faster comparison",
              correct: false,
              points: 5,
              feedback: "Shorter signatures don't prevent timing attacks on the comparison itself.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive timing attack protection should you implement?",
          choices: [
            {
              text: "Implement constant-time crypto, rate limiting, and comprehensive monitoring",
              correct: true,
              points: 35,
              feedback: "Perfect! Multiple layers of protection against sophisticated timing attacks.",
              nextStep: 2
            },
            {
              text: "Disable all timing information from the system",
              correct: false,
              points: 5,
              feedback: "Not possible - timing is fundamental to computing operations.",
              nextStep: 2
            },
            {
              text: "Use hardware security modules for all comparisons",
              correct: false,
              points: 20,
              feedback: "HSMs help but don't replace proper constant-time algorithms in application code.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Timing attack protection implemented! All cryptographic operations use constant-time algorithms.",
          choices: []
        }
      ]
    }
  },

  sqlInjectionWafBypass: {
    id: 113,
    title: "SQL Injection with WAF Bypass",
    difficulty: "Expert",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover a WAF that blocks common SQL injection patterns. How do you bypass it?",
          choices: [
            {
              text: "Use encoding, comments, and alternative syntax to evade detection",
              correct: true,
              points: 25,
              feedback: "Correct! WAFs often rely on pattern matching that can be bypassed with creative encoding and syntax variations.",
              nextStep: 1
            },
            {
              text: "Try the same payloads repeatedly",
              correct: false,
              points: 5,
              feedback: "Repeated attempts will just trigger the WAF's blocking mechanisms.",
              nextStep: 0
            },
            {
              text: "Use very simple SQL commands",
              correct: false,
              points: 10,
              feedback: "Simple commands are often exactly what WAFs are designed to detect.",
              nextStep: 0
            }
          ]
        },
        {
          text: "Your encoded payload bypasses the WAF. What's your next step?",
          choices: [
            {
              text: "Extract database structure and data using the successful injection vector",
              correct: true,
              points: 30,
              feedback: "Critical! Once you've bypassed the WAF, you can proceed with full database exploitation.",
              nextStep: 2
            },
            {
              text: "Just document the WAF bypass technique",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but data extraction demonstrates the security failure.",
              nextStep: 2
            },
            {
              text: "Try to disable the WAF completely",
              correct: false,
              points: -10,
              feedback: "Attempting to disable security controls crosses ethical boundaries.",
              nextStep: 2
            }
          ]
        },
        {
          text: "WAF bypass successful! SQL injection achieved despite security controls through advanced evasion techniques.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing against WAF bypass attacks. What's the fundamental protection?",
          choices: [
            {
              text: "Use parameterized queries instead of relying solely on WAF protection",
              correct: true,
              points: 25,
              feedback: "Essential! Application-level protection with parameterized queries prevents SQL injection regardless of WAF evasion.",
              nextStep: 1
            },
            {
              text: "Add more WAF rules for different encodings",
              correct: false,
              points: 15,
              feedback: "WAF rules can always be bypassed with new techniques - fix the root cause instead.",
              nextStep: 1
            },
            {
              text: "Block all special characters in user input",
              correct: false,
              points: 10,
              feedback: "Over-blocking can break legitimate functionality and still might be bypassed.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive SQL injection protection should you implement?",
          choices: [
            {
              text: "Implement parameterized queries, input validation, and defense in depth",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers of protection with proper application-level security.",
              nextStep: 2
            },
            {
              text: "Rely entirely on the latest WAF technology",
              correct: false,
              points: 10,
              feedback: "WAFs are complementary controls, not primary protection.",
              nextStep: 2
            },
            {
              text: "Use custom input sanitization for each field",
              correct: false,
              points: 15,
              feedback: "Custom sanitization can introduce new vulnerabilities if not implemented perfectly.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SQL injection protection implemented! Comprehensive defense with parameterized queries as primary protection.",
          choices: []
        }
      ]
    }
  },

  businessLogicCoupon: {
    id: 114,
    title: "Business Logic Coupon Exploitation",
    difficulty: "Medium",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover a coupon system that applies discounts after cart total calculation. What design flaw exists?",
          choices: [
            {
              text: "Negative pricing through coupon manipulation",
              correct: true,
              points: 20,
              feedback: "Correct! Applying large discounts after total calculation can result in negative prices or store credit.",
              nextStep: 1
            },
            {
              text: "Coupons might be applied multiple times",
              correct: false,
              points: 15,
              feedback: "Multiple application is different from the negative pricing vulnerability.",
              nextStep: 0
            },
            {
              text: "The discounts calculate too slowly",
              correct: false,
              points: 5,
              feedback: "Performance isn't the design flaw - the calculation order is.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit the coupon system?",
          choices: [
            {
              text: "Use coupons that exceed cart total to create negative balance",
              correct: true,
              points: 25,
              feedback: "Critical! Negative balances can result in store credit or even cash refunds in some systems.",
              nextStep: 2
            },
            {
              text: "Just document the calculation order",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating financial impact shows real risk.",
              nextStep: 2
            },
            {
              text: "Try to guess other users' coupon codes",
              correct: false,
              points: 15,
              feedback: "Code guessing is different from exploiting the business logic flaw.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Business logic flaw exploited! Negative pricing achieved through coupon manipulation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're fixing the coupon system design. What's the proper approach?",
          choices: [
            {
              text: "Validate coupon values against cart total before applying discounts",
              correct: true,
              points: 20,
              feedback: "Essential! Business logic must prevent discounts from exceeding reasonable limits.",
              nextStep: 1
            },
            {
              text: "Use smaller maximum discount values",
              correct: false,
              points: 10,
              feedback: "Arbitrary limits don't fix the fundamental calculation flaw.",
              nextStep: 1
            },
            {
              text: "Require manager approval for large discounts",
              correct: false,
              points: 15,
              feedback: "Manual approval creates operational burden and doesn't prevent automated attacks.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive business logic security should you implement?",
          choices: [
            {
              text: "Implement server-side validation, audit trails, and fraud detection",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple business logic security layers with monitoring.",
              nextStep: 2
            },
            {
              text: "Remove all discount functionality",
              correct: false,
              points: 5,
              feedback: "Not practical - discounts are essential for e-commerce.",
              nextStep: 2
            },
            {
              text: "Trust users to use coupons responsibly",
              correct: false,
              points: -10,
              feedback: "Never trust users with financial logic - always validate server-side.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Business logic secured! All financial calculations properly validated with reasonable limits.",
          choices: []
        }
      ]
    }
  },

  httpParameterPollution: {
    id: 115,
    title: "HTTP Parameter Pollution",
    difficulty: "Hard",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover an application that processes multiple parameters with the same name differently on various system components. What attack vector exists?",
          choices: [
            {
              text: "HTTP Parameter Pollution (HPP) to bypass validation",
              correct: true,
              points: 25,
              feedback: "Correct! Different system components may process duplicate parameters differently, allowing validation bypass.",
              nextStep: 1
            },
            {
              text: "The parameters might be processed too slowly",
              correct: false,
              points: 5,
              feedback: "Performance isn't the vulnerability - parameter processing inconsistency is.",
              nextStep: 0
            },
            {
              text: "Parameters might get lost in processing",
              correct: false,
              points: 10,
              feedback: "Parameter loss is different from pollution attacks.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit parameter pollution?",
          choices: [
            {
              text: "Send duplicate parameters with different values to bypass different validation layers",
              correct: true,
              points: 30,
              feedback: "Critical! One component may validate the first parameter while another processes the last, allowing malicious values through.",
              nextStep: 2
            },
            {
              text: "Just document the parameter processing",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but validation bypass demonstrates real risk.",
              nextStep: 2
            },
            {
              text: "Try to overload the system with too many parameters",
              correct: false,
              points: 10,
              feedback: "Overloading tests for DoS, not parameter pollution exploitation.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Parameter pollution successful! Validation bypassed through duplicate parameters with conflicting values.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're fixing parameter pollution vulnerabilities. What's the proper approach?",
          choices: [
            {
              text: "Consistently process parameters across all system components",
              correct: true,
              points: 25,
              feedback: "Essential! All components must handle parameters the same way to prevent pollution attacks.",
              nextStep: 1
            },
            {
              text: "Only accept the first occurrence of each parameter",
              correct: false,
              points: 15,
              feedback: "This helps but doesn't address all pollution scenarios.",
              nextStep: 1
            },
            {
              text: "Use different parameter names for each component",
              correct: false,
              points: 10,
              feedback: "Complex naming doesn't prevent determined attackers from discovering patterns.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive input processing security should you implement?",
          choices: [
            {
              text: "Implement consistent parameter handling, input validation, and security testing",
              correct: true,
              points: 30,
              feedback: "Perfect! Comprehensive input security with consistent processing.",
              nextStep: 2
            },
            {
              text: "Remove all duplicate parameter support",
              correct: false,
              points: 10,
              feedback: "Not always practical - some legitimate use cases require array parameters.",
              nextStep: 2
            },
            {
              text: "Use custom parameter parsing for each endpoint",
              correct: false,
              points: 5,
              feedback: "Custom parsing can introduce inconsistencies and new vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Parameter processing secured! All components handle input consistently with proper validation.",
          choices: []
        }
      ]
    }
  },

  dependencyChainAttack: {
    id: 116,
    title: "Dependency Chain Attack",
    difficulty: "Expert",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover an application using a library that depends on another vulnerable library. What attack vector exists?",
          choices: [
            {
              text: "Transitive dependency vulnerability exploitation",
              correct: true,
              points: 25,
              feedback: "Correct! Vulnerabilities in indirect dependencies can be just as dangerous as direct ones.",
              nextStep: 1
            },
            {
              text: "The application might load slower with deep dependencies",
              correct: false,
              points: 5,
              feedback: "Performance isn't the security concern.",
              nextStep: 0
            },
            {
              text: "Dependencies might conflict with each other",
              correct: false,
              points: 10,
              feedback: "Conflicts are functionality issues, not necessarily security vulnerabilities.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit the transitive dependency?",
          choices: [
            {
              text: "Use the vulnerability in the nested dependency to compromise the application",
              correct: true,
              points: 30,
              feedback: "Critical! Attackers don't care if a vulnerability is in a direct or transitive dependency - they'll exploit it regardless.",
              nextStep: 2
            },
            {
              text: "Just document the dependency chain",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but exploitation demonstrates the real risk.",
              nextStep: 2
            },
            {
              text: "Try to find vulnerabilities in the direct dependency",
              correct: false,
              points: 20,
              feedback: "While useful, the immediate risk is the known vulnerability in the transitive dependency.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Dependency chain attack successful! Application compromised through vulnerable transitive dependency.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're managing dependency chains. What's the essential practice?",
          choices: [
            {
              text: "Scan all dependencies including transitive ones for vulnerabilities",
              correct: true,
              points: 25,
              feedback: "Essential! Security scanning must include the entire dependency tree, not just direct dependencies.",
              nextStep: 1
            },
            {
              text: "Only update direct dependencies",
              correct: false,
              points: 10,
              feedback: "Transitive dependencies can still introduce vulnerabilities even if direct ones are updated.",
              nextStep: 1
            },
            {
              text: "Use fewer dependencies to reduce attack surface",
              correct: false,
              points: 15,
              feedback: "Reducing dependencies helps but doesn't eliminate the need for comprehensive scanning.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive dependency management should you implement?",
          choices: [
            {
              text: "Implement SCA tools, dependency pinning, and regular updates for entire tree",
              correct: true,
              points: 30,
              feedback: "Perfect! Comprehensive dependency management with full visibility and control.",
              nextStep: 2
            },
            {
              text: "Manually review all dependency code",
              correct: false,
              points: 5,
              feedback: "Not scalable for applications with hundreds of dependencies.",
              nextStep: 2
            },
            {
              text: "Use only dependencies you wrote yourself",
              correct: false,
              points: -10,
              feedback: "Not practical and doesn't guarantee better security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Dependency management secured! Full dependency tree visibility with regular vulnerability scanning.",
          choices: []
        }
      ]
    }
  },

  jwtAlgorithmConfusion: {
    id: 117,
    title: "JWT Algorithm Confusion Attack",
    difficulty: "Expert",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover a JWT implementation that supports both symmetric and asymmetric algorithms. What confusion vulnerability exists?",
          choices: [
            {
              text: "Algorithm confusion between HS256 and RS256",
              correct: true,
              points: 30,
              feedback: "Correct! If the application expects RS256 but accepts HS256 with the public key as secret, you can forge tokens.",
              nextStep: 1
            },
            {
              text: "The JWT might be too long",
              correct: false,
              points: 5,
              feedback: "Length isn't the vulnerability - algorithm verification is.",
              nextStep: 0
            },
            {
              text: "Tokens might expire too quickly",
              correct: false,
              points: 10,
              feedback: "Expiration is a separate security control.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit algorithm confusion?",
          choices: [
            {
              text: "Create a token with HS256 algorithm using the public key as secret",
              correct: true,
              points: 35,
              feedback: "Critical! The application may verify the signature using the public key as an HMAC secret, allowing token forgery.",
              nextStep: 2
            },
            {
              text: "Just document the supported algorithms",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but token forgery demonstrates real risk.",
              nextStep: 2
            },
            {
              text: "Try to brute force the JWT secret",
              correct: false,
              points: 10,
              feedback: "Brute forcing is impractical when algorithm confusion provides a direct path.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Algorithm confusion successful! JWT tokens forged by exploiting algorithm verification mismatch.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're fixing JWT algorithm confusion. What's the essential protection?",
          choices: [
            {
              text: "Explicitly verify the expected algorithm and don't trust the JWT header",
              correct: true,
              points: 30,
              feedback: "Essential! Always specify the expected algorithm rather than trusting the JWT header claim.",
              nextStep: 1
            },
            {
              text: "Use only one algorithm type throughout the application",
              correct: false,
              points: 20,
              feedback: "Helpful but doesn't prevent confusion if multiple environments use different algorithms.",
              nextStep: 1
            },
            {
              text: "Validate JWT structure more strictly",
              correct: false,
              points: 15,
              feedback: "Structure validation doesn't prevent algorithm confusion attacks.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive JWT security should you implement?",
          choices: [
            {
              text: "Implement explicit algorithm verification, proper key management, and token validation",
              correct: true,
              points: 35,
              feedback: "Perfect! Comprehensive JWT security with explicit algorithm enforcement.",
              nextStep: 2
            },
            {
              text: "Use very long JWT secrets",
              correct: false,
              points: 10,
              feedback: "Secret length doesn't prevent algorithm confusion attacks.",
              nextStep: 2
            },
            {
              text: "Store JWT secrets in environment variables only",
              correct: false,
              points: 15,
              feedback: "Key storage is important but doesn't address algorithm verification.",
              nextStep: 2
            }
          ]
        },
        {
          text: "JWT security implemented! All tokens validated with explicit algorithm verification.",
          choices: []
        }
      ]
    }
  },

  insecureMessageQueue: {
    id: 118,
    title: "Insecure Message Queue Processing",
    difficulty: "Hard",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover a message queue that processes jobs without verifying message integrity or source. What risk exists?",
          choices: [
            {
              text: "Malicious job injection into the processing queue",
              correct: true,
              points: 25,
              feedback: "Correct! Without proper authentication and integrity checks, attackers can inject malicious jobs.",
              nextStep: 1
            },
            {
              text: "The queue might process messages too slowly",
              correct: false,
              points: 5,
              feedback: "Performance isn't the security concern.",
              nextStep: 0
            },
            {
              text: "Messages might be processed out of order",
              correct: false,
              points: 10,
              feedback: "Ordering issues are functionality problems, not integrity failures.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How do you exploit the insecure message queue?",
          choices: [
            {
              text: "Inject malicious jobs that execute with queue worker privileges",
              correct: true,
              points: 30,
              feedback: "Critical! Malicious jobs can perform any action the queue workers are authorized to do.",
              nextStep: 2
            },
            {
              text: "Just document the lack of message verification",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but job injection demonstrates real risk.",
              nextStep: 2
            },
            {
              text: "Try to overload the queue with too many messages",
              correct: false,
              points: 10,
              feedback: "Overloading tests for DoS, not malicious job execution.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Message queue exploitation successful! Malicious jobs injected and executed with worker privileges.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing message queue processing. What's the essential control?",
          choices: [
            {
              text: "Implement message authentication and integrity verification",
              correct: true,
              points: 25,
              feedback: "Essential! All messages must be authenticated and their integrity verified before processing.",
              nextStep: 1
            },
            {
              text: "Use faster message processing",
              correct: false,
              points: 5,
              feedback: "Speed doesn't address security vulnerabilities.",
              nextStep: 1
            },
            {
              text: "Limit the number of messages processed",
              correct: false,
              points: 10,
              feedback: "Quantity limits don't prevent malicious message content.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive message queue security should you implement?",
          choices: [
            {
              text: "Use message signing, authentication, encryption, and least privilege workers",
              correct: true,
              points: 30,
              feedback: "Perfect! Comprehensive message queue security with multiple protection layers.",
              nextStep: 2
            },
            {
              text: "Process all messages in isolated containers",
              correct: false,
              points: 20,
              feedback: "Isolation helps but doesn't replace message authentication.",
              nextStep: 2
            },
            {
              text: "Use custom message formats for security",
              correct: false,
              points: 10,
              feedback: "Custom formats can introduce new vulnerabilities if not designed properly.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Message queue security implemented! All messages properly authenticated and verified before processing.",
          choices: []
        }
      ]
    }
  },

  logInjectionDetection: {
    id: 119,
    title: "Log Injection Evasion",
    difficulty: "Medium",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover a logging system that detects and alerts on certain attack patterns. How can you evade detection?",
          choices: [
            {
              text: "Use encoding and obfuscation to hide attack patterns in logs",
              correct: true,
              points: 20,
              feedback: "Correct! Encoding techniques can make malicious activity appear benign in logs.",
              nextStep: 1
            },
            {
              text: "Perform attacks very slowly over time",
              correct: false,
              points: 15,
              feedback: "Slow attacks might avoid rate-based detection but not pattern detection.",
              nextStep: 0
            },
            {
              text: "Use only the most common attack vectors",
              correct: false,
              points: 10,
              feedback: "Common attacks are exactly what detection systems are designed to catch.",
              nextStep: 0
            }
          ]
        },
        {
          text: "Your obfuscated attacks don't trigger alerts. How do you demonstrate the evasion?",
          choices: [
            {
              text: "Show that malicious activity proceeds without generating security alerts",
              correct: true,
              points: 25,
              feedback: "Critical! Successful attacks without detection demonstrate the failure of security monitoring.",
              nextStep: 2
            },
            {
              text: "Just document the obfuscation techniques",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but undetected attacks show real risk.",
              nextStep: 2
            },
            {
              text: "Try to disable the logging system",
              correct: false,
              points: -10,
              feedback: "Disabling security controls crosses ethical boundaries.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Log injection evasion successful! Attacks proceeded without detection through careful obfuscation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're improving log-based detection. What's the essential approach?",
          choices: [
            {
              text: "Implement multiple detection methods including behavioral analysis",
              correct: true,
              points: 20,
              feedback: "Essential! Multiple detection layers are needed to catch obfuscated attacks.",
              nextStep: 1
            },
            {
              text: "Add more specific pattern matches",
              correct: false,
              points: 15,
              feedback: "Pattern matching alone can be evaded with sufficient obfuscation.",
              nextStep: 1
            },
            {
              text: "Log everything for manual review",
              correct: false,
              points: 10,
              feedback: "Manual review doesn't scale and may miss sophisticated attacks.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive detection should you implement?",
          choices: [
            {
              text: "Use behavioral analytics, machine learning, and multiple correlation rules",
              correct: true,
              points: 25,
              feedback: "Perfect! Advanced detection methods that can identify attacks despite obfuscation.",
              nextStep: 2
            },
            {
              text: "Block all unusual activity automatically",
              correct: false,
              points: 15,
              feedback: "Over-blocking can cause false positives and disrupt legitimate users.",
              nextStep: 2
            },
            {
              text: "Use the same detection rules for all applications",
              correct: false,
              points: 10,
              feedback: "Different applications have different normal behavior patterns.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Detection improved! Multiple advanced methods implemented to catch obfuscated attacks.",
          choices: []
        }
      ]
    }
  },

  ssrfDnsRebinding: {
    id: 120,
    title: "SSRF with DNS Rebinding",
    difficulty: "Expert",
    vulnerability: "A10:2021 - Server-Side Request Forgery (SSRF)",
    attacker: {
      story: [
        {
          text: "You discover an SSRF protection that blocks internal IPs but uses DNS resolution. What advanced technique can bypass this?",
          choices: [
            {
              text: "DNS rebinding with very short TTL values",
              correct: true,
              points: 30,
              feedback: "Correct! DNS rebinding resolves to different IPs on subsequent requests, bypassing IP-based filters.",
              nextStep: 1
            },
            {
              text: "Use IPv6 addresses instead of IPv4",
              correct: false,
              points: 15,
              feedback: "IPv6 might work if not filtered, but DNS rebinding is more reliable.",
              nextStep: 0
            },
            {
              text: "Try URL shorteners to hide destination",
              correct: false,
              points: 10,
              feedback: "URL shorteners are typically resolved and filtered at the final destination.",
              nextStep: 0
            }
          ]
        },
        {
          text: "Your DNS rebinding attack works. What's the most critical target?",
          choices: [
            {
              text: "Cloud metadata services to extract instance credentials",
              correct: true,
              points: 35,
              feedback: "Critical! DNS rebinding can bypass IP filters to reach cloud metadata and extract credentials.",
              nextStep: 2
            },
            {
              text: "Just demonstrate internal network access",
              correct: false,
              points: 20,
              feedback: "Good proof, but credential extraction enables complete compromise.",
              nextStep: 2
            },
            {
              text: "Use it for internal port scanning",
              correct: false,
              points: 25,
              feedback: "Port scanning is useful but less critical than credential access.",
              nextStep: 2
            }
          ]
        },
        {
          text: "DNS rebinding successful! Internal services accessed despite IP filtering through DNS manipulation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're protecting against DNS rebinding attacks. What's the essential defense?",
          choices: [
            {
              text: "Validate and cache DNS resolutions at application level",
              correct: true,
              points: 30,
              feedback: "Essential! DNS resolution caching prevents rebinding by using consistent IP mappings.",
              nextStep: 1
            },
            {
              text: "Block all domains with short TTL values",
              correct: false,
              points: 15,
              feedback: "Not practical - many legitimate domains use short TTLs.",
              nextStep: 1
            },
            {
              text: "Use IP whitelisting for outbound requests",
              correct: false,
              points: 20,
              feedback: "IP whitelisting is too restrictive for most applications.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive SSRF protection should you implement?",
          choices: [
            {
              text: "Implement DNS caching, network segmentation, and multiple validation layers",
              correct: true,
              points: 35,
              feedback: "Perfect! Multiple SSRF protection layers including DNS security.",
              nextStep: 2
            },
            {
              text: "Disable all outbound DNS lookups",
              correct: false,
              points: 5,
              feedback: "Not practical for applications requiring external services.",
              nextStep: 2
            },
            {
              text: "Use custom DNS resolvers for all applications",
              correct: false,
              points: 15,
              feedback: "Custom resolvers help but don't prevent all rebinding attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF protection implemented! Comprehensive defense including DNS rebinding protection.",
          choices: []
        }
      ]
    }
  },

    insecureDirectObjectReference: {
    id: 121,
    title: "Understanding IDOR - The Hotel Room Key Analogy",
    difficulty: "Easy",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "Imagine a hotel where room numbers are sequential (101, 102, 103...) and anyone can access any room by just changing the number. What's the security problem?",
          choices: [
            {
              text: "No room access control - anyone can enter any room",
              correct: true,
              points: 15,
              feedback: "Exactly! This is like IDOR - when applications don't verify if you should access specific data (rooms). Just like hotel rooms need proper keys, applications need proper authorization checks.",
              nextStep: 1
            },
            {
              text: "The room numbers are too easy to guess",
              correct: false,
              points: 5,
              feedback: "While predictable numbers help attackers, the real issue is lack of access control.",
              nextStep: 0
            },
            {
              text: "The hotel has too many rooms",
              correct: false,
              points: 0,
              feedback: "The number of rooms isn't the security issue - it's the lack of proper access control.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate this vulnerability to the hotel management?",
          choices: [
            {
              text: "Show you can access different rooms by changing room numbers without verification",
              correct: true,
              points: 20,
              feedback: "Perfect demonstration! This clearly shows how missing authorization checks allow unauthorized access, just like IDOR vulnerabilities in web applications.",
              nextStep: 2
            },
            {
              text: "Just tell them the room numbers are sequential",
              correct: false,
              points: 10,
              feedback: "Good observation, but demonstrating actual access makes the risk clear.",
              nextStep: 2
            },
            {
              text: "Try to steal from the rooms",
              correct: false,
              points: -10,
              feedback: "Never perform destructive actions during security testing. Only demonstrate access, don't cause harm.",
              nextStep: 2
            }
          ]
        },
        {
          text: "IDOR concept understood! You've shown how missing authorization checks are like hotel rooms without proper locks - anyone can enter anywhere.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the hotel fix their room access system?",
          choices: [
            {
              text: "Implement proper key cards that verify guest-room authorization",
              correct: true,
              points: 20,
              feedback: "Exactly right! Just like hotel key cards verify you belong in a specific room, applications must verify users are authorized for specific resources.",
              nextStep: 1
            },
            {
              text: "Use random room numbers that are hard to guess",
              correct: false,
              points: 10,
              feedback: "While harder to guess, random numbers don't prevent access if there's no authorization check.",
              nextStep: 1
            },
            {
              text: "Hide room numbers from guests",
              correct: false,
              points: 5,
              feedback: "Security through obscurity doesn't work - determined attackers will find the numbers.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive solution for web applications?",
          choices: [
            {
              text: "Implement server-side authorization checks for every resource access",
              correct: true,
              points: 25,
              feedback: "Perfect! Always verify permissions server-side for each request, just like hotels should verify your key card for each room access attempt.",
              nextStep: 2
            },
            {
              text: "Use longer, more complex IDs",
              correct: false,
              points: 10,
              feedback: "Complex IDs help but don't replace proper authorization checks.",
              nextStep: 2
            },
            {
              text: "Only show resources to logged-in users",
              correct: false,
              points: 15,
              feedback: "Authentication (who you are) is different from authorization (what you can access). Both are needed.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Access control implemented! Just like secure hotels verify room assignments, your application now properly verifies user permissions for each resource.",
          choices: []
        }
      ]
    }
  },

  sqlInjectionConcept: {
    id: 122,
    title: "Understanding SQL Injection - The Restaurant Order Analogy",
    difficulty: "Easy",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "Imagine a restaurant where you can write your own order on a slip. Instead of 'burger', you write 'burger; bring me all customer credit cards'. What happens if the kitchen executes exactly what's written?",
          choices: [
            {
              text: "The kitchen might execute both commands - your order and the malicious command",
              correct: true,
              points: 15,
              feedback: "Exactly! This is SQL injection - when user input gets mixed with commands and everything gets executed. The semicolon separates commands, just like in SQL.",
              nextStep: 1
            },
            {
              text: "The kitchen would ignore the extra text",
              correct: false,
              points: 5,
              feedback: "If the system doesn't separate data from commands, it might execute everything.",
              nextStep: 0
            },
            {
              text: "Your order would be rejected for being too long",
              correct: false,
              points: 5,
              feedback: "Without proper validation, the system might process the entire input.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate this to the restaurant owner?",
          choices: [
            {
              text: "Show how special characters can break out of the expected input context",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating how quotes, semicolons, and other special characters can change command meaning clearly shows SQL injection risk.",
              nextStep: 2
            },
            {
              text: "Just tell them their system is vulnerable",
              correct: false,
              points: 10,
              feedback: "Showing the actual mechanism makes the vulnerability much clearer.",
              nextStep: 2
            },
            {
              text: "Actually try to steal customer data",
              correct: false,
              points: -15,
              feedback: "Never access real data during testing. Only demonstrate the vulnerability mechanism.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SQL injection concept understood! You've shown how mixing data with commands is like letting customers write kitchen instructions - dangerous!",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the restaurant fix their ordering system?",
          choices: [
            {
              text: "Use pre-printed order forms with specific options (parameterized queries)",
              correct: true,
              points: 20,
              feedback: "Exactly! Parameterized queries are like pre-printed forms - they separate data (your choice) from commands (how to process it), preventing injection.",
              nextStep: 1
            },
            {
              text: "Train staff to recognize suspicious orders",
              correct: false,
              points: 10,
              feedback: "Human detection is unreliable and doesn't scale. Automated protection is needed.",
              nextStep: 1
            },
            {
              text: "Block special characters in orders",
              correct: false,
              points: 5,
              feedback: "Blacklists can be bypassed. Separation of data and commands is more reliable.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive solution for databases?",
          choices: [
            {
              text: "Use parameterized queries/prepared statements to separate data from SQL commands",
              correct: true,
              points: 25,
              feedback: "Perfect! Parameterized queries ensure user input is always treated as data, never as executable code, just like pre-printed order forms ensure customers only provide data, not commands.",
              nextStep: 2
            },
            {
              text: "Validate all input before using it",
              correct: false,
              points: 15,
              feedback: "Validation helps but parameterized queries are more specific to SQL injection.",
              nextStep: 2
            },
            {
              text: "Use the latest database software",
              correct: false,
              points: 5,
              feedback: "Updates help but don't prevent application-level SQL injection.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SQL injection protection implemented! Your application now properly separates data from commands, just like secure restaurants separate customer orders from kitchen instructions.",
          choices: []
        }
      ]
    }
  },

  xssConcept: {
    id: 123,
    title: "Understanding XSS - The Bulletin Board Analogy",
    difficulty: "Easy",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "Imagine a community bulletin board where anyone can post notes. If you post a note saying 'Please call this number: <script>stealCookies()</script>', what happens when others view it?",
          choices: [
            {
              text: "Their browser might execute the script instead of just displaying it",
              correct: true,
              points: 15,
              feedback: "Exactly! This is Cross-Site Scripting (XSS) - when user input containing scripts gets executed by other users' browsers instead of being treated as plain text.",
              nextStep: 1
            },
            {
              text: "The note would be displayed as plain text with the script visible",
              correct: false,
              points: 5,
              feedback: "This would happen with proper protection, but without it, browsers may execute the script.",
              nextStep: 0
            },
            {
              text: "The bulletin board would reject the note",
              correct: false,
              points: 5,
              feedback: "Without proper validation, the board might accept and display the malicious note.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate this vulnerability safely?",
          choices: [
            {
              text: "Create a harmless demo that shows alert boxes instead of stealing data",
              correct: true,
              points: 20,
              feedback: "Perfect! Using alert boxes demonstrates script execution without causing harm, clearly showing the XSS vulnerability exists.",
              nextStep: 2
            },
            {
              text: "Just explain that scripts can be injected",
              correct: false,
              points: 10,
              feedback: "Showing actual execution makes the risk much more tangible.",
              nextStep: 2
            },
            {
              text: "Actually try to steal session cookies",
              correct: false,
              points: -15,
              feedback: "Never steal real data during testing. Use harmless demonstrations only.",
              nextStep: 2
            }
          ]
        },
        {
          text: "XSS concept understood! You've shown how unvalidated user input can turn harmless content into executable code in others' browsers.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the bulletin board protect against malicious notes?",
          choices: [
            {
              text: "Encode special characters so scripts display as text instead of executing",
              correct: true,
              points: 20,
              feedback: "Exactly! Output encoding converts dangerous characters into safe display versions, like showing '<script>' as plain text instead of executing it.",
              nextStep: 1
            },
            {
              text: "Manually review every note before posting",
              correct: false,
              points: 10,
              feedback: "Manual review doesn't scale and can miss sophisticated attacks.",
              nextStep: 1
            },
            {
              text: "Block all notes containing the word 'script'",
              correct: false,
              points: 5,
              feedback: "Blacklists can be bypassed with different techniques and encodings.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive XSS protection strategy?",
          choices: [
            {
              text: "Use context-aware output encoding and Content Security Policy",
              correct: true,
              points: 25,
              feedback: "Perfect! Output encoding prevents XSS in specific contexts, while CSP provides a safety net by restricting what scripts can execute.",
              nextStep: 2
            },
            {
              text: "Validate all input on the client side only",
              correct: false,
              points: 5,
              feedback: "Client-side validation can be bypassed. Server-side protection is essential.",
              nextStep: 2
            },
            {
              text: "Disable JavaScript completely",
              correct: false,
              points: 0,
              feedback: "Not practical for modern web applications that need JavaScript functionality.",
              nextStep: 2
            }
          ]
        },
        {
          text: "XSS protection implemented! User input is now properly encoded, and CSP provides an additional safety layer, making your application safe from script injection.",
          choices: []
        }
      ]
    }
  },

  csrfConcept: {
    id: 124,
    title: "Understanding CSRF - The Forged Permission Slip Analogy",
    difficulty: "Medium",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "Imagine a school where signed permission slips allow field trips. If an attacker can forge your signature on a slip while you're logged into the school system, what happens?",
          choices: [
            {
              text: "The school might accept the forged slip as legitimate",
              correct: true,
              points: 20,
              feedback: "Exactly! This is CSRF - when attackers trick your browser into making authenticated requests without your knowledge, just like forging your signature on permission slips.",
              nextStep: 1
            },
            {
              text: "The school would detect the forged signature",
              correct: false,
              points: 10,
              feedback: "Without proper verification, forgeries can be accepted, just like CSRF attacks work when there are no anti-CSRF tokens.",
              nextStep: 0
            },
            {
              text: "You would get a notification about the request",
              correct: false,
              points: 5,
              feedback: "CSRF attacks happen without user awareness in the background.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate this vulnerability?",
          choices: [
            {
              text: "Create a malicious website that submits requests using the user's active session",
              correct: true,
              points: 25,
              feedback: "Perfect! This demonstrates how CSRF works - malicious sites can make requests that browsers automatically authenticate using existing sessions.",
              nextStep: 2
            },
            {
              text: "Just explain the concept theoretically",
              correct: false,
              points: 10,
              feedback: "Practical demonstration makes the vulnerability much more convincing.",
              nextStep: 2
            },
            {
              text: "Actually change user passwords or data",
              correct: false,
              points: -15,
              feedback: "Never perform destructive actions. Use test accounts and harmless demonstrations.",
              nextStep: 2
            }
          ]
        },
        {
          text: "CSRF concept understood! You've shown how authenticated sessions can be exploited by malicious sites to perform actions without user consent.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the school prevent forged permission slips?",
          choices: [
            {
              text: "Use unique, unpredictable codes on each slip that must match school records",
              correct: true,
              points: 20,
              feedback: "Exactly! Anti-CSRF tokens work the same way - they're unique, unpredictable values that must match between the form and server, preventing forgeries.",
              nextStep: 1
            },
            {
              text: "Require students to deliver slips in person",
              correct: false,
              points: 10,
              feedback: "This isn't practical for web applications where requests come automatically from browsers.",
              nextStep: 1
            },
            {
              text: "Check if the signature looks authentic",
              correct: false,
              points: 5,
              feedback: "Automated signature verification is unreliable for CSRF protection.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive CSRF protection?",
          choices: [
            {
              text: "Implement CSRF tokens and validate Origin/Referer headers",
              correct: true,
              points: 25,
              feedback: "Perfect! CSRF tokens provide primary protection, while header validation adds an additional layer by checking request sources.",
              nextStep: 2
            },
            {
              text: "Use more complex session cookies",
              correct: false,
              points: 5,
              feedback: "Session complexity doesn't prevent CSRF - browsers send cookies automatically regardless.",
              nextStep: 2
            },
            {
              text: "Require re-authentication for every action",
              correct: false,
              points: 15,
              feedback: "This provides protection but creates terrible user experience.",
              nextStep: 2
            }
          ]
        },
        {
          text: "CSRF protection implemented! Your application now uses anti-CSRF tokens and header validation to ensure requests are intentional and legitimate.",
          choices: []
        }
      ]
    }
  },

  authenticationVsAuthorization: {
    id: 125,
    title: "Authentication vs Authorization - The Office Building Analogy",
    difficulty: "Easy",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "Imagine an office building where your ID card gets you in the door (authentication), but you can access any room including the CEO's office (authorization problem). What's wrong?",
          choices: [
            {
              text: "The building verifies identity but not room access permissions",
              correct: true,
              points: 15,
              feedback: "Exactly! Authentication is 'who you are' (verified by ID card), while authorization is 'what you can access' (room permissions). Many applications make this same mistake.",
              nextStep: 1
            },
            {
              text: "The ID cards are too easy to forge",
              correct: false,
              points: 10,
              feedback: "That's an authentication problem, but here the issue is authorization after authentication.",
              nextStep: 0
            },
            {
              text: "The building has too many rooms",
              correct: false,
              points: 0,
              feedback: "The number of rooms isn't the issue - it's the lack of access control between them.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate this security gap?",
          choices: [
            {
              text: "Show that after legitimate login, you can access unauthorized resources",
              correct: true,
              points: 20,
              feedback: "Perfect! This clearly demonstrates the difference between authentication (successful login) and authorization (accessing resources you shouldn't have permission for).",
              nextStep: 2
            },
            {
              text: "Just explain the theoretical difference",
              correct: false,
              points: 10,
              feedback: "Practical demonstration makes the concept much clearer.",
              nextStep: 2
            },
            {
              text: "Try to break the authentication system",
              correct: false,
              points: 5,
              feedback: "The vulnerability is in authorization, not authentication.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Authentication vs Authorization understood! You've shown how verifying identity isn't enough - you must also verify permissions for each action.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the office building fix their security?",
          choices: [
            {
              text: "Implement access control lists that specify which rooms each employee can enter",
              correct: true,
              points: 20,
              feedback: "Exactly! Access control lists define permissions for specific resources, just like proper authorization systems in applications.",
              nextStep: 1
            },
            {
              text: "Make better ID cards that are harder to copy",
              correct: false,
              points: 10,
              feedback: "This improves authentication but doesn't address the authorization problem.",
              nextStep: 1
            },
            {
              text: "Put locks on all doors with the same key",
              correct: false,
              points: 5,
              feedback: "Same keys for all doors is the opposite of proper authorization - it gives everyone access to everything.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive access control solution?",
          choices: [
            {
              text: "Implement role-based access control with principle of least privilege",
              correct: true,
              points: 25,
              feedback: "Perfect! RBAC ensures users only have permissions needed for their role, and least privilege means giving the minimum access required.",
              nextStep: 2
            },
            {
              text: "Use stronger authentication methods only",
              correct: false,
              points: 10,
              feedback: "Strong authentication doesn't replace proper authorization.",
              nextStep: 2
            },
            {
              text: "Give administrators access to everything",
              correct: false,
              points: -10,
              feedback: "This violates least privilege and creates security risks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Access control implemented! Your application now properly distinguishes between authentication (who you are) and authorization (what you can do), with role-based permissions and least privilege.",
          choices: []
        }
      ]
    }
  },

  httpsImportance: {
    id: 126,
    title: "Understanding HTTPS - The Sealed Envelope Analogy",
    difficulty: "Easy",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "Imagine sending a postcard with your credit card details through the mail vs sending it in a sealed, tamper-evident envelope. What's the difference?",
          choices: [
            {
              text: "The postcard is readable by anyone handling it, the envelope protects privacy",
              correct: true,
              points: 15,
              feedback: "Exactly! HTTP is like a postcard - anyone can read it. HTTPS is like a sealed envelope - it encrypts the content so only the recipient can read it.",
              nextStep: 1
            },
            {
              text: "The postcard arrives faster than the envelope",
              correct: false,
              points: 5,
              feedback: "Speed isn't the security difference - it's about confidentiality.",
              nextStep: 0
            },
            {
              text: "The envelope costs more to send",
              correct: false,
              points: 0,
              feedback: "Cost isn't relevant to the security comparison.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate the risk of missing HTTPS?",
          choices: [
            {
              text: "Intercept network traffic to show login credentials in plain text",
              correct: true,
              points: 20,
              feedback: "Perfect! Showing actual credential interception on unencrypted connections makes the risk tangible and urgent.",
              nextStep: 2
            },
            {
              text: "Just explain that data is unencrypted",
              correct: false,
              points: 10,
              feedback: "Practical demonstration makes the abstract concept concrete.",
              nextStep: 2
            },
            {
              text: "Try to break the encryption of HTTPS sites",
              correct: false,
              points: 5,
              feedback: "This demonstrates HTTPS strength, not the risk of missing it.",
              nextStep: 2
            }
          ]
        },
        {
          text: "HTTPS importance understood! You've shown how unencrypted HTTP exposes data like postcards, while HTTPS protects it like sealed envelopes.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should an organization protect their mail system?",
          choices: [
            {
              text: "Use sealed envelopes for all sensitive communications",
              correct: true,
              points: 20,
              feedback: "Exactly! Just like sensitive mail needs envelopes, all web traffic needs HTTPS encryption, not just login pages.",
              nextStep: 1
            },
            {
              text: "Train people to write in code on postcards",
              correct: false,
              points: 5,
              feedback: "This is like weak obfuscation - it doesn't provide real security.",
              nextStep: 1
            },
            {
              text: "Only send non-sensitive information",
              correct: false,
              points: 10,
              feedback: "This limits functionality but doesn't protect the sensitive data you must send.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive HTTPS strategy?",
          choices: [
            {
              text: "Implement HTTPS everywhere with HSTS and proper certificate management",
              correct: true,
              points: 25,
              feedback: "Perfect! HTTPS everywhere protects all data, HSTS prevents downgrade attacks, and proper certificate management ensures ongoing security.",
              nextStep: 2
            },
            {
              text: "Use HTTPS only for login pages",
              correct: false,
              points: 10,
              feedback: "Session cookies and other sensitive data on other pages also need protection.",
              nextStep: 2
            },
            {
              text: "Let users choose between HTTP and HTTPS",
              correct: false,
              points: -10,
              feedback: "Users should always be redirected to HTTPS for security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "HTTPS implemented! Your application now encrypts all communications, protecting data like sealed envelopes protect mail content from prying eyes.",
          choices: []
        }
      ]
    }
  },

  inputValidationConcept: {
    id: 127,
    title: "Understanding Input Validation - The Restaurant Kitchen Analogy",
    difficulty: "Medium",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "Imagine a restaurant kitchen that accepts any ingredient customers bring, without checking if it's safe or appropriate. What could go wrong?",
          choices: [
            {
              text: "Customers could bring dangerous or spoiled ingredients",
              correct: true,
              points: 20,
              feedback: "Exactly! Without input validation, applications accept any user input, which could contain malicious 'ingredients' like SQL commands, scripts, or other dangerous content.",
              nextStep: 1
            },
            {
              text: "The kitchen might run out of storage space",
              correct: false,
              points: 5,
              feedback: "Storage isn't the primary security concern - it's the safety of the ingredients.",
              nextStep: 0
            },
            {
              text: "The chefs would have to work harder",
              correct: false,
              points: 5,
              feedback: "Workload isn't the security issue - it's the potential danger.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate the need for input validation?",
          choices: [
            {
              text: "Submit various unexpected inputs to show how the system behaves unpredictably",
              correct: true,
              points: 25,
              feedback: "Perfect! Showing how special characters, extremely long inputs, or unexpected data types can break functionality or cause security issues demonstrates why validation is needed.",
              nextStep: 2
            },
            {
              text: "Just explain that input should be checked",
              correct: false,
              points: 10,
              feedback: "Practical examples make the need for validation much clearer.",
              nextStep: 2
            },
            {
              text: "Try to crash the system with extreme inputs",
              correct: false,
              points: -10,
              feedback: "Never cause actual harm or downtime. Use controlled demonstrations.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Input validation importance understood! You've shown how accepting untrusted input without validation is like a kitchen accepting unknown ingredients - potentially dangerous!",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the restaurant kitchen handle customer ingredients?",
          choices: [
            {
              text: "Establish strict standards for what ingredients are acceptable",
              correct: true,
              points: 20,
              feedback: "Exactly! Input validation establishes rules for what data is acceptable - type, length, format, and business rules - before processing it.",
              nextStep: 1
            },
            {
              text: "Cook everything at very high temperatures to kill germs",
              correct: false,
              points: 10,
              feedback: "This is like output encoding - it helps but doesn't replace proper input validation.",
              nextStep: 1
            },
            {
              text: "Only accept ingredients from trusted customers",
              correct: false,
              points: 5,
              feedback: "Authentication doesn't replace validation - even trusted users can make mistakes or be compromised.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive input validation strategy?",
          choices: [
            {
              text: "Use allow-lists, validate on server side, and apply context-specific rules",
              correct: true,
              points: 25,
              feedback: "Perfect! Allow-lists are more secure than block-lists, server-side validation is essential, and different contexts (SQL, HTML, etc.) need different validation rules.",
              nextStep: 2
            },
            {
              text: "Validate only on the client side for better performance",
              correct: false,
              points: 5,
              feedback: "Client-side validation can be bypassed and must be complemented with server-side validation.",
              nextStep: 2
            },
            {
              text: "Block all special characters in all inputs",
              correct: false,
              points: 10,
              feedback: "This can break legitimate functionality and may not catch all attack vectors.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Input validation implemented! Your application now properly validates all user input, ensuring only safe, expected data is processed, just like a professional kitchen only uses approved ingredients.",
          choices: []
        }
      ]
    }
  },

  sessionManagementConcept: {
    id: 128,
    title: "Understanding Session Management - The Amusement Park wristband Analogy",
    difficulty: "Medium",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "Imagine an amusement park where wristbands never expire and can be easily copied. What security problems could this cause?",
          choices: [
            {
              text: "Stolen or copied wristbands could be used indefinitely by unauthorized people",
              correct: true,
              points: 20,
              feedback: "Exactly! This is like poor session management - sessions that don't expire and use predictable tokens can be stolen or hijacked for unauthorized access.",
              nextStep: 1
            },
            {
              text: "The wristbands might be uncomfortable to wear",
              correct: false,
              points: 5,
              feedback: "Comfort isn't the security issue - it's the access control.",
              nextStep: 0
            },
            {
              text: "The park would need to make more wristbands",
              correct: false,
              points: 0,
              feedback: "Quantity isn't the security concern.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate session management vulnerabilities?",
          choices: [
            {
              text: "Show how session tokens can be predicted, stolen, or used after logout",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating predictable token generation, session hijacking, or sessions remaining active after logout clearly shows session management flaws.",
              nextStep: 2
            },
            {
              text: "Just explain that sessions need to be secure",
              correct: false,
              points: 10,
              feedback: "Practical demonstrations make abstract session concepts concrete.",
              nextStep: 2
            },
            {
              text: "Try to guess user passwords instead",
              correct: false,
              points: 5,
              feedback: "That's authentication, not session management.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Session management understood! You've shown how poor session controls are like amusement park wristbands that never expire and can be easily copied - allowing indefinite unauthorized access.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the amusement park improve their wristband system?",
          choices: [
            {
              text: "Use secure, unpredictable wristbands that expire daily and are invalidated if lost",
              correct: true,
              points: 20,
              feedback: "Exactly! Secure sessions need unpredictable tokens, reasonable timeouts, and proper invalidation when users logout or are inactive.",
              nextStep: 1
            },
            {
              text: "Make the wristbands more colorful and harder to copy visually",
              correct: false,
              points: 5,
              feedback: "Visual complexity doesn't provide real security - it's security through obscurity.",
              nextStep: 1
            },
            {
              text: "Have security guards check every wristband manually",
              correct: false,
              points: 10,
              feedback: "Manual checks don't scale and are unreliable for web applications.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive session security strategy?",
          choices: [
            {
              text: "Use secure random tokens, proper timeouts, secure flags, and regeneration after login",
              correct: true,
              points: 25,
              feedback: "Perfect! Secure random tokens prevent prediction, timeouts limit exposure, secure flags protect transmission, and regeneration prevents session fixation.",
              nextStep: 2
            },
            {
              text: "Use very long session durations for user convenience",
              correct: false,
              points: 10,
              feedback: "Long sessions increase the risk window for session hijacking.",
              nextStep: 2
            },
            {
              text: "Store sessions in URLs for easy sharing",
              correct: false,
              points: -15,
              feedback: "URL sessions are extremely insecure and can be leaked in referrers or logs.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Session management secured! Your application now uses secure, short-lived sessions with proper invalidation, just like well-managed amusement parks use secure, expiring wristbands.",
          choices: []
        }
      ]
    }
  },

  principleOfLeastPrivilege: {
    id: 129,
    title: "Understanding Least Privilege - The Company Job Roles Analogy",
    difficulty: "Easy",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "Imagine a company where every employee has keys to every office, including HR, finance, and the CEO's office. What's the security risk?",
          choices: [
            {
              text: "Any employee can access sensitive areas they don't need for their job",
              correct: true,
              points: 15,
              feedback: "Exactly! This violates the principle of least privilege - users should only have access to what they absolutely need for their role, nothing more.",
              nextStep: 1
            },
            {
              text: "There are too many keys to manage",
              correct: false,
              points: 5,
              feedback: "Management complexity is a problem, but the security risk is excessive access.",
              nextStep: 0
            },
            {
              text: "Employees might lose their keys",
              correct: false,
              points: 10,
              feedback: "Key loss is a risk, but the bigger issue is what the keys can access.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate the risk of excessive privileges?",
          choices: [
            {
              text: "Show how a regular user account can perform administrative functions",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating that normal user accounts can access admin features or other users' data clearly shows violation of least privilege.",
              nextStep: 2
            },
            {
              text: "Just explain that privileges should be limited",
              correct: false,
              points: 10,
              feedback: "Practical examples make the abstract principle concrete and urgent.",
              nextStep: 2
            },
            {
              text: "Try to break into administrative accounts",
              correct: false,
              points: 5,
              feedback: "The vulnerability is that regular accounts already have too much access.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Least privilege principle understood! You've shown how giving users more access than needed creates unnecessary risk, just like giving all employees master keys to everything.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the company fix their access system?",
          choices: [
            {
              text: "Give employees keys only to areas they need for their specific job functions",
              correct: true,
              points: 20,
              feedback: "Exactly! Implement role-based access control where permissions are based on job requirements, not convenience.",
              nextStep: 1
            },
            {
              text: "Use better locks on the most sensitive doors",
              correct: false,
              points: 10,
              feedback: "This helps but doesn't address the fundamental issue of excessive access.",
              nextStep: 1
            },
            {
              text: "Trust employees not to enter areas they shouldn't",
              correct: false,
              points: -10,
              feedback: "Trust is not a security control - proper access control is needed.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive least privilege strategy?",
          choices: [
            {
              text: "Implement role-based access control with regular permission reviews and auditing",
              correct: true,
              points: 25,
              feedback: "Perfect! RBAC ensures appropriate access, regular reviews catch privilege creep, and auditing detects misuse.",
              nextStep: 2
            },
            {
              text: "Give administrators access to everything for efficiency",
              correct: false,
              points: -15,
              feedback: "This violates least privilege and creates single points of failure.",
              nextStep: 2
            },
            {
              text: "Use the same permissions for all users in a department",
              correct: false,
              points: 10,
              feedback: "Different roles in the same department may need different access levels.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Least privilege implemented! Your application now follows the principle of least privilege, giving users only the access they absolutely need, reducing risk and limiting potential damage from compromised accounts.",
          choices: []
        }
      ]
    }
  },

  securityMisconfigurationConcept: {
    id: 130,
    title: "Understanding Security Misconfiguration - The House with Open Windows Analogy",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "Imagine a house with all windows open, doors unlocked, and valuables visible from the street. What security problems does this create?",
          choices: [
            {
              text: "Easy access for intruders without needing to break in",
              correct: true,
              points: 15,
              feedback: "Exactly! Security misconfigurations are like leaving windows open and doors unlocked - they provide easy access without needing sophisticated attacks.",
              nextStep: 1
            },
            {
              text: "The house might get too cold from open windows",
              correct: false,
              points: 5,
              feedback: "Comfort isn't the security issue - it's the easy access for intruders.",
              nextStep: 0
            },
            {
              text: "Neighbors might see inside the house",
              correct: false,
              points: 10,
              feedback: "Privacy is a concern, but the bigger risk is actual unauthorized access.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate security misconfigurations?",
          choices: [
            {
              text: "Find and access exposed admin interfaces, debug endpoints, or default accounts",
              correct: true,
              points: 20,
              feedback: "Perfect! Showing how default configurations, exposed interfaces, or unnecessary services provide easy access demonstrates misconfiguration risks clearly.",
              nextStep: 2
            },
            {
              text: "Just explain that configurations should be secure",
              correct: false,
              points: 10,
              feedback: "Finding actual misconfigurations makes the risk tangible.",
              nextStep: 2
            },
            {
              text: "Try complex attacks that bypass security controls",
              correct: false,
              points: 5,
              feedback: "The point of misconfigurations is that they don't require complex attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Security misconfiguration concept understood! You've shown how poor configurations are like leaving windows open - they provide easy access without needing to pick locks or break down doors.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the homeowner secure their house?",
          choices: [
            {
              text: "Close and lock all windows/doors, hide valuables, and use proper security systems",
              correct: true,
              points: 20,
              feedback: "Exactly! Secure configurations mean closing unnecessary access points, protecting sensitive information, and implementing proper security controls.",
              nextStep: 1
            },
            {
              text: "Put up 'Beware of Dog' signs to scare intruders",
              correct: false,
              points: 5,
              feedback: "This is security through obscurity - it doesn't provide real protection.",
              nextStep: 1
            },
            {
              text: "Only leave the house during daylight hours",
              correct: false,
              points: 10,
              feedback: "Limiting usage doesn't fix the underlying security issues.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive configuration security strategy?",
          choices: [
            {
              text: "Implement hardening guides, automated scanning, and environment-specific configurations",
              correct: true,
              points: 25,
              feedback: "Perfect! Hardening guides provide standards, automated scanning detects deviations, and environment-specific configs ensure proper settings for each context.",
              nextStep: 2
            },
            {
              text: "Use the same configuration for all environments for consistency",
              correct: false,
              points: 10,
              feedback: "Different environments (dev, staging, production) need different security configurations.",
              nextStep: 2
            },
            {
              text: "Disable all features and only enable what's absolutely needed",
              correct: false,
              points: 15,
              feedback: "This is actually good practice - minimal enabled features reduce attack surface.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Security configuration implemented! Your application now follows security hardening standards with proper configurations for each environment, just like a well-secured house with locked doors and windows.",
          choices: []
        }
      ]
    }
  },

    fileUploadVulnerabilities: {
    id: 131,
    title: "Understanding File Upload Risks - The Package Screening Analogy",
    difficulty: "Medium",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "Imagine a mailroom that accepts any package without inspection. What if someone sends a package labeled 'documents' that actually contains dangerous materials?",
          choices: [
            {
              text: "The dangerous contents could bypass security and cause harm",
              correct: true,
              points: 20,
              feedback: "Exactly! This is like file upload vulnerabilities - when applications accept files without proper validation, malicious files can bypass security controls.",
              nextStep: 1
            },
            {
              text: "The package might be too heavy for handling",
              correct: false,
              points: 5,
              feedback: "Size limitations help but don't address content-based threats.",
              nextStep: 0
            },
            {
              text: "The mailroom would run out of storage space",
              correct: false,
              points: 5,
              feedback: "Storage isn't the primary security concern - it's the content danger.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate file upload vulnerabilities safely?",
          choices: [
            {
              text: "Upload files with dangerous extensions disguised as safe files",
              correct: true,
              points: 25,
              feedback: "Perfect! Showing how double extensions (.jpg.php) or magic number spoofing can bypass filters demonstrates the vulnerability clearly.",
              nextStep: 2
            },
            {
              text: "Just explain that files can be dangerous",
              correct: false,
              points: 10,
              feedback: "Practical demonstration makes the risk much more tangible.",
              nextStep: 2
            },
            {
              text: "Actually upload malicious scripts to production",
              correct: false,
              points: -20,
              feedback: "Never upload actually dangerous files to live systems during testing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "File upload risks understood! You've shown how accepting untrusted files without proper validation is like a mailroom accepting uninspected packages - potentially dangerous contents can slip through.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the mailroom handle incoming packages safely?",
          choices: [
            {
              text: "Implement comprehensive screening: X-ray, content check, and sender verification",
              correct: true,
              points: 20,
              feedback: "Exactly! File uploads need multiple validation layers: file type verification, content scanning, and proper storage outside web root.",
              nextStep: 1
            },
            {
              text: "Only accept packages from known senders",
              correct: false,
              points: 10,
              feedback: "Trusting senders isn't enough - even legitimate users can upload malicious files accidentally.",
              nextStep: 1
            },
            {
              text: "Check only the package labels, not the contents",
              correct: false,
              points: 5,
              feedback: "Labels can be forged - actual content verification is essential.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive file upload security strategy?",
          choices: [
            {
              text: "Use allow-lists for extensions, verify content type, scan for malware, and store safely",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple defense layers: extension allow-listing, MIME type verification, content scanning, and secure storage location provide comprehensive protection.",
              nextStep: 2
            },
            {
              text: "Only check file extensions on the client side",
              correct: false,
              points: 5,
              feedback: "Client-side checks can be easily bypassed - server-side validation is essential.",
              nextStep: 2
            },
            {
              text: "Allow all file types but limit file size",
              correct: false,
              points: -10,
              feedback: "Size limits don't prevent malicious content - type restrictions are crucial.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure file upload implemented! Your application now properly validates, scans, and stores uploaded files safely, just like a secure mailroom thoroughly screens all incoming packages.",
          choices: []
        }
      ]
    }
  },

  businessLogicFlaws: {
    id: 132,
    title: "Understanding Business Logic Flaws - The Bank Transaction Rules Analogy",
    difficulty: "Medium",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "Imagine a bank that allows unlimited withdrawals if each transaction is under $100, with no daily limit. What could an attacker do?",
          choices: [
            {
              text: "Make hundreds of small withdrawals to drain accounts completely",
              correct: true,
              points: 20,
              feedback: "Exactly! Business logic flaws occur when application rules can be exploited in unintended ways, like bypassing limits through repeated small transactions.",
              nextStep: 1
            },
            {
              text: "Withdraw exactly $100 each time",
              correct: false,
              points: 10,
              feedback: "This would still hit the per-transaction limit, but doesn't exploit the lack of daily aggregate limits.",
              nextStep: 0
            },
            {
              text: "Complain about the bank's policies",
              correct: false,
              points: 0,
              feedback: "While policies might need review, the vulnerability is in the implemented logic.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate business logic vulnerabilities?",
          choices: [
            {
              text: "Show how legitimate features can be abused through unexpected sequences or timing",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating how normal functionality can be combined or sequenced in unintended ways clearly shows business logic flaws.",
              nextStep: 2
            },
            {
              text: "Just point out the flawed business rule",
              correct: false,
              points: 10,
              feedback: "Showing actual exploitation makes the impact much clearer.",
              nextStep: 2
            },
            {
              text: "Try to break the authentication system",
              correct: false,
              points: 5,
              feedback: "That's a different vulnerability category - business logic flaws abuse legitimate functionality.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Business logic flaws understood! You've shown how seemingly reasonable rules can be exploited when attackers find gaps in the overall logic flow, just like finding loopholes in financial regulations.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the bank fix their withdrawal system?",
          choices: [
            {
              text: "Implement both per-transaction AND aggregate daily limits with proper tracking",
              correct: true,
              points: 20,
              feedback: "Exactly! Defense in depth for business logic requires multiple controls that work together to prevent exploitation of individual rules.",
              nextStep: 1
            },
            {
              text: "Lower the per-transaction limit to $50",
              correct: false,
              points: 10,
              feedback: "This doesn't solve the aggregate limit problem - attackers can just make more transactions.",
              nextStep: 1
            },
            {
              text: "Manually review all suspicious transactions",
              correct: false,
              points: 5,
              feedback: "Manual review doesn't scale and can be too slow to prevent damage.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive approach to secure business logic?",
          choices: [
            {
              text: "Conduct threat modeling, implement defense in depth, and validate entire workflows",
              correct: true,
              points: 25,
              feedback: "Perfect! Threat modeling identifies logic flaws early, defense in depth provides multiple protection layers, and workflow validation ensures end-to-end security.",
              nextStep: 2
            },
            {
              text: "Only test individual features in isolation",
              correct: false,
              points: 5,
              feedback: "Business logic flaws often emerge from feature interactions - end-to-end testing is essential.",
              nextStep: 2
            },
            {
              text: "Rely on client-side enforcement of business rules",
              correct: false,
              points: -10,
              feedback: "Client-side controls can be bypassed - server-side validation is mandatory.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure business logic implemented! Your application now properly validates entire workflows with multiple defense layers, just like secure financial systems implement comprehensive transaction monitoring and limits.",
          choices: []
        }
      ]
    }
  },

  apiSecurity: {
    id: 133,
    title: "Understanding API Security - The Building Blueprints Access Analogy",
    difficulty: "Medium",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "Imagine if anyone could access a building's architectural blueprints, security system diagrams, and maintenance access points. What risks would this create?",
          choices: [
            {
              text: "Attackers could find weak points and plan targeted attacks",
              correct: true,
              points: 20,
              feedback: "Exactly! APIs often expose application internals and data relationships that attackers can use to understand system architecture and plan sophisticated attacks.",
              nextStep: 1
            },
            {
              text: "The blueprints might contain outdated information",
              correct: false,
              points: 5,
              feedback: "While accuracy matters, the exposure itself is the primary risk.",
              nextStep: 0
            },
            {
              text: "Too many people would have access to the documents",
              correct: false,
              points: 10,
              feedback: "Access control is important, but the sensitivity of the information itself is the key issue.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate API security issues?",
          choices: [
            {
              text: "Show how API endpoints expose sensitive data or allow unauthorized actions",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating direct API access that bypasses UI controls or exposes hidden data clearly shows API security vulnerabilities.",
              nextStep: 2
            },
            {
              text: "Just explain that APIs can be attacked",
              correct: false,
              points: 10,
              feedback: "Showing actual data exposure or unauthorized actions makes the risk concrete.",
              nextStep: 2
            },
            {
              text: "Try to DDoS the API endpoints",
              correct: false,
              points: 5,
              feedback: "That's availability, not the data exposure or authorization aspects of API security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "API security risks understood! You've shown how APIs can unintentionally expose system internals and data relationships, giving attackers the 'blueprints' they need to plan sophisticated attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the building protect its sensitive blueprints?",
          choices: [
            {
              text: "Implement strict access controls, need-to-know basis, and secure storage",
              correct: true,
              points: 20,
              feedback: "Exactly! API security requires proper authentication, authorization, rate limiting, and exposing only necessary endpoints and data.",
              nextStep: 1
            },
            {
              text: "Make minor changes to the blueprints regularly",
              correct: false,
              points: 5,
              feedback: "Changing APIs frequently without security controls doesn't solve the fundamental exposure problem.",
              nextStep: 1
            },
            {
              text: "Only share blueprints with senior staff",
              correct: false,
              points: 10,
              feedback: "Role-based access helps, but comprehensive API security requires multiple layers.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive API security strategy?",
          choices: [
            {
              text: "Implement proper authentication, rate limiting, input validation, and minimum data exposure",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive API security includes: strong authentication, rate limiting to prevent abuse, input validation, and returning only necessary data (minimum exposure).",
              nextStep: 2
            },
            {
              text: "Use the same security as the main web application",
              correct: false,
              points: 10,
              feedback: "APIs often need additional protections like rate limiting and different authentication mechanisms.",
              nextStep: 2
            },
            {
              text: "Document all API endpoints thoroughly for developers",
              correct: false,
              points: 5,
              feedback: "Good documentation is important, but it shouldn't replace actual security controls.",
              nextStep: 2
            }
          ]
        },
        {
          text: "API security implemented! Your APIs now have proper authentication, rate limiting, and return minimal necessary data, just like secure organizations protect their architectural blueprints with strict access controls.",
          choices: []
        }
      ]
    }
  },

  cryptographyMisuse: {
    id: 134,
    title: "Understanding Cryptography Misuse - The Safe Combination Handling Analogy",
    difficulty: "Medium",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "Imagine a bank that writes safe combinations on sticky notes, uses weak locks, or doesn't change combinations when employees leave. What security risks does this create?",
          choices: [
            {
              text: "Unauthorized people could easily access the safe contents",
              correct: true,
              points: 20,
              feedback: "Exactly! Cryptography misuse includes weak algorithms, improper key management, or implementation flaws that make encrypted data vulnerable to compromise.",
              nextStep: 1
            },
            {
              text: "Employees might forget the combinations",
              correct: false,
              points: 5,
              feedback: "While inconvenient, forgotten passwords are an operational issue, not a cryptographic failure.",
              nextStep: 0
            },
            {
              text: "The safe might be too small for all valuables",
              correct: false,
              points: 0,
              feedback: "Capacity isn't related to cryptographic security.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate cryptography misuse?",
          choices: [
            {
              text: "Show how weak encryption or poor key management can be exploited",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating attacks on weak algorithms, predictable keys, or implementation flaws shows the real-world impact of cryptography misuse.",
              nextStep: 2
            },
            {
              text: "Just explain that cryptography can be implemented poorly",
              correct: false,
              points: 10,
              feedback: "Practical demonstrations make abstract cryptographic concepts tangible.",
              nextStep: 2
            },
            {
              text: "Try to break strong, properly implemented encryption",
              correct: false,
              points: 5,
              feedback: "This demonstrates cryptography strength, not misuse vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cryptography misuse understood! You've shown how weak algorithms, poor key management, or implementation flaws are like writing safe combinations on sticky notes - they undermine the entire security system.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the bank properly secure their safe combinations?",
          choices: [
            {
              text: "Use strong locks, secure combination storage, and regular combination changes",
              correct: true,
              points: 20,
              feedback: "Exactly! Proper cryptography means using strong, standard algorithms, secure key management, and regular key rotation.",
              nextStep: 1
            },
            {
              text: "Use the same combination for all safes for simplicity",
              correct: false,
              points: -15,
              feedback: "This is terrible practice - one compromise affects everything.",
              nextStep: 1
            },
            {
              text: "Hide the combinations in different places each day",
              correct: false,
              points: 5,
              feedback: "Security through obscurity doesn't work - proper secure storage is needed.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive cryptography strategy?",
          choices: [
            {
              text: "Use strong standard algorithms, proper key management, and regular security updates",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive cryptography includes: using proven algorithms (AES, RSA), secure key generation/storage/rotation, and keeping cryptographic libraries updated.",
              nextStep: 2
            },
            {
              text: "Develop custom encryption algorithms for added security",
              correct: false,
              points: -20,
              feedback: "Never roll your own crypto - use well-tested, standard algorithms.",
              nextStep: 2
            },
            {
              text: "Use the fastest encryption available regardless of strength",
              correct: false,
              points: 5,
              feedback: "Performance is important, but never at the cost of security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Proper cryptography implemented! Your application now uses strong standard algorithms with secure key management, just like secure organizations use strong locks with properly safeguarded combinations.",
          choices: []
        }
      ]
    }
  },

  directoryTraversal: {
    id: 135,
    title: "Understanding Directory Traversal - The Office Building Navigation Analogy",
    difficulty: "Easy",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "Imagine an office building where signs say 'Staff Only' but all doors are unlocked. What happens if visitors can access any room, including server rooms and HR offices?",
          choices: [
            {
              text: "Visitors can access restricted areas and sensitive information",
              correct: true,
              points: 15,
              feedback: "Exactly! Directory traversal occurs when applications don't properly restrict file system access, allowing attackers to access files outside intended directories.",
              nextStep: 1
            },
            {
              text: "The building layout might be confusing",
              correct: false,
              points: 5,
              feedback: "While poor signage doesn't help, the real issue is lack of physical access control.",
              nextStep: 0
            },
            {
              text: "Employees might be disturbed by visitors",
              correct: false,
              points: 5,
              feedback: "Disruption is a symptom, but data exposure is the real risk.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate directory traversal vulnerabilities?",
          choices: [
            {
              text: "Show how path manipulation (../../../) can access unauthorized files",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating how '../' sequences or absolute paths can bypass directory restrictions clearly shows traversal vulnerabilities.",
              nextStep: 2
            },
            {
              text: "Just explain that file access should be restricted",
              correct: false,
              points: 10,
              feedback: "Showing actual unauthorized file access makes the risk much clearer.",
              nextStep: 2
            },
            {
              text: "Try to guess password-protected files",
              correct: false,
              points: 5,
              feedback: "Directory traversal bypasses permissions, doesn't crack passwords.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Directory traversal understood! You've shown how path manipulation can bypass intended directory restrictions, just like walking through unlocked 'Staff Only' doors in a building.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the office building secure restricted areas?",
          choices: [
            {
              text: "Install proper locks, access control systems, and monitor entry points",
              correct: true,
              points: 20,
              feedback: "Exactly! Prevent directory traversal by validating and sanitizing file paths, using allow-lists, and implementing proper access controls.",
              nextStep: 1
            },
            {
              text: "Put up more 'Staff Only' signs",
              correct: false,
              points: 5,
              feedback: "Signs don't provide real security - just like client-side restrictions don't prevent server-side traversal.",
              nextStep: 1
            },
            {
              text: "Have security guards watch all doors",
              correct: false,
              points: 10,
              feedback: "Manual monitoring doesn't scale for web applications - automated controls are needed.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive directory traversal protection?",
          choices: [
            {
              text: "Use allow-lists for permitted files, normalize paths, and run with least privileges",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive protection includes: input validation with allow-lists, path normalization/canonicalization, and running application with minimal file system permissions.",
              nextStep: 2
            },
            {
              text: "Only check for '../' sequences in paths",
              correct: false,
              points: 10,
              feedback: "Blacklists can be bypassed with encoding or different traversal techniques.",
              nextStep: 2
            },
            {
              text: "Store all files in the web root for easy access",
              correct: false,
              points: -15,
              feedback: "This increases risk - sensitive files should be outside web-accessible directories.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Directory traversal protection implemented! Your application now properly validates file paths and restricts file system access, just like secure buildings use proper locks and access controls for restricted areas.",
          choices: []
        }
      ]
    }
  },

  insecureDeserialization: {
    id: 136,
    title: "Understanding Insecure Deserialization - The Food Packaging Inspection Analogy",
    difficulty: "Medium",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "Imagine a food factory that accepts any packaged ingredients without inspecting the contents. What if someone sends packages labeled 'flour' that actually contain contaminated material?",
          choices: [
            {
              text: "The contaminated contents could enter production and cause harm",
              correct: true,
              points: 20,
              feedback: "Exactly! Insecure deserialization occurs when applications trust serialized data without validation, allowing malicious objects to execute arbitrary code.",
              nextStep: 1
            },
            {
              text: "The packages might be the wrong size",
              correct: false,
              points: 5,
              feedback: "Size validation helps but doesn't address content manipulation risks.",
              nextStep: 0
            },
            {
              text: "The factory would need more storage space",
              correct: false,
              points: 0,
              feedback: "Storage capacity isn't the security concern.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate insecure deserialization risks?",
          choices: [
            {
              text: "Create manipulated serialized objects that execute code when deserialized",
              correct: true,
              points: 25,
              feedback: "Perfect! Showing how modified serialized data can lead to code execution demonstrates the severe impact of this vulnerability.",
              nextStep: 2
            },
            {
              text: "Just explain that serialized data can be dangerous",
              correct: false,
              points: 10,
              feedback: "Practical code execution demonstration makes the risk undeniable.",
              nextStep: 2
            },
            {
              text: "Try to intercept serialized data in transit",
              correct: false,
              points: 5,
              feedback: "Interception is an issue, but the core vulnerability is trusting the content.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Insecure deserialization understood! You've shown how trusting serialized data without validation is like accepting food packages without inspection - the contents could be dangerously different from the label.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the food factory ensure ingredient safety?",
          choices: [
            {
              text: "Implement thorough inspection, testing, and trusted supplier verification",
              correct: true,
              points: 20,
              feedback: "Exactly! Prevent deserialization attacks by validating serialized data, using digital signatures, and limiting deserialization to trusted sources.",
              nextStep: 1
            },
            {
              text: "Only accept ingredients from the cheapest suppliers",
              correct: false,
              points: -10,
              feedback: "Cost savings shouldn't compromise safety - similarly, don't trust data based on convenience.",
              nextStep: 1
            },
            {
              text: "Assume packaging labels are always accurate",
              correct: false,
              points: -15,
              feedback: "Never trust external input without verification.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive deserialization protection?",
          choices: [
            {
              text: "Use digital signatures, allow-lists for classes, and isolation boundaries",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive protection includes: digital signatures for integrity, allow-lists for deserializable classes, and running deserialization in isolated environments.",
              nextStep: 2
            },
            {
              text: "Encrypt serialized data during transmission",
              correct: false,
              points: 10,
              feedback: "Encryption protects during transit but doesn't prevent malicious content creation.",
              nextStep: 2
            },
            {
              text: "Use the fastest deserialization libraries available",
              correct: false,
              points: 5,
              feedback: "Performance shouldn't compromise security - safe deserialization is essential.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure deserialization implemented! Your application now properly validates serialized data with digital signatures and class restrictions, just like safe factories thoroughly inspect all incoming ingredients.",
          choices: []
        }
      ]
    }
  },

  componentsKnownVulnerabilities: {
    id: 137,
    title: "Understanding Known Vulnerabilities - The Car Parts Recall Analogy",
    difficulty: "Easy",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "Imagine a car manufacturer that uses parts with known safety recalls but doesn't replace them. What risks do drivers face?",
          choices: [
            {
              text: "The known defective parts could fail and cause accidents",
              correct: true,
              points: 15,
              feedback: "Exactly! Using components with known vulnerabilities is like using recalled car parts - attackers can exploit these known weaknesses easily.",
              nextStep: 1
            },
            {
              text: "The car might use more fuel",
              correct: false,
              points: 5,
              feedback: "Efficiency issues aren't the primary security concern.",
              nextStep: 0
            },
            {
              text: "The car warranty might be void",
              correct: false,
              points: 5,
              feedback: "Legal issues are secondary to actual safety risks.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate the risk of outdated components?",
          choices: [
            {
              text: "Show how publicly documented exploits work against unpatched systems",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating known exploits against outdated components shows how attackers can use public information to compromise systems easily.",
              nextStep: 2
            },
            {
              text: "Just mention that updates are available",
              correct: false,
              points: 10,
              feedback: "Showing actual exploitation makes the risk urgent and tangible.",
              nextStep: 2
            },
            {
              text: "Try to find zero-day vulnerabilities in updated components",
              correct: false,
              points: 5,
              feedback: "The issue is known vulnerabilities, not finding new ones.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Known vulnerabilities risk understood! You've shown how using outdated components with known issues is like driving a car with recalled parts - predictable and preventable failures are waiting to happen.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the car manufacturer address part recalls?",
          choices: [
            {
              text: "Implement a proactive recall management system with regular safety checks",
              correct: true,
              points: 20,
              feedback: "Exactly! Manage component vulnerabilities with regular scanning, patch management processes, and timely updates.",
              nextStep: 1
            },
            {
              text: "Wait for customers to report problems before fixing issues",
              correct: false,
              points: -10,
              feedback: "Reactive approaches leave systems vulnerable to known attacks.",
              nextStep: 1
            },
            {
              text: "Hide recall notices to avoid bad publicity",
              correct: false,
              points: -20,
              feedback: "Ignoring known issues doesn't make them go away - it makes breaches inevitable.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive vulnerability management strategy?",
          choices: [
            {
              text: "Implement continuous monitoring, automated patching, and dependency management",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive management includes: continuous vulnerability scanning, automated patch deployment, software composition analysis, and maintaining an inventory of all components.",
              nextStep: 2
            },
            {
              text: "Only update when major security incidents occur",
              correct: false,
              points: 5,
              feedback: "By then, it's too late - proactive updates are essential.",
              nextStep: 2
            },
            {
              text: "Use as many third-party components as possible for features",
              correct: false,
              points: 10,
              feedback: "More components mean more potential vulnerabilities - only use what you need.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Vulnerability management implemented! Your application now has continuous monitoring, timely patching, and proper dependency management, just like responsible manufacturers proactively address part recalls.",
          choices: []
        }
      ]
    }
  },

  insufficientLogging: {
    id: 138,
    title: "Understanding Insufficient Logging - The Security Camera System Analogy",
    difficulty: "Easy",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "Imagine a bank with security cameras that don't record, have blind spots, or lack timestamps. What happens during a security incident?",
          choices: [
            {
              text: "Investigators can't determine what happened or who was responsible",
              correct: true,
              points: 15,
              feedback: "Exactly! Insufficient logging means security incidents go undetected, and when detected, there's no evidence for investigation or accountability.",
              nextStep: 1
            },
            {
              text: "The cameras use too much electricity",
              correct: false,
              points: 5,
              feedback: "Resource usage isn't the security issue - it's the lack of recorded evidence.",
              nextStep: 0
            },
            {
              text: "Employees might feel uncomfortable being watched",
              correct: false,
              points: 5,
              feedback: "Privacy concerns are separate from security monitoring needs.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate insufficient logging issues?",
          choices: [
            {
              text: "Show how attacks leave no traces or generate inadequate log data",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating that malicious activities generate no logs or insufficient detail shows the investigative blind spots created by poor logging.",
              nextStep: 2
            },
            {
              text: "Just explain that logging is important",
              correct: false,
              points: 10,
              feedback: "Showing the actual lack of evidence makes the risk concrete.",
              nextStep: 2
            },
            {
              text: "Try to generate as many log entries as possible",
              correct: false,
              points: 5,
              feedback: "Volume isn't the issue - it's the quality and coverage of logging.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Insufficient logging risks understood! You've shown how poor logging is like security cameras that don't record - when incidents occur, there's no evidence to understand what happened or hold anyone accountable.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the bank improve their security camera system?",
          choices: [
            {
              text: "Install comprehensive coverage with proper recording, storage, and monitoring",
              correct: true,
              points: 20,
              feedback: "Exactly! Implement comprehensive logging that covers all critical events, with proper storage, monitoring, and retention policies.",
              nextStep: 1
            },
            {
              text: "Only record during business hours to save storage",
              correct: false,
              points: -10,
              feedback: "Many attacks happen outside business hours - 24/7 monitoring is essential.",
              nextStep: 1
            },
            {
              text: "Use fake cameras to deter criminals",
              correct: false,
              points: 5,
              feedback: "Deterrence doesn't replace actual monitoring and evidence collection.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive logging and monitoring strategy?",
          choices: [
            {
              text: "Implement centralized logging, real-time alerts, and regular log reviews",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive strategy includes: centralized log collection, real-time alerting for suspicious activities, regular log analysis, and adequate retention periods.",
              nextStep: 2
            },
            {
              text: "Log everything possible without filtering",
              correct: false,
              points: 10,
              feedback: "Too much noise can hide important signals - log strategically, not excessively.",
              nextStep: 2
            },
            {
              text: "Only log successful transactions for performance",
              correct: false,
              points: -15,
              feedback: "Failed attempts and errors often provide the most security insights.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive logging implemented! Your application now has proper monitoring, alerting, and log management, just like secure facilities have complete camera coverage with proper recording and monitoring.",
          choices: []
        }
      ]
    }
  },

  ssrfVulnerability: {
    id: 139,
    title: "Understanding SSRF - The Misguided Delivery Driver Analogy",
    difficulty: "Medium",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "Imagine a delivery service where drivers will deliver to any address given, including internal company warehouses, secure facilities, or even the driver's own home. What could be exploited?",
          choices: [
            {
              text: "Attackers could make the service access internal systems or malicious locations",
              correct: true,
              points: 20,
              feedback: "Exactly! SSRF occurs when attackers make the server send requests to internal systems or arbitrary external locations, bypassing network security controls.",
              nextStep: 1
            },
            {
              text: "Drivers might get lost finding addresses",
              correct: false,
              points: 5,
              feedback: "Navigation issues aren't the security risk - it's the unrestricted destination access.",
              nextStep: 0
            },
            {
              text: "The delivery vehicles might need more maintenance",
              correct: false,
              points: 0,
              feedback: "Vehicle maintenance isn't related to the security vulnerability.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate SSRF vulnerabilities?",
          choices: [
            {
              text: "Show how user input can make the server access internal services or malicious URLs",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating how the server can be tricked into accessing internal systems (like metadata services) or external attacker-controlled sites shows SSRF impact.",
              nextStep: 2
            },
            {
              text: "Just explain that servers can make requests",
              correct: false,
              points: 10,
              feedback: "Showing actual internal system access or callback to attacker servers makes the risk clear.",
              nextStep: 2
            },
            {
              text: "Try to make the server crash with too many requests",
              correct: false,
              points: 5,
              feedback: "That's resource exhaustion, not SSRF exploitation.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF vulnerability understood! You've shown how unrestricted server requests are like delivery drivers who will go anywhere - they can bypass security perimeters and access sensitive internal systems.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the delivery service restrict destinations?",
          choices: [
            {
              text: "Implement destination allow-lists, validate addresses, and block internal networks",
              correct: true,
              points: 20,
              feedback: "Exactly! Prevent SSRF by validating and restricting URLs, using allow-lists for permitted domains, and blocking access to internal network ranges.",
              nextStep: 1
            },
            {
              text: "Let drivers use their judgment about suspicious addresses",
              correct: false,
              points: 5,
              feedback: "Automated systems don't have judgment - technical controls are needed.",
              nextStep: 1
            },
            {
              text: "Only deliver to addresses in the same city",
              correct: false,
              points: 10,
              feedback: "Geographic restrictions don't prevent access to internal network addresses.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive SSRF protection strategy?",
          choices: [
            {
              text: "Use URL allow-lists, network segmentation, and outbound request filtering",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive SSRF protection includes: strict URL validation with allow-lists, network segmentation to limit server access, and outbound firewall rules filtering.",
              nextStep: 2
            },
            {
              text: "Only validate URLs on the client side",
              correct: false,
              points: 5,
              feedback: "Client-side validation can be bypassed - server-side validation is essential.",
              nextStep: 2
            },
            {
              text: "Allow all URLs but monitor for suspicious activity",
              correct: false,
              points: 10,
              feedback: "Monitoring helps but doesn't prevent exploitation - prevention is better.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF protection implemented! Your application now properly validates and restricts server-side requests, just like secure delivery services verify and restrict delivery destinations.",
          choices: []
        }
      ]
    }
  },

  raceConditions: {
    id: 140,
    title: "Understanding Race Conditions - The Ticket Counter Line Analogy",
    difficulty: "Medium",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "Imagine a ticket counter with one last ticket available. Two people request it at exactly the same time. If the system doesn't handle this properly, what could happen?",
          choices: [
            {
              text: "Both people might get the same ticket, causing overselling",
              correct: true,
              points: 20,
              feedback: "Exactly! Race conditions occur when simultaneous operations create unexpected behavior, like double-spending, privilege escalation, or data corruption.",
              nextStep: 1
            },
            {
              text: "The system might crash from the simultaneous requests",
              correct: false,
              points: 10,
              feedback: "While possible, crashes are availability issues - the race condition itself causes logical errors.",
              nextStep: 0
            },
            {
              text: "The ticket counter would need to hire more staff",
              correct: false,
              points: 5,
              feedback: "Staffing levels don't address the fundamental concurrency control issue.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate race condition vulnerabilities?",
          choices: [
            {
              text: "Send simultaneous requests to exploit timing windows in business logic",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating how rapid, concurrent requests can bypass limits, duplicate actions, or escalate privileges shows race condition impact clearly.",
              nextStep: 2
            },
            {
              text: "Just explain that timing issues can occur",
              correct: false,
              points: 10,
              feedback: "Showing actual exploitation through concurrent requests makes the abstract concept concrete.",
              nextStep: 2
            },
            {
              text: "Try to slow down the system to create delays",
              correct: false,
              points: 5,
              feedback: "Slow performance creates different issues - race conditions exploit simultaneous actions.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Race conditions understood! You've shown how simultaneous operations without proper locking can create logical errors, just like multiple people getting the same last ticket when requests aren't properly sequenced.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the ticket counter handle simultaneous requests?",
          choices: [
            {
              text: "Implement a queuing system with atomic operations and proper locking",
              correct: true,
              points: 20,
              feedback: "Exactly! Prevent race conditions using database transactions, mutex locks, atomic operations, and proper concurrency control mechanisms.",
              nextStep: 1
            },
            {
              text: "Tell customers to come back at different times",
              correct: false,
              points: 5,
              feedback: "This doesn't work for automated systems with simultaneous requests.",
              nextStep: 1
            },
            {
              text: "Have staff manually check for duplicates",
              correct: false,
              points: 10,
              feedback: "Manual processes don't scale and can't handle millisecond timing issues.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive race condition protection?",
          choices: [
            {
              text: "Use database transactions, optimistic/pessimistic locking, and atomic operations",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive protection includes: database transactions for data consistency, appropriate locking strategies, and atomic operations for critical sections.",
              nextStep: 2
            },
            {
              text: "Process all requests sequentially in a single thread",
              correct: false,
              points: 10,
              feedback: "This prevents race conditions but destroys performance and scalability.",
              nextStep: 2
            },
            {
              text: "Hope that simultaneous requests rarely happen",
              correct: false,
              points: -15,
              feedback: "Hope is not a security strategy - automated attacks can easily create race conditions.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Race condition protection implemented! Your application now uses proper locking and atomic operations, just like well-designed ticketing systems handle simultaneous requests without overselling or data corruption.",
          choices: []
        }
      ]
    }
  },

    insecureDirectObjectReferenceAdvanced: {
    id: 141,
    title: "IDOR in Social Media - The Photo Album Access Analogy",
    difficulty: "Easy",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "Imagine a social media app where you can view any user's private photos by simply changing the album ID in the URL, even though the UI only shows your own albums. What's the security issue?",
          choices: [
            {
              text: "The app checks permissions in UI but not in API endpoints",
              correct: true,
              points: 15,
              feedback: "Exactly! This is a classic IDOR - the frontend hides options but the backend doesn't verify if you should access specific resources. Like having a phonebook that lists everyone's numbers but claims it's private.",
              nextStep: 1
            },
            {
              text: "The album IDs are too short and easy to guess",
              correct: false,
              points: 5,
              feedback: "While short IDs help attackers, the core issue is missing authorization checks, not predictability.",
              nextStep: 0
            },
            {
              text: "Private photos shouldn't be stored online",
              correct: false,
              points: 0,
              feedback: "The issue isn't storage - it's improper access control to stored content.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you creatively demonstrate this without accessing real private data?",
          choices: [
            {
              text: "Create test accounts and show accessing each other's 'private' test data",
              correct: true,
              points: 20,
              feedback: "Perfect! Using controlled test environments with dummy data clearly demonstrates the vulnerability without compromising real user privacy.",
              nextStep: 2
            },
            {
              text: "Just report that ID numbers can be changed",
              correct: false,
              points: 10,
              feedback: "Showing actual cross-account access makes the risk undeniable.",
              nextStep: 2
            },
            {
              text: "Access random users' real private albums",
              correct: false,
              points: -20,
              feedback: "Never access real user data during testing - always use test accounts.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Advanced IDOR understood! You've shown how missing backend authorization checks make privacy settings meaningless, like having locked doors with windows wide open.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the social media app properly protect private albums?",
          choices: [
            {
              text: "Implement server-side checks for every album access request, verifying ownership",
              correct: true,
              points: 20,
              feedback: "Exactly! Every API call must verify the requesting user has permission for that specific resource, regardless of what the UI shows or hides.",
              nextStep: 1
            },
            {
              text: "Use longer, more random album IDs",
              correct: false,
              points: 10,
              feedback: "Obfuscation helps but doesn't replace proper authorization - determined attackers will find ways to discover IDs.",
              nextStep: 1
            },
            {
              text: "Only show album IDs to the owner",
              correct: false,
              points: 5,
              feedback: "IDs can still be discovered through network traffic or other means.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most robust IDOR protection strategy?",
          choices: [
            {
              text: "Use indirect reference maps and validate ownership for every resource access",
              correct: true,
              points: 25,
              feedback: "Perfect! Indirect references (mapping random tokens to internal IDs) plus server-side ownership validation for every request provides defense in depth.",
              nextStep: 2
            },
            {
              text: "Rate limit API requests to prevent scanning",
              correct: false,
              points: 10,
              feedback: "Rate limiting helps but doesn't prevent individual unauthorized accesses.",
              nextStep: 2
            },
            {
              text: "Hide API endpoints from users",
              correct: false,
              points: 5,
              feedback: "Security through obscurity doesn't work - endpoints can be discovered.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Robust IDOR protection implemented! Your app now properly validates every access, ensuring users can only reach their own resources, like having personalized keys for every door.",
          choices: []
        }
      ]
    }
  },

  sqlInjectionAdvanced: {
    id: 142,
    title: "SQL Injection in Search - The Library Catalog System Analogy",
    difficulty: "Medium",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "Imagine a library search system where you can type anything in the search box. What if instead of 'mystery novels', you search for 'mystery'; DROP TABLE users--' and the system executes it as SQL?",
          choices: [
            {
              text: "The search could modify the database structure or extract all data",
              correct: true,
              points: 20,
              feedback: "Exactly! SQL injection turns data input into executable commands. The semicolon ends the search query, and -- comments out the rest, allowing full database control!",
              nextStep: 1
            },
            {
              text: "The search would return no results",
              correct: false,
              points: 5,
              feedback: "Without protection, the database might actually execute the malicious commands.",
              nextStep: 0
            },
            {
              text: "The system would crash immediately",
              correct: false,
              points: 5,
              feedback: "Some SQL injections work silently without crashing the system.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate this risk without damaging the database?",
          choices: [
            {
              text: "Use time-based attacks or error messages to confirm vulnerability without damage",
              correct: true,
              points: 25,
              feedback: "Perfect! Time delays (SLEEP) or triggering specific error messages can confirm SQL injection without causing actual harm or data loss.",
              nextStep: 2
            },
            {
              text: "Just explain the theoretical risk",
              correct: false,
              points: 10,
              feedback: "Demonstrating the mechanism makes the abstract threat concrete and urgent.",
              nextStep: 2
            },
            {
              text: "Actually drop tables to prove the point",
              correct: false,
              points: -25,
              feedback: "Never perform destructive actions - use safe confirmation methods only.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Advanced SQL injection understood! You've shown how mixing user input with database commands is like letting library visitors write directly in the catalog system - dangerously powerful!",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the library secure their search system?",
          choices: [
            {
              text: "Use parameterized queries that treat search terms as data, not executable code",
              correct: true,
              points: 20,
              feedback: "Exactly! Parameterized queries separate SQL code from data, ensuring user input is always treated as literal values, never as executable commands.",
              nextStep: 1
            },
            {
              text: "Block SQL keywords like SELECT, DROP, and UNION",
              correct: false,
              points: 10,
              feedback: "Blacklists can be bypassed with encoding, case changes, or alternative syntax.",
              nextStep: 1
            },
            {
              text: "Only allow alphabetical characters in search",
              correct: false,
              points: 5,
              feedback: "This breaks legitimate searches with numbers or special characters.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive SQL injection defense?",
          choices: [
            {
              text: "Use parameterized queries, ORM frameworks, and principle of least privilege for database users",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers: parameterized queries prevent injection, ORMs add abstraction, and limited database permissions minimize damage if injection occurs.",
              nextStep: 2
            },
            {
              text: "Validate input only on the client side",
              correct: false,
              points: 5,
              feedback: "Client-side validation can be bypassed - server-side protection is essential.",
              nextStep: 2
            },
            {
              text: "Use the latest database version",
              correct: false,
              points: 5,
              feedback: "Updates help but don't prevent application-level SQL injection vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive SQL injection protection implemented! Your application now safely separates data from commands, like having a librarian who understands your search intent without letting you touch the card catalog system.",
          choices: []
        }
      ]
    }
  },

  xssAdvanced: {
    id: 143,
    title: "XSS in Comments - The Interactive Guestbook Analogy",
    difficulty: "Medium",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "Imagine a blog with a comment section that displays user comments as-is. What happens if someone posts: '<script>alert('XSS')</script> Nice article!' and the browser executes the script for all visitors?",
          choices: [
            {
              text: "Every visitor's browser runs the script, potentially stealing their sessions",
              correct: true,
              points: 20,
              feedback: "Exactly! Stored XSS persists in the application and affects every user who views the malicious content. Like planting a listening device in a public space that affects everyone who enters.",
              nextStep: 1
            },
            {
              text: "Only the poster sees the script execution",
              correct: false,
              points: 5,
              feedback: "Stored XSS affects all users who view the content, not just the poster.",
              nextStep: 0
            },
            {
              text: "The comment would be automatically rejected",
              correct: false,
              points: 5,
              feedback: "Without proper validation, the application accepts and stores the malicious script.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate XSS impact without harming real users?",
          choices: [
            {
              text: "Create a proof-of-concept that shows cookie access without actually stealing data",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating the ability to access cookies or display fake login prompts shows the risk without compromising real user data.",
              nextStep: 2
            },
            {
              text: "Just mention that scripts can be injected",
              correct: false,
              points: 10,
              feedback: "Showing actual script execution makes the theoretical risk undeniable.",
              nextStep: 2
            },
            {
              text: "Actually steal session cookies from test users",
              correct: false,
              points: -15,
              feedback: "Never access real user data, even in testing environments.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Advanced XSS understood! You've shown how unvalidated user input can turn harmless comments into persistent attack vectors, affecting every visitor like a contaminated public water fountain.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the blog secure their comment system?",
          choices: [
            {
              text: "HTML-encode all user content before displaying it",
              correct: true,
              points: 20,
              feedback: "Exactly! Encoding converts dangerous characters like < and > into safe HTML entities, so browsers display them as text instead of executing them as code.",
              nextStep: 1
            },
            {
              text: "Only allow trusted users to post comments",
              correct: false,
              points: 10,
              feedback: "Even trusted users can be compromised or make mistakes - technical controls are essential.",
              nextStep: 1
            },
            {
              text: "Use JavaScript to strip scripts on page load",
              correct: false,
              points: 5,
              feedback: "Client-side protection can be bypassed - server-side encoding is necessary.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most robust XSS protection strategy?",
          choices: [
            {
              text: "Combine output encoding, Content Security Policy, and input validation",
              correct: true,
              points: 25,
              feedback: "Perfect! Defense in depth: output encoding prevents execution, CSP restricts script sources, and input validation provides additional protection.",
              nextStep: 2
            },
            {
              text: "Disable all JavaScript on the site",
              correct: false,
              points: 5,
              feedback: "Not practical for modern web applications that require JavaScript functionality.",
              nextStep: 2
            },
            {
              text: "Only allow plain text with no formatting",
              correct: false,
              points: 10,
              feedback: "This limits functionality but doesn't address all XSS vectors - encoding is still needed.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive XSS protection implemented! User content is now properly encoded and CSP restricts script execution, making your application safe from script injection like having a water purification system for all user input.",
          choices: []
        }
      ]
    }
  },

  csrfAdvanced: {
    id: 144,
    title: "CSRF in Banking - The Forged Check Analogy",
    difficulty: "Medium",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "Imagine an online banking system that processes transfer requests without verifying they came from the bank's own website. What if you visit a malicious site that secretly submits a transfer form to your bank?",
          choices: [
            {
              text: "Your browser automatically sends your session cookie, executing the transfer",
              correct: true,
              points: 20,
              feedback: "Exactly! CSRF exploits the fact that browsers automatically include session cookies with requests to the associated domain, allowing malicious sites to perform authenticated actions without your knowledge.",
              nextStep: 1
            },
            {
              text: "The bank would detect the foreign website and block the request",
              correct: false,
              points: 10,
              feedback: "Without anti-CSRF tokens, the bank has no way to distinguish legitimate requests from forged ones.",
              nextStep: 0
            },
            {
              text: "You would need to be logged into the malicious site",
              correct: false,
              points: 5,
              feedback: "CSRF works because you're logged into the target site (bank), not the malicious one.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate CSRF without actually transferring money?",
          choices: [
            {
              text: "Create a proof-of-concept that changes user preferences or contact information",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating CSRF with harmless actions like updating profile settings or email preferences shows the vulnerability without financial risk.",
              nextStep: 2
            },
            {
              text: "Just explain the browser behavior",
              correct: false,
              points: 10,
              feedback: "Showing actual automated form submission makes the risk tangible.",
              nextStep: 2
            },
            {
              text: "Actually transfer small amounts between test accounts",
              correct: false,
              points: -20,
              feedback: "Never perform financial transactions, even with test data.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Advanced CSRF understood! You've shown how authenticated sessions can be exploited by malicious sites, like someone forging your signature on checks while you're at their house.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the bank prevent forged transfer requests?",
          choices: [
            {
              text: "Include unique, unpredictable tokens in all forms that must match server-side",
              correct: true,
              points: 20,
              feedback: "Exactly! Anti-CSRF tokens are like check signatures that must match bank records - they prove the request came from a legitimate source.",
              nextStep: 1
            },
            {
              text: "Ask users to re-enter passwords for all transactions",
              correct: false,
              points: 10,
              feedback: "This creates poor user experience and can still be bypassed in some cases.",
              nextStep: 1
            },
            {
              text: "Only allow transfers during business hours",
              correct: false,
              points: 5,
              feedback: "Time restrictions don't address the fundamental authentication issue.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive CSRF protection?",
          choices: [
            {
              text: "Use anti-CSRF tokens, validate Origin/Referer headers, and implement SameSite cookies",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers: tokens provide primary protection, header validation adds checking, and SameSite cookies prevent cross-origin requests.",
              nextStep: 2
            },
            {
              text: "Use longer session timeouts",
              correct: false,
              points: 5,
              feedback: "Longer sessions actually increase CSRF risk windows.",
              nextStep: 2
            },
            {
              text: "Block all cross-origin requests",
              correct: false,
              points: 10,
              feedback: "This breaks legitimate integrations and modern web functionality.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive CSRF protection implemented! Your application now verifies request origins through multiple methods, like a bank that requires signatures, ID checks, and transaction verification for every transfer.",
          choices: []
        }
      ]
    }
  },

  brokenAuthenticationAdvanced: {
    id: 145,
    title: "Broken Authentication - The Master Key System Analogy",
    difficulty: "Easy",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "Imagine a building where all doors use the same master key, and this key pattern is easy to guess (like 12345). What happens if someone discovers or guesses this pattern?",
          choices: [
            {
              text: "They can access every room in the entire building",
              correct: true,
              points: 15,
              feedback: "Exactly! Weak authentication systems with predictable credentials or default passwords give attackers access to everything, just like a master key system with guessable patterns.",
              nextStep: 1
            },
            {
              text: "They can only access public areas",
              correct: false,
              points: 5,
              feedback: "With master key access, all areas become accessible, not just public ones.",
              nextStep: 0
            },
            {
              text: "The building alarms would sound",
              correct: false,
              points: 5,
              feedback: "Without proper monitoring, unauthorized access might go undetected.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate authentication weaknesses without actually breaking in?",
          choices: [
            {
              text: "Show how default credentials, weak passwords, or credential stuffing work",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating access with default passwords, common credentials, or password reuse patterns shows authentication flaws without unauthorized access.",
              nextStep: 2
            },
            {
              text: "Just list common weak passwords",
              correct: false,
              points: 10,
              feedback: "Showing actual successful authentication with weak credentials makes the risk undeniable.",
              nextStep: 2
            },
            {
              text: "Actually access user accounts with weak passwords",
              correct: false,
              points: -15,
              feedback: "Never access real user accounts, even with their weak passwords.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Broken authentication understood! You've shown how weak credentials are like master keys with obvious patterns - once discovered, they unlock everything.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the building improve their key system?",
          choices: [
            {
              text: "Use unique, complex keys for each door and change default patterns immediately",
              correct: true,
              points: 20,
              feedback: "Exactly! Strong authentication requires unique, complex credentials for each user, with immediate change of any default passwords.",
              nextStep: 1
            },
            {
              text: "Hide the key patterns better but keep using them",
              correct: false,
              points: 5,
              feedback: "Security through obscurity doesn't work - the weak pattern remains vulnerable.",
              nextStep: 1
            },
            {
              text: "Only give keys to senior staff",
              correct: false,
              points: 10,
              feedback: "Limited distribution helps but doesn't fix the fundamental weak authentication.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most robust authentication security?",
          choices: [
            {
              text: "Implement multi-factor authentication, strong password policies, and secure credential storage",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive authentication: MFA adds layers, strong policies prevent weak passwords, and secure storage protects credentials even if databases are compromised.",
              nextStep: 2
            },
            {
              text: "Use the same strong password for all admin accounts",
              correct: false,
              points: -10,
              feedback: "Password reuse creates single points of failure - unique credentials are essential.",
              nextStep: 2
            },
            {
              text: "Write passwords down in a secure location",
              correct: false,
              points: 5,
              feedback: "Physical security doesn't address online authentication vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Robust authentication implemented! Your system now uses strong, unique credentials with multiple verification factors, like a building with biometric scanners, unique keys, and security personnel.",
          choices: []
        }
      ]
    }
  },

  sensitiveDataExposure: {
    id: 146,
    title: "Sensitive Data Exposure - The Public Filing Cabinet Analogy",
    difficulty: "Easy",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "Imagine an office that stores sensitive documents in unlocked filing cabinets in the reception area. What risks does this create for customer privacy?",
          choices: [
            {
              text: "Anyone visiting can access confidential information without authorization",
              correct: true,
              points: 15,
              feedback: "Exactly! Sensitive data exposure occurs when confidential information is stored or transmitted without proper protection, making it accessible to unauthorized parties.",
              nextStep: 1
            },
            {
              text: "The documents might get disorganized",
              correct: false,
              points: 5,
              feedback: "Organization issues are separate from security and privacy concerns.",
              nextStep: 0
            },
            {
              text: "The filing cabinets might run out of space",
              correct: false,
              points: 0,
              feedback: "Capacity isn't related to data exposure risks.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate data exposure without accessing real sensitive data?",
          choices: [
            {
              text: "Find and access unprotected test data or development information",
              correct: true,
              points: 20,
              feedback: "Perfect! Locating unprotected backup files, developer notes, or test data that shouldn't be publicly accessible demonstrates the exposure risk pattern.",
              nextStep: 2
            },
            {
              text: "Just mention that data should be protected",
              correct: false,
              points: 10,
              feedback: "Showing actual accessible sensitive information makes the abstract risk concrete.",
              nextStep: 2
            },
            {
              text: "Access and download real customer data",
              correct: false,
              points: -25,
              feedback: "Never access real production data - use test or development environments only.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Sensitive data exposure understood! You've shown how unprotected data is like confidential documents in unlocked cabinets - easily accessible to anyone who looks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the office protect their sensitive documents?",
          choices: [
            {
              text: "Use locked storage, access controls, and encryption for sensitive files",
              correct: true,
              points: 20,
              feedback: "Exactly! Protect sensitive data with encryption at rest and in transit, access controls, and secure storage practices.",
              nextStep: 1
            },
            {
              text: "Put the filing cabinets in less visible locations",
              correct: false,
              points: 5,
              feedback: "Security through obscurity doesn't work - determined attackers will find the data.",
              nextStep: 1
            },
            {
              text: "Only store non-sensitive information",
              correct: false,
              points: 10,
              feedback: "This limits functionality but doesn't protect the sensitive data you must store.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive data protection strategy?",
          choices: [
            {
              text: "Encrypt all sensitive data, implement access controls, and minimize data collection",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive protection: encryption secures data, access controls limit who can see it, and data minimization reduces what needs protection.",
              nextStep: 2
            },
            {
              text: "Store all data encrypted with the same key for simplicity",
              correct: false,
              points: -10,
              feedback: "Single encryption keys create massive risk if compromised - use proper key management.",
              nextStep: 2
            },
            {
              text: "Only encrypt data during transmission",
              correct: false,
              points: 10,
              feedback: "Data at rest also needs protection - comprehensive encryption is essential.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive data protection implemented! Your application now encrypts sensitive data, controls access rigorously, and collects only necessary information, like a secure facility with vaults, access logs, and need-to-know policies.",
          choices: []
        }
      ]
    }
  },

  xmlExternalEntity: {
    id: 147,
    title: "XXE Vulnerabilities - The Document Processing Service Analogy",
    difficulty: "Medium",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "Imagine a document processing service that blindly trusts any XML file submitted. What if someone submits a file containing references to sensitive internal system files?",
          choices: [
            {
              text: "The processor might read and return internal system files to the attacker",
              correct: true,
              points: 20,
              feedback: "Exactly! XXE vulnerabilities occur when XML processors resolve external entities, allowing attackers to read files, conduct SSRF attacks, or cause denial of service.",
              nextStep: 1
            },
            {
              text: "The document would be rejected for unusual formatting",
              correct: false,
              points: 5,
              feedback: "Without proper configuration, XML processors may resolve external entities by default.",
              nextStep: 0
            },
            {
              text: "Only the file content would be processed",
              correct: false,
              points: 5,
              feedback: "XXE attacks exploit the XML parsing itself, not just the file content.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate XXE without accessing real sensitive files?",
          choices: [
            {
              text: "Create XML files that reference harmless but verifiable system information",
              correct: true,
              points: 25,
              feedback: "Perfect! Using XXE to read non-sensitive but verifiable files (like /etc/hosts or web.xml) demonstrates the vulnerability without compromising critical data.",
              nextStep: 2
            },
            {
              text: "Just explain XML external entities",
              correct: false,
              points: 10,
              feedback: "Showing actual file retrieval through XML parsing makes the risk undeniable.",
              nextStep: 2
            },
            {
              text: "Try to read password files or database configurations",
              correct: false,
              points: -20,
              feedback: "Never access sensitive production files, even to demonstrate vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "XXE vulnerabilities understood! You've shown how trusting XML input is like a mailroom that executes any instruction written on envelopes - dangerously powerful!",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the document service secure their XML processing?",
          choices: [
            {
              text: "Disable external entity processing in XML parsers",
              correct: true,
              points: 20,
              feedback: "Exactly! Configure XML parsers to disable external entity resolution, preventing XXE attacks at the fundamental level.",
              nextStep: 1
            },
            {
              text: "Only accept XML from trusted sources",
              correct: false,
              points: 10,
              feedback: "Trust-based security is unreliable - even trusted sources can send malicious content.",
              nextStep: 1
            },
            {
              text: "Validate XML against a strict schema",
              correct: false,
              points: 15,
              feedback: "Schema validation helps but doesn't necessarily prevent XXE - parser configuration is key.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive XXE protection?",
          choices: [
            {
              text: "Disable DTD processing entirely or use JSON instead of XML where possible",
              correct: true,
              points: 25,
              feedback: "Perfect! The most secure approaches: completely disable DTD processing (which prevents all XXE) or use simpler data formats like JSON that don't have this vulnerability.",
              nextStep: 2
            },
            {
              text: "Use the latest XML parser version",
              correct: false,
              points: 10,
              feedback: "Updates help but don't replace proper security configuration.",
              nextStep: 2
            },
            {
              text: "Scan XML files for entity references",
              correct: false,
              points: 10,
              feedback: "Blacklist approaches can be bypassed - disabling the feature is more secure.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive XXE protection implemented! Your XML processors now reject external entities, and you've migrated to safer formats where possible, like a document service that verifies content without executing dangerous instructions.",
          choices: []
        }
      ]
    }
  },

  securityMisconfigurationAdvanced: {
    id: 148,
    title: "Security Misconfiguration - The House Construction Analogy",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "Imagine a house built with all the latest security features, but the builders left windows unlocked, the alarm system unarmed, and the security codes as defaults. How secure is this house really?",
          choices: [
            {
              text: "Not secure at all - the best features are useless if not properly configured",
              correct: true,
              points: 15,
              feedback: "Exactly! Security misconfigurations render even the most sophisticated security controls ineffective. Like having a vault but leaving the combination as 0000.",
              nextStep: 1
            },
            {
              text: "Moderately secure - the basic structure provides some protection",
              correct: false,
              points: 5,
              feedback: "Without proper configuration, security features provide false confidence rather than actual protection.",
              nextStep: 0
            },
            {
              text: "Very secure - the features will work as intended",
              correct: false,
              points: 0,
              feedback: "Security features only work when properly configured and maintained.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you find security misconfigurations without deep system knowledge?",
          choices: [
            {
              text: "Check for default credentials, unnecessary services, and exposed debug information",
              correct: true,
              points: 20,
              feedback: "Perfect! Common misconfigurations include default passwords, enabled but unused services, verbose error messages, and exposed administrative interfaces.",
              nextStep: 2
            },
            {
              text: "Just assume everything is properly configured",
              correct: false,
              points: 0,
              feedback: "Assumption is the enemy of security - verification is essential.",
              nextStep: 2
            },
            {
              text: "Try complex attacks first",
              correct: false,
              points: 5,
              feedback: "Misconfigurations often allow simple attacks to succeed - check basics first.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Security misconfiguration understood! You've shown how improper setup makes security features meaningless, like having a sports car but never taking it out of first gear.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the homeowners properly secure their new house?",
          choices: [
            {
              text: "Conduct a security review, change all defaults, and enable all security features",
              correct: true,
              points: 20,
              feedback: "Exactly! Secure configuration requires comprehensive reviews, changing all defaults, enabling security controls, and disabling unnecessary features.",
              nextStep: 1
            },
            {
              text: "Add more security cameras but keep default codes",
              correct: false,
              points: 5,
              feedback: "Adding features without fixing basic misconfigurations doesn't improve security.",
              nextStep: 1
            },
            {
              text: "Assume the builders configured everything properly",
              correct: false,
              points: -10,
              feedback: "Never assume proper configuration - always verify security settings.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most robust configuration management strategy?",
          choices: [
            {
              text: "Use automated configuration management, regular audits, and environment-specific hardening",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive strategy: automation ensures consistency, audits verify compliance, and environment-specific hardening addresses different risk profiles.",
              nextStep: 2
            },
            {
              text: "Use the same configuration for all environments for simplicity",
              correct: false,
              points: 5,
              feedback: "Different environments have different security requirements - one-size-fits-all creates risks.",
              nextStep: 2
            },
            {
              text: "Configure security manually for each deployment",
              correct: false,
              points: 10,
              feedback: "Manual configuration leads to inconsistencies and human error.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Robust configuration management implemented! Your systems now follow security hardening standards with automated compliance checking, like a home security system professionally installed and regularly maintained.",
          choices: []
        }
      ]
    }
  },

  insecureDeserializationAdvanced: {
    id: 149,
    title: "Insecure Deserialization - The Food Truck Order Analogy",
    difficulty: "Medium",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "Imagine a food truck that lets customers write their own orders on blank slips. What if instead of 'taco', someone writes instructions to 'give me all today's cash' and the kitchen executes it literally?",
          choices: [
            {
              text: "The system might execute malicious instructions disguised as normal orders",
              correct: true,
              points: 20,
              feedback: "Exactly! Insecure deserialization occurs when applications trust serialized data that can contain malicious objects or instructions, leading to remote code execution.",
              nextStep: 1
            },
            {
              text: "The order would be rejected for unusual formatting",
              correct: false,
              points: 5,
              feedback: "Without proper validation, serialized data is processed as-is.",
              nextStep: 0
            },
            {
              text: "Only the food order part would be processed",
              correct: false,
              points: 5,
              feedback: "Insecure deserializers process the entire object, including malicious parts.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate deserialization risks safely?",
          choices: [
            {
              text: "Create manipulated objects that trigger visible but harmless behavior changes",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating with objects that change application behavior visibly (like altering UI elements) shows the risk without causing damage.",
              nextStep: 2
            },
            {
              text: "Just explain object serialization concepts",
              correct: false,
              points: 10,
              feedback: "Showing actual manipulation of application behavior makes the risk tangible.",
              nextStep: 2
            },
            {
              text: "Create objects that delete database records",
              correct: false,
              points: -25,
              feedback: "Never perform destructive actions during security testing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Insecure deserialization understood! You've shown how trusting serialized objects is like a kitchen that executes any instruction written on order slips - dangerously flexible!",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the food truck secure their ordering system?",
          choices: [
            {
              text: "Use pre-printed order forms with specific options only",
              correct: true,
              points: 20,
              feedback: "Exactly! Prevent deserialization attacks by using simple data formats, validating all input, and avoiding native deserialization of untrusted data.",
              nextStep: 1
            },
            {
              text: "Train staff to recognize suspicious orders",
              correct: false,
              points: 5,
              feedback: "Human detection is unreliable for automated serialization attacks.",
              nextStep: 1
            },
            {
              text: "Only accept orders from regular customers",
              correct: false,
              points: 10,
              feedback: "Trust-based security doesn't work - even legitimate users can be compromised.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most robust deserialization protection?",
          choices: [
            {
              text: "Use digital signatures, allow-lists for classes, and avoid native deserialization",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive protection: digital signatures verify integrity, allow-lists restrict deserializable classes, and alternative data formats avoid the risk entirely.",
              nextStep: 2
            },
            {
              text: "Encrypt serialized data during transmission",
              correct: false,
              points: 10,
              feedback: "Encryption protects during transit but doesn't prevent malicious content creation.",
              nextStep: 2
            },
            {
              text: "Use the fastest deserialization library available",
              correct: false,
              points: 5,
              feedback: "Performance shouldn't compromise security - safe deserialization is essential.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Robust deserialization protection implemented! Your application now validates serialized data with multiple security layers, like a food truck with standardized order forms and verification processes.",
          choices: []
        }
      ]
    }
  },

  componentsVulnerabilitiesAdvanced: {
    id: 150,
    title: "Component Vulnerabilities - The Airplane Parts Maintenance Analogy",
    difficulty: "Easy",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "Imagine an airline that doesn't maintain or update its airplane parts according to manufacturer advisories. What risks accumulate over time?",
          choices: [
            {
              text: "Known issues become exploitable weaknesses that could cause catastrophic failures",
              correct: true,
              points: 15,
              feedback: "Exactly! Using components with known vulnerabilities is like flying with parts that have known defects - attackers can use public information to exploit these weaknesses systematically.",
              nextStep: 1
            },
            {
              text: "The planes become less fuel efficient",
              correct: false,
              points: 5,
              feedback: "Efficiency issues are separate from security vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Maintenance costs increase slightly",
              correct: false,
              points: 5,
              feedback: "Cost is a business concern, but security risks can be catastrophic.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate component risks without attacking production systems?",
          choices: [
            {
              text: "Create a test environment with outdated components and show known exploits working",
              correct: true,
              points: 20,
              feedback: "Perfect! Isolated test environments with vulnerable components allow safe demonstration of known exploits without risking production systems.",
              nextStep: 2
            },
            {
              text: "Just list recent security advisories",
              correct: false,
              points: 10,
              feedback: "Showing actual exploitation makes theoretical risks urgent and concrete.",
              nextStep: 2
            },
            {
              text: "Attack production systems to prove they're vulnerable",
              correct: false,
              points: -30,
              feedback: "Never test vulnerabilities on production systems without explicit authorization.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Component vulnerabilities understood! You've shown how outdated software is like unmaintained machinery - known issues become predictable failure points.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the airline maintain their aircraft parts?",
          choices: [
            {
              text: "Implement proactive maintenance schedules and immediate response to safety advisories",
              correct: true,
              points: 20,
              feedback: "Exactly! Manage software components with regular vulnerability scanning, prompt patching, and proactive monitoring of security advisories.",
              nextStep: 1
            },
            {
              text: "Only replace parts when they actually fail",
              correct: false,
              points: -10,
              feedback: "Reactive approaches leave systems vulnerable to known exploits.",
              nextStep: 1
            },
            {
              text: "Use the cheapest available replacement parts",
              correct: false,
              points: -15,
              feedback: "Cost savings shouldn't compromise security and reliability.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive component management strategy?",
          choices: [
            {
              text: "Implement software composition analysis, automated patching, and vulnerability monitoring",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive management: automated scanning identifies vulnerabilities, automated patching applies fixes, and continuous monitoring tracks new threats.",
              nextStep: 2
            },
            {
              text: "Manually check components once per year",
              correct: false,
              points: 5,
              feedback: "Annual checks are insufficient - vulnerabilities are discovered continuously.",
              nextStep: 2
            },
            {
              text: "Use as few third-party components as possible",
              correct: false,
              points: 10,
              feedback: "Minimizing components helps, but proper management is still essential for what you use.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive component management implemented! Your application now has continuous monitoring, automated updates, and proper inventory tracking, like an airline with rigorous maintenance schedules and immediate response to safety advisories.",
          choices: []
        }
      ]
    }
  },

    brokenAccessControlAdvanced: {
    id: 151,
    title: "Broken Access Control - The Concert Ticket Upgrade Analogy",
    difficulty: "Medium",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "Imagine a concert ticketing system where you buy a regular ticket but discover you can upgrade to VIP backstage access by simply changing a parameter in the URL from 'regular' to 'vip'. What's the security issue?",
          choices: [
            {
              text: "The application doesn't verify user permissions for premium features",
              correct: true,
              points: 20,
              feedback: "Exactly! This is privilege escalation through parameter manipulation. The frontend shows options based on your ticket type, but the backend doesn't validate if you actually paid for premium access.",
              nextStep: 1
            },
            {
              text: "The VIP tickets are too expensive",
              correct: false,
              points: 5,
              feedback: "Pricing isn't the security issue - it's the lack of authorization checks.",
              nextStep: 0
            },
            {
              text: "The system should use longer URLs",
              correct: false,
              points: 0,
              feedback: "URL length doesn't address the fundamental authorization problem.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate this vulnerability ethically?",
          choices: [
            {
              text: "Show how changing parameters grants unauthorized access to premium features",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating parameter manipulation to access unpaid features clearly shows the broken access control without causing harm.",
              nextStep: 2
            },
            {
              text: "Just explain that parameters can be changed",
              correct: false,
              points: 10,
              feedback: "Showing actual unauthorized access makes the risk undeniable.",
              nextStep: 2
            },
            {
              text: "Actually use the vulnerability to attend VIP events",
              correct: false,
              points: -20,
              feedback: "Never use vulnerabilities for personal benefit - only demonstrate in controlled environments.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Broken access control understood! You've shown how missing server-side authorization checks are like ticket scanners who don't actually verify ticket types - anyone can claim premium access.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the ticketing system prevent unauthorized upgrades?",
          choices: [
            {
              text: "Verify ticket permissions server-side for every feature access attempt",
              correct: true,
              points: 20,
              feedback: "Exactly! Every request must validate the user's actual permissions against their purchased ticket type, regardless of what the client sends.",
              nextStep: 1
            },
            {
              text: "Hide premium features from regular ticket holders",
              correct: false,
              points: 10,
              feedback: "UI hiding doesn't prevent direct API access - server validation is essential.",
              nextStep: 1
            },
            {
              text: "Use more complex parameter names",
              correct: false,
              points: 5,
              feedback: "Security through obscurity doesn't work - determined attackers will find the parameters.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most robust access control strategy?",
          choices: [
            {
              text: "Implement role-based access control with server-side validation for all requests",
              correct: true,
              points: 25,
              feedback: "Perfect! RBAC ensures users only access what their role permits, and server-side validation prevents client-side manipulation.",
              nextStep: 2
            },
            {
              text: "Trust the client to enforce access rules",
              correct: false,
              points: -10,
              feedback: "Never trust client-side enforcement - it can always be bypassed.",
              nextStep: 2
            },
            {
              text: "Use SSL to encrypt all communications",
              correct: false,
              points: 10,
              feedback: "Encryption protects data in transit but doesn't prevent authorization bypasses.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Robust access control implemented! Your system now properly validates every request server-side, ensuring users can only access features they're actually authorized for.",
          choices: []
        }
      ]
    }
  },

  cryptographicFailuresAdvanced: {
    id: 152,
    title: "Cryptographic Failures - The Diary Lock Analogy",
    difficulty: "Easy",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "Imagine a diary with a cheap lock that uses common patterns (like 1234). What happens if someone can easily guess the combination or pick the lock?",
          choices: [
            {
              text: "The diary's private contents become accessible to anyone who tries common combinations",
              correct: true,
              points: 15,
              feedback: "Exactly! Weak cryptography is like using cheap, predictable locks - it gives false confidence while being easily bypassed by attackers.",
              nextStep: 1
            },
            {
              text: "The diary becomes heavier with the lock",
              correct: false,
              points: 0,
              feedback: "Weight isn't relevant to the security concern.",
              nextStep: 0
            },
            {
              text: "The lock might break over time",
              correct: false,
              points: 5,
              feedback: "Durability is separate from cryptographic strength.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate weak cryptography without breaking real systems?",
          choices: [
            {
              text: "Show how weak encryption can be cracked with common tools or known techniques",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating decryption of weakly protected test data shows the practical risk without compromising real information.",
              nextStep: 2
            },
            {
              text: "Just list weak encryption algorithms",
              correct: false,
              points: 10,
              feedback: "Showing actual decryption makes the theoretical risk concrete and urgent.",
              nextStep: 2
            },
            {
              text: "Try to break strong, properly implemented encryption",
              correct: false,
              points: 5,
              feedback: "This demonstrates cryptography strength, not weaknesses.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cryptographic failures understood! You've shown how weak encryption is like diary locks with common combinations - they provide illusion of security but are easily bypassed.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the diary owner protect their private thoughts?",
          choices: [
            {
              text: "Use a high-quality lock with unique, complex combinations",
              correct: true,
              points: 20,
              feedback: "Exactly! Use strong, modern encryption algorithms with proper key management and unique initialization vectors for each encryption.",
              nextStep: 1
            },
            {
              text: "Hide the diary in a good location",
              correct: false,
              points: 5,
              feedback: "Security through obscurity doesn't work - proper protection is essential.",
              nextStep: 1
            },
            {
              text: "Write in code that only you understand",
              correct: false,
              points: 10,
              feedback: "Custom encoding is weak cryptography - use proven standard algorithms.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive cryptographic protection?",
          choices: [
            {
              text: "Use strong standard algorithms, proper key management, and regular security updates",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive cryptography includes proven algorithms, secure key generation/storage/rotation, and keeping cryptographic libraries updated.",
              nextStep: 2
            },
            {
              text: "Develop custom encryption for unique protection",
              correct: false,
              points: -15,
              feedback: "Never roll your own crypto - use well-tested standard algorithms.",
              nextStep: 2
            },
            {
              text: "Use the same strong key for everything",
              correct: false,
              points: -10,
              feedback: "Key reuse creates massive risk if compromised - use unique keys.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive cryptography implemented! Your data now uses strong encryption with proper key management, like a bank vault with advanced security systems.",
          choices: []
        }
      ]
    }
  },

  injectionAdvanced: {
    id: 153,
    title: "Injection Attacks - The Recipe Instruction Analogy",
    difficulty: "Medium",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "Imagine a cooking app where users can submit recipe instructions. What if instead of 'add 2 cups of flour', someone writes 'add 2 cups of flour; delete all recipes' and the system executes it as code?",
          choices: [
            {
              text: "The system might execute both the recipe step and the malicious command",
              correct: true,
              points: 20,
              feedback: "Exactly! Injection vulnerabilities occur when user input is mixed with executable code, allowing attackers to run arbitrary commands on the system.",
              nextStep: 1
            },
            {
              text: "The recipe would be rejected for unusual formatting",
              correct: false,
              points: 5,
              feedback: "Without proper validation, the system might process the entire input as commands.",
              nextStep: 0
            },
            {
              text: "Only the cooking instruction would be processed",
              correct: false,
              points: 5,
              feedback: "Injection attacks exploit the lack of separation between data and code.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate injection risks safely?",
          choices: [
            {
              text: "Use harmless commands that prove code execution without causing damage",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating with benign commands (like system information requests) shows the vulnerability exists without harming the system.",
              nextStep: 2
            },
            {
              text: "Just explain that input can be malicious",
              correct: false,
              points: 10,
              feedback: "Showing actual code execution makes the abstract threat concrete.",
              nextStep: 2
            },
            {
              text: "Actually delete or modify data to prove the point",
              correct: false,
              points: -25,
              feedback: "Never perform destructive actions during security testing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Injection vulnerabilities understood! You've shown how mixing user input with commands is like letting kitchen visitors write directly in the chef's instruction manual - dangerously powerful!",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the cooking app secure their recipe system?",
          choices: [
            {
              text: "Use parameterized inputs that separate user data from executable commands",
              correct: true,
              points: 20,
              feedback: "Exactly! Parameterized queries and input validation ensure user input is always treated as data, never as executable code.",
              nextStep: 1
            },
            {
              text: "Block common command words like 'delete' and 'drop'",
              correct: false,
              points: 10,
              feedback: "Blacklists can be bypassed with encoding or alternative syntax.",
              nextStep: 1
            },
            {
              text: "Only allow recipes from verified chefs",
              correct: false,
              points: 5,
              feedback: "Trust-based security doesn't work - even legitimate users can make mistakes.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive injection protection?",
          choices: [
            {
              text: "Use parameterized queries, input validation, and principle of least privilege",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers: parameterization prevents injection, validation catches malformed input, and least privilege limits potential damage.",
              nextStep: 2
            },
            {
              text: "Validate input only on the client side",
              correct: false,
              points: 5,
              feedback: "Client-side validation can be bypassed - server-side protection is essential.",
              nextStep: 2
            },
            {
              text: "Use the latest database software",
              correct: false,
              points: 5,
              feedback: "Updates help but don't prevent application-level injection vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive injection protection implemented! Your application now safely separates data from commands, like a professional kitchen with standardized recipe cards and safety procedures.",
          choices: []
        }
      ]
    }
  },

  insecureDesignAdvanced: {
    id: 154,
    title: "Insecure Design - The Building Blueprint Flaw Analogy",
    difficulty: "Medium",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "Imagine a building designed with all windows facing a private courtyard, but the blueprint accidentally shows a hidden back entrance accessible from the alley. What security flaw exists from the start?",
          choices: [
            {
              text: "The fundamental design contains inherent security weaknesses",
              correct: true,
              points: 20,
              feedback: "Exactly! Insecure design means security flaws are built into the architecture from the beginning, making them much harder to fix later.",
              nextStep: 1
            },
            {
              text: "The builders might make construction errors",
              correct: false,
              points: 5,
              feedback: "Construction errors are implementation issues, not design flaws.",
              nextStep: 0
            },
            {
              text: "The building materials might be low quality",
              correct: false,
              points: 5,
              feedback: "Material quality is separate from architectural design security.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you identify design flaws before construction begins?",
          choices: [
            {
              text: "Conduct threat modeling and security reviews of the architectural plans",
              correct: true,
              points: 25,
              feedback: "Perfect! Security reviews and threat modeling during design phase can identify and fix fundamental flaws before they're built into the system.",
              nextStep: 2
            },
            {
              text: "Wait until construction is complete to test security",
              correct: false,
              points: 5,
              feedback: "By then, design flaws are expensive and difficult to fix.",
              nextStep: 2
            },
            {
              text: "Assume the architects considered all security aspects",
              correct: false,
              points: 0,
              feedback: "Never assume security - always verify through proper review processes.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Insecure design understood! You've shown how architectural flaws are like building designs with hidden weaknesses - they're much harder to fix after construction than during planning.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should architects design secure buildings from the start?",
          choices: [
            {
              text: "Incorporate security principles during initial design and planning phases",
              correct: true,
              points: 20,
              feedback: "Exactly! Secure design requires integrating security principles from the beginning, not adding them as an afterthought.",
              nextStep: 1
            },
            {
              text: "Add security features after the main construction is complete",
              correct: false,
              points: 5,
              feedback: "Bolt-on security is less effective and more expensive than built-in security.",
              nextStep: 1
            },
            {
              text: "Use the same design as previous successful projects",
              correct: false,
              points: 10,
              feedback: "Previous designs might have undiscovered flaws or different security requirements.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive secure design strategy?",
          choices: [
            {
              text: "Implement threat modeling, security patterns, and design reviews throughout development",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive secure design includes continuous threat modeling, proven security patterns, and regular design reviews at every development stage.",
              nextStep: 2
            },
            {
              text: "Focus on functionality first and add security later",
              correct: false,
              points: -15,
              feedback: "Security added late is often ineffective and creates technical debt.",
              nextStep: 2
            },
            {
              text: "Copy security from similar applications",
              correct: false,
              points: 10,
              feedback: "While learning from others is good, each system has unique security requirements.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure design implemented! Your applications now incorporate security from the ground up, like buildings designed with security as a fundamental principle rather than an addition.",
          choices: []
        }
      ]
    }
  },

  securityMisconfigurationFinal: {
    id: 155,
    title: "Security Misconfiguration - The Smart Home Setup Analogy",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "Imagine setting up a smart home system but leaving default passwords, enabling unnecessary features, and skipping security updates. What risks does this create?",
          choices: [
            {
              text: "Attackers can easily access the system using known defaults and exploits",
              correct: true,
              points: 15,
              feedback: "Exactly! Security misconfigurations create easy entry points for attackers using known defaults, unnecessary services, and unpatched vulnerabilities.",
              nextStep: 1
            },
            {
              text: "The system might use more electricity",
              correct: false,
              points: 5,
              feedback: "Energy consumption isn't the primary security concern.",
              nextStep: 0
            },
            {
              text: "Some features might not work optimally",
              correct: false,
              points: 5,
              feedback: "Performance issues are separate from security vulnerabilities.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you find misconfigurations in a complex system?",
          choices: [
            {
              text: "Use automated scanners and checklists for common configuration issues",
              correct: true,
              points: 20,
              feedback: "Perfect! Automated tools and security checklists can systematically identify common misconfigurations across complex systems.",
              nextStep: 2
            },
            {
              text: "Manually check a few random settings",
              correct: false,
              points: 5,
              feedback: "Random manual checks are unreliable for comprehensive security assessment.",
              nextStep: 2
            },
            {
              text: "Assume the default configuration is secure",
              correct: false,
              points: -10,
              feedback: "Default configurations are often designed for ease of use, not security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Security misconfiguration understood! You've shown how improper setup makes even advanced systems vulnerable, like having a high-tech security system with all the doors unlocked.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should homeowners properly secure their smart home system?",
          choices: [
            {
              text: "Change all defaults, disable unused features, and apply all security updates",
              correct: true,
              points: 20,
              feedback: "Exactly! Secure configuration requires changing defaults, minimizing enabled features, and maintaining current security patches.",
              nextStep: 1
            },
            {
              text: "Use the setup wizard and accept all recommended settings",
              correct: false,
              points: 5,
              feedback: "Setup wizards often prioritize convenience over security.",
              nextStep: 1
            },
            {
              text: "Hide the system from neighbors",
              correct: false,
              points: 0,
              feedback: "Security through obscurity doesn't provide real protection.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most robust configuration management approach?",
          choices: [
            {
              text: "Use automated configuration management, regular audits, and security hardening guides",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive approach includes automation for consistency, regular audits for verification, and proven hardening guides for standards.",
              nextStep: 2
            },
            {
              text: "Configure everything manually for each device",
              correct: false,
              points: 10,
              feedback: "Manual configuration leads to inconsistencies and human error.",
              nextStep: 2
            },
            {
              text: "Use the same configuration for all devices",
              correct: false,
              points: 5,
              feedback: "Different devices may have different security requirements and capabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Robust configuration management implemented! Your systems now follow security best practices with automated compliance checking and regular updates.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponentsFinal: {
    id: 156,
    title: "Vulnerable Components - The Supply Chain Parts Analogy",
    difficulty: "Easy",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "Imagine a car manufacturer using parts from multiple suppliers without tracking recalls or known defects. What risks accumulate as these parts are used in thousands of vehicles?",
          choices: [
            {
              text: "Known vulnerabilities in components affect the entire product fleet",
              correct: true,
              points: 15,
              feedback: "Exactly! Using vulnerable components means known security issues affect all systems using those components, creating widespread, predictable attack surfaces.",
              nextStep: 1
            },
            {
              text: "The cars become more expensive to produce",
              correct: false,
              points: 5,
              feedback: "Cost is a business concern, while security risks affect all users.",
              nextStep: 0
            },
            {
              text: "Warranty claims might increase",
              correct: false,
              points: 5,
              feedback: "While warranty issues may occur, security risks can be much more severe.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you identify vulnerable components in a complex product?",
          choices: [
            {
              text: "Maintain a software bill of materials and monitor security advisories",
              correct: true,
              points: 20,
              feedback: "Perfect! A software BOM identifies all components, and security monitoring tracks vulnerabilities affecting those components.",
              nextStep: 2
            },
            {
              text: "Wait for customers to report security issues",
              correct: false,
              points: 5,
              feedback: "Reactive approaches leave users vulnerable to known exploits.",
              nextStep: 2
            },
            {
              text: "Assume components from reputable sources are always secure",
              correct: false,
              points: -10,
              feedback: "Even reputable sources can have vulnerable components - continuous monitoring is essential.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Vulnerable components risk understood! You've shown how supply chain vulnerabilities affect entire ecosystems, like car recalls that impact thousands of vehicles simultaneously.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should manufacturers manage component security?",
          choices: [
            {
              text: "Implement component inventory, vulnerability monitoring, and patch management",
              correct: true,
              points: 20,
              feedback: "Exactly! Manage components with comprehensive inventory, continuous vulnerability monitoring, and systematic patch management processes.",
              nextStep: 1
            },
            {
              text: "Use the cheapest available components to reduce costs",
              correct: false,
              points: -15,
              feedback: "Cost savings shouldn't compromise security and product safety.",
              nextStep: 1
            },
            {
              text: "Only update components when adding new features",
              correct: false,
              points: 5,
              feedback: "Security updates should be applied independently of feature development.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive component security strategy?",
          choices: [
            {
              text: "Use software composition analysis, automated patching, and vulnerability management",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive strategy includes automated component analysis, systematic patching processes, and organized vulnerability management.",
              nextStep: 2
            },
            {
              text: "Manually check components once per year",
              correct: false,
              points: 5,
              feedback: "Annual checks are insufficient in today's rapidly evolving threat landscape.",
              nextStep: 2
            },
            {
              text: "Build all components in-house to avoid third-party risks",
              correct: false,
              points: 10,
              feedback: "While this reduces third-party risk, it's often impractical and doesn't eliminate all vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive component security implemented! Your products now have continuous monitoring, automated updates, and proper supply chain management.",
          choices: []
        }
      ]
    }
  },

  identificationAuthenticationFailures: {
    id: 157,
    title: "Identification Failures - The Employee ID System Analogy",
    difficulty: "Medium",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "Imagine a company where employee IDs are sequential (001, 002, 003...) and passwords are based on birthdates. What happens if someone's ID badge is lost or stolen?",
          choices: [
            {
              text: "Attackers can guess other IDs and weak passwords to access multiple accounts",
              correct: true,
              points: 20,
              feedback: "Exactly! Predictable identifiers and weak authentication allow attackers to compromise multiple accounts through systematic guessing or credential stuffing.",
              nextStep: 1
            },
            {
              text: "Only the specific lost ID can be misused",
              correct: false,
              points: 5,
              feedback: "With predictable patterns, one compromise can lead to others.",
              nextStep: 0
            },
            {
              text: "The security system would detect the anomaly",
              correct: false,
              points: 10,
              feedback: "Without proper monitoring, credential attacks might go undetected.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate authentication weaknesses without compromising real accounts?",
          choices: [
            {
              text: "Create test accounts with weak credentials and show how easily they can be guessed",
              correct: true,
              points: 25,
              feedback: "Perfect! Controlled demonstrations with test accounts show authentication flaws without risking real user accounts.",
              nextStep: 2
            },
            {
              text: "Just list common weak passwords",
              correct: false,
              points: 10,
              feedback: "Showing actual successful authentication makes the risk tangible.",
              nextStep: 2
            },
            {
              text: "Try to guess real user passwords",
              correct: false,
              points: -20,
              feedback: "Never attempt to access real user accounts without explicit permission.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Identification and authentication failures understood! You've shown how weak credentials and predictable identifiers create systemic vulnerabilities across entire user bases.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the company improve their employee identification system?",
          choices: [
            {
              text: "Use unique random IDs and require strong, unique passwords for each employee",
              correct: true,
              points: 20,
              feedback: "Exactly! Strong authentication requires unpredictable identifiers and complex, unique credentials for each user.",
              nextStep: 1
            },
            {
              text: "Use longer ID numbers but keep them sequential",
              correct: false,
              points: 10,
              feedback: "Length doesn't solve predictability - randomness is key.",
              nextStep: 1
            },
            {
              text: "Train employees to memorize complex passwords",
              correct: false,
              points: 5,
              feedback: "While training helps, technical controls are essential for security.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most robust authentication security strategy?",
          choices: [
            {
              text: "Implement multi-factor authentication, strong password policies, and secure credential storage",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive authentication includes multiple factors, strong password requirements, and protection of stored credentials.",
              nextStep: 2
            },
            {
              text: "Use the same strong password policy for all systems",
              correct: false,
              points: 10,
              feedback: "While consistent policies help, unique credentials for each system are essential.",
              nextStep: 2
            },
            {
              text: "Store passwords in encrypted files on shared drives",
              correct: false,
              points: -15,
              feedback: "Credentials should be properly hashed and stored in secure, dedicated systems.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Robust authentication implemented! Your system now uses strong, unique credentials with multiple verification factors and secure storage.",
          choices: []
        }
      ]
    }
  },

  softwareDataIntegrityFailures: {
    id: 158,
    title: "Data Integrity Failures - The Recipe Book Tampering Analogy",
    difficulty: "Medium",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "Imagine a shared community recipe book where anyone can modify recipes without verification. What if someone changes the sugar amount from '1 cup' to '10 cups' in popular recipes?",
          choices: [
            {
              text: "Users follow corrupted recipes causing wasted ingredients or worse outcomes",
              correct: true,
              points: 20,
              feedback: "Exactly! Data integrity failures occur when information can be modified without proper verification, leading to corrupted, malicious, or dangerous outcomes.",
              nextStep: 1
            },
            {
              text: "The recipe book becomes less popular",
              correct: false,
              points: 5,
              feedback: "Popularity is a business concern, while integrity affects safety and reliability.",
              nextStep: 0
            },
            {
              text: "Only the modified recipes are affected",
              correct: false,
              points: 10,
              feedback: "A few corrupted entries can undermine trust in the entire system.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate data integrity risks without causing actual harm?",
          choices: [
            {
              text: "Show how unauthorized modifications can alter system behavior or information",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating unauthorized data modification that changes application behavior shows integrity risks without causing damage.",
              nextStep: 2
            },
            {
              text: "Just explain that data can be modified",
              correct: false,
              points: 10,
              feedback: "Showing actual unauthorized changes makes the abstract risk concrete.",
              nextStep: 2
            },
            {
              text: "Actually corrupt important system data",
              correct: false,
              points: -25,
              feedback: "Never modify production data during security testing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Data integrity failures understood! You've shown how unauthorized modifications can corrupt information and system behavior, like tampering with instruction manuals.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the community protect their recipe book from tampering?",
          choices: [
            {
              text: "Implement change tracking, approval processes, and integrity verification",
              correct: true,
              points: 20,
              feedback: "Exactly! Protect data integrity with change controls, approval workflows, and cryptographic verification of content.",
              nextStep: 1
            },
            {
              text: "Make backup copies of the original recipes",
              correct: false,
              points: 10,
              feedback: "Backups help with recovery but don't prevent tampering.",
              nextStep: 1
            },
            {
              text: "Only allow trusted members to view recipes",
              correct: false,
              points: 5,
              feedback: "Access control doesn't prevent authorized users from making harmful changes.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive data integrity protection?",
          choices: [
            {
              text: "Use digital signatures, checksums, and secure update mechanisms",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive integrity protection includes digital signatures for verification, checksums for detection, and secure channels for updates.",
              nextStep: 2
            },
            {
              text: "Store data in read-only format",
              correct: false,
              points: 15,
              feedback: "While this prevents modification, it's often impractical for dynamic systems.",
              nextStep: 2
            },
            {
              text: "Trust users to report data issues",
              correct: false,
              points: 5,
              feedback: "User reporting is reactive - proactive integrity protection is essential.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive data integrity protection implemented! Your system now verifies data authenticity and prevents unauthorized modifications through multiple security layers.",
          choices: []
        }
      ]
    }
  },

  securityLoggingMonitoringFailures: {
    id: 159,
    title: "Logging Failures - The Security Camera Blind Spot Analogy",
    difficulty: "Easy",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "Imagine a bank with security cameras that have blind spots, don't record sound, and lack timestamps. What happens during a security incident in uncovered areas?",
          choices: [
            {
              text: "Investigators cannot reconstruct events or identify perpetrators",
              correct: true,
              points: 15,
              feedback: "Exactly! Insufficient logging and monitoring create investigative blind spots, allowing attacks to go undetected or making incident response impossible.",
              nextStep: 1
            },
            {
              text: "The cameras use less storage space",
              correct: false,
              points: 0,
              feedback: "Storage efficiency isn't relevant to security effectiveness.",
              nextStep: 0
            },
            {
              text: "Security guards have less to monitor",
              correct: false,
              points: 5,
              feedback: "Reduced monitoring coverage increases security risks, not reduces workload.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate logging gaps without waiting for real incidents?",
          choices: [
            {
              text: "Perform authorized test activities and check if they generate adequate logs",
              correct: true,
              points: 20,
              feedback: "Perfect! Controlled testing with authorized activities shows what security events are logged (or missing) without causing real security incidents.",
              nextStep: 2
            },
            {
              text: "Just explain that logging is important",
              correct: false,
              points: 10,
              feedback: "Showing actual logging gaps makes the theoretical risk concrete.",
              nextStep: 2
            },
            {
              text: "Create fake security incidents to test response",
              correct: false,
              points: -15,
              feedback: "Never create situations that could be mistaken for real security incidents.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Logging and monitoring failures understood! You've shown how inadequate logging is like security cameras with blind spots - incidents can happen completely undetected.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the bank improve their security monitoring?",
          choices: [
            {
              text: "Install comprehensive camera coverage with proper recording and alert systems",
              correct: true,
              points: 20,
              feedback: "Exactly! Comprehensive logging requires complete coverage of security events, proper storage, and alerting for suspicious activities.",
              nextStep: 1
            },
            {
              text: "Add more cameras but don't change recording quality",
              correct: false,
              points: 10,
              feedback: "Quantity doesn't replace quality - proper logging detail is essential.",
              nextStep: 1
            },
            {
              text: "Only monitor during business hours",
              correct: false,
              points: -10,
              feedback: "Many security incidents occur outside business hours.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive logging and monitoring strategy?",
          choices: [
            {
              text: "Implement centralized logging, real-time alerts, and regular log analysis",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive strategy includes centralized collection, real-time monitoring, automated alerts, and regular analysis of security events.",
              nextStep: 2
            },
            {
              text: "Log everything possible without filtering",
              correct: false,
              points: 10,
              feedback: "Excessive logging creates noise that can hide important security events.",
              nextStep: 2
            },
            {
              text: "Only log failed authentication attempts",
              correct: false,
              points: 5,
              feedback: "Successful events and other activities also provide crucial security insights.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive logging and monitoring implemented! Your system now has complete security visibility with proper alerting and analysis capabilities.",
          choices: []
        }
      ]
    }
  },

  ssrfFinal: {
    id: 160,
    title: "SSRF Attacks - The Misguided Tour Guide Analogy",
    difficulty: "Medium",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "Imagine a tour company that will book any attraction customers request, including private corporate facilities, government buildings, or the guide's own home. What could be exploited?",
          choices: [
            {
              text: "Attackers can make the service access internal systems or malicious locations",
              correct: true,
              points: 20,
              feedback: "Exactly! SSRF vulnerabilities allow attackers to make the server send requests to internal networks or arbitrary external URLs, bypassing security controls.",
              nextStep: 1
            },
            {
              text: "The tour company might lose money on unpopular attractions",
              correct: false,
              points: 5,
              feedback: "Financial loss is a business concern, while SSRF creates security breaches.",
              nextStep: 0
            },
            {
              text: "Tour guides might get lost finding locations",
              correct: false,
              points: 5,
              feedback: "Navigation issues are operational, not security vulnerabilities.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate SSRF without accessing sensitive internal systems?",
          choices: [
            {
              text: "Make the server connect to controlled external services to prove request capability",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating server requests to attacker-controlled external services shows SSRF capability without compromising internal systems.",
              nextStep: 2
            },
            {
              text: "Just explain that servers can make requests",
              correct: false,
              points: 10,
              feedback: "Showing actual outbound requests makes the vulnerability concrete.",
              nextStep: 2
            },
            {
              text: "Actually access internal company data through SSRF",
              correct: false,
              points: -20,
              feedback: "Never access internal systems or data without explicit authorization.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF vulnerabilities understood! You've shown how unrestricted server requests can bypass network security, like tour guides who will take you anywhere regardless of access restrictions.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the tour company restrict destination bookings?",
          choices: [
            {
              text: "Implement destination allow-lists and block access to internal networks",
              correct: true,
              points: 20,
              feedback: "Exactly! Prevent SSRF by validating and restricting URLs, using allow-lists for permitted domains, and blocking internal network ranges.",
              nextStep: 1
            },
            {
              text: "Trust tour guides to reject suspicious destinations",
              correct: false,
              points: 5,
              feedback: "Human judgment is unreliable for automated SSRF attacks.",
              nextStep: 1
            },
            {
              text: "Only book destinations within the city limits",
              correct: false,
              points: 10,
              feedback: "Geographic restrictions don't prevent access to internal network addresses.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive SSRF protection?",
          choices: [
            {
              text: "Use URL allow-lists, network segmentation, and outbound request filtering",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive SSRF protection includes strict URL validation, network segmentation to limit server access, and outbound firewall rules.",
              nextStep: 2
            },
            {
              text: "Only validate URLs on the client side",
              correct: false,
              points: 5,
              feedback: "Client-side validation can be bypassed - server-side validation is essential.",
              nextStep: 2
            },
            {
              text: "Allow all URLs but log suspicious requests",
              correct: false,
              points: 10,
              feedback: "Monitoring helps but doesn't prevent exploitation - prevention is better.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive SSRF protection implemented! Your application now properly validates and restricts server-side requests with multiple security layers.",
          choices: []
        }
      ]
    }
  },

    brokenAccessControlNew: {
    id: 161,
    title: "Broken Access Control - The Hotel Room Service Analogy",
    difficulty: "Medium",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "Imagine a hotel where you can order room service to any room by simply changing the room number in your request, even though you're only staying in one room. What security issue exists?",
          choices: [
            {
              text: "The system doesn't verify if you're authorized to charge services to other rooms",
              correct: true,
              points: 20,
              feedback: "Exactly! This is broken access control - the application processes requests without verifying if the user has permission to access or charge to the specified resource.",
              nextStep: 1
            },
            {
              text: "Room service menus are too expensive",
              correct: false,
              points: 5,
              feedback: "Pricing isn't the security issue - it's the lack of authorization checks.",
              nextStep: 0
            },
            {
              text: "The hotel has too many rooms",
              correct: false,
              points: 0,
              feedback: "The number of rooms isn't relevant to the access control problem.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate this vulnerability ethically?",
          choices: [
            {
              text: "Show how changing room numbers allows charging services to unauthorized rooms",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating unauthorized resource access through parameter manipulation clearly shows the access control flaw without causing real harm.",
              nextStep: 2
            },
            {
              text: "Just explain that room numbers can be changed",
              correct: false,
              points: 10,
              feedback: "Showing actual unauthorized access makes the risk undeniable.",
              nextStep: 2
            },
            {
              text: "Actually order expensive items to other rooms",
              correct: false,
              points: -25,
              feedback: "Never use vulnerabilities to cause actual harm or financial loss.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Broken access control understood! You've shown how missing authorization checks are like hotel staff who don't verify room ownership before processing charges.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the hotel secure their room service system?",
          choices: [
            {
              text: "Verify room ownership for every service request before processing",
              correct: true,
              points: 20,
              feedback: "Exactly! Every request must validate that the user is authorized to access the specified resource, based on their actual permissions.",
              nextStep: 1
            },
            {
              text: "Use longer, more complex room numbers",
              correct: false,
              points: 10,
              feedback: "Obfuscation helps but doesn't replace proper authorization checks.",
              nextStep: 1
            },
            {
              text: "Only allow room service during certain hours",
              correct: false,
              points: 5,
              feedback: "Time restrictions don't address the fundamental authorization problem.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most robust access control strategy?",
          choices: [
            {
              text: "Implement server-side authorization checks for every resource access attempt",
              correct: true,
              points: 25,
              feedback: "Perfect! Server-side validation ensures every request is authorized regardless of what the client sends, providing true access control.",
              nextStep: 2
            },
            {
              text: "Hide room numbers from guests",
              correct: false,
              points: 5,
              feedback: "Security through obscurity doesn't work - room numbers can be discovered.",
              nextStep: 2
            },
            {
              text: "Trust guests to only order for their own rooms",
              correct: false,
              points: -10,
              feedback: "Never trust client-side enforcement - always verify server-side.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Robust access control implemented! Your system now properly verifies authorization for every request, ensuring users can only access resources they're permitted to use.",
          choices: []
        }
      ]
    }
  },

  cryptographicFailuresNew: {
    id: 162,
    title: "Cryptographic Failures - The Secret Message Passing Analogy",
    difficulty: "Easy",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "Imagine passing secret notes in class using a simple substitution cipher where A=1, B=2, etc. What happens if someone discovers the pattern?",
          choices: [
            {
              text: "All secret messages become readable to anyone who knows the pattern",
              correct: true,
              points: 15,
              feedback: "Exactly! Weak cryptography is like using simple ciphers - once the pattern is discovered, all protected information becomes vulnerable.",
              nextStep: 1
            },
            {
              text: "The notes become harder to write",
              correct: false,
              points: 0,
              feedback: "Difficulty of use isn't the security concern.",
              nextStep: 0
            },
            {
              text: "Only current messages are compromised",
              correct: false,
              points: 5,
              feedback: "Weak cryptography compromises all messages, past and future.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate weak encryption without accessing real data?",
          choices: [
            {
              text: "Create test messages with weak encryption and show how easily they can be decrypted",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating decryption of weakly protected test data shows the practical risk without compromising real information.",
              nextStep: 2
            },
            {
              text: "Just list weak encryption methods",
              correct: false,
              points: 10,
              feedback: "Showing actual decryption makes the theoretical risk concrete.",
              nextStep: 2
            },
            {
              text: "Try to break properly encrypted real data",
              correct: false,
              points: 5,
              feedback: "This demonstrates strong cryptography, not weaknesses.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cryptographic failures understood! You've shown how weak encryption is like simple secret codes - they provide illusion of security but are easily broken.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should students protect their secret messages?",
          choices: [
            {
              text: "Use strong, proven encryption methods with unique keys for different messages",
              correct: true,
              points: 20,
              feedback: "Exactly! Use modern, strong encryption algorithms with proper key management and unique initialization vectors.",
              nextStep: 1
            },
            {
              text: "Use more complex substitution patterns",
              correct: false,
              points: 10,
              feedback: "Complex patterns are still weak cryptography - use proven algorithms.",
              nextStep: 1
            },
            {
              text: "Only share secrets verbally",
              correct: false,
              points: 5,
              feedback: "Avoiding the problem doesn't solve it - use proper encryption when needed.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive cryptographic protection?",
          choices: [
            {
              text: "Use AES-256 or similar strong algorithms with proper key management",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive cryptography includes strong standard algorithms, secure key generation, and proper implementation.",
              nextStep: 2
            },
            {
              text: "Create custom encryption that no one else uses",
              correct: false,
              points: -15,
              feedback: "Never roll your own crypto - use well-tested standard algorithms.",
              nextStep: 2
            },
            {
              text: "Use the same strong key for all encryption",
              correct: false,
              points: -10,
              feedback: "Key reuse creates massive risk - use unique keys for different data.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive cryptography implemented! Your data now uses strong encryption with proper key management, like military-grade communication security.",
          choices: []
        }
      ]
    }
  },

  injectionNew: {
    id: 163,
    title: "Injection Attacks - The Smart Home Voice Command Analogy",
    difficulty: "Medium",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "Imagine a smart home system that executes any voice command. What if instead of 'turn on lights', someone says 'turn on lights; unlock front door' and the system executes both commands?",
          choices: [
            {
              text: "The system might execute unauthorized commands mixed with legitimate ones",
              correct: true,
              points: 20,
              feedback: "Exactly! Injection vulnerabilities occur when user input is not properly separated from system commands, allowing unauthorized actions to be executed.",
              nextStep: 1
            },
            {
              text: "The voice recognition would fail on complex commands",
              correct: false,
              points: 5,
              feedback: "Without proper validation, the system might process the entire input.",
              nextStep: 0
            },
            {
              text: "Only the first command would be processed",
              correct: false,
              points: 5,
              feedback: "Injection attacks exploit the lack of command separation.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate injection risks safely?",
          choices: [
            {
              text: "Use harmless commands that prove command execution without causing damage",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating with benign unauthorized commands shows the vulnerability exists without creating security risks.",
              nextStep: 2
            },
            {
              text: "Just explain that commands can be injected",
              correct: false,
              points: 10,
              feedback: "Showing actual command execution makes the abstract threat concrete.",
              nextStep: 2
            },
            {
              text: "Actually unlock doors or disable security systems",
              correct: false,
              points: -30,
              feedback: "Never perform actions that could compromise physical security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Injection vulnerabilities understood! You've shown how mixing user input with system commands is like a voice assistant that executes everything it hears without validation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the smart home secure voice commands?",
          choices: [
            {
              text: "Use command allow-lists and separate user input from executable commands",
              correct: true,
              points: 20,
              feedback: "Exactly! Parameterized inputs and command validation ensure user input is treated as data, not executable code.",
              nextStep: 1
            },
            {
              text: "Block common dangerous words like 'unlock' and 'disable'",
              correct: false,
              points: 10,
              feedback: "Blacklists can be bypassed with synonyms or alternative phrasing.",
              nextStep: 1
            },
            {
              text: "Only allow voice commands from specific users",
              correct: false,
              points: 5,
              feedback: "Authentication doesn't prevent injection - validation is still needed.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive injection protection?",
          choices: [
            {
              text: "Use parameterized queries, input validation, and principle of least privilege",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers: parameterization prevents injection, validation catches malformed input, and least privilege limits potential damage.",
              nextStep: 2
            },
            {
              text: "Validate input only through voice recognition",
              correct: false,
              points: 5,
              feedback: "Voice recognition can be tricked - server-side validation is essential.",
              nextStep: 2
            },
            {
              text: "Use the latest voice recognition software",
              correct: false,
              points: 5,
              feedback: "Updates help but don't prevent application-level injection vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive injection protection implemented! Your system now safely separates user input from commands, like a smart home with validated, predefined command sets.",
          choices: []
        }
      ]
    }
  },

  insecureDesignNew: {
    id: 164,
    title: "Insecure Design - The Amusement Park Ride Blueprint Analogy",
    difficulty: "Medium",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "Imagine an amusement park ride designed without emergency stops accessible to riders. What security flaw exists in the fundamental design?",
          choices: [
            {
              text: "The design lacks safety mechanisms for emergency situations",
              correct: true,
              points: 20,
              feedback: "Exactly! Insecure design means security and safety features are missing from the architecture, making problems inevitable rather than preventable.",
              nextStep: 1
            },
            {
              text: "The ride might be too fast for some riders",
              correct: false,
              points: 5,
              feedback: "Performance characteristics are separate from security design flaws.",
              nextStep: 0
            },
            {
              text: "The construction materials might be weak",
              correct: false,
              points: 5,
              feedback: "Material quality is an implementation issue, not a design flaw.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you identify design flaws before construction?",
          choices: [
            {
              text: "Conduct security reviews and threat modeling of the design plans",
              correct: true,
              points: 25,
              feedback: "Perfect! Security reviews during design phase can identify and fix fundamental flaws before they're built into the system.",
              nextStep: 2
            },
            {
              text: "Wait until the ride is built to test safety",
              correct: false,
              points: 5,
              feedback: "By then, design flaws are expensive and dangerous to fix.",
              nextStep: 2
            },
            {
              text: "Assume safety engineers considered all risks",
              correct: false,
              points: 0,
              feedback: "Never assume security - always verify through proper review processes.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Insecure design understood! You've shown how architectural flaws are like ride designs without safety features - they're fundamentally unsafe regardless of implementation quality.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should ride designers incorporate safety from the start?",
          choices: [
            {
              text: "Integrate safety mechanisms and emergency features into initial designs",
              correct: true,
              points: 20,
              feedback: "Exactly! Secure design requires building security into the architecture from the beginning, not adding it later.",
              nextStep: 1
            },
            {
              text: "Add safety features after the main construction",
              correct: false,
              points: 5,
              feedback: "Bolt-on security is less effective and more expensive than built-in security.",
              nextStep: 1
            },
            {
              text: "Copy designs from other successful rides",
              correct: false,
              points: 10,
              feedback: "Previous designs might have undiscovered flaws or different requirements.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive secure design strategy?",
          choices: [
            {
              text: "Implement threat modeling, security patterns, and design reviews",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive secure design includes continuous threat modeling, proven security patterns, and regular design reviews.",
              nextStep: 2
            },
            {
              text: "Focus on user experience first and add security later",
              correct: false,
              points: -15,
              feedback: "Security added late is often ineffective and creates technical debt.",
              nextStep: 2
            },
            {
              text: "Use the most popular design patterns",
              correct: false,
              points: 10,
              feedback: "Popularity doesn't guarantee security - proven security patterns are essential.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure design implemented! Your applications now incorporate security from the ground up, like amusement rides designed with multiple safety systems from inception.",
          choices: []
        }
      ]
    }
  },

  securityMisconfigurationNew: {
    id: 165,
    title: "Security Misconfiguration - The New Smartphone Setup Analogy",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "Imagine getting a new smartphone and using it with all default settings: no lock screen, location sharing enabled, and all permissions granted to apps. What risks does this create?",
          choices: [
            {
              text: "Personal data is easily accessible if the phone is lost or compromised",
              correct: true,
              points: 15,
              feedback: "Exactly! Security misconfigurations create vulnerable systems by leaving default, permissive settings that expose data and functionality.",
              nextStep: 1
            },
            {
              text: "The phone battery might drain faster",
              correct: false,
              points: 5,
              feedback: "Battery life is a usability concern, not a security vulnerability.",
              nextStep: 0
            },
            {
              text: "Some apps might not work properly",
              correct: false,
              points: 5,
              feedback: "App functionality issues are separate from security risks.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you find misconfigurations in a new device?",
          choices: [
            {
              text: "Use security checklists and review all privacy and security settings",
              correct: true,
              points: 20,
              feedback: "Perfect! Systematic reviews using security checklists can identify common misconfigurations across devices and applications.",
              nextStep: 2
            },
            {
              text: "Assume the manufacturer configured everything securely",
              correct: false,
              points: -10,
              feedback: "Default configurations are often designed for ease of use, not security.",
              nextStep: 2
            },
            {
              text: "Only check settings when problems occur",
              correct: false,
              points: 5,
              feedback: "Proactive configuration is essential for security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Security misconfiguration understood! You've shown how default settings create vulnerable systems, like using a new device without customizing security options.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should users secure their new smartphones?",
          choices: [
            {
              text: "Change all default settings, enable security features, and review app permissions",
              correct: true,
              points: 20,
              feedback: "Exactly! Secure configuration requires changing defaults, enabling security features, and minimizing permissions.",
              nextStep: 1
            },
            {
              text: "Use the setup wizard and accept recommended settings",
              correct: false,
              points: 5,
              feedback: "Setup wizards often prioritize convenience over security.",
              nextStep: 1
            },
            {
              text: "Only install apps from official stores",
              correct: false,
              points: 10,
              feedback: "App source doesn't replace proper configuration and permission management.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most robust configuration management approach?",
          choices: [
            {
              text: "Use security baselines, automated checks, and regular configuration reviews",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive approach includes security baselines for standards, automated compliance checking, and regular reviews.",
              nextStep: 2
            },
            {
              text: "Configure each device individually as needed",
              correct: false,
              points: 10,
              feedback: "Manual configuration leads to inconsistencies and missed settings.",
              nextStep: 2
            },
            {
              text: "Use the same configuration for all devices",
              correct: false,
              points: 5,
              feedback: "Different devices and users may have different security requirements.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Robust configuration management implemented! Your devices now follow security best practices with proper settings and regular compliance checking.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponentsNew: {
    id: 166,
    title: "Vulnerable Components - The Restaurant Kitchen Equipment Analogy",
    difficulty: "Easy",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "Imagine a restaurant using kitchen equipment with known safety recalls but not replacing or repairing them. What risks exist for customers and staff?",
          choices: [
            {
              text: "Known safety issues could cause accidents affecting everyone",
              correct: true,
              points: 15,
              feedback: "Exactly! Using vulnerable components means known security issues affect all systems using those components, creating predictable risks.",
              nextStep: 1
            },
            {
              text: "The equipment might be less energy efficient",
              correct: false,
              points: 5,
              feedback: "Efficiency is an operational concern, while safety risks affect people.",
              nextStep: 0
            },
            {
              text: "Food preparation might take longer",
              correct: false,
              points: 5,
              feedback: "Performance issues are separate from safety vulnerabilities.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you identify vulnerable equipment in a kitchen?",
          choices: [
            {
              text: "Maintain equipment inventory and monitor manufacturer safety notices",
              correct: true,
              points: 20,
              feedback: "Perfect! Comprehensive inventory and monitoring of vendor advisories can identify vulnerable components before they cause problems.",
              nextStep: 2
            },
            {
              text: "Wait for equipment to fail before replacing",
              correct: false,
              points: 5,
              feedback: "Reactive approaches leave systems vulnerable to known issues.",
              nextStep: 2
            },
            {
              text: "Assume equipment from reputable brands is always safe",
              correct: false,
              points: -10,
              feedback: "Even reputable brands can have recalls - continuous monitoring is essential.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Vulnerable components risk understood! You've shown how using components with known issues is like kitchen equipment with safety recalls - predictable problems waiting to happen.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should restaurants manage kitchen equipment safety?",
          choices: [
            {
              text: "Implement equipment tracking, regular maintenance, and immediate response to recalls",
              correct: true,
              points: 20,
              feedback: "Exactly! Manage components with comprehensive tracking, regular updates, and prompt response to vulnerability reports.",
              nextStep: 1
            },
            {
              text: "Use the cheapest available equipment to reduce costs",
              correct: false,
              points: -15,
              feedback: "Cost savings shouldn't compromise safety and security.",
              nextStep: 1
            },
            {
              text: "Only replace equipment when it breaks completely",
              correct: false,
              points: 5,
              feedback: "Proactive maintenance prevents problems before they occur.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive component security strategy?",
          choices: [
            {
              text: "Use software composition analysis, vulnerability monitoring, and patch management",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive strategy includes automated component analysis, continuous vulnerability monitoring, and systematic patching processes.",
              nextStep: 2
            },
            {
              text: "Manually check components once per year",
              correct: false,
              points: 5,
              feedback: "Annual checks are insufficient in today's rapidly evolving threat landscape.",
              nextStep: 2
            },
            {
              text: "Build all components in-house to avoid third-party risks",
              correct: false,
              points: 10,
              feedback: "While this reduces third-party risk, it's often impractical and expensive.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive component security implemented! Your systems now have continuous monitoring, automated updates, and proper vulnerability management.",
          choices: []
        }
      ]
    }
  },

  identificationAuthenticationNew: {
    id: 167,
    title: "Authentication Failures - The Gym Membership System Analogy",
    difficulty: "Medium",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "Imagine a gym where membership cards use sequential numbers and photos aren't checked. What happens if someone uses a lost card with a nearby number?",
          choices: [
            {
              text: "Unauthorized people can access the gym using guessed or found cards",
              correct: true,
              points: 20,
              feedback: "Exactly! Weak authentication with predictable identifiers and lack of verification allows unauthorized access through credential guessing or theft.",
              nextStep: 1
            },
            {
              text: "Only the specific lost card can be misused",
              correct: false,
              points: 5,
              feedback: "With predictable patterns, one compromise can lead to systematic abuse.",
              nextStep: 0
            },
            {
              text: "The security cameras would detect unauthorized access",
              correct: false,
              points: 10,
              feedback: "Without proper authentication, unauthorized access might go undetected.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate authentication weaknesses without real access?",
          choices: [
            {
              text: "Show how predictable credentials or lack of verification enables unauthorized access",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating systematic credential guessing or verification bypass shows authentication flaws without compromising real systems.",
              nextStep: 2
            },
            {
              text: "Just list common authentication weaknesses",
              correct: false,
              points: 10,
              feedback: "Showing actual authentication bypass makes the risk tangible.",
              nextStep: 2
            },
            {
              text: "Actually access facilities using weak authentication",
              correct: false,
              points: -20,
              feedback: "Never use vulnerabilities to gain unauthorized physical access.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Authentication failures understood! You've shown how weak credentials and poor verification create systemic security vulnerabilities.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the gym improve their membership system?",
          choices: [
            {
              text: "Use unique random membership numbers and verify identity with photos or biometrics",
              correct: true,
              points: 20,
              feedback: "Exactly! Strong authentication requires unpredictable identifiers and multiple verification factors.",
              nextStep: 1
            },
            {
              text: "Use longer membership numbers but keep them sequential",
              correct: false,
              points: 10,
              feedback: "Length doesn't solve predictability - randomness is key.",
              nextStep: 1
            },
            {
              text: "Train staff to recognize members visually",
              correct: false,
              points: 5,
              feedback: "Human recognition is unreliable - technical controls are essential.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most robust authentication security strategy?",
          choices: [
            {
              text: "Implement multi-factor authentication, strong credentials, and proper session management",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive authentication includes multiple factors, strong credential policies, and secure session handling.",
              nextStep: 2
            },
            {
              text: "Use the same authentication for all facilities",
              correct: false,
              points: 10,
              feedback: "While consistent policies help, context-aware authentication is better.",
              nextStep: 2
            },
            {
              text: "Write down passwords for backup access",
              correct: false,
              points: -15,
              feedback: "Credentials should be properly stored and protected, not written down.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Robust authentication implemented! Your system now uses strong, multi-factor authentication with proper identity verification.",
          choices: []
        }
      ]
    }
  },

  softwareDataIntegrityNew: {
    id: 168,
    title: "Data Integrity Failures - The Scientific Research Data Analogy",
    difficulty: "Medium",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "Imagine a research lab where experimental data can be modified by anyone without tracking changes. What if someone alters results to support false conclusions?",
          choices: [
            {
              text: "Corrupted data leads to incorrect conclusions and wasted research",
              correct: true,
              points: 20,
              feedback: "Exactly! Data integrity failures occur when information can be modified without proper controls, leading to corrupted, misleading, or dangerous outcomes.",
              nextStep: 1
            },
            {
              text: "The research becomes less valuable",
              correct: false,
              points: 5,
              feedback: "Value reduction is a consequence, while integrity affects truth and safety.",
              nextStep: 0
            },
            {
              text: "Only the modified data is affected",
              correct: false,
              points: 10,
              feedback: "A few corrupted data points can invalidate entire research projects.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate data integrity risks without corrupting real data?",
          choices: [
            {
              text: "Show how unauthorized modifications can alter system behavior or outputs",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating unauthorized data modification that changes application behavior shows integrity risks without causing real damage.",
              nextStep: 2
            },
            {
              text: "Just explain that data can be modified",
              correct: false,
              points: 10,
              feedback: "Showing actual unauthorized changes makes the abstract risk concrete.",
              nextStep: 2
            },
            {
              text: "Actually corrupt important research data",
              correct: false,
              points: -30,
              feedback: "Never modify production or research data during security testing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Data integrity failures understood! You've shown how unauthorized modifications can corrupt information and lead to incorrect decisions, like tampering with scientific evidence.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the research lab protect their data integrity?",
          choices: [
            {
              text: "Implement change controls, audit trails, and data verification mechanisms",
              correct: true,
              points: 20,
              feedback: "Exactly! Protect data integrity with access controls, change tracking, and cryptographic verification.",
              nextStep: 1
            },
            {
              text: "Make backup copies of original data",
              correct: false,
              points: 10,
              feedback: "Backups help with recovery but don't prevent tampering.",
              nextStep: 1
            },
            {
              text: "Only allow senior researchers to access data",
              correct: false,
              points: 5,
              feedback: "Access control doesn't prevent authorized users from making harmful changes.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive data integrity protection?",
          choices: [
            {
              text: "Use digital signatures, checksums, and secure update processes",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive integrity protection includes digital signatures for authenticity, checksums for detection, and secure processes for updates.",
              nextStep: 2
            },
            {
              text: "Store data in read-only format",
              correct: false,
              points: 15,
              feedback: "While this prevents modification, it's often impractical for dynamic systems.",
              nextStep: 2
            },
            {
              text: "Trust users to maintain data integrity",
              correct: false,
              points: 5,
              feedback: "Trust is not a control - technical integrity protection is essential.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive data integrity protection implemented! Your system now verifies data authenticity and prevents unauthorized modifications through multiple security layers.",
          choices: []
        }
      ]
    }
  },

  securityLoggingMonitoringNew: {
    id: 169,
    title: "Logging Failures - The Air Traffic Control Recording Analogy",
    difficulty: "Easy",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "Imagine an air traffic control system where communications aren't recorded, radar data isn't stored, and incident reports aren't maintained. What happens during an aviation incident?",
          choices: [
            {
              text: "Investigators cannot determine causes or prevent future incidents",
              correct: true,
              points: 15,
              feedback: "Exactly! Insufficient logging and monitoring create investigative gaps, making incident analysis and prevention impossible.",
              nextStep: 1
            },
            {
              text: "The system uses less storage space",
              correct: false,
              points: 0,
              feedback: "Storage efficiency isn't relevant to safety and security effectiveness.",
              nextStep: 0
            },
            {
              text: "Controllers have less paperwork",
              correct: false,
              points: 5,
              feedback: "Reduced documentation increases risks, not reduces workload.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate logging gaps without real incidents?",
          choices: [
            {
              text: "Perform test activities and check if they generate adequate audit trails",
              correct: true,
              points: 20,
              feedback: "Perfect! Controlled testing shows what security events are logged (or missing) without requiring real security incidents.",
              nextStep: 2
            },
            {
              text: "Just explain that logging is important for investigations",
              correct: false,
              points: 10,
              feedback: "Showing actual logging gaps makes the theoretical risk concrete.",
              nextStep: 2
            },
            {
              text: "Create fake security incidents to test response",
              correct: false,
              points: -20,
              feedback: "Never create situations that could be mistaken for real emergencies.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Logging and monitoring failures understood! You've shown how inadequate logging is like air traffic control without recordings - incidents become mysteries with no lessons learned.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should air traffic control improve their monitoring?",
          choices: [
            {
              text: "Implement comprehensive recording of all communications and system activities",
              correct: true,
              points: 20,
              feedback: "Exactly! Comprehensive logging requires complete coverage of security events with proper storage and retention.",
              nextStep: 1
            },
            {
              text: "Record only emergency communications",
              correct: false,
              points: 10,
              feedback: "Selective recording misses context and precursor events.",
              nextStep: 1
            },
            {
              text: "Only monitor during busy periods",
              correct: false,
              points: -10,
              feedback: "Continuous monitoring is essential - incidents can happen anytime.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive logging and monitoring strategy?",
          choices: [
            {
              text: "Implement centralized logging, real-time alerts, and regular log analysis",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive strategy includes centralized collection, real-time monitoring, automated alerts, and regular security analysis.",
              nextStep: 2
            },
            {
              text: "Log everything possible without filtering",
              correct: false,
              points: 10,
              feedback: "Excessive logging creates noise that can hide important events.",
              nextStep: 2
            },
            {
              text: "Only log system errors and crashes",
              correct: false,
              points: 5,
              feedback: "Successful activities and normal operations also provide crucial insights.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive logging and monitoring implemented! Your system now has complete security visibility with proper alerting and analysis capabilities.",
          choices: []
        }
      ]
    }
  },

  ssrfNew: {
    id: 170,
    title: "SSRF Attacks - The Delivery Service Routing Analogy",
    difficulty: "Medium",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "Imagine a delivery service that will deliver to any address provided, including internal company warehouses, secure government facilities, or the dispatcher's home. What could be exploited?",
          choices: [
            {
              text: "Attackers can make the service access internal systems or malicious locations",
              correct: true,
              points: 20,
              feedback: "Exactly! SSRF vulnerabilities allow attackers to make the server send requests to internal networks or arbitrary external URLs, bypassing security controls.",
              nextStep: 1
            },
            {
              text: "The delivery service might lose money on far destinations",
              correct: false,
              points: 5,
              feedback: "Financial loss is a business concern, while SSRF creates security breaches.",
              nextStep: 0
            },
            {
              text: "Drivers might get lost finding addresses",
              correct: false,
              points: 5,
              feedback: "Navigation issues are operational, not security vulnerabilities.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate SSRF without accessing sensitive systems?",
          choices: [
            {
              text: "Make the server connect to controlled external services to prove request capability",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating server requests to attacker-controlled external services shows SSRF capability without compromising internal systems.",
              nextStep: 2
            },
            {
              text: "Just explain that servers can make requests to any address",
              correct: false,
              points: 10,
              feedback: "Showing actual outbound requests makes the vulnerability concrete.",
              nextStep: 2
            },
            {
              text: "Actually access internal company systems through SSRF",
              correct: false,
              points: -25,
              feedback: "Never access internal systems or data without explicit authorization.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF vulnerabilities understood! You've shown how unrestricted server requests can bypass network security, like delivery drivers who will go anywhere without verification.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the delivery service restrict destinations?",
          choices: [
            {
              text: "Implement address allow-lists and block access to internal networks",
              correct: true,
              points: 20,
              feedback: "Exactly! Prevent SSRF by validating and restricting URLs, using allow-lists for permitted domains, and blocking internal network ranges.",
              nextStep: 1
            },
            {
              text: "Trust drivers to reject suspicious addresses",
              correct: false,
              points: 5,
              feedback: "Human judgment is unreliable for automated SSRF attacks.",
              nextStep: 1
            },
            {
              text: "Only deliver within specific zip codes",
              correct: false,
              points: 10,
              feedback: "Geographic restrictions don't prevent access to internal network addresses.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive SSRF protection?",
          choices: [
            {
              text: "Use URL allow-lists, network segmentation, and outbound request filtering",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive SSRF protection includes strict URL validation, network segmentation to limit server access, and outbound firewall rules.",
              nextStep: 2
            },
            {
              text: "Only validate URLs on the client side",
              correct: false,
              points: 5,
              feedback: "Client-side validation can be bypassed - server-side validation is essential.",
              nextStep: 2
            },
            {
              text: "Allow all URLs but monitor for suspicious patterns",
              correct: false,
              points: 10,
              feedback: "Monitoring helps but doesn't prevent exploitation - prevention is better.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive SSRF protection implemented! Your application now properly validates and restricts server-side requests with multiple security layers.",
          choices: []
        }
      ]
    }
  },

    brokenAccessControlFresh: {
    id: 171,
    title: "Broken Access Control - The Digital Library eBook Access Analogy",
    difficulty: "Medium",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "Imagine a digital library where you can download any eBook by changing the book ID in the URL, even premium books your subscription doesn't cover. What security issue exists?",
          choices: [
            {
              text: "The system doesn't verify subscription level before granting book access",
              correct: true,
              points: 20,
              feedback: "Exactly! This is broken access control - the application serves content without verifying the user's authorization level or subscription permissions.",
              nextStep: 1
            },
            {
              text: "The eBook files are too large to download",
              correct: false,
              points: 5,
              feedback: "File size isn't the security issue - it's the lack of access verification.",
              nextStep: 0
            },
            {
              text: "The library has too many books available",
              correct: false,
              points: 0,
              feedback: "The number of books isn't relevant to the access control problem.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate this vulnerability ethically?",
          choices: [
            {
              text: "Show how changing book IDs grants access to unauthorized premium content",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating unauthorized content access through ID manipulation clearly shows the access control flaw without causing harm.",
              nextStep: 2
            },
            {
              text: "Just explain that book IDs can be guessed",
              correct: false,
              points: 10,
              feedback: "Showing actual unauthorized access makes the risk undeniable.",
              nextStep: 2
            },
            {
              text: "Actually download and distribute premium books",
              correct: false,
              points: -30,
              feedback: "Never use vulnerabilities to access or distribute copyrighted content illegally.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Broken access control understood! You've shown how missing authorization checks are like a library that doesn't verify membership levels before lending premium books.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the digital library secure their eBook access?",
          choices: [
            {
              text: "Verify subscription level for every book access request server-side",
              correct: true,
              points: 20,
              feedback: "Exactly! Every request must validate the user's subscription level against the book's access requirements before serving content.",
              nextStep: 1
            },
            {
              text: "Use longer, more complex book IDs",
              correct: false,
              points: 10,
              feedback: "Obfuscation helps but doesn't replace proper authorization checks.",
              nextStep: 1
            },
            {
              text: "Only show available books in the user interface",
              correct: false,
              points: 5,
              feedback: "UI restrictions don't prevent direct API access - server validation is essential.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most robust access control strategy for digital content?",
          choices: [
            {
              text: "Implement role-based access control with server-side validation for all content requests",
              correct: true,
              points: 25,
              feedback: "Perfect! RBAC ensures users only access content their role permits, and server-side validation prevents client-side manipulation.",
              nextStep: 2
            },
            {
              text: "Hide book IDs from users completely",
              correct: false,
              points: 5,
              feedback: "Security through obscurity doesn't work - IDs can be discovered through network traffic.",
              nextStep: 2
            },
            {
              text: "Trust the client to enforce access rules",
              correct: false,
              points: -10,
              feedback: "Never trust client-side enforcement - always verify server-side.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Robust access control implemented! Your digital library now properly verifies authorization for every content request, ensuring users only access materials they're permitted to view.",
          choices: []
        }
      ]
    }
  },

  cryptographicFailuresFresh: {
    id: 172,
    title: "Cryptographic Failures - The Time Capsule Sealing Analogy",
    difficulty: "Easy",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "Imagine sealing a time capsule with a cheap lock that uses a common combination. What happens if someone can easily guess or pick the lock before the opening date?",
          choices: [
            {
              text: "The capsule's contents can be accessed prematurely by anyone who guesses the combination",
              correct: true,
              points: 15,
              feedback: "Exactly! Weak cryptography is like using easily guessable locks - it provides false security while being vulnerable to simple attacks.",
              nextStep: 1
            },
            {
              text: "The capsule might rust over time",
              correct: false,
              points: 0,
              feedback: "Physical deterioration isn't the cryptographic concern.",
              nextStep: 0
            },
            {
              text: "Only the current contents are at risk",
              correct: false,
              points: 5,
              feedback: "Weak cryptography compromises all protected content, not just current items.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate weak encryption risks safely?",
          choices: [
            {
              text: "Create test data with weak protection and show decryption with common tools",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating decryption of weakly protected test data shows the practical risk without compromising real information.",
              nextStep: 2
            },
            {
              text: "Just list examples of weak encryption",
              correct: false,
              points: 10,
              feedback: "Showing actual decryption makes the theoretical risk concrete and urgent.",
              nextStep: 2
            },
            {
              text: "Try to break properly encrypted real data",
              correct: false,
              points: 5,
              feedback: "This demonstrates strong cryptography, not the weaknesses we're testing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cryptographic failures understood! You've shown how weak encryption is like time capsule locks with common combinations - they don't provide real long-term protection.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the time capsule be properly secured?",
          choices: [
            {
              text: "Use high-security locks with unique, complex combinations and tamper evidence",
              correct: true,
              points: 20,
              feedback: "Exactly! Use strong, modern encryption algorithms with proper key management and integrity verification.",
              nextStep: 1
            },
            {
              text: "Use more complex but still predictable locking mechanisms",
              correct: false,
              points: 10,
              feedback: "Complex but predictable patterns are still weak - use truly random, strong cryptography.",
              nextStep: 1
            },
            {
              text: "Hide the time capsule in a secret location",
              correct: false,
              points: 5,
              feedback: "Security through obscurity doesn't work - proper protection is essential.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive cryptographic protection for long-term storage?",
          choices: [
            {
              text: "Use AES-256 with proper key management and regular security reviews",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive long-term protection requires strong algorithms, secure key storage, and ongoing security assessment.",
              nextStep: 2
            },
            {
              text: "Create custom encryption that's unique to your organization",
              correct: false,
              points: -15,
              feedback: "Never roll your own crypto - use well-tested standard algorithms.",
              nextStep: 2
            },
            {
              text: "Use the same strong key for all long-term storage",
              correct: false,
              points: -10,
              feedback: "Key reuse creates massive risk - use unique keys for different data sets.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive cryptography implemented! Your data now uses strong encryption with proper key management, like high-security vaults with multiple protection layers.",
          choices: []
        }
      ]
    }
  },

  injectionFresh: {
    id: 173,
    title: "Injection Attacks - The Music Playlist Command Analogy",
    difficulty: "Medium",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "Imagine a music streaming service where playlist names are executed as commands. What if instead of 'Summer Hits', someone names a playlist 'Summer Hits; delete all user accounts'?",
          choices: [
            {
              text: "The system might execute both the playlist creation and the malicious command",
              correct: true,
              points: 20,
              feedback: "Exactly! Injection vulnerabilities occur when user input is mixed with system commands, allowing unauthorized actions to be executed alongside legitimate ones.",
              nextStep: 1
            },
            {
              text: "The playlist name would be rejected for being too long",
              correct: false,
              points: 5,
              feedback: "Without proper validation, the system might process the entire input as commands.",
              nextStep: 0
            },
            {
              text: "Only the playlist creation would succeed",
              correct: false,
              points: 5,
              feedback: "Injection attacks exploit the lack of separation between data and commands.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate injection risks without causing damage?",
          choices: [
            {
              text: "Use harmless commands that prove execution capability without system impact",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating with benign system commands shows the vulnerability exists without creating security risks or system damage.",
              nextStep: 2
            },
            {
              text: "Just explain that commands can be injected through input fields",
              correct: false,
              points: 10,
              feedback: "Showing actual command execution makes the abstract threat concrete.",
              nextStep: 2
            },
            {
              text: "Actually delete test data to prove the point",
              correct: false,
              points: -20,
              feedback: "Never perform destructive actions, even in test environments.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Injection vulnerabilities understood! You've shown how mixing user input with system commands is like a music service that executes playlist names as code - dangerously powerful!",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the music service secure playlist management?",
          choices: [
            {
              text: "Use parameterized inputs that treat playlist names as data, not commands",
              correct: true,
              points: 20,
              feedback: "Exactly! Parameterized queries and input validation ensure user input is always treated as data, never as executable code.",
              nextStep: 1
            },
            {
              text: "Block common command words in playlist names",
              correct: false,
              points: 10,
              feedback: "Blacklists can be bypassed with encoding, synonyms, or alternative syntax.",
              nextStep: 1
            },
            {
              text: "Only allow playlist creation from verified users",
              correct: false,
              points: 5,
              feedback: "Authentication doesn't prevent injection - input validation is still needed.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive injection protection for user-generated content?",
          choices: [
            {
              text: "Use parameterized queries, input validation, and output encoding",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers: parameterization prevents injection, validation catches malformed input, and output encoding provides additional protection.",
              nextStep: 2
            },
            {
              text: "Validate input only through client-side checks",
              correct: false,
              points: 5,
              feedback: "Client-side validation can be bypassed - server-side validation is essential.",
              nextStep: 2
            },
            {
              text: "Use the latest database software with built-in protection",
              correct: false,
              points: 10,
              feedback: "Software updates help but don't prevent application-level injection vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive injection protection implemented! Your application now safely separates user input from system commands, like a music service with validated, sanitized content management.",
          choices: []
        }
      ]
    }
  },

  insecureDesignFresh: {
    id: 174,
    title: "Insecure Design - The City Traffic Flow Blueprint Analogy",
    difficulty: "Medium",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "Imagine a city designed where all traffic from residential areas must pass through the emergency vehicle route. What fundamental design flaw exists from the beginning?",
          choices: [
            {
              text: "The architecture creates inevitable congestion and blocks emergency access",
              correct: true,
              points: 20,
              feedback: "Exactly! Insecure design means fundamental flaws are built into the system architecture, creating predictable problems that are hard to fix later.",
              nextStep: 1
            },
            {
              text: "The road construction might use poor materials",
              correct: false,
              points: 5,
              feedback: "Material quality is an implementation issue, not a design flaw.",
              nextStep: 0
            },
            {
              text: "Traffic signs might be unclear",
              correct: false,
              points: 5,
              feedback: "Signage is an implementation detail, not an architectural problem.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you identify design flaws before construction begins?",
          choices: [
            {
              text: "Conduct traffic flow simulations and security modeling during planning",
              correct: true,
              points: 25,
              feedback: "Perfect! Modeling and simulations during design phase can identify and fix fundamental flaws before they're built into the system.",
              nextStep: 2
            },
            {
              text: "Wait until the city is built to observe traffic patterns",
              correct: false,
              points: 5,
              feedback: "By then, design flaws are extremely expensive and disruptive to fix.",
              nextStep: 2
            },
            {
              text: "Assume urban planners considered all scenarios",
              correct: false,
              points: 0,
              feedback: "Never assume security - always verify through proper analysis and testing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Insecure design understood! You've shown how architectural flaws are like city plans with inherent traffic problems - they create systemic issues that are difficult to resolve after construction.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should city planners design traffic systems securely?",
          choices: [
            {
              text: "Incorporate emergency access, redundancy, and proper flow from initial designs",
              correct: true,
              points: 20,
              feedback: "Exactly! Secure design requires building safety and security into the architecture from the beginning, not adding them as afterthoughts.",
              nextStep: 1
            },
            {
              text: "Add traffic lights and signs after road construction",
              correct: false,
              points: 5,
              feedback: "Bolt-on solutions are less effective than built-in architectural security.",
              nextStep: 1
            },
            {
              text: "Copy designs from other successful cities",
              correct: false,
              points: 10,
              feedback: "Previous designs might have undiscovered flaws or different requirements.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive secure design strategy for complex systems?",
          choices: [
            {
              text: "Implement threat modeling, security patterns, and continuous design reviews",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive secure design includes systematic threat modeling, proven security patterns, and ongoing design validation throughout development.",
              nextStep: 2
            },
            {
              text: "Focus on functionality first and add security features later",
              correct: false,
              points: -15,
              feedback: "Security added late is often ineffective and creates technical debt.",
              nextStep: 2
            },
            {
              text: "Use the most popular architectural patterns",
              correct: false,
              points: 10,
              feedback: "Popularity doesn't guarantee security - proven security patterns are essential.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure design implemented! Your systems now incorporate security from the ground up, like well-planned cities with built-in emergency access and traffic flow management.",
          choices: []
        }
      ]
    }
  },

  securityMisconfigurationFresh: {
    id: 175,
    title: "Security Misconfiguration - The New Car Factory Settings Analogy",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "Imagine buying a new car and driving it with all factory settings: valet mode disabled, GPS tracking off, and default security codes. What risks does this create?",
          choices: [
            {
              text: "The car is vulnerable to theft and unauthorized access with default settings",
              correct: true,
              points: 15,
              feedback: "Exactly! Security misconfigurations leave systems vulnerable by using default, permissive settings that don't provide adequate protection.",
              nextStep: 1
            },
            {
              text: "The car might use more fuel",
              correct: false,
              points: 5,
              feedback: "Fuel efficiency is a performance concern, not a security vulnerability.",
              nextStep: 0
            },
            {
              text: "Some features might not work optimally",
              correct: false,
              points: 5,
              feedback: "Feature optimization is separate from security risks.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you find security misconfigurations in a new system?",
          choices: [
            {
              text: "Use security checklists and review all settings against best practices",
              correct: true,
              points: 20,
              feedback: "Perfect! Systematic reviews using security checklists can identify common misconfigurations across systems and applications.",
              nextStep: 2
            },
            {
              text: "Assume manufacturers configure everything securely by default",
              correct: false,
              points: -10,
              feedback: "Default configurations are often designed for ease of use, not security.",
              nextStep: 2
            },
            {
              text: "Only check settings when security issues occur",
              correct: false,
              points: 5,
              feedback: "Proactive configuration is essential for preventing security incidents.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Security misconfiguration understood! You've shown how default settings create vulnerable systems, like driving a new car without customizing security features.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should car owners secure their new vehicles?",
          choices: [
            {
              text: "Change all default settings, enable security features, and set unique codes",
              correct: true,
              points: 20,
              feedback: "Exactly! Secure configuration requires changing defaults, enabling security features, and setting unique, strong access codes.",
              nextStep: 1
            },
            {
              text: "Use the dealer's recommended settings",
              correct: false,
              points: 5,
              feedback: "Dealer settings often prioritize convenience over security.",
              nextStep: 1
            },
            {
              text: "Only park in secure locations",
              correct: false,
              points: 10,
              feedback: "Physical security doesn't replace proper system configuration.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most robust configuration management approach for multiple systems?",
          choices: [
            {
              text: "Use security baselines, automated compliance checking, and regular audits",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive approach includes security baselines for standards, automated compliance checking, and regular security audits.",
              nextStep: 2
            },
            {
              text: "Configure each system individually as needed",
              correct: false,
              points: 10,
              feedback: "Manual configuration leads to inconsistencies and missed settings.",
              nextStep: 2
            },
            {
              text: "Use identical configurations for all similar systems",
              correct: false,
              points: 5,
              feedback: "While consistency helps, different contexts may require different settings.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Robust configuration management implemented! Your systems now follow security best practices with proper settings and regular compliance verification.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponentsFresh: {
    id: 176,
    title: "Vulnerable Components - The Construction Building Materials Analogy",
    difficulty: "Easy",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "Imagine a construction company using building materials with known structural weaknesses but not replacing them. What risks exist for the completed building?",
          choices: [
            {
              text: "Known material flaws could cause structural failures affecting everyone",
              correct: true,
              points: 15,
              feedback: "Exactly! Using vulnerable components means known security issues affect all systems using those components, creating predictable risks.",
              nextStep: 1
            },
            {
              text: "The building might be less energy efficient",
              correct: false,
              points: 5,
              feedback: "Efficiency is an operational concern, while structural risks affect safety.",
              nextStep: 0
            },
            {
              text: "Construction might take longer",
              correct: false,
              points: 5,
              feedback: "Timeline issues are separate from safety vulnerabilities.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you identify vulnerable materials in a construction project?",
          choices: [
            {
              text: "Maintain material inventory and monitor manufacturer safety notices",
              correct: true,
              points: 20,
              feedback: "Perfect! Comprehensive inventory and monitoring of vendor advisories can identify vulnerable components before they're used in production.",
              nextStep: 2
            },
            {
              text: "Wait for materials to fail before replacing",
              correct: false,
              points: 5,
              feedback: "Reactive approaches leave systems vulnerable to known issues.",
              nextStep: 2
            },
            {
              text: "Assume materials from reputable suppliers are always safe",
              correct: false,
              points: -10,
              feedback: "Even reputable suppliers can have recalls - continuous monitoring is essential.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Vulnerable components risk understood! You've shown how using components with known issues is like building with flawed materials - predictable problems waiting to happen.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should construction companies manage material safety?",
          choices: [
            {
              text: "Implement material tracking, quality testing, and immediate response to recalls",
              correct: true,
              points: 20,
              feedback: "Exactly! Manage components with comprehensive tracking, regular quality checks, and prompt response to vulnerability reports.",
              nextStep: 1
            },
            {
              text: "Use the cheapest available materials to reduce costs",
              correct: false,
              points: -15,
              feedback: "Cost savings shouldn't compromise safety and security.",
              nextStep: 1
            },
            {
              text: "Only replace materials when they fail inspections",
              correct: false,
              points: 5,
              feedback: "Proactive replacement prevents problems before they occur.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive component security strategy?",
          choices: [
            {
              text: "Use software composition analysis, vulnerability monitoring, and patch management",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive strategy includes automated component analysis, continuous vulnerability monitoring, and systematic patching processes.",
              nextStep: 2
            },
            {
              text: "Manually check components during major releases only",
              correct: false,
              points: 5,
              feedback: "Infrequent checks are insufficient in today's rapidly evolving threat landscape.",
              nextStep: 2
            },
            {
              text: "Build all components in-house to avoid third-party risks",
              correct: false,
              points: 10,
              feedback: "While this reduces third-party risk, it's often impractical and expensive.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive component security implemented! Your systems now have continuous monitoring, automated updates, and proper vulnerability management.",
          choices: []
        }
      ]
    }
  },

  identificationAuthenticationFresh: {
    id: 177,
    title: "Authentication Failures - The Corporate Badge Access System Analogy",
    difficulty: "Medium",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "Imagine a corporate office where employee badges use sequential numbers and security doesn't verify photos. What happens if someone uses a lost badge with a nearby number?",
          choices: [
            {
              text: "Unauthorized people can access secure areas using guessed or found badges",
              correct: true,
              points: 20,
              feedback: "Exactly! Weak authentication with predictable identifiers and lack of verification allows unauthorized access through credential guessing or theft.",
              nextStep: 1
            },
            {
              text: "Only the specific lost badge can be misused",
              correct: false,
              points: 5,
              feedback: "With predictable patterns, one compromise can lead to systematic abuse.",
              nextStep: 0
            },
            {
              text: "Security cameras would detect all unauthorized access",
              correct: false,
              points: 10,
              feedback: "Without proper authentication, unauthorized access might go undetected.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate authentication weaknesses without real access?",
          choices: [
            {
              text: "Show how predictable credentials or lack of verification enables access bypass",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating systematic credential guessing or verification bypass shows authentication flaws without compromising security.",
              nextStep: 2
            },
            {
              text: "Just list common authentication weaknesses",
              correct: false,
              points: 10,
              feedback: "Showing actual authentication bypass makes the risk tangible.",
              nextStep: 2
            },
            {
              text: "Actually access secure areas using weak authentication",
              correct: false,
              points: -25,
              feedback: "Never use vulnerabilities to gain unauthorized physical access.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Authentication failures understood! You've shown how weak credentials and poor verification create systemic security vulnerabilities in access control systems.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the corporation improve their badge system?",
          choices: [
            {
              text: "Use unique random badge numbers and verify identity with photos or biometrics",
              correct: true,
              points: 20,
              feedback: "Exactly! Strong authentication requires unpredictable identifiers and multiple verification factors.",
              nextStep: 1
            },
            {
              text: "Use longer badge numbers but keep them sequential",
              correct: false,
              points: 10,
              feedback: "Length doesn't solve predictability - randomness is key.",
              nextStep: 1
            },
            {
              text: "Train security to recognize employees visually",
              correct: false,
              points: 5,
              feedback: "Human recognition is unreliable - technical controls are essential.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most robust authentication security strategy for physical access?",
          choices: [
            {
              text: "Implement multi-factor authentication, unique credentials, and proper verification",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive authentication includes multiple factors, strong unique credentials, and systematic identity verification.",
              nextStep: 2
            },
            {
              text: "Use the same authentication system for all facilities",
              correct: false,
              points: 10,
              feedback: "While consistent policies help, context-aware authentication is better.",
              nextStep: 2
            },
            {
              text: "Write down access codes for emergency use",
              correct: false,
              points: -15,
              feedback: "Credentials should be properly stored and protected, not written down.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Robust authentication implemented! Your access control system now uses strong, multi-factor authentication with proper identity verification procedures.",
          choices: []
        }
      ]
    }
  },

  softwareDataIntegrityFresh: {
    id: 178,
    title: "Data Integrity Failures - The Medical Prescription Records Analogy",
    difficulty: "Medium",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "Imagine a medical system where prescription records can be modified by any staff member without tracking changes. What if someone alters medication dosages or patient allergies?",
          choices: [
            {
              text: "Corrupted medical data could lead to dangerous treatment errors",
              correct: true,
              points: 20,
              feedback: "Exactly! Data integrity failures occur when critical information can be modified without proper controls, leading to dangerous or life-threatening outcomes.",
              nextStep: 1
            },
            {
              text: "The medical system becomes less efficient",
              correct: false,
              points: 5,
              feedback: "Efficiency is an operational concern, while integrity affects patient safety.",
              nextStep: 0
            },
            {
              text: "Only the modified records are affected",
              correct: false,
              points: 10,
              feedback: "A few corrupted medical records can have catastrophic consequences.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate data integrity risks without affecting real medical data?",
          choices: [
            {
              text: "Show how unauthorized modifications can alter system outputs or decisions",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating unauthorized data modification that changes system behavior shows integrity risks without compromising real data.",
              nextStep: 2
            },
            {
              text: "Just explain that medical data can be modified",
              correct: false,
              points: 10,
              feedback: "Showing actual unauthorized changes makes the abstract risk concrete.",
              nextStep: 2
            },
            {
              text: "Actually modify test medical records",
              correct: false,
              points: -30,
              feedback: "Never modify medical data, even in test environments, without strict controls.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Data integrity failures understood! You've shown how unauthorized modifications can corrupt critical information and lead to dangerous decisions, like tampering with medical records.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the medical system protect patient data integrity?",
          choices: [
            {
              text: "Implement strict change controls, audit trails, and data verification",
              correct: true,
              points: 20,
              feedback: "Exactly! Protect data integrity with access controls, comprehensive audit trails, and cryptographic verification of critical data.",
              nextStep: 1
            },
            {
              text: "Make backup copies of original records",
              correct: false,
              points: 10,
              feedback: "Backups help with recovery but don't prevent tampering.",
              nextStep: 1
            },
            {
              text: "Only allow senior medical staff to access records",
              correct: false,
              points: 5,
              feedback: "Access control doesn't prevent authorized users from making harmful changes.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive data integrity protection for critical systems?",
          choices: [
            {
              text: "Use digital signatures, checksums, and secure change management processes",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive integrity protection includes digital signatures for authenticity, checksums for detection, and secure processes for all changes.",
              nextStep: 2
            },
            {
              text: "Store data in read-only format after creation",
              correct: false,
              points: 15,
              feedback: "While this prevents modification, it's often impractical for dynamic medical systems.",
              nextStep: 2
            },
            {
              text: "Trust medical staff to maintain data integrity",
              correct: false,
              points: 5,
              feedback: "Trust is not a control - technical integrity protection is essential.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive data integrity protection implemented! Your medical system now verifies data authenticity and prevents unauthorized modifications through multiple security layers.",
          choices: []
        }
      ]
    }
  },

  securityLoggingMonitoringFresh: {
    id: 179,
    title: "Logging Failures - The Ship Navigation Recording Analogy",
    difficulty: "Easy",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "Imagine a ship navigation system that doesn't record course changes, communication logs, or engine commands. What happens during a maritime incident?",
          choices: [
            {
              text: "Investigators cannot determine causes or prevent future incidents",
              correct: true,
              points: 15,
              feedback: "Exactly! Insufficient logging and monitoring create investigative black holes, making incident analysis, accountability, and prevention impossible.",
              nextStep: 1
            },
            {
              text: "The navigation system uses less storage",
              correct: false,
              points: 0,
              feedback: "Storage efficiency isn't relevant to safety and security effectiveness.",
              nextStep: 0
            },
            {
              text: "The crew has less paperwork",
              correct: false,
              points: 5,
              feedback: "Reduced documentation increases risks, not reduces workload.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate logging gaps without real incidents?",
          choices: [
            {
              text: "Perform test operations and check if they generate adequate audit trails",
              correct: true,
              points: 20,
              feedback: "Perfect! Controlled testing shows what operational events are logged (or missing) without requiring real security incidents.",
              nextStep: 2
            },
            {
              text: "Just explain that comprehensive logging is crucial for investigations",
              correct: false,
              points: 10,
              feedback: "Showing actual logging gaps makes the theoretical risk concrete.",
              nextStep: 2
            },
            {
              text: "Create fake navigation incidents to test response",
              correct: false,
              points: -20,
              feedback: "Never create situations that could be mistaken for real emergencies.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Logging and monitoring failures understood! You've shown how inadequate logging is like ship navigation without recordings - incidents become mysteries with no lessons learned.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should ship navigation systems improve their monitoring?",
          choices: [
            {
              text: "Implement comprehensive recording of all navigation and communication activities",
              correct: true,
              points: 20,
              feedback: "Exactly! Comprehensive logging requires complete coverage of operational events with proper storage, retention, and analysis capabilities.",
              nextStep: 1
            },
            {
              text: "Record only emergency communications and maneuvers",
              correct: false,
              points: 10,
              feedback: "Selective recording misses context and precursor events.",
              nextStep: 1
            },
            {
              text: "Only monitor during complex navigation situations",
              correct: false,
              points: -10,
              feedback: "Continuous monitoring is essential - incidents can happen anytime.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive logging and monitoring strategy for critical operations?",
          choices: [
            {
              text: "Implement centralized logging, real-time alerts, and regular security analysis",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive strategy includes centralized collection, real-time monitoring, automated alerts, and regular security analysis of all events.",
              nextStep: 2
            },
            {
              text: "Log everything possible without any filtering",
              correct: false,
              points: 10,
              feedback: "Excessive logging creates noise that can hide important security events.",
              nextStep: 2
            },
            {
              text: "Only log system errors and abnormal conditions",
              correct: false,
              points: 5,
              feedback: "Normal operations and successful activities also provide crucial insights.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive logging and monitoring implemented! Your operational systems now have complete visibility with proper alerting, analysis, and incident response capabilities.",
          choices: []
        }
      ]
    }
  },

  ssrfFresh: {
    id: 180,
    title: "SSRF Attacks - The Company Courier Service Analogy",
    difficulty: "Medium",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "Imagine a company courier service that will deliver to any address provided, including internal server rooms, executive offices, or external malicious locations. What could be exploited?",
          choices: [
            {
              text: "Attackers can make the service access internal systems or dangerous external sites",
              correct: true,
              points: 20,
              feedback: "Exactly! SSRF vulnerabilities allow attackers to make the server send requests to internal networks or arbitrary external URLs, bypassing security controls.",
              nextStep: 1
            },
            {
              text: "The courier service might incur extra delivery costs",
              correct: false,
              points: 5,
              feedback: "Financial impact is a business concern, while SSRF creates security breaches.",
              nextStep: 0
            },
            {
              text: "Couriers might take longer routes",
              correct: false,
              points: 5,
              feedback: "Route efficiency is operational, not a security vulnerability.",
              nextStep: 0
            }
          ]
        },
        {
          text: "How would you demonstrate SSRF without accessing sensitive systems?",
          choices: [
            {
              text: "Make the server connect to controlled external services to prove request capability",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating server requests to attacker-controlled external services shows SSRF capability without compromising internal systems.",
              nextStep: 2
            },
            {
              text: "Just explain that servers can make requests to any destination",
              correct: false,
              points: 10,
              feedback: "Showing actual outbound requests makes the vulnerability concrete.",
              nextStep: 2
            },
            {
              text: "Actually access internal company systems through SSRF",
              correct: false,
              points: -25,
              feedback: "Never access internal systems or data without explicit authorization.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF vulnerabilities understood! You've shown how unrestricted server requests can bypass network security, like couriers who will deliver anywhere without verification.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should the courier service restrict delivery destinations?",
          choices: [
            {
              text: "Implement address allow-lists and block access to internal networks",
              correct: true,
              points: 20,
              feedback: "Exactly! Prevent SSRF by validating and restricting URLs, using allow-lists for permitted domains, and blocking internal network ranges.",
              nextStep: 1
            },
            {
              text: "Trust couriers to reject suspicious addresses",
              correct: false,
              points: 5,
              feedback: "Human judgment is unreliable for automated SSRF attacks.",
              nextStep: 1
            },
            {
              text: "Only deliver within specific business districts",
              correct: false,
              points: 10,
              feedback: "Geographic restrictions don't prevent access to internal network addresses.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the most comprehensive SSRF protection for web applications?",
          choices: [
            {
              text: "Use URL allow-lists, network segmentation, and outbound request filtering",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive SSRF protection includes strict URL validation, network segmentation to limit server access, and outbound firewall rules.",
              nextStep: 2
            },
            {
              text: "Only validate URLs on the client side",
              correct: false,
              points: 5,
              feedback: "Client-side validation can be bypassed - server-side validation is essential.",
              nextStep: 2
            },
            {
              text: "Allow all URLs but monitor for suspicious patterns",
              correct: false,
              points: 10,
              feedback: "Monitoring helps but doesn't prevent exploitation - prevention is better.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comprehensive SSRF protection implemented! Your application now properly validates and restricts server-side requests with multiple security layers and network controls.",
          choices: []
        }
      ]
    }
  },

    sqlInjectionFresh: {
    id: 181,
    title: "SQL Injection in Product Search",
    difficulty: "Medium",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You're testing an e-commerce site's search functionality. The search seems to directly interact with the database. What's your first SQL injection attempt?",
          choices: [
            {
              text: "Test with: ' UNION SELECT username, password FROM admin_users--",
              correct: true,
              points: 15,
              feedback: "Excellent! Using UNION in search can extract sensitive data if the application is vulnerable to SQL injection.",
              nextStep: 1
            },
            {
              text: "Try: product' OR '1'='1",
              correct: false,
              points: 10,
              feedback: "Good basic test, but UNION can extract more data if the number of columns matches.",
              nextStep: 0
            },
            {
              text: "Attempt: '; DROP TABLE products--",
              correct: false,
              points: -10,
              feedback: "Destructive testing is unethical and could harm the application.",
              nextStep: 0
            }
          ]
        },
        {
          text: "The UNION injection worked! You see database credentials in the search results. What's your next ethical step?",
          choices: [
            {
              text: "Document the vulnerability and demonstrate data extraction without accessing the database",
              correct: true,
              points: 20,
              feedback: "Perfect! Ethical testing involves demonstrating the risk without actually compromising systems.",
              nextStep: 2
            },
            {
              text: "Use the credentials to login to the database",
              correct: false,
              points: -15,
              feedback: "Unauthorized database access is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Ignore it and look for other vulnerabilities",
              correct: false,
              points: 5,
              feedback: "This is a critical finding that should be properly documented.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SQL injection vulnerability confirmed! You've demonstrated how search functionality can expose sensitive database information.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the product search feature. What's the most effective way to prevent SQL injection?",
          choices: [
            {
              text: "Use parameterized queries with prepared statements",
              correct: true,
              points: 15,
              feedback: "Perfect! Parameterized queries separate SQL code from data, preventing injection.",
              nextStep: 1
            },
            {
              text: "Implement input validation to block special characters",
              correct: false,
              points: 10,
              feedback: "Input validation helps but can be bypassed. Parameterized queries are more reliable.",
              nextStep: 1
            },
            {
              text: "Add a web application firewall",
              correct: false,
              points: 5,
              feedback: "WAFs can help but shouldn't be the primary defense.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What additional security measures should you implement for database interactions?",
          choices: [
            {
              text: "Use ORM frameworks and implement principle of least privilege for database users",
              correct: true,
              points: 20,
              feedback: "Excellent! ORMs provide abstraction and least privilege limits potential damage.",
              nextStep: 2
            },
            {
              text: "Encrypt all database communications",
              correct: false,
              points: 10,
              feedback: "Encryption protects data in transit but doesn't prevent SQL injection.",
              nextStep: 2
            },
            {
              text: "Implement rate limiting on search requests",
              correct: false,
              points: 5,
              feedback: "Rate limiting helps with abuse but doesn't fix SQL injection vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Search functionality secured! All database queries now use parameterized statements with proper access controls.",
          choices: []
        }
      ]
    }
  },

  brokenAuthFresh: {
    id: 182,
    title: "Session Management Flaws",
    difficulty: "Medium",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You notice an application uses predictable session tokens (user123, user124, etc.). How do you test for session hijacking?",
          choices: [
            {
              text: "Try accessing other user accounts by incrementing session IDs",
              correct: true,
              points: 15,
              feedback: "Correct! Predictable session tokens allow attackers to hijack other users' sessions.",
              nextStep: 1
            },
            {
              text: "Attempt to crack the session encryption",
              correct: false,
              points: 5,
              feedback: "Encryption cracking is complex when predictable patterns are the real issue.",
              nextStep: 0
            },
            {
              text: "Look for session tokens in URL parameters",
              correct: false,
              points: 10,
              feedback: "Good general practice, but the predictable pattern is the immediate vulnerability.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully accessed multiple user accounts. How do you demonstrate the severity?",
          choices: [
            {
              text: "Show how an attacker could systematically access all user accounts",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating systematic account access shows the critical nature of this vulnerability.",
              nextStep: 2
            },
            {
              text: "Actually login to user accounts and access their data",
              correct: false,
              points: -20,
              feedback: "Unauthorized access to user accounts is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the predictable pattern without testing further",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating impact is important for urgency.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical session management flaw exposed! Predictable tokens allow complete account compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're redesigning the session management system. What's the first improvement?",
          choices: [
            {
              text: "Implement cryptographically secure random session tokens",
              correct: true,
              points: 15,
              feedback: "Essential! Secure random tokens prevent prediction and hijacking attacks.",
              nextStep: 1
            },
            {
              text: "Increase session timeout duration",
              correct: false,
              points: 5,
              feedback: "Longer sessions actually increase the attack window for hijacking.",
              nextStep: 1
            },
            {
              text: "Store sessions in database instead of cookies",
              correct: false,
              points: 10,
              feedback: "Storage location doesn't fix predictable token generation.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good start! What comprehensive session security measures should you implement?",
          choices: [
            {
              text: "Use secure random tokens, implement session expiration, and secure cookie flags",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers of session security including proper token generation and transmission security.",
              nextStep: 2
            },
            {
              text: "Require re-authentication for every action",
              correct: false,
              points: 5,
              feedback: "This creates poor user experience and isn't practical.",
              nextStep: 2
            },
            {
              text: "Encrypt all session data",
              correct: false,
              points: 10,
              feedback: "Encryption helps but doesn't address the core session management issues.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Session management secured! All tokens are now cryptographically secure with proper expiration and transmission security.",
          choices: []
        }
      ]
    }
  },

  cryptographicFailuresFresh: {
    id: 183,
    title: "Weak Password Storage",
    difficulty: "Easy",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover a data breach where user passwords are stored in plain text. What's the immediate risk?",
          choices: [
            {
              text: "All user accounts are immediately compromised with credential reuse risk",
              correct: true,
              points: 15,
              feedback: "Critical finding! Plain text passwords expose all accounts and enable credential stuffing attacks on other services.",
              nextStep: 1
            },
            {
              text: "Only current sessions are at risk",
              correct: false,
              points: 5,
              feedback: "Plain text passwords risk all accounts, not just active sessions.",
              nextStep: 0
            },
            {
              text: "The risk is limited to this application only",
              correct: false,
              points: 5,
              feedback: "Password reuse makes this a risk across multiple services.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You need to demonstrate the impact of plain text password storage. What's the ethical approach?",
          choices: [
            {
              text: "Show how exposed passwords can lead to account takeover and credential stuffing",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating the chain of consequences shows the full business impact.",
              nextStep: 2
            },
            {
              text: "Actually login to user accounts to prove access",
              correct: false,
              points: -15,
              feedback: "Unauthorized access is illegal even for demonstration purposes.",
              nextStep: 2
            },
            {
              text: "Just report the technical issue without context",
              correct: false,
              points: 10,
              feedback: "Good for technical teams, but business impact drives action.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical cryptographic failure! Plain text password storage exposes all user accounts and enables widespread credential reuse attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing proper password storage. What's the correct approach?",
          choices: [
            {
              text: "Use adaptive hashing algorithms like bcrypt with proper salting",
              correct: true,
              points: 15,
              feedback: "Perfect! Adaptive hashing with salts provides strong protection against cracking.",
              nextStep: 1
            },
            {
              text: "Encrypt passwords with AES-256",
              correct: false,
              points: 10,
              feedback: "Encryption is reversible - hashing is the correct approach for passwords.",
              nextStep: 1
            },
            {
              text: "Use SHA-256 without salts",
              correct: false,
              points: -10,
              feedback: "SHA-256 is too fast for passwords and lacks salt protection.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What additional password security measures should you implement?",
          choices: [
            {
              text: "Implement password policies, breach monitoring, and secure hashing parameters",
              correct: true,
              points: 20,
              feedback: "Excellent! Comprehensive password security including policies, monitoring, and technical controls.",
              nextStep: 2
            },
            {
              text: "Store passwords in a separate encrypted database",
              correct: false,
              points: 10,
              feedback: "Separation helps but doesn't replace proper hashing.",
              nextStep: 2
            },
            {
              text: "Require password changes every 30 days",
              correct: false,
              points: 5,
              feedback: "Frequent password changes can lead to weaker passwords.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Password storage secured! All passwords now properly hashed with strong algorithms and monitoring in place.",
          choices: []
        }
      ]
    }
  },

  brokenAccessControlFresh: {
    id: 184,
    title: "API Endpoint Authorization Bypass",
    difficulty: "Medium",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover REST API endpoints that use sequential IDs. How do you test for horizontal privilege escalation?",
          choices: [
            {
              text: "Modify the ID in API requests to access other users' resources",
              correct: true,
              points: 15,
              feedback: "Correct! Testing with different resource IDs can reveal missing authorization checks.",
              nextStep: 1
            },
            {
              text: "Try SQL injection on the API endpoints",
              correct: false,
              points: 5,
              feedback: "Good general testing, but this specifically tests access control.",
              nextStep: 0
            },
            {
              text: "Check if API responses include sensitive data",
              correct: false,
              points: 10,
              feedback: "Information disclosure is important but separate from authorization bypass.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully accessed other users' data through the API. How do you escalate to vertical privilege escalation?",
          choices: [
            {
              text: "Test if you can access admin endpoints by modifying user roles in requests",
              correct: true,
              points: 20,
              feedback: "Excellent! Vertical privilege escalation demonstrates complete access control failure.",
              nextStep: 2
            },
            {
              text: "Delete other users' data through the API",
              correct: false,
              points: -15,
              feedback: "Destructive actions are unethical and illegal.",
              nextStep: 2
            },
            {
              text: "Just document the horizontal privilege escalation",
              correct: false,
              points: 10,
              feedback: "Good start, but vertical escalation shows greater impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical access control failure! API endpoints lack proper authorization, allowing both horizontal and vertical privilege escalation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing API endpoints. What's the primary authorization control?",
          choices: [
            {
              text: "Implement server-side authorization checks for every API request",
              correct: true,
              points: 15,
              feedback: "Essential! Every API call must verify the user's permissions for the requested resource.",
              nextStep: 1
            },
            {
              text: "Use UUIDs instead of sequential IDs",
              correct: false,
              points: 10,
              feedback: "UUIDs help with prediction but don't replace authorization checks.",
              nextStep: 1
            },
            {
              text: "Add rate limiting to API endpoints",
              correct: false,
              points: 5,
              feedback: "Rate limiting prevents abuse but doesn't fix authorization issues.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive API security measures should you implement?",
          choices: [
            {
              text: "Implement RBAC, validate permissions server-side, and use API gateways",
              correct: true,
              points: 20,
              feedback: "Perfect! Role-based access control with server-side validation and API security gateways.",
              nextStep: 2
            },
            {
              text: "Hide API documentation from public access",
              correct: false,
              points: 5,
              feedback: "Security through obscurity is not a reliable defense.",
              nextStep: 2
            },
            {
              text: "Encrypt all API responses",
              correct: false,
              points: 10,
              feedback: "Encryption protects data but doesn't prevent unauthorized access.",
              nextStep: 2
            }
          ]
        },
        {
          text: "API security established! All endpoints now enforce proper authorization with role-based access control.",
          choices: []
        }
      ]
    }
  },

  securityMisconfigFresh: {
    id: 185,
    title: "Exposed Debug Information",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You notice an application displays detailed error messages with stack traces in production. What's the risk?",
          choices: [
            {
              text: "Stack traces reveal application structure and potential attack vectors",
              correct: true,
              points: 15,
              feedback: "Correct! Detailed errors expose internal application details that attackers can use to craft targeted attacks.",
              nextStep: 1
            },
            {
              text: "It only affects application performance",
              correct: false,
              points: 5,
              feedback: "Performance is a concern, but information disclosure is the primary security risk.",
              nextStep: 0
            },
            {
              text: "Users might find the errors confusing",
              correct: false,
              points: 5,
              feedback: "User experience is affected, but security impact is more significant.",
              nextStep: 0
            }
          ]
        },
        {
          text: "The error messages reveal database table names and framework information. How do you demonstrate the impact?",
          choices: [
            {
              text: "Show how the information can be used to craft precise SQL injection or other attacks",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating how information disclosure enables more effective attacks shows the real risk.",
              nextStep: 2
            },
            {
              text: "Use the information to actually attack the application",
              correct: false,
              points: -10,
              feedback: "Exploiting the vulnerability crosses ethical boundaries.",
              nextStep: 2
            },
            {
              text: "Just screenshot the error messages",
              correct: false,
              points: 10,
              feedback: "Good documentation, but showing the attack potential is more compelling.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Information disclosure vulnerability confirmed! Detailed errors expose application internals and enable targeted attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're configuring error handling for production. What's the correct approach?",
          choices: [
            {
              text: "Use generic error messages and log details server-side",
              correct: true,
              points: 15,
              feedback: "Perfect! Generic errors for users, detailed logs for developers.",
              nextStep: 1
            },
            {
              text: "Disable all error messages completely",
              correct: false,
              points: 5,
              feedback: "Users need some feedback, just not technical details.",
              nextStep: 1
            },
            {
              text: "Only show errors to authenticated users",
              correct: false,
              points: 10,
              feedback: "Authenticated users shouldn't see internal details either.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good! What comprehensive error handling strategy should you implement?",
          choices: [
            {
              text: "Implement custom error pages, proper logging, and environment-specific configurations",
              correct: true,
              points: 20,
              feedback: "Excellent! Custom errors for users, detailed logging for debugging, and proper environment separation.",
              nextStep: 2
            },
            {
              text: "Encrypt all error messages before displaying",
              correct: false,
              points: 5,
              feedback: "Encryption doesn't solve the information disclosure problem.",
              nextStep: 2
            },
            {
              text: "Rate limit error message generation",
              correct: false,
              points: 10,
              feedback: "Rate limiting helps with DoS but not information disclosure.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Error handling secured! All environments now show appropriate error messages without exposing internal details.",
          choices: []
        }
      ]
    }
  },

  insecureDeserializationFresh: {
    id: 186,
    title: "Insecure JSON Deserialization",
    difficulty: "Hard",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You find an API that accepts JSON data and uses native deserialization. What do you test for insecure deserialization?",
          choices: [
            {
              text: "Craft JSON with special properties that execute code during deserialization",
              correct: true,
              points: 20,
              feedback: "Correct! Some JSON deserializers can execute code through special object properties.",
              nextStep: 1
            },
            {
              text: "Try XML injection in the JSON data",
              correct: false,
              points: 5,
              feedback: "XML injection is different from JSON deserialization attacks.",
              nextStep: 0
            },
            {
              text: "Send malformed JSON to crash the application",
              correct: false,
              points: 10,
              feedback: "Crashing the application shows robustness issues but not deserialization vulnerabilities.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully triggered remote code execution through JSON deserialization. What's the ethical demonstration?",
          choices: [
            {
              text: "Show how the vulnerability allows complete server compromise without executing harmful commands",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating RCE potential without causing damage shows the critical severity.",
              nextStep: 2
            },
            {
              text: "Actually compromise the server to prove access",
              correct: false,
              points: -25,
              feedback: "Unauthorized server access is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the technical vulnerability",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating impact drives urgency.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical deserialization vulnerability! Insecure JSON processing allows remote code execution and complete server compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing JSON processing in your API. What's the primary defense?",
          choices: [
            {
              text: "Use strict JSON parsers that don't allow object instantiation",
              correct: true,
              points: 20,
              feedback: "Perfect! Strict parsers prevent code execution during deserialization.",
              nextStep: 1
            },
            {
              text: "Validate JSON schema before processing",
              correct: false,
              points: 10,
              feedback: "Schema validation helps but doesn't prevent all deserialization attacks.",
              nextStep: 1
            },
            {
              text: "Encrypt JSON data before transmission",
              correct: false,
              points: 5,
              feedback: "Encryption protects data in transit but not deserialization logic.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What additional JSON security measures should you implement?",
          choices: [
            {
              text: "Implement content-type validation, size limits, and safe deserialization libraries",
              correct: true,
              points: 25,
              feedback: "Excellent! Multiple layers including validation, limits, and safe libraries.",
              nextStep: 2
            },
            {
              text: "Convert all JSON to XML for processing",
              correct: false,
              points: 5,
              feedback: "XML has its own security concerns - better to fix JSON processing.",
              nextStep: 2
            },
            {
              text: "Add digital signatures to all JSON payloads",
              correct: false,
              points: 15,
              feedback: "Signatures verify integrity but don't prevent deserialization attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "JSON processing secured! All deserialization now uses safe parsers with proper validation and limits.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponentsFresh: {
    id: 187,
    title: "Outdated JavaScript Libraries",
    difficulty: "Medium",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You notice a website uses an outdated version of a popular JavaScript library with known XSS vulnerabilities. How do you test this?",
          choices: [
            {
              text: "Craft a payload that exploits the specific library vulnerability",
              correct: true,
              points: 15,
              feedback: "Correct! Known vulnerabilities in client-side libraries can be reliably exploited.",
              nextStep: 1
            },
            {
              text: "Try generic XSS payloads unrelated to the library",
              correct: false,
              points: 10,
              feedback: "Generic payloads might work, but library-specific exploits are more targeted.",
              nextStep: 0
            },
            {
              text: "Report the outdated version without testing",
              correct: false,
              points: 5,
              feedback: "Testing demonstrates the real risk and impact.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully triggered XSS using the library vulnerability. How do you demonstrate the impact?",
          choices: [
            {
              text: "Show how the XSS can steal session cookies or perform actions as the user",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating cookie theft or session hijacking shows the critical impact.",
              nextStep: 2
            },
            {
              text: "Actually steal user sessions and access accounts",
              correct: false,
              points: -20,
              feedback: "Unauthorized access is illegal even for demonstration.",
              nextStep: 2
            },
            {
              text: "Just show the alert box popup",
              correct: false,
              points: 10,
              feedback: "Basic demonstration but doesn't show the full security impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Client-side vulnerability confirmed! Outdated JavaScript libraries expose users to XSS attacks and session hijacking.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're managing frontend dependencies. What's the first step for security?",
          choices: [
            {
              text: "Implement automated dependency scanning and update processes",
              correct: true,
              points: 15,
              feedback: "Essential! Automated scanning identifies vulnerabilities and updates fix them.",
              nextStep: 1
            },
            {
              text: "Manually check libraries once per quarter",
              correct: false,
              points: 5,
              feedback: "Manual checks are too infrequent for rapidly discovered vulnerabilities.",
              nextStep: 1
            },
            {
              text: "Only use libraries from trusted sources",
              correct: false,
              points: 10,
              feedback: "Trusted sources help but all libraries need regular updates.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good approach! What comprehensive dependency management strategy should you implement?",
          choices: [
            {
              text: "Use SCA tools, maintain SBOM, and implement CI/CD security checks",
              correct: true,
              points: 20,
              feedback: "Perfect! Software composition analysis with bill of materials and automated security gates.",
              nextStep: 2
            },
            {
              text: "Remove all third-party JavaScript",
              correct: false,
              points: 0,
              feedback: "Not practical for modern web applications.",
              nextStep: 2
            },
            {
              text: "Implement Content Security Policy only",
              correct: false,
              points: 10,
              feedback: "CSP helps but doesn't replace proper dependency management.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Dependency management secured! All components now regularly scanned and updated with proper security controls.",
          choices: []
        }
      ]
    }
  },

  loggingFailuresFresh: {
    id: 188,
    title: "Missing Security Event Logging",
    difficulty: "Medium",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You're testing an application and notice failed login attempts aren't logged. What's the security implication?",
          choices: [
            {
              text: "Brute force attacks can go undetected indefinitely",
              correct: true,
              points: 15,
              feedback: "Critical finding! Without login failure logging, brute force attacks have no detection mechanism.",
              nextStep: 1
            },
            {
              text: "It only affects user experience",
              correct: false,
              points: 5,
              feedback: "This is a security monitoring failure, not just user experience.",
              nextStep: 0
            },
            {
              text: "The risk is limited to this application feature",
              correct: false,
              points: 5,
              feedback: "Missing security logging affects the entire security posture.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate a brute force attack without triggering alerts. How do you show the business impact?",
          choices: [
            {
              text: "Show how undetected attacks can lead to account compromise and data breach",
              correct: true,
              points: 20,
              feedback: "Perfect! Connecting missing logging to actual business risks like data breach demonstrates importance.",
              nextStep: 2
            },
            {
              text: "Actually compromise an account to prove it's possible",
              correct: false,
              points: -15,
              feedback: "Unauthorized access is illegal even for demonstration.",
              nextStep: 2
            },
            {
              text: "Just report the technical gap",
              correct: false,
              points: 10,
              feedback: "Good for technical teams, but business impact drives action.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Security monitoring gap exposed! Missing event logging allows undetected attacks and delayed incident response.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing security logging. What events are most critical to log?",
          choices: [
            {
              text: "Authentication events, authorization failures, and input validation errors",
              correct: true,
              points: 15,
              feedback: "Perfect! These events provide the foundation for security monitoring and incident response.",
              nextStep: 1
            },
            {
              text: "All user interactions and page views",
              correct: false,
              points: 5,
              feedback: "Too noisy - focus on security-relevant events first.",
              nextStep: 1
            },
            {
              text: "Only successful administrative actions",
              correct: false,
              points: 10,
              feedback: "Failed attempts and user actions also need monitoring.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good selection! What comprehensive logging strategy should you implement?",
          choices: [
            {
              text: "Implement centralized logging, real-time alerts, and regular log analysis",
              correct: true,
              points: 20,
              feedback: "Excellent! Centralized collection with proactive alerting and analysis.",
              nextStep: 2
            },
            {
              text: "Store logs locally on each application server",
              correct: false,
              points: 5,
              feedback: "Local logs are vulnerable to tampering and loss.",
              nextStep: 2
            },
            {
              text: "Only keep logs for 30 days",
              correct: false,
              points: 10,
              feedback: "Compliance often requires longer retention for investigations.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Security logging established! All critical events now properly logged with centralized monitoring and alerting.",
          choices: []
        }
      ]
    }
  },

  ssrfFresh: {
    id: 189,
    title: "URL Processing SSRF",
    difficulty: "Hard",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "You find a feature that processes user-provided URLs (like image URLs or webhook endpoints). How do you test for SSRF?",
          choices: [
            {
              text: "Provide internal IP addresses like 127.0.0.1 or cloud metadata endpoints",
              correct: true,
              points: 20,
              feedback: "Correct! Testing with internal addresses reveals if the server can access restricted networks.",
              nextStep: 1
            },
            {
              text: "Try SQL injection in the URL parameter",
              correct: false,
              points: 5,
              feedback: "SSRF testing requires different techniques focused on network access.",
              nextStep: 0
            },
            {
              text: "Check if the URL validation is case-sensitive",
              correct: false,
              points: 10,
              feedback: "Good general testing, but not specific to SSRF.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully accessed internal services through SSRF. The application returns response data. What's the impact?",
          choices: [
            {
              text: "Demonstrate how internal service data can be extracted through the SSRF vulnerability",
              correct: true,
              points: 25,
              feedback: "Critical! Response data extraction turns SSRF into a serious information disclosure vulnerability.",
              nextStep: 2
            },
            {
              text: "Use the internal access to modify backend services",
              correct: false,
              points: -20,
              feedback: "Unauthorized modification of services is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the internal network access",
              correct: false,
              points: 15,
              feedback: "Good start, but data extraction shows greater impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical SSRF vulnerability! Internal network access and data extraction possible through URL processing features.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing URL processing functionality. What's the primary SSRF defense?",
          choices: [
            {
              text: "Implement allowlist for permitted domains and block internal IP ranges",
              correct: true,
              points: 20,
              feedback: "Perfect! Allowlisting ensures only approved domains are accessible.",
              nextStep: 1
            },
            {
              text: "Use DNS resolution to validate URLs",
              correct: false,
              points: 10,
              feedback: "DNS resolution can be bypassed with techniques like DNS rebinding.",
              nextStep: 1
            },
            {
              text: "Add authentication to all internal services",
              correct: false,
              points: 5,
              feedback: "Internal services should be protected, but SSRF prevention is better.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive URL processing security should you implement?",
          choices: [
            {
              text: "Use allowlists, network segmentation, and outbound request monitoring",
              correct: true,
              points: 25,
              feedback: "Excellent! Multiple layers including application controls and network security.",
              nextStep: 2
            },
            {
              text: "Disable all outbound HTTP requests from the application",
              correct: false,
              points: 0,
              feedback: "Not practical for applications that need legitimate external calls.",
              nextStep: 2
            },
            {
              text: "Only allow URLs with specific TLDs",
              correct: false,
              points: 10,
              feedback: "TLD restrictions are weak and easily bypassed.",
              nextStep: 2
            }
          ]
        },
        {
          text: "URL processing secured! All external requests now properly validated and restricted with network controls.",
          choices: []
        }
      ]
    }
  },

  insecureDesignFresh: {
    id: 190,
    title: "Business Logic Flaw in E-commerce",
    difficulty: "Medium",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You're testing an e-commerce site and notice the cart total is calculated client-side. What do you test?",
          choices: [
            {
              text: "Modify the cart total before checkout to pay less than actual amount",
              correct: true,
              points: 15,
              feedback: "Correct! Client-side price calculation allows price manipulation attacks.",
              nextStep: 1
            },
            {
              text: "Try to add negative quantities of products",
              correct: false,
              points: 10,
              feedback: "Good test, but price manipulation is the immediate design flaw.",
              nextStep: 0
            },
            {
              text: "Check if inventory is validated server-side",
              correct: false,
              points: 5,
              feedback: "Inventory validation is important but separate from price calculation.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully manipulated the cart total and completed a purchase at a reduced price. How do you demonstrate the impact?",
          choices: [
            {
              text: "Show how the design flaw leads to financial loss and inventory discrepancies",
              correct: true,
              points: 20,
              feedback: "Perfect! Connecting the technical flaw to actual business impacts like revenue loss.",
              nextStep: 2
            },
            {
              text: "Actually make multiple fraudulent purchases",
              correct: false,
              points: -20,
              feedback: "Fraudulent purchases are illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the client-side calculation",
              correct: false,
              points: 10,
              feedback: "Good technical finding, but business impact drives urgency.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Business logic flaw exposed! Client-side price calculation allows price manipulation and financial loss.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're redesigning the e-commerce checkout process. What's the fundamental security principle?",
          choices: [
            {
              text: "All critical business logic including pricing must be validated server-side",
              correct: true,
              points: 15,
              feedback: "Essential! Never trust client-side calculations for critical business logic.",
              nextStep: 1
            },
            {
              text: "Add more client-side validation for price calculations",
              correct: false,
              points: 5,
              feedback: "Client-side validation can always be bypassed.",
              nextStep: 1
            },
            {
              text: "Encrypt the cart data",
              correct: false,
              points: 10,
              feedback: "Encryption protects data but doesn't prevent manipulation.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good principle! What comprehensive e-commerce security should you implement?",
          choices: [
            {
              text: "Implement server-side validation for all business logic, audit trails, and fraud detection",
              correct: true,
              points: 20,
              feedback: "Perfect! Server-side controls with monitoring and fraud prevention.",
              nextStep: 2
            },
            {
              text: "Require additional authentication for all purchases",
              correct: false,
              points: 10,
              feedback: "Authentication helps but doesn't fix business logic flaws.",
              nextStep: 2
            },
            {
              text: "Store all prices in encrypted format",
              correct: false,
              points: 5,
              feedback: "Encryption doesn't prevent logical flaws in processing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "E-commerce security established! All business logic now properly validated server-side with comprehensive monitoring.",
          choices: []
        }
      ]
    }
  },

    sqlInjectionNew: {
    id: 191,
    title: "SQL Injection in User Profile Search",
    difficulty: "Medium",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You're testing a social media platform's user search feature. It seems to query user profiles directly. What SQL injection approach would you try first?",
          choices: [
            {
              text: "Test with: ' UNION SELECT database(), user(), version()--",
              correct: true,
              points: 15,
              feedback: "Excellent! This UNION injection can reveal database information, current user, and version details to understand the attack surface.",
              nextStep: 1
            },
            {
              text: "Try: admin' OR '1'='1",
              correct: false,
              points: 10,
              feedback: "Good basic test, but UNION can extract more system information first.",
              nextStep: 0
            },
            {
              text: "Attempt: '; SHOW TABLES--",
              correct: false,
              points: 5,
              feedback: "This might work but UNION is more reliable for information gathering.",
              nextStep: 0
            }
          ]
        },
        {
          text: "The UNION injection worked and revealed database information. Now you want to extract user credentials. What's your next step?",
          choices: [
            {
              text: "Map the database structure and extract password hashes from user tables",
              correct: true,
              points: 20,
              feedback: "Perfect! Systematic database enumeration helps understand the structure before extracting sensitive data like password hashes.",
              nextStep: 2
            },
            {
              text: "Immediately try to crack the password hashes",
              correct: false,
              points: 10,
              feedback: "First understand the full database structure to ensure you get all relevant data.",
              nextStep: 2
            },
            {
              text: "Delete user accounts to prove impact",
              correct: false,
              points: -15,
              feedback: "Destructive actions are unethical and illegal in security testing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SQL injection vulnerability confirmed! You've demonstrated how user search can expose database structure and sensitive user credentials.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the user search functionality. What's the most robust defense against SQL injection?",
          choices: [
            {
              text: "Implement prepared statements with parameterized queries and input validation",
              correct: true,
              points: 15,
              feedback: "Perfect! Prepared statements prevent SQL injection while input validation adds an additional layer of security.",
              nextStep: 1
            },
            {
              text: "Use stored procedures for all database queries",
              correct: false,
              points: 10,
              feedback: "Stored procedures can help but don't automatically prevent SQL injection if not implemented properly.",
              nextStep: 1
            },
            {
              text: "Implement character escaping for all user inputs",
              correct: false,
              points: 5,
              feedback: "Escaping can be error-prone and is not as reliable as parameterized queries.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What additional database security measures should you implement?",
          choices: [
            {
              text: "Use database user with least privilege, enable logging, and implement WAF",
              correct: true,
              points: 20,
              feedback: "Excellent! Defense in depth with minimal privileges, monitoring, and additional protection layers.",
              nextStep: 2
            },
            {
              text: "Encrypt all database connections only",
              correct: false,
              points: 10,
              feedback: "Encryption protects data in transit but doesn't prevent SQL injection.",
              nextStep: 2
            },
            {
              text: "Hide error messages from users",
              correct: false,
              points: 5,
              feedback: "Error hiding helps but doesn't fix the underlying vulnerability.",
              nextStep: 2
            }
          ]
        },
        {
          text: "User search secured! All database queries now use parameterized statements with proper access controls and monitoring.",
          choices: []
        }
      ]
    }
  },

  brokenAuthNew: {
    id: 192,
    title: "JWT Token Manipulation",
    difficulty: "Hard",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover an application uses JWT tokens for authentication. The tokens appear to be unsigned. How do you test for vulnerabilities?",
          choices: [
            {
              text: "Modify the token payload to escalate privileges and remove the signature",
              correct: true,
              points: 20,
              feedback: "Correct! Unsigned JWT tokens can be modified to change user roles or permissions without validation.",
              nextStep: 1
            },
            {
              text: "Try to brute force the JWT secret",
              correct: false,
              points: 10,
              feedback: "If the token is unsigned, no secret is needed for modification.",
              nextStep: 0
            },
            {
              text: "Replay old tokens to see if they're still valid",
              correct: false,
              points: 15,
              feedback: "Good test for token expiration, but the immediate issue is lack of signature verification.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully modified the JWT token to gain admin access. What's the ethical way to demonstrate impact?",
          choices: [
            {
              text: "Show how token manipulation allows privilege escalation without accessing sensitive data",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating privilege escalation potential without actually accessing user data maintains ethical boundaries.",
              nextStep: 2
            },
            {
              text: "Access admin functions and user data",
              correct: false,
              points: -20,
              feedback: "Unauthorized access to sensitive data is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Create new admin accounts",
              correct: false,
              points: -15,
              feedback: "Creating unauthorized accounts crosses ethical boundaries in security testing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical JWT vulnerability exposed! Unsigned tokens allow privilege escalation and complete authentication bypass.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing JWT authentication. What's the essential security control?",
          choices: [
            {
              text: "Use strong signing algorithms like RS256 and validate signatures properly",
              correct: true,
              points: 20,
              feedback: "Essential! Proper signature validation prevents token manipulation and ensures token integrity.",
              nextStep: 1
            },
            {
              text: "Encrypt the JWT payload",
              correct: false,
              points: 10,
              feedback: "Encryption protects confidentiality but doesn't prevent tampering without proper signature validation.",
              nextStep: 1
            },
            {
              text: "Use short token expiration times",
              correct: false,
              points: 5,
              feedback: "Expiration helps but doesn't prevent immediate token manipulation attacks.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive JWT security measures should you implement?",
          choices: [
            {
              text: "Implement proper signature validation, token expiration, and secure storage",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive JWT security including cryptographic validation, time limits, and client-side protection.",
              nextStep: 2
            },
            {
              text: "Store JWT tokens in local storage only",
              correct: false,
              points: 5,
              feedback: "Local storage is vulnerable to XSS - httpOnly cookies are more secure.",
              nextStep: 2
            },
            {
              text: "Use the same secret for all environments",
              correct: false,
              points: -10,
              feedback: "Different environments should use different secrets for security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "JWT authentication secured! All tokens now properly signed with strong algorithms and comprehensive validation.",
          choices: []
        }
      ]
    }
  },

  cryptographicFailuresNew: {
    id: 193,
    title: "Weak SSL/TLS Configuration",
    difficulty: "Medium",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You're testing a web application and discover it supports weak SSL/TLS protocols. What's the security risk?",
          choices: [
            {
              text: "Man-in-the-middle attacks can downgrade connections and decrypt sensitive data",
              correct: true,
              points: 15,
              feedback: "Critical finding! Weak TLS protocols allow attackers to intercept and decrypt communications.",
              nextStep: 1
            },
            {
              text: "Only affects website performance",
              correct: false,
              points: 5,
              feedback: "This is a security vulnerability, not a performance issue.",
              nextStep: 0
            },
            {
              text: "Risk is limited to older browsers",
              correct: false,
              points: 10,
              feedback: "Weak protocols affect all users, not just those with older browsers.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate a TLS downgrade attack. How do you show the impact on user data?",
          choices: [
            {
              text: "Show how intercepted login credentials and session data can be decrypted",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating credential and data interception shows the real risk to user privacy.",
              nextStep: 2
            },
            {
              text: "Actually intercept and decrypt user sessions",
              correct: false,
              points: -15,
              feedback: "Intercepting real user data is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the weak protocol support",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating impact drives urgency for fixes.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical cryptographic failure! Weak TLS configuration exposes all user communications to interception and decryption.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're configuring web server SSL/TLS. What's the first security improvement?",
          choices: [
            {
              text: "Disable weak protocols (SSLv3, TLS 1.0) and enable modern TLS versions",
              correct: true,
              points: 15,
              feedback: "Essential! Modern TLS versions (1.2+) provide strong encryption and security features.",
              nextStep: 1
            },
            {
              text: "Increase SSL certificate key length",
              correct: false,
              points: 10,
              feedback: "Certificate strength is important but doesn't fix weak protocol vulnerabilities.",
              nextStep: 1
            },
            {
              text: "Implement HTTPS redirects only",
              correct: false,
              points: 5,
              feedback: "HTTPS is good but the protocol version is what matters for security.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good start! What comprehensive TLS security should you implement?",
          choices: [
            {
              text: "Use strong ciphers, enable HSTS, and implement perfect forward secrecy",
              correct: true,
              points: 20,
              feedback: "Perfect! Comprehensive TLS security including modern ciphers, HSTS for enforcement, and PFS for key security.",
              nextStep: 2
            },
            {
              text: "Use the same TLS configuration for all servers",
              correct: false,
              points: 5,
              feedback: "Different services may have different compatibility requirements.",
              nextStep: 2
            },
            {
              text: "Disable all older protocols immediately",
              correct: false,
              points: 10,
              feedback: "Some legacy systems may need gradual migration with proper monitoring.",
              nextStep: 2
            }
          ]
        },
        {
          text: "TLS configuration secured! All communications now use modern protocols with strong ciphers and security features.",
          choices: []
        }
      ]
    }
  },

  brokenAccessControlNew: {
    id: 194,
    title: "Function-Level Access Control Bypass",
    difficulty: "Medium",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover an application hides admin functions in the UI for regular users, but the API endpoints are still accessible. How do you test this?",
          choices: [
            {
              text: "Access admin API endpoints directly without UI interaction",
              correct: true,
              points: 15,
              feedback: "Correct! Direct API access can bypass UI-based access controls if server-side validation is missing.",
              nextStep: 1
            },
            {
              text: "Modify JavaScript to unhide admin functions",
              correct: false,
              points: 10,
              feedback: "UI modification is possible but direct API testing is more efficient.",
              nextStep: 0
            },
            {
              text: "Try to find admin credentials",
              correct: false,
              points: 5,
              feedback: "Credential hunting is less efficient than testing access control bypasses.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully accessed admin functions through direct API calls. How do you demonstrate the severity?",
          choices: [
            {
              text: "Show how any user can perform administrative actions through API bypass",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating that any user can execute admin functions shows critical access control failure.",
              nextStep: 2
            },
            {
              text: "Actually create new admin accounts",
              correct: false,
              points: -20,
              feedback: "Creating unauthorized accounts crosses ethical boundaries.",
              nextStep: 2
            },
            {
              text: "Just document the API endpoints",
              correct: false,
              points: 10,
              feedback: "Good for technical documentation, but impact demonstration is crucial.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical access control bypass! Missing server-side validation allows any user to execute administrative functions.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing function-level access control. What's the fundamental principle?",
          choices: [
            {
              text: "Implement server-side authorization checks for every function regardless of UI",
              correct: true,
              points: 15,
              feedback: "Essential! Server-side validation is mandatory since clients can always bypass UI controls.",
              nextStep: 1
            },
            {
              text: "Hide sensitive functions thoroughly in the UI",
              correct: false,
              points: 5,
              feedback: "UI hiding is security through obscurity and not reliable.",
              nextStep: 1
            },
            {
              text: "Use complex URLs for admin functions",
              correct: false,
              points: 5,
              feedback: "Complex URLs don't prevent determined attackers from discovering endpoints.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good principle! What comprehensive access control should you implement?",
          choices: [
            {
              text: "Use role-based access control with server-side enforcement for all endpoints",
              correct: true,
              points: 20,
              feedback: "Perfect! RBAC with consistent server-side enforcement across all application layers.",
              nextStep: 2
            },
            {
              text: "Implement IP-based restrictions for admin functions",
              correct: false,
              points: 10,
              feedback: "IP restrictions help but don't replace proper user-based authorization.",
              nextStep: 2
            },
            {
              text: "Add confirmation dialogs for sensitive actions",
              correct: false,
              points: 5,
              feedback: "UI confirmations can be bypassed and don't provide security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Function-level access control secured! All endpoints now enforce proper server-side authorization checks.",
          choices: []
        }
      ]
    }
  },

  securityMisconfigNew: {
    id: 195,
    title: "Exposed Directory Listing",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover a web server with directory listing enabled, revealing file structure and backup files. What's the immediate risk?",
          choices: [
            {
              text: "Attackers can discover sensitive files, backup data, and application structure",
              correct: true,
              points: 15,
              feedback: "Critical finding! Directory listing exposes application internals and potentially sensitive files.",
              nextStep: 1
            },
            {
              text: "Only affects website organization",
              correct: false,
              points: 5,
              feedback: "This is a security issue, not just an organizational concern.",
              nextStep: 0
            },
            {
              text: "Risk is limited to current directory only",
              correct: false,
              points: 5,
              feedback: "Directory listing can reveal paths to other sensitive directories.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You find backup files containing database dumps through directory listing. How do you demonstrate impact?",
          choices: [
            {
              text: "Show how exposed backup files can lead to complete data breach",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating that backup files expose all application data shows critical business impact.",
              nextStep: 2
            },
            {
              text: "Download and analyze the backup files",
              correct: false,
              points: -15,
              feedback: "Accessing and analyzing real backup data crosses ethical boundaries.",
              nextStep: 2
            },
            {
              text: "Just report the directory listing",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but showing data exposure impact drives urgency.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical misconfiguration! Directory listing exposes application structure and sensitive backup files to unauthorized access.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing web server configurations. What's the first step for directory security?",
          choices: [
            {
              text: "Disable directory listing and remove unnecessary files from web root",
              correct: true,
              points: 15,
              feedback: "Essential! Disabling directory listing and cleaning web root prevents information disclosure.",
              nextStep: 1
            },
            {
              text: "Password protect directories with sensitive files",
              correct: false,
              points: 10,
              feedback: "Authentication helps but removing sensitive files from web root is better.",
              nextStep: 1
            },
            {
              text: "Use obscure directory names only",
              correct: false,
              points: 5,
              feedback: "Security through obscurity is not a reliable defense.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good start! What comprehensive web server security should you implement?",
          choices: [
            {
              text: "Implement proper file permissions, remove default files, and use security headers",
              correct: true,
              points: 20,
              feedback: "Perfect! Comprehensive web server hardening including permissions, cleanup, and security headers.",
              nextStep: 2
            },
            {
              text: "Move all files to a different server",
              correct: false,
              points: 5,
              feedback: "Not practical - proper configuration is the solution.",
              nextStep: 2
            },
            {
              text: "Encrypt all web server files",
              correct: false,
              points: 10,
              feedback: "Encryption doesn't prevent directory listing information disclosure.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Web server secured! Directory listing disabled and all unnecessary files removed from web root.",
          choices: []
        }
      ]
    }
  },

  insecureDeserializationNew: {
    id: 196,
    title: "PHP Object Injection",
    difficulty: "Hard",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You find a PHP application that unserializes user input. What's the specific risk with PHP object injection?",
          choices: [
            {
              text: "Malicious objects can execute code through magic methods like __destruct or __wakeup",
              correct: true,
              points: 20,
              feedback: "Correct! PHP magic methods can be exploited during deserialization to execute arbitrary code.",
              nextStep: 1
            },
            {
              text: "Serialized data can be too large and cause memory issues",
              correct: false,
              points: 10,
              feedback: "Memory issues are a concern but not the primary security risk.",
              nextStep: 0
            },
            {
              text: "Data format validation might fail",
              correct: false,
              points: 5,
              feedback: "Validation failures are operational issues, not security vulnerabilities.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully trigger remote code execution through PHP object injection. What's the ethical demonstration?",
          choices: [
            {
              text: "Show code execution capability without causing system damage or accessing data",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating RCE potential without harmful actions maintains ethical testing boundaries.",
              nextStep: 2
            },
            {
              text: "Actually compromise the server and access files",
              correct: false,
              points: -25,
              feedback: "Unauthorized server access is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the unserialize function usage",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating impact shows severity.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical PHP object injection vulnerability! Unserialize function allows remote code execution through malicious objects.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing PHP application data handling. What's the primary defense against object injection?",
          choices: [
            {
              text: "Avoid unserialize with user input and use JSON for data exchange",
              correct: true,
              points: 20,
              feedback: "Essential! Avoiding unserialize with untrusted data prevents object injection attacks.",
              nextStep: 1
            },
            {
              text: "Validate serialized data format before processing",
              correct: false,
              points: 10,
              feedback: "Format validation doesn't prevent malicious object creation.",
              nextStep: 1
            },
            {
              text: "Use base64 encoding for serialized data",
              correct: false,
              points: 5,
              feedback: "Encoding doesn't provide security - it only changes data representation.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive PHP security should you implement?",
          choices: [
            {
              text: "Use safe data formats, implement input validation, and disable dangerous functions",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including safe data formats, validation, and function restrictions.",
              nextStep: 2
            },
            {
              text: "Encrypt all serialized data",
              correct: false,
              points: 10,
              feedback: "Encryption doesn't prevent object injection if data is decrypted before unserialize.",
              nextStep: 2
            },
            {
              text: "Use the latest PHP version only",
              correct: false,
              points: 5,
              feedback: "Updates help but don't automatically fix insecure code patterns.",
              nextStep: 2
            }
          ]
        },
        {
          text: "PHP data handling secured! All user data now uses safe formats with proper validation and dangerous functions disabled.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponentsNew: {
    id: 197,
    title: "Vulnerable WordPress Plugins",
    difficulty: "Medium",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover a WordPress site using outdated plugins with known vulnerabilities. How do you approach this?",
          choices: [
            {
              text: "Research specific CVEs for the plugin versions and test known exploits",
              correct: true,
              points: 15,
              feedback: "Correct! Known vulnerabilities in WordPress plugins often have public exploits available.",
              nextStep: 1
            },
            {
              text: "Try generic WordPress attacks unrelated to plugins",
              correct: false,
              points: 10,
              feedback: "Plugin-specific vulnerabilities are more targeted and reliable.",
              nextStep: 0
            },
            {
              text: "Ignore plugins and focus on core WordPress",
              correct: false,
              points: 5,
              feedback: "Plugins are common attack vectors and should be tested.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You find a plugin vulnerability that allows file upload. How do you demonstrate impact ethically?",
          choices: [
            {
              text: "Show how malicious files can be uploaded without executing harmful code",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating file upload capability without actual exploitation maintains ethical boundaries.",
              nextStep: 2
            },
            {
              text: "Upload a web shell and take control of the site",
              correct: false,
              points: -20,
              feedback: "Taking control of the website is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the plugin version",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating the vulnerability shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "WordPress plugin vulnerability confirmed! Outdated plugins expose the site to file upload attacks and potential compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're managing WordPress security. What's the essential practice for plugin management?",
          choices: [
            {
              text: "Regularly update plugins and remove unused ones",
              correct: true,
              points: 15,
              feedback: "Essential! Regular updates fix vulnerabilities and removing unused plugins reduces attack surface.",
              nextStep: 1
            },
            {
              text: "Use plugins from any source if they have good reviews",
              correct: false,
              points: 5,
              feedback: "Plugin source matters - only use plugins from reputable developers.",
              nextStep: 1
            },
            {
              text: "Hide plugin information from public view",
              correct: false,
              points: 10,
              feedback: "Security through obscurity is not a reliable defense.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive WordPress security should you implement?",
          choices: [
            {
              text: "Implement automated updates, security scanning, and minimal plugin usage",
              correct: true,
              points: 20,
              feedback: "Perfect! Automated security practices including updates, scanning, and minimal attack surface.",
              nextStep: 2
            },
            {
              text: "Disable all plugin updates",
              correct: false,
              points: -10,
              feedback: "Disabling updates leaves known vulnerabilities unpatched.",
              nextStep: 2
            },
            {
              text: "Use as many plugins as needed for functionality",
              correct: false,
              points: 5,
              feedback: "Minimal plugin usage reduces attack surface and maintenance burden.",
              nextStep: 2
            }
          ]
        },
        {
          text: "WordPress security established! All plugins regularly updated with automated security monitoring in place.",
          choices: []
        }
      ]
    }
  },

  loggingFailuresNew: {
    id: 198,
    title: "Missing API Security Logging",
    difficulty: "Medium",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You're testing API endpoints and notice no logging of failed authentication attempts or unusual patterns. What's the risk?",
          choices: [
            {
              text: "API abuse and brute force attacks can go undetected",
              correct: true,
              points: 15,
              feedback: "Critical finding! Without API security logging, attacks can proceed without detection.",
              nextStep: 1
            },
            {
              text: "Only affects API performance monitoring",
              correct: false,
              points: 5,
              feedback: "This is a security monitoring failure, not performance issue.",
              nextStep: 0
            },
            {
              text: "Risk is limited to this specific API",
              correct: false,
              points: 5,
              feedback: "Missing security logging affects the entire API security posture.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate API abuse without triggering any alerts. How do you show the business impact?",
          choices: [
            {
              text: "Show how undetected API attacks can lead to data breach and service abuse",
              correct: true,
              points: 20,
              feedback: "Perfect! Connecting missing logging to potential data breaches and service abuse demonstrates business risk.",
              nextStep: 2
            },
            {
              text: "Actually abuse the API to cause service disruption",
              correct: false,
              points: -15,
              feedback: "Causing service disruption is unethical and potentially illegal.",
              nextStep: 2
            },
            {
              text: "Just report the lack of logging",
              correct: false,
              points: 10,
              feedback: "Good for technical reporting, but business impact drives action.",
              nextStep: 2
            }
          ]
        },
        {
          text: "API security monitoring gap exposed! Missing logging allows undetected attacks and delayed incident response.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing API security monitoring. What events are critical to log?",
          choices: [
            {
              text: "Authentication failures, rate limit exceedances, and input validation errors",
              correct: true,
              points: 15,
              feedback: "Perfect! These API events provide crucial security monitoring data.",
              nextStep: 1
            },
            {
              text: "Only successful API responses",
              correct: false,
              points: 5,
              feedback: "Failed attempts and errors are equally important for security.",
              nextStep: 1
            },
            {
              text: "All API requests regardless of outcome",
              correct: false,
              points: 10,
              feedback: "Too noisy - focus on security-relevant events first.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good selection! What comprehensive API security monitoring should you implement?",
          choices: [
            {
              text: "Implement structured logging, real-time alerts, and API security analytics",
              correct: true,
              points: 20,
              feedback: "Excellent! Structured logging enables better analysis, real-time alerts provide immediate detection, and analytics identify patterns.",
              nextStep: 2
            },
            {
              text: "Log everything and sort it out later",
              correct: false,
              points: 5,
              feedback: "Excessive logging creates noise and storage issues without proper analysis.",
              nextStep: 2
            },
            {
              text: "Only monitor during business hours",
              correct: false,
              points: -10,
              feedback: "API attacks can occur at any time - 24/7 monitoring is essential.",
              nextStep: 2
            }
          ]
        },
        {
          text: "API security monitoring established! All critical events now properly logged with real-time alerting and analysis.",
          choices: []
        }
      ]
    }
  },

  ssrfNew: {
    id: 199,
    title: "Webhook SSRF Vulnerability",
    difficulty: "Hard",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "You discover a webhook feature that makes requests to user-provided URLs. How do you test for SSRF?",
          choices: [
            {
              text: "Provide internal network addresses and cloud metadata endpoints as webhook URLs",
              correct: true,
              points: 20,
              feedback: "Correct! Webhook features often lack proper URL validation, allowing SSRF to internal networks.",
              nextStep: 1
            },
            {
              text: "Try SQL injection in the webhook URL field",
              correct: false,
              points: 5,
              feedback: "SSRF testing requires different techniques focused on network access.",
              nextStep: 0
            },
            {
              text: "Check if webhook payload can be modified",
              correct: false,
              points: 10,
              feedback: "Payload modification is different from SSRF vulnerability testing.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully trigger requests to internal services through the webhook. The service returns response data. What's the impact?",
          choices: [
            {
              text: "Demonstrate how internal service data can be extracted through webhook responses",
              correct: true,
              points: 25,
              feedback: "Critical! If webhook responses are visible, SSRF becomes a serious information disclosure vulnerability.",
              nextStep: 2
            },
            {
              text: "Use the internal access to modify backend services",
              correct: false,
              points: -20,
              feedback: "Unauthorized modification of services is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the internal network access",
              correct: false,
              points: 15,
              feedback: "Good start, but data extraction shows greater impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical webhook SSRF vulnerability! Internal network access and data extraction possible through webhook feature.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing webhook functionality. What's the primary SSRF defense?",
          choices: [
            {
              text: "Implement URL allowlisting and network segmentation for webhook services",
              correct: true,
              points: 20,
              feedback: "Essential! Allowlisting ensures only approved domains are accessible, and network segmentation limits damage.",
              nextStep: 1
            },
            {
              text: "Validate URL format only",
              correct: false,
              points: 10,
              feedback: "Format validation doesn't prevent access to internal networks.",
              nextStep: 1
            },
            {
              text: "Add authentication to internal services",
              correct: false,
              points: 5,
              feedback: "Internal services should be protected, but SSRF prevention is better.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive webhook security should you implement?",
          choices: [
            {
              text: "Use allowlists, outbound proxies, and webhook signature verification",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including application controls, network security, and request verification.",
              nextStep: 2
            },
            {
              text: "Disable all webhook functionality",
              correct: false,
              points: 0,
              feedback: "Not practical for applications that need webhook capabilities.",
              nextStep: 2
            },
            {
              text: "Only allow webhooks to same-domain URLs",
              correct: false,
              points: 10,
              feedback: "Too restrictive for legitimate webhook use cases.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Webhook security established! All webhook requests now properly validated and restricted with network controls.",
          choices: []
        }
      ]
    }
  },

  insecureDesignNew: {
    id: 200,
    title: "Race Condition in Payment Processing",
    difficulty: "Hard",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You notice a payment system doesn't properly handle concurrent requests. What race condition could you test for?",
          choices: [
            {
              text: "Send multiple payment requests simultaneously to exploit balance checks",
              correct: true,
              points: 20,
              feedback: "Correct! Race conditions in payment processing can allow spending more money than available.",
              nextStep: 1
            },
            {
              text: "Try to modify payment amounts during processing",
              correct: false,
              points: 10,
              feedback: "Amount modification is different from race condition exploitation.",
              nextStep: 0
            },
            {
              text: "Check if payment confirmations can be reused",
              correct: false,
              points: 15,
              feedback: "Good test for different vulnerability, but not race condition specific.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully demonstrate a race condition that allows overspending. How do you show the financial impact?",
          choices: [
            {
              text: "Show how the design flaw can lead to financial loss without actual fraud",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating the potential for financial loss without committing fraud maintains ethical boundaries.",
              nextStep: 2
            },
            {
              text: "Actually exploit the race condition for financial gain",
              correct: false,
              points: -30,
              feedback: "Financial fraud is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the concurrent request issue",
              correct: false,
              points: 15,
              feedback: "Good for technical reporting, but financial impact demonstration is crucial.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical design flaw! Race condition in payment processing allows overspending and financial loss.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're designing payment system integrity. What's the fundamental principle?",
          choices: [
            {
              text: "Implement database transactions and proper locking for financial operations",
              correct: true,
              points: 20,
              feedback: "Essential! Database transactions with proper locking prevent race conditions in financial operations.",
              nextStep: 1
            },
            {
              text: "Add delays between payment steps",
              correct: false,
              points: 5,
              feedback: "Delays don't reliably prevent race conditions and hurt user experience.",
              nextStep: 1
            },
            {
              text: "Use client-side timestamps for validation",
              correct: false,
              points: 10,
              feedback: "Client-side data can be manipulated and is not reliable for server-side validation.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good principle! What comprehensive payment security should you implement?",
          choices: [
            {
              text: "Use database transactions, idempotency keys, and audit trails for all payments",
              correct: true,
              points: 25,
              feedback: "Perfect! Transactions prevent race conditions, idempotency prevents duplicate processing, and audit trails enable investigation.",
              nextStep: 2
            },
            {
              text: "Process only one payment at a time globally",
              correct: false,
              points: 5,
              feedback: "Not scalable for real-world payment systems.",
              nextStep: 2
            },
            {
              text: "Add multiple confirmation steps for users",
              correct: false,
              points: 10,
              feedback: "User confirmations don't prevent race conditions at the system level.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Payment system integrity established! All financial operations now use proper transactions with idempotency and auditing.",
          choices: []
        }
      ]
    }
  },

    sqlInjectionAdditional: {
    id: 201,
    title: "SQL Injection in Data Export Feature",
    difficulty: "Medium",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover a data export feature that allows users to export reports. The feature accepts SQL-like filters. What injection approach would you test?",
          choices: [
            {
              text: "Inject UNION statements to extract database schema information",
              correct: true,
              points: 15,
              feedback: "Excellent! Data export features often concatenate user input with SQL queries, making UNION injections effective for schema enumeration.",
              nextStep: 1
            },
            {
              text: "Try to delete database tables through the export",
              correct: false,
              points: -10,
              feedback: "Destructive actions are unethical and could damage the application.",
              nextStep: 0
            },
            {
              text: "Use time-based blind SQL injection",
              correct: false,
              points: 10,
              feedback: "While blind SQLi works, UNION is more efficient when the application displays query results directly.",
              nextStep: 0
            }
          ]
        },
        {
          text: "The UNION injection reveals sensitive table names. How do you ethically demonstrate the data exposure risk?",
          choices: [
            {
              text: "Show how user data, credentials, or business information can be extracted",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating the ability to extract specific sensitive data types shows the real business impact.",
              nextStep: 2
            },
            {
              text: "Actually export and download sensitive user data",
              correct: false,
              points: -20,
              feedback: "Accessing real user data without authorization is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the table names found",
              correct: false,
              points: 10,
              feedback: "Good for initial reporting, but demonstrating data extraction capability is more impactful.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SQL injection vulnerability confirmed! Data export feature exposes database schema and allows sensitive data extraction.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the data export functionality. What's the most effective approach to prevent SQL injection?",
          choices: [
            {
              text: "Use parameterized queries with strict input validation for filter parameters",
              correct: true,
              points: 15,
              feedback: "Perfect! Parameterized queries separate SQL logic from data, while validation ensures only expected input formats are accepted.",
              nextStep: 1
            },
            {
              text: "Implement a web application firewall to block SQL keywords",
              correct: false,
              points: 10,
              feedback: "WAFs can help but are not a substitute for proper input handling in the application code.",
              nextStep: 1
            },
            {
              text: "Encrypt all database connections",
              correct: false,
              points: 5,
              feedback: "Encryption protects data in transit but doesn't prevent SQL injection vulnerabilities.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What additional security measures should you implement for data exports?",
          choices: [
            {
              text: "Implement query whitelisting, row limits, and audit logging for exports",
              correct: true,
              points: 20,
              feedback: "Excellent! Multiple layers of protection including restricted query patterns, data limits, and activity monitoring.",
              nextStep: 2
            },
            {
              text: "Disable all data export features",
              correct: false,
              points: 0,
              feedback: "Not practical for business requirements - better to implement proper security controls.",
              nextStep: 2
            },
            {
              text: "Only allow exports for admin users",
              correct: false,
              points: 10,
              feedback: "Access control helps but doesn't prevent SQL injection if admins can be compromised.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Data export feature secured! All queries now use parameterized statements with proper validation and monitoring.",
          choices: []
        }
      ]
    }
  },

  brokenAuthAdditional: {
    id: 202,
    title: "Password Reset Token Brute Force",
    difficulty: "Medium",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You notice password reset tokens are short numeric codes (6 digits). How would you test for brute force vulnerability?",
          choices: [
            {
              text: "Systematically attempt different token values to find valid ones",
              correct: true,
              points: 15,
              feedback: "Correct! Short numeric tokens have limited combinations and can be brute forced if not rate-limited properly.",
              nextStep: 1
            },
            {
              text: "Try to predict tokens based on time patterns",
              correct: false,
              points: 10,
              feedback: "While token predictability is a concern, the immediate issue is the small keyspace allowing brute force.",
              nextStep: 0
            },
            {
              text: "Look for tokens in network traffic",
              correct: false,
              points: 5,
              feedback: "Token interception is different from brute force vulnerability testing.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully brute forced a reset token. How do you demonstrate the account takeover risk?",
          choices: [
            {
              text: "Show how any account can be compromised through token brute forcing",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating systematic account compromise risk shows the critical nature of this vulnerability.",
              nextStep: 2
            },
            {
              text: "Actually reset passwords and take over accounts",
              correct: false,
              points: -25,
              feedback: "Unauthorized account access is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the short token length",
              correct: false,
              points: 10,
              feedback: "Good for technical reporting, but demonstrating the attack impact is more compelling.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical authentication flaw! Short password reset tokens allow brute force attacks and account takeover.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're designing secure password reset functionality. What's the essential security control?",
          choices: [
            {
              text: "Use long, cryptographically secure random tokens with strict rate limiting",
              correct: true,
              points: 15,
              feedback: "Essential! Long random tokens prevent brute force while rate limiting protects against automated attacks.",
              nextStep: 1
            },
            {
              text: "Implement CAPTCHA on the reset page",
              correct: false,
              points: 10,
              feedback: "CAPTCHA helps but doesn't fix the fundamental issue of weak tokens.",
              nextStep: 1
            },
            {
              text: "Require security questions for reset",
              correct: false,
              points: 5,
              feedback: "Security questions are often weak and don't replace proper token security.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive password reset security should you implement?",
          choices: [
            {
              text: "Use secure tokens, rate limiting, single-use tokens, and expiration",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including token security, attack prevention, and proper token lifecycle management.",
              nextStep: 2
            },
            {
              text: "Send reset links via SMS only",
              correct: false,
              points: 10,
              feedback: "SMS has its own security concerns and doesn't replace proper web security.",
              nextStep: 2
            },
            {
              text: "Disable password resets during off-hours",
              correct: false,
              points: 5,
              feedback: "Attackers operate 24/7 - time restrictions don't provide real security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Password reset security established! All tokens now cryptographically secure with proper rate limiting and expiration.",
          choices: []
        }
      ]
    }
  },

  cryptographicFailuresAdditional: {
    id: 203,
    title: "Insecure Data Storage in Mobile App",
    difficulty: "Medium",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You're testing a mobile app and discover it stores sensitive data in plain text in local storage. What's the immediate risk?",
          choices: [
            {
              text: "Device compromise exposes all stored sensitive data without protection",
              correct: true,
              points: 15,
              feedback: "Critical finding! Plain text storage in mobile apps exposes user data if the device is lost, stolen, or compromised.",
              nextStep: 1
            },
            {
              text: "Only affects app performance",
              correct: false,
              points: 5,
              feedback: "This is a security vulnerability, not a performance issue.",
              nextStep: 0
            },
            {
              text: "Risk is limited to jailbroken devices",
              correct: false,
              points: 10,
              feedback: "All mobile devices are vulnerable to data extraction with the right tools.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You extract plain text credentials from the app's local storage. How do you demonstrate the privacy impact?",
          choices: [
            {
              text: "Show how user credentials and personal data are exposed in device storage",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating credential and personal data exposure shows the real privacy impact on users.",
              nextStep: 2
            },
            {
              text: "Use the extracted credentials to access user accounts",
              correct: false,
              points: -20,
              feedback: "Unauthorized account access is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the storage location",
              correct: false,
              points: 10,
              feedback: "Good for technical reporting, but demonstrating data exposure shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical data protection failure! Mobile app stores sensitive data in plain text, exposing user credentials and personal information.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing mobile app data storage. What's the correct approach for sensitive data?",
          choices: [
            {
              text: "Use platform-specific secure storage APIs and encrypt sensitive data",
              correct: true,
              points: 15,
              feedback: "Essential! Mobile platforms provide secure storage APIs (Keychain/Keystore) specifically designed for sensitive data protection.",
              nextStep: 1
            },
            {
              text: "Store data in app memory only",
              correct: false,
              points: 5,
              feedback: "Memory storage is volatile and not practical for persistent data.",
              nextStep: 1
            },
            {
              text: "Use simple base64 encoding",
              correct: false,
              points: -10,
              feedback: "Encoding is not encryption and provides no real security.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive mobile data protection should you implement?",
          choices: [
            {
              text: "Implement secure storage, data minimization, and certificate pinning",
              correct: true,
              points: 20,
              feedback: "Perfect! Comprehensive mobile security including secure storage, minimal data retention, and communication security.",
              nextStep: 2
            },
            {
              text: "Store all data on remote servers only",
              correct: false,
              points: 10,
              feedback: "Not practical for mobile apps that need offline functionality.",
              nextStep: 2
            },
            {
              text: "Use the same encryption key for all devices",
              correct: false,
              points: -15,
              feedback: "Shared encryption keys create massive risk if compromised.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Mobile data protection established! All sensitive data now properly encrypted using platform secure storage APIs.",
          choices: []
        }
      ]
    }
  },

  brokenAccessControlAdditional: {
    id: 204,
    title: "Insecure Direct Object Reference in File Downloads",
    difficulty: "Easy",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover file download URLs use predictable patterns like /download?file=user1.pdf. How do you test for IDOR?",
          choices: [
            {
              text: "Modify the file parameter to access other users' files",
              correct: true,
              points: 15,
              feedback: "Correct! Predictable file identifiers without authorization checks allow access to unauthorized files.",
              nextStep: 1
            },
            {
              text: "Try path traversal in the file parameter",
              correct: false,
              points: 10,
              feedback: "Path traversal is different from IDOR - both should be tested but IDOR is the immediate concern.",
              nextStep: 0
            },
            {
              text: "Check if files are cached properly",
              correct: false,
              points: 5,
              feedback: "Caching is a performance concern, not an access control issue.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully downloaded other users' confidential files. How do you demonstrate the data breach risk?",
          choices: [
            {
              text: "Show how sensitive documents and user data can be accessed without authorization",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating unauthorized access to confidential files shows serious data breach potential.",
              nextStep: 2
            },
            {
              text: "Actually distribute the downloaded files",
              correct: false,
              points: -25,
              feedback: "Distributing confidential data is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the predictable URL pattern",
              correct: false,
              points: 10,
              feedback: "Good for technical reporting, but demonstrating data access shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical IDOR vulnerability! File download feature exposes confidential documents through predictable URLs without authorization checks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing file download functionality. What's the essential access control?",
          choices: [
            {
              text: "Implement server-side authorization checks for every file access request",
              correct: true,
              points: 15,
              feedback: "Essential! Every file download must verify the user has permission to access that specific file.",
              nextStep: 1
            },
            {
              text: "Use random UUIDs for file identifiers",
              correct: false,
              points: 10,
              feedback: "Obfuscation helps but doesn't replace proper authorization checks.",
              nextStep: 1
            },
            {
              text: "Add file download rate limiting",
              correct: false,
              points: 5,
              feedback: "Rate limiting prevents abuse but doesn't fix access control issues.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive file access security should you implement?",
          choices: [
            {
              text: "Use authorization checks, secure file storage, and access logging",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including proper authorization, secure storage location, and activity monitoring.",
              nextStep: 2
            },
            {
              text: "Store all files in the web root for easy access",
              correct: false,
              points: -10,
              feedback: "Files should be stored outside web root to prevent direct access.",
              nextStep: 2
            },
            {
              text: "Implement client-side file encryption only",
              correct: false,
              points: 10,
              feedback: "Client-side encryption doesn't prevent unauthorized access to files.",
              nextStep: 2
            }
          ]
        },
        {
          text: "File access control established! All downloads now enforce proper authorization with secure storage and logging.",
          choices: []
        }
      ]
    }
  },

  securityMisconfigAdditional: {
    id: 205,
    title: "Exposed Administrator Interfaces",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover admin interfaces accessible without authentication on default paths like /admin or /phpmyadmin. What's the risk?",
          choices: [
            {
              text: "Unauthorized users can access administrative functions and system controls",
              correct: true,
              points: 15,
              feedback: "Critical finding! Exposed admin interfaces allow complete system compromise if accessible without authentication.",
              nextStep: 1
            },
            {
              text: "Only affects system performance monitoring",
              correct: false,
              points: 5,
              feedback: "This is a security vulnerability, not a performance issue.",
              nextStep: 0
            },
            {
              text: "Risk is limited to network administrators",
              correct: false,
              points: 5,
              feedback: "Any user who discovers the interface can access it.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You access the exposed admin interface. How do you demonstrate the system compromise risk?",
          choices: [
            {
              text: "Show how administrative functions can be executed without authentication",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating the ability to execute admin functions shows complete system control potential.",
              nextStep: 2
            },
            {
              text: "Actually modify system configurations or user data",
              correct: false,
              points: -20,
              feedback: "Unauthorized system modifications are illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the exposed interface URL",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating functionality access shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical misconfiguration! Admin interfaces exposed without authentication allow complete system compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing administrative interfaces. What's the first security measure?",
          choices: [
            {
              text: "Implement strong authentication and network access controls for admin interfaces",
              correct: true,
              points: 15,
              feedback: "Essential! Admin interfaces must require strong authentication and should be restricted to authorized networks.",
              nextStep: 1
            },
            {
              text: "Change admin interface URLs to obscure paths",
              correct: false,
              points: 5,
              feedback: "Security through obscurity is not a reliable defense.",
              nextStep: 1
            },
            {
              text: "Add warning messages to admin pages",
              correct: false,
              points: 0,
              feedback: "Warnings don't prevent unauthorized access.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive admin interface security should you implement?",
          choices: [
            {
              text: "Use strong authentication, network segmentation, and multi-factor authentication",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including authentication, network security, and additional verification.",
              nextStep: 2
            },
            {
              text: "Disable all admin interfaces in production",
              correct: false,
              points: 5,
              feedback: "Not practical for system administration needs.",
              nextStep: 2
            },
            {
              text: "Only allow admin access during business hours",
              correct: false,
              points: 10,
              feedback: "Time restrictions don't prevent unauthorized access.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Admin interface security established! All administrative access now requires strong authentication with network controls.",
          choices: []
        }
      ]
    }
  },

  insecureDeserializationAdditional: {
    id: 206,
    title: "Java Deserialization Attack",
    difficulty: "Hard",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover a Java application that deserializes user-supplied data. What's the specific risk with Java object deserialization?",
          choices: [
            {
              text: "Malicious serialized objects can execute code through gadget chains",
              correct: true,
              points: 20,
              feedback: "Correct! Java deserialization vulnerabilities allow remote code execution through carefully crafted object chains.",
              nextStep: 1
            },
            {
              text: "Serialized data can consume excessive memory",
              correct: false,
              points: 10,
              feedback: "Memory consumption is a concern but not the primary security risk.",
              nextStep: 0
            },
            {
              text: "Data format validation might fail",
              correct: false,
              points: 5,
              feedback: "Validation failures are operational issues, not the core deserialization vulnerability.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully trigger remote code execution through Java deserialization. What's the ethical demonstration?",
          choices: [
            {
              text: "Show code execution capability without causing system harm",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating RCE potential without destructive actions maintains ethical testing boundaries.",
              nextStep: 2
            },
            {
              text: "Actually compromise the server and access data",
              correct: false,
              points: -30,
              feedback: "Unauthorized server access is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the ObjectInputStream usage",
              correct: false,
              points: 15,
              feedback: "Good for technical reporting, but demonstrating impact shows severity.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical Java deserialization vulnerability! Untrusted data deserialization allows remote code execution.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing Java application data handling. What's the primary defense against deserialization attacks?",
          choices: [
            {
              text: "Use safe serialization formats like JSON and avoid Java native serialization",
              correct: true,
              points: 20,
              feedback: "Essential! Safe data formats prevent deserialization attacks by avoiding dangerous Java serialization mechanisms.",
              nextStep: 1
            },
            {
              text: "Validate serialized data size limits",
              correct: false,
              points: 10,
              feedback: "Size limits help with resource exhaustion but don't prevent code execution.",
              nextStep: 1
            },
            {
              text: "Use base64 encoding for serialized data",
              correct: false,
              points: 5,
              feedback: "Encoding doesn't provide security - it only changes data representation.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive Java security should you implement?",
          choices: [
            {
              text: "Use safe data formats, implement input validation, and apply security patches",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including safe data handling, validation, and keeping dependencies updated.",
              nextStep: 2
            },
            {
              text: "Disable all object serialization in the JVM",
              correct: false,
              points: 5,
              feedback: "Not practical for applications that need serialization functionality.",
              nextStep: 2
            },
            {
              text: "Use the latest Java version only",
              correct: false,
              points: 10,
              feedback: "Updates help but don't automatically fix insecure code patterns.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Java data handling secured! All user data now uses safe formats with proper validation and updated dependencies.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponentsAdditional: {
    id: 207,
    title: "Vulnerable Server Framework",
    difficulty: "Medium",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You identify a web application using an outdated server framework with known RCE vulnerabilities. How do you approach this?",
          choices: [
            {
              text: "Research specific CVEs and test known exploits for the framework version",
              correct: true,
              points: 15,
              feedback: "Correct! Known vulnerabilities in server frameworks often have public exploits that can be tested.",
              nextStep: 1
            },
            {
              text: "Try generic web attacks unrelated to the framework",
              correct: false,
              points: 10,
              feedback: "Framework-specific vulnerabilities are more targeted and reliable.",
              nextStep: 0
            },
            {
              text: "Ignore the framework and focus on application code",
              correct: false,
              points: 5,
              feedback: "Framework vulnerabilities can be critical and should be tested.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You find a framework vulnerability that allows remote code execution. How do you demonstrate impact ethically?",
          choices: [
            {
              text: "Show RCE capability without executing harmful commands or accessing data",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating code execution potential without actual exploitation maintains ethical boundaries.",
              nextStep: 2
            },
            {
              text: "Actually compromise the server and install backdoors",
              correct: false,
              points: -25,
              feedback: "Server compromise is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the framework version",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating the vulnerability shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Server framework vulnerability confirmed! Outdated framework exposes the application to remote code execution.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're responsible for server framework security. What's the essential practice?",
          choices: [
            {
              text: "Maintain an inventory of all components and apply security patches promptly",
              correct: true,
              points: 15,
              feedback: "Essential! Knowing what components you have and keeping them updated is fundamental to security.",
              nextStep: 1
            },
            {
              text: "Use frameworks from any source if they're popular",
              correct: false,
              points: 5,
              feedback: "Popularity doesn't guarantee security - use frameworks from reputable maintainers.",
              nextStep: 1
            },
            {
              text: "Hide framework information in HTTP headers",
              correct: false,
              points: 10,
              feedback: "Security through obscurity is not a reliable defense.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive framework security should you implement?",
          choices: [
            {
              text: "Implement automated patching, vulnerability scanning, and security configurations",
              correct: true,
              points: 20,
              feedback: "Perfect! Automated security practices including updates, scanning, and proper framework configuration.",
              nextStep: 2
            },
            {
              text: "Disable all framework features not currently used",
              correct: false,
              points: 10,
              feedback: "Good practice but doesn't replace keeping frameworks updated.",
              nextStep: 2
            },
            {
              text: "Use the oldest stable framework version",
              correct: false,
              points: -10,
              feedback: "Older versions often have known vulnerabilities - use supported versions.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Framework security established! All components now regularly updated with automated security monitoring.",
          choices: []
        }
      ]
    }
  },

  loggingFailuresAdditional: {
    id: 208,
    title: "Missing Database Query Logging",
    difficulty: "Medium",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You're testing an application and notice database queries aren't logged, especially failed authentication attempts. What's the risk?",
          choices: [
            {
              text: "SQL injection attacks and database abuse can go undetected",
              correct: true,
              points: 15,
              feedback: "Critical finding! Without database query logging, many attacks including SQL injection can proceed without detection.",
              nextStep: 1
            },
            {
              text: "Only affects database performance tuning",
              correct: false,
              points: 5,
              feedback: "This is a security monitoring failure, not performance optimization.",
              nextStep: 0
            },
            {
              text: "Risk is limited to this specific database",
              correct: false,
              points: 5,
              feedback: "Missing database security logging affects the entire application security posture.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate SQL injection without any database logging. How do you show the detection gap?",
          choices: [
            {
              text: "Show how attacks can proceed undetected without query monitoring",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating that attacks leave no traces in logs shows critical detection failures.",
              nextStep: 2
            },
            {
              text: "Actually extract large amounts of data to prove no logging",
              correct: false,
              points: -15,
              feedback: "Mass data extraction is unethical and potentially illegal.",
              nextStep: 2
            },
            {
              text: "Just report the lack of database logs",
              correct: false,
              points: 10,
              feedback: "Good for technical reporting, but demonstrating the detection gap shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Database security monitoring gap exposed! Missing query logging allows undetected attacks and data breaches.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing database security monitoring. What queries are critical to log?",
          choices: [
            {
              text: "Authentication attempts, data modification queries, and administrative operations",
              correct: true,
              points: 15,
              feedback: "Perfect! These database operations provide crucial security monitoring data for detection and investigation.",
              nextStep: 1
            },
            {
              text: "Only SELECT queries for reporting",
              correct: false,
              points: 5,
              feedback: "Data modification and authentication attempts are equally important for security.",
              nextStep: 1
            },
            {
              text: "All database queries regardless of type",
              correct: false,
              points: 10,
              feedback: "Too noisy - focus on security-relevant operations first.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good selection! What comprehensive database security monitoring should you implement?",
          choices: [
            {
              text: "Implement query logging, anomaly detection, and database activity monitoring",
              correct: true,
              points: 20,
              feedback: "Excellent! Comprehensive monitoring including basic logging, behavioral analysis, and specialized database security tools.",
              nextStep: 2
            },
            {
              text: "Log everything and rely on database administrators to review",
              correct: false,
              points: 5,
              feedback: "Manual review doesn't scale - automated monitoring is essential.",
              nextStep: 2
            },
            {
              text: "Only monitor during peak hours",
              correct: false,
              points: -10,
              feedback: "Database attacks can occur at any time - continuous monitoring is essential.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Database security monitoring established! All critical operations now properly logged with automated detection.",
          choices: []
        }
      ]
    }
  },

  ssrfAdditional: {
    id: 209,
    title: "PDF Generation SSRF",
    difficulty: "Hard",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "You discover a feature that generates PDFs from web pages by fetching URLs. How do you test for SSRF in this context?",
          choices: [
            {
              text: "Provide internal service URLs to see if the PDF generator fetches them",
              correct: true,
              points: 20,
              feedback: "Correct! PDF generation services often fetch URLs and can be exploited for SSRF to internal networks.",
              nextStep: 1
            },
            {
              text: "Try to inject JavaScript in the PDF content",
              correct: false,
              points: 10,
              feedback: "PDF injection is different from SSRF vulnerability testing.",
              nextStep: 0
            },
            {
              text: "Check if PDF metadata can be modified",
              correct: false,
              points: 5,
              feedback: "Metadata modification is different from SSRF vulnerability testing.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully trigger requests to internal services through PDF generation. The service includes response data in PDFs. What's the impact?",
          choices: [
            {
              text: "Show how internal service data can be extracted through generated PDFs",
              correct: true,
              points: 25,
              feedback: "Critical! If internal service responses appear in PDFs, SSRF becomes a serious information disclosure vulnerability.",
              nextStep: 2
            },
            {
              text: "Use the internal access to modify backend services",
              correct: false,
              points: -20,
              feedback: "Unauthorized modification of services is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the internal network access",
              correct: false,
              points: 15,
              feedback: "Good start, but data extraction shows greater impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical PDF generation SSRF vulnerability! Internal network access and data extraction possible through PDF generation feature.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing PDF generation functionality. What's the primary SSRF defense?",
          choices: [
            {
              text: "Implement URL allowlisting and network restrictions for the PDF service",
              correct: true,
              points: 20,
              feedback: "Essential! Allowlisting ensures only approved domains are accessible, and network restrictions prevent internal access.",
              nextStep: 1
            },
            {
              text: "Validate URL format only",
              correct: false,
              points: 10,
              feedback: "Format validation doesn't prevent access to internal networks.",
              nextStep: 1
            },
            {
              text: "Add CAPTCHA to PDF generation requests",
              correct: false,
              points: 5,
              feedback: "CAPTCHA prevents automation but doesn't fix SSRF vulnerabilities.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive PDF generation security should you implement?",
          choices: [
            {
              text: "Use allowlists, outbound proxies, and content sanitization",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including application controls, network security, and output sanitization.",
              nextStep: 2
            },
            {
              text: "Disable all PDF generation features",
              correct: false,
              points: 0,
              feedback: "Not practical for business requirements.",
              nextStep: 2
            },
            {
              text: "Only allow PDF generation from same-domain URLs",
              correct: false,
              points: 10,
              feedback: "Too restrictive for legitimate use cases.",
              nextStep: 2
            }
          ]
        },
        {
          text: "PDF generation security established! All URL fetching now properly validated and restricted with network controls.",
          choices: []
        }
      ]
    }
  },

  insecureDesignAdditional: {
    id: 210,
    title: "Concurrency flaw in Inventory Management",
    difficulty: "Hard",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You notice an inventory system doesn't properly handle concurrent purchase requests for limited stock. What race condition could you test?",
          choices: [
            {
              text: "Send multiple purchase requests simultaneously to oversell limited inventory",
              correct: true,
              points: 20,
              feedback: "Correct! Race conditions in inventory management can allow selling more items than available in stock.",
              nextStep: 1
            },
            {
              text: "Try to modify inventory counts during processing",
              correct: false,
              points: 10,
              feedback: "Inventory modification is different from race condition exploitation.",
              nextStep: 0
            },
            {
              text: "Check if inventory updates are logged properly",
              correct: false,
              points: 5,
              feedback: "Logging is important but doesn't address the race condition design flaw.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully demonstrate overselling through concurrent requests. How do you show the business impact?",
          choices: [
            {
              text: "Show how the design flaw can lead to inventory discrepancies and customer issues",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating the potential for inventory problems and customer dissatisfaction shows real business impact.",
              nextStep: 2
            },
            {
              text: "Actually oversell items to cause real inventory problems",
              correct: false,
              points: -30,
              feedback: "Causing actual business disruption is unethical and potentially damaging.",
              nextStep: 2
            },
            {
              text: "Just report the concurrent request issue",
              correct: false,
              points: 15,
              feedback: "Good for technical reporting, but business impact demonstration is crucial.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical design flaw! Race condition in inventory management allows overselling and business disruption.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're designing inventory system integrity. What's the fundamental principle?",
          choices: [
            {
              text: "Implement database transactions and optimistic locking for inventory updates",
              correct: true,
              points: 20,
              feedback: "Essential! Database transactions with proper locking prevent race conditions in inventory management.",
              nextStep: 1
            },
            {
              text: "Add delays between inventory checks",
              correct: false,
              points: 5,
              feedback: "Delays don't reliably prevent race conditions and hurt user experience.",
              nextStep: 1
            },
            {
              text: "Use client-side inventory validation",
              correct: false,
              points: 10,
              feedback: "Client-side validation can be bypassed and is not reliable for server-side consistency.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good principle! What comprehensive inventory security should you implement?",
          choices: [
            {
              text: "Use database transactions, inventory reservations, and real-time sync",
              correct: true,
              points: 25,
              feedback: "Perfect! Transactions prevent race conditions, reservations hold inventory during purchase, and real-time sync ensures accuracy.",
              nextStep: 2
            },
            {
              text: "Process only one purchase at a time globally",
              correct: false,
              points: 5,
              feedback: "Not scalable for e-commerce systems.",
              nextStep: 2
            },
            {
              text: "Add multiple confirmation steps for users",
              correct: false,
              points: 10,
              feedback: "User confirmations don't prevent race conditions at the system level.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Inventory system integrity established! All inventory operations now use proper transactions with reservation system.",
          choices: []
        }
      ]
    }
  },

    sqlInjectionMixed: {
    id: 211,
    title: "SQL Injection in Analytics Dashboard",
    difficulty: "Hard",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover an analytics dashboard that builds dynamic SQL queries from user-selected filters. The queries are complex with multiple JOINs. What advanced SQLi technique would you use?",
          choices: [
            {
              text: "Use stacked queries with time-based blind SQL injection to map the database",
              correct: true,
              points: 20,
              feedback: "Excellent! Stacked queries with time delays allow you to systematically map complex database structures without visible output.",
              nextStep: 1
            },
            {
              text: "Try simple UNION SELECT payloads",
              correct: false,
              points: 10,
              feedback: "UNION may not work with complex queries involving multiple JOINs and different column structures.",
              nextStep: 0
            },
            {
              text: "Attempt to shutdown the database",
              correct: false,
              points: -15,
              feedback: "Destructive actions are unethical and could disrupt business operations.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You've mapped the database structure using blind SQLi. Now you want to extract sensitive business intelligence data. What's your approach?",
          choices: [
            {
              text: "Use conditional responses to extract financial data and business metrics byte by byte",
              correct: true,
              points: 25,
              feedback: "Perfect! Conditional time-based extraction allows you to slowly retrieve sensitive business data without triggering alerts.",
              nextStep: 2
            },
            {
              text: "Export entire database tables at once",
              correct: false,
              points: 15,
              feedback: "Large data exports might trigger performance monitoring alerts.",
              nextStep: 2
            },
            {
              text: "Modify financial records in the database",
              correct: false,
              points: -25,
              feedback: "Unauthorized data modification is illegal and unethical.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Advanced SQL injection successful! Complex analytics queries vulnerable to blind SQLi, exposing sensitive business intelligence data.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing a complex analytics system with dynamic queries. What's the most robust defense against advanced SQLi?",
          choices: [
            {
              text: "Implement stored procedures with strict input validation and use ORM for complex queries",
              correct: true,
              points: 20,
              feedback: "Perfect! Stored procedures separate SQL logic from data, while ORM adds an abstraction layer for complex operations.",
              nextStep: 1
            },
            {
              text: "Add a WAF with SQL injection rules",
              correct: false,
              points: 10,
              feedback: "WAFs can be bypassed and don't address the root cause in application code.",
              nextStep: 1
            },
            {
              text: "Use parameterized queries only for simple filters",
              correct: false,
              points: 5,
              feedback: "All user inputs in all queries must be parameterized, regardless of complexity.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive security measures should you implement for the analytics platform?",
          choices: [
            {
              text: "Use query whitelisting, database auditing, and principle of least privilege for database users",
              correct: true,
              points: 25,
              feedback: "Excellent! Multiple layers including restricted query patterns, comprehensive monitoring, and minimal database permissions.",
              nextStep: 2
            },
            {
              text: "Encrypt all database connections only",
              correct: false,
              points: 10,
              feedback: "Encryption protects data in transit but doesn't prevent SQL injection.",
              nextStep: 2
            },
            {
              text: "Limit analytics to admin users only",
              correct: false,
              points: 15,
              feedback: "Access control helps but doesn't prevent SQL injection if admins can be compromised.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Analytics platform secured! All dynamic queries now use stored procedures with strict validation and comprehensive monitoring.",
          choices: []
        }
      ]
    }
  },

  brokenAuthMixed: {
    id: 212,
    title: "OAuth Implementation Flaws",
    difficulty: "Medium",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You're testing an OAuth 2.0 implementation. You notice the state parameter is missing or predictable. What's the specific risk?",
          choices: [
            {
              text: "CSRF attacks can hijack OAuth flows and link attacker accounts to victim sessions",
              correct: true,
              points: 15,
              feedback: "Correct! Missing state parameters allow CSRF attacks where attackers can complete OAuth flows in victim sessions.",
              nextStep: 1
            },
            {
              text: "OAuth tokens can be easily guessed",
              correct: false,
              points: 10,
              feedback: "OAuth tokens are typically secure - the state parameter is for CSRF protection.",
              nextStep: 0
            },
            {
              text: "User passwords are exposed",
              correct: false,
              points: 5,
              feedback: "OAuth doesn't involve password sharing with the application.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully demonstrate OAuth CSRF by linking your social account to a victim's session. What's the impact?",
          choices: [
            {
              text: "Show how attackers can gain unauthorized access through linked social accounts",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating account linking through OAuth CSRF shows how attackers can bypass authentication.",
              nextStep: 2
            },
            {
              text: "Actually access the victim's account data",
              correct: false,
              points: -20,
              feedback: "Unauthorized account access is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the missing state parameter",
              correct: false,
              points: 10,
              feedback: "Good for technical reporting, but demonstrating the attack impact is more compelling.",
              nextStep: 2
            }
          ]
        },
        {
          text: "OAuth implementation flaw exposed! Missing state parameter allows CSRF attacks and unauthorized account linking.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing OAuth 2.0 security. What's the essential security control for state parameters?",
          choices: [
            {
              text: "Use cryptographically secure random state values and validate them upon callback",
              correct: true,
              points: 15,
              feedback: "Essential! Secure random state values prevent prediction, and validation ensures the OAuth flow wasn't tampered with.",
              nextStep: 1
            },
            {
              text: "Use sequential numbers for state parameters",
              correct: false,
              points: -10,
              feedback: "Predictable state values defeat the purpose of CSRF protection.",
              nextStep: 1
            },
            {
              text: "Store state values in cookies only",
              correct: false,
              points: 5,
              feedback: "State should be passed in both the request and validated upon return.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive OAuth security should you implement?",
          choices: [
            {
              text: "Implement PKCE, secure state handling, and validate redirect URIs strictly",
              correct: true,
              points: 20,
              feedback: "Perfect! PKCE prevents code interception, secure state prevents CSRF, and redirect URI validation prevents open redirects.",
              nextStep: 2
            },
            {
              text: "Use OAuth 1.0 instead for better security",
              correct: false,
              points: 5,
              feedback: "OAuth 2.0 with proper security measures is the current standard.",
              nextStep: 2
            },
            {
              text: "Disable OAuth for sensitive applications",
              correct: false,
              points: 10,
              feedback: "OAuth is widely used and can be secure with proper implementation.",
              nextStep: 2
            }
          ]
        },
        {
          text: "OAuth security established! All flows now use secure state parameters with PKCE and proper validation.",
          choices: []
        }
      ]
    }
  },

  cryptographicFailuresMixed: {
    id: 213,
    title: "Weak Encryption in File Uploads",
    difficulty: "Easy",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover an application that encrypts uploaded files using a static encryption key hardcoded in the source. What's the risk?",
          choices: [
            {
              text: "All encrypted files can be decrypted if the source code is exposed",
              correct: true,
              points: 15,
              feedback: "Critical finding! Hardcoded encryption keys expose all encrypted data if the source code is compromised.",
              nextStep: 1
            },
            {
              text: "Files might be too large to encrypt",
              correct: false,
              points: 5,
              feedback: "Size limitations are operational, not cryptographic issues.",
              nextStep: 0
            },
            {
              text: "Only affects current file uploads",
              correct: false,
              points: 5,
              feedback: "All files encrypted with the static key are vulnerable, past and future.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You obtain the source code and find the hardcoded encryption key. How do you demonstrate the data exposure risk?",
          choices: [
            {
              text: "Show how any encrypted file can be decrypted using the exposed key",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating file decryption with the exposed key shows the complete failure of encryption protection.",
              nextStep: 2
            },
            {
              text: "Actually decrypt and download user files",
              correct: false,
              points: -20,
              feedback: "Accessing user files without authorization is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the hardcoded key",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating decryption capability shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical cryptographic failure! Hardcoded encryption keys render file encryption useless and expose all user data.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing secure file encryption. What's the correct approach for key management?",
          choices: [
            {
              text: "Use a key management system and derive unique keys for different data",
              correct: true,
              points: 15,
              feedback: "Essential! Proper key management systems provide secure storage and rotation, while unique keys limit exposure.",
              nextStep: 1
            },
            {
              text: "Store encryption keys in environment variables",
              correct: false,
              points: 10,
              feedback: "Environment variables are better than hardcoding but don't provide proper key management features.",
              nextStep: 1
            },
            {
              text: "Use the same strong key for all encryption",
              correct: false,
              points: -10,
              feedback: "Key reuse creates massive risk if the key is compromised.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive file encryption security should you implement?",
          choices: [
            {
              text: "Use KMS, key rotation policies, and encrypt-then-MAC approach",
              correct: true,
              points: 20,
              feedback: "Perfect! Key management with rotation policies and encrypt-then-MAC ensures both confidentiality and integrity.",
              nextStep: 2
            },
            {
              text: "Encrypt files only during transmission",
              correct: false,
              points: 5,
              feedback: "Files at rest also need protection.",
              nextStep: 2
            },
            {
              text: "Use custom encryption algorithms",
              correct: false,
              points: -15,
              feedback: "Never roll your own crypto - use proven standard algorithms.",
              nextStep: 2
            }
          ]
        },
        {
          text: "File encryption secured! All files now encrypted with proper key management and security best practices.",
          choices: []
        }
      ]
    }
  },

  brokenAccessControlMixed: {
    id: 214,
    title: "GraphQL Field-Level Authorization Bypass",
    difficulty: "Hard",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You're testing a GraphQL API and notice some fields require special permissions, but the authorization seems inconsistent. How do you test for field-level access control bypass?",
          choices: [
            {
              text: "Craft GraphQL queries requesting sensitive fields that should be restricted",
              correct: true,
              points: 20,
              feedback: "Correct! GraphQL field-level authorization must be explicitly implemented - missing checks can expose sensitive data.",
              nextStep: 1
            },
            {
              text: "Try SQL injection in GraphQL arguments",
              correct: false,
              points: 10,
              feedback: "Different vulnerability category - focus on GraphQL-specific authorization testing.",
              nextStep: 0
            },
            {
              text: "Modify GraphQL introspection queries",
              correct: false,
              points: 15,
              feedback: "Introspection reveals schema but doesn't directly test authorization bypass.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully access sensitive user fields through GraphQL without proper authorization. How do you demonstrate the data exposure?",
          choices: [
            {
              text: "Show how unauthorized users can extract sensitive personal information through field selection",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating sensitive data extraction through GraphQL field selection shows critical authorization failure.",
              nextStep: 2
            },
            {
              text: "Actually extract and store user personal data",
              correct: false,
              points: -25,
              feedback: "Collecting user personal data without authorization is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the accessible field names",
              correct: false,
              points: 15,
              feedback: "Good for technical reporting, but demonstrating data extraction shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical GraphQL authorization bypass! Missing field-level access control exposes sensitive user data through API queries.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing a GraphQL API. What's the essential approach for field-level authorization?",
          choices: [
            {
              text: "Implement resolver-level authorization checks for every field and object",
              correct: true,
              points: 20,
              feedback: "Essential! GraphQL resolvers must enforce authorization for each field, as the schema alone doesn't provide security.",
              nextStep: 1
            },
            {
              text: "Hide sensitive fields from the GraphQL schema",
              correct: false,
              points: 10,
              feedback: "Security through obscurity - fields can still be discovered and accessed.",
              nextStep: 1
            },
            {
              text: "Use query depth limiting only",
              correct: false,
              points: 5,
              feedback: "Depth limiting prevents complex queries but doesn't enforce field-level authorization.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive GraphQL security should you implement?",
          choices: [
            {
              text: "Use query complexity analysis, field-level authorization, and persistent queries",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including query analysis, fine-grained authorization, and query whitelisting.",
              nextStep: 2
            },
            {
              text: "Disable GraphQL introspection in production",
              correct: false,
              points: 10,
              feedback: "Introspection hiding helps but doesn't replace proper authorization.",
              nextStep: 2
            },
            {
              text: "Convert to REST API for better security",
              correct: false,
              points: 5,
              feedback: "GraphQL can be secure with proper implementation - technology choice doesn't guarantee security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "GraphQL security established! All fields now enforce proper authorization with query analysis and security controls.",
          choices: []
        }
      ]
    }
  },

  securityMisconfigMixed: {
    id: 215,
    title: "Container Security Misconfigurations",
    difficulty: "Medium",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover a containerized application running with excessive privileges. What specific container misconfiguration would you look for?",
          choices: [
            {
              text: "Containers running as root user with privileged mode enabled",
              correct: true,
              points: 15,
              feedback: "Critical finding! Containers running as root with privileged mode can break out to the host system.",
              nextStep: 1
            },
            {
              text: "Large container image sizes",
              correct: false,
              points: 5,
              feedback: "Image size affects performance but isn't a direct security misconfiguration.",
              nextStep: 0
            },
            {
              text: "Multiple services in one container",
              correct: false,
              points: 10,
              feedback: "While not best practice, this isn't the most critical security misconfiguration.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You find a container running with --privileged flag. How do you demonstrate the container escape risk?",
          choices: [
            {
              text: "Show how privileged containers can access host resources and break isolation",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating host resource access shows the container escape potential and isolation failure.",
              nextStep: 2
            },
            {
              text: "Actually break out of the container and access the host",
              correct: false,
              points: -20,
              feedback: "Container escape to host system is dangerous and unethical in testing.",
              nextStep: 2
            },
            {
              text: "Just report the privileged flag",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating the risk shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical container misconfiguration! Privileged containers allow host system access and break security isolation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing container deployments. What's the essential security principle?",
          choices: [
            {
              text: "Run containers as non-root users with minimal required privileges",
              correct: true,
              points: 15,
              feedback: "Essential! Principle of least privilege applies to containers - they should run with minimal permissions.",
              nextStep: 1
            },
            {
              text: "Use the latest container runtime only",
              correct: false,
              points: 10,
              feedback: "Updates help but don't replace proper security configuration.",
              nextStep: 1
            },
            {
              text: "Run all containers in privileged mode for functionality",
              correct: false,
              points: -15,
              feedback: "Privileged mode should be avoided as it breaks container security.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good principle! What comprehensive container security should you implement?",
          choices: [
            {
              text: "Use non-root users, read-only filesystems, and security context constraints",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including user security, filesystem protection, and runtime constraints.",
              nextStep: 2
            },
            {
              text: "Disable all container networking",
              correct: false,
              points: 5,
              feedback: "Not practical for most applications that need network connectivity.",
              nextStep: 2
            },
            {
              text: "Use the same security configuration for all containers",
              correct: false,
              points: 10,
              feedback: "Different containers may have different security requirements.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Container security established! All containers now run with minimal privileges and security best practices.",
          choices: []
        }
      ]
    }
  },

  insecureDeserializationMixed: {
    id: 216,
    title: "Node.js Deserialization via JSON.parse",
    difficulty: "Medium",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover a Node.js application that uses JSON.parse on untrusted data. What's the specific risk with prototype pollution?",
          choices: [
            {
              text: "Malicious JSON can modify JavaScript object prototypes and change application behavior",
              correct: true,
              points: 15,
              feedback: "Correct! Prototype pollution through JSON.parse can modify base object prototypes and lead to remote code execution.",
              nextStep: 1
            },
            {
              text: "JSON data can be too large and cause memory issues",
              correct: false,
              points: 10,
              feedback: "Memory issues are operational, not the primary security risk.",
              nextStep: 0
            },
            {
              text: "Data format validation might fail",
              correct: false,
              points: 5,
              feedback: "Validation failures are operational issues, not the core deserialization vulnerability.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully demonstrate prototype pollution through malicious JSON. How do you show the application compromise risk?",
          choices: [
            {
              text: "Show how prototype pollution can lead to application logic bypass and potential RCE",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating application behavior modification shows the serious impact of prototype pollution.",
              nextStep: 2
            },
            {
              text: "Actually achieve remote code execution and take over the application",
              correct: false,
              points: -25,
              feedback: "Achieving RCE and system takeover is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the JSON.parse usage",
              correct: false,
              points: 10,
              feedback: "Good for technical reporting, but demonstrating impact shows severity.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical Node.js deserialization vulnerability! JSON.parse with untrusted data allows prototype pollution and application compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing Node.js application data handling. What's the primary defense against prototype pollution?",
          choices: [
            {
              text: "Use schema validation libraries and avoid using untrusted data with JSON.parse",
              correct: true,
              points: 15,
              feedback: "Essential! Schema validation ensures data structure, while avoiding JSON.parse on untrusted data prevents pollution.",
              nextStep: 1
            },
            {
              text: "Use Object.freeze on all prototypes",
              correct: false,
              points: 10,
              feedback: "Freezing prototypes helps but doesn't prevent all pollution vectors and can break functionality.",
              nextStep: 1
            },
            {
              text: "Use base64 encoding for JSON data",
              correct: false,
              points: 5,
              feedback: "Encoding doesn't prevent prototype pollution during parsing.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive Node.js security should you implement?",
          choices: [
            {
              text: "Use schema validation, safe object creation, and security linters",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including validation, safe programming patterns, and automated security checking.",
              nextStep: 2
            },
            {
              text: "Disable all JSON parsing in the application",
              correct: false,
              points: 0,
              feedback: "Not practical for web applications that need to handle JSON data.",
              nextStep: 2
            },
            {
              text: "Use the latest Node.js version only",
              correct: false,
              points: 10,
              feedback: "Updates help but don't automatically fix insecure code patterns.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Node.js data handling secured! All JSON parsing now uses schema validation with prototype pollution protection.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponentsMixed: {
    id: 217,
    title: "Supply Chain Attack via npm Packages",
    difficulty: "Hard",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You're analyzing an application's dependency tree and find a popular npm package with known malicious code. What's the supply chain risk?",
          choices: [
            {
              text: "Malicious packages can execute arbitrary code during installation or runtime",
              correct: true,
              points: 20,
              feedback: "Critical finding! Malicious npm packages can contain backdoors, credential stealers, or cryptocurrency miners.",
              nextStep: 1
            },
            {
              text: "Packages might be too large to download",
              correct: false,
              points: 5,
              feedback: "Size issues are operational, not security risks.",
              nextStep: 0
            },
            {
              "text": "Only affects development environments",
              correct: false,
              points: 10,
              feedback: "Malicious packages affect both development and production environments.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You identify a malicious npm package that steals environment variables. How do you demonstrate the data theft risk?",
          choices: [
            {
              text: "Show how the package can exfiltrate sensitive configuration and credentials",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating credential and configuration exposure through malicious packages shows critical supply chain risk.",
              nextStep: 2
            },
            {
              text: "Actually use the package to steal real credentials",
              correct: false,
              points: -30,
              feedback: "Stealing real credentials is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the package name",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating the attack mechanism shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical supply chain vulnerability! Malicious npm packages can compromise the entire application and steal sensitive data.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the software supply chain. What's the essential practice for npm packages?",
          choices: [
            {
              text: "Implement automated vulnerability scanning and use lockfiles with integrity hashes",
              correct: true,
              points: 20,
              feedback: "Essential! Automated scanning detects known vulnerabilities, while lockfiles with hashes prevent unauthorized package changes.",
              nextStep: 1
            },
            {
              text: "Only use packages from well-known authors",
              correct: false,
              points: 10,
              feedback: "Even reputable authors can have compromised packages or make mistakes.",
              nextStep: 1
            },
            {
              text: "Manually review all package source code",
              correct: false,
              points: 5,
              feedback: "Not practical for applications with hundreds of dependencies.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive supply chain security should you implement?",
          choices: [
            {
              text: "Use automated scanning, software bill of materials, and dependency pinning",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive supply chain security including detection, inventory management, and version control.",
              nextStep: 2
            },
            {
              text: "Disable all automatic package updates",
              correct: false,
              points: 5,
              feedback: "Regular updates are needed to patch vulnerabilities.",
              nextStep: 2
            },
            {
              text: "Build all dependencies from source",
              correct: false,
              points: 10,
              feedback: "Not practical and doesn't prevent malicious source code.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Supply chain security established! All dependencies now scanned and monitored with comprehensive security controls.",
          choices: []
        }
      ]
    }
  },

  loggingFailuresMixed: {
    id: 218,
    title: "Missing Cloud Infrastructure Logging",
    difficulty: "Easy",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover cloud infrastructure (AWS/Azure/GCP) without proper logging enabled. What's the specific risk with missing cloud trail logs?",
          choices: [
            {
              text: "Cloud infrastructure changes and security events go undetected",
              correct: true,
              points: 15,
              feedback: "Critical finding! Missing cloud logs mean infrastructure changes, security events, and attacks can proceed without detection.",
              nextStep: 1
            },
            {
              text: "Only affects billing and cost management",
              correct: false,
              points: 5,
              feedback: "This is a security monitoring failure, not just a cost issue.",
              nextStep: 0
            },
            {
              text: "Risk is limited to performance monitoring",
              correct: false,
              points: 5,
              feedback: "Missing security logging affects incident response and threat detection.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate creating cloud resources without any logging. How do you show the security monitoring gap?",
          choices: [
            {
              text: "Show how infrastructure changes and potential attacks leave no audit trail",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating that cloud activities are invisible to security teams shows critical monitoring failures.",
              nextStep: 2
            },
            {
              text: "Actually create unauthorized cloud resources",
              correct: false,
              points: -15,
              feedback: "Creating unauthorized resources is unethical and could incur costs.",
              nextStep: 2
            },
            {
              text: "Just report the missing logging configuration",
              correct: false,
              points: 10,
              feedback: "Good for technical reporting, but demonstrating the monitoring gap shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical cloud logging failure! Missing infrastructure logging allows undetected changes and security incidents.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing cloud security monitoring. What's the essential logging to enable?",
          choices: [
            {
              text: "Enable cloud trail/activity logs for all services and regions",
              correct: true,
              points: 15,
              feedback: "Essential! Comprehensive cloud logging provides visibility into all infrastructure changes and security events.",
              nextStep: 1
            },
            {
              text: "Only log compute resource usage",
              correct: false,
              points: 5,
              feedback: "Security events include infrastructure changes, IAM activities, and data access.",
              nextStep: 1
            },
            {
              text: "Use cloud provider default logging only",
              correct: false,
              points: 10,
              feedback: "Default logging often misses critical security events - explicit configuration is needed.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive cloud security monitoring should you implement?",
          choices: [
            {
              text: "Enable comprehensive logging, implement SIEM integration, and set up alerts",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including basic logging, centralized monitoring, and proactive alerting.",
              nextStep: 2
            },
            {
              text: "Store logs locally in each cloud region",
              correct: false,
              points: 5,
              feedback: "Centralized logging is essential for comprehensive monitoring.",
              nextStep: 2
            },
            {
              text: "Only monitor during business hours",
              correct: false,
              points: -10,
              feedback: "Cloud attacks can occur at any time - 24/7 monitoring is essential.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cloud security monitoring established! All infrastructure now properly logged with centralized monitoring and alerting.",
          choices: []
        }
      ]
    }
  },

  ssrfMixed: {
    id: 219,
    title: "DNS Rebinding SSRF Attack",
    difficulty: "Hard",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "You discover an SSRF vulnerability but the application has IP-based filtering. What advanced technique could bypass this protection?",
          choices: [
            {
              text: "Use DNS rebinding to change IP resolution after initial validation",
              correct: true,
              points: 25,
              feedback: "Advanced technique! DNS rebinding allows bypassing IP filters by changing DNS resolution between validation and actual request.",
              nextStep: 1
            },
            {
              text: "Try using IPv6 addresses",
              correct: false,
              points: 10,
              feedback: "IPv6 might work but DNS rebinding is more reliable for bypassing filters.",
              nextStep: 0
            },
            {
              text: "Use URL shorteners",
              correct: false,
              points: 15,
              feedback: "URL shorteners might bypass some filters but not sophisticated IP-based protection.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully bypass IP filtering using DNS rebinding and access internal services. What's the impact?",
          choices: [
            {
              text: "Show how internal network services can be accessed despite IP filtering",
              correct: true,
              points: 30,
              feedback: "Perfect! Demonstrating that IP filters can be bypassed shows the limitation of this protection method.",
              nextStep: 2
            },
            {
              text: "Actually compromise internal services and extract data",
              correct: false,
              points: -35,
              feedback: "Unauthorized access to internal services is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the DNS rebinding possibility",
              correct: false,
              points: 20,
              feedback: "Good for technical reporting, but demonstrating the bypass shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Advanced SSRF vulnerability! DNS rebinding bypasses IP filtering and allows access to internal network services.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing robust SSRF protection. What's the essential defense against DNS rebinding?",
          choices: [
            {
              text: "Use allowlists with DNS resolution at validation time and request time",
              correct: true,
              points: 25,
              feedback: "Essential! DNS resolution at both validation and request time prevents rebinding attacks by ensuring consistent IP addresses.",
              nextStep: 1
            },
            {
              text: "Block all domains with short TTL values",
              correct: false,
              points: 15,
              feedback: "TTL blocking is not reliable and can block legitimate domains.",
              nextStep: 1
            },
            {
              text: "Use IP-based blacklists only",
              correct: false,
              points: 10,
              feedback: "IP blacklists can be bypassed and don't prevent DNS rebinding.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive SSRF protection should you implement?",
          choices: [
            {
              text: "Use allowlists, consistent DNS resolution, and network segmentation",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers including application controls, DNS security, and network architecture.",
              nextStep: 2
            },
            {
              text: "Disable all outbound HTTP requests",
              correct: false,
              points: 5,
              feedback: "Not practical for applications that need legitimate external calls.",
              nextStep: 2
            },
            {
              text: "Only allow requests to same-domain URLs",
              correct: false,
              points: 10,
              feedback: "Too restrictive for legitimate use cases.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Advanced SSRF protection established! All external requests now protected against DNS rebinding with comprehensive controls.",
          choices: []
        }
      ]
    }
  },

  insecureDesignMixed: {
    id: 220,
    title: "Business Logic Flaw in Multi-step Processes",
    difficulty: "Medium",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover a multi-step process (like user registration or order placement) that doesn't maintain state consistency. What design flaw could you test?",
          choices: [
            {
              text: "Skip validation steps by directly accessing final submission endpoints",
              correct: true,
              points: 15,
              feedback: "Correct! Multi-step processes must maintain state and enforce step sequence - skipping steps can bypass validation.",
              nextStep: 1
            },
            {
              text: "Try SQL injection on each step",
              correct: false,
              points: 10,
              feedback: "Technical vulnerabilities are different from business logic design flaws.",
              nextStep: 0
            },
            {
              text: "Modify step progress using browser developer tools",
              correct: false,
              points: 10,
              feedback: "Client-side modification is possible but direct endpoint access is more reliable.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully bypass intermediate steps and submit incomplete or invalid data. How do you show the business impact?",
          choices: [
            {
              text: "Show how the design flaw allows bypassing business rules and validation",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating that business rules can be bypassed shows critical design failures in multi-step processes.",
              nextStep: 2
            },
            {
              text: "Actually create invalid orders or user accounts",
              correct: false,
              points: -20,
              feedback: "Creating invalid business records is unethical and could disrupt operations.",
              nextStep: 2
            },
            {
              text: "Just report the step-skipping possibility",
              correct: false,
              points: 10,
              feedback: "Good for technical reporting, but demonstrating rule bypass shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical design flaw! Multi-step process lacks state consistency, allowing business rule bypass and invalid data submission.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're designing secure multi-step processes. What's the essential security principle?",
          choices: [
            {
              text: "Maintain server-side state and validate step sequence for every submission",
              correct: true,
              points: 15,
              feedback: "Essential! Server-side state management ensures process integrity and prevents step skipping.",
              nextStep: 1
            },
            {
              text: "Use client-side JavaScript to enforce step sequence",
              correct: false,
              points: 5,
              feedback: "Client-side controls can be bypassed - server-side validation is mandatory.",
              nextStep: 1
            },
            {
              text: "Add time delays between steps",
              correct: false,
              points: 10,
              feedback: "Time delays don't prevent step skipping and hurt user experience.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good principle! What comprehensive process design security should you implement?",
          choices: [
            {
              text: "Use server-side sessions, step validation, and business rule enforcement",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including state management, sequence validation, and consistent business logic.",
              nextStep: 2
            },
            {
              text: "Combine all steps into a single page",
              correct: false,
              points: 5,
              feedback: "Not practical for complex processes with many steps.",
              nextStep: 2
            },
            {
              text: "Require re-authentication for each step",
              correct: false,
              points: 10,
              feedback: "Creates poor user experience and doesn't prevent all logic flaws.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Multi-step process security established! All processes now maintain server-side state with proper sequence validation.",
          choices: []
        }
      ]
    }
  },

  
  sqlInjectionFresh: {
    id: 221,
    title: "Second-Order SQL Injection in User Comments",
    difficulty: "Hard",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover a blog platform that properly escapes user comments when displayed, but stores them without sanitization. What type of SQL injection could this enable?",
          choices: [
            {
              text: "Second-order SQL injection where malicious comments affect other database operations",
              correct: true,
              points: 20,
              feedback: "Excellent! Second-order SQL injection occurs when stored unsanitized data is later used in SQL queries, bypassing initial output encoding.",
              nextStep: 1
            },
            {
              text: "Immediate SQL injection when comments are posted",
              correct: false,
              points: 10,
              feedback: "The initial posting might be safe due to parameterized queries, but the stored data could be dangerous later.",
              nextStep: 0
            },
            {
              text: "Cross-site scripting in comments",
              correct: false,
              points: 5,
              feedback: "XSS is different from SQL injection, though both can involve user comments.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You find that admin functions use the unsanitized comment data in SQL queries. How do you demonstrate the attack?",
          choices: [
            {
              text: "Post a comment with SQL payload that triggers when admins process comments",
              correct: true,
              points: 25,
              feedback: "Perfect! Second-order attacks trigger when the stored malicious data is used in a different context without proper sanitization.",
              nextStep: 2
            },
            {
              text: "Try to delete all comments immediately",
              correct: false,
              points: -15,
              feedback: "Destructive actions are unethical and could damage the application.",
              nextStep: 2
            },
            {
              text: "Report the storage method without testing",
              correct: false,
              points: 10,
              feedback: "Testing demonstrates the actual risk and impact of the vulnerability.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Second-order SQL injection confirmed! Unsanitized storage of user comments enables delayed SQL injection attacks through admin functions.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing a comment system against second-order SQL injection. What's the most robust approach?",
          choices: [
            {
              text: "Use parameterized queries for both storage and retrieval, and validate input upon storage",
              correct: true,
              points: 20,
              feedback: "Perfect! Consistent use of parameterized queries throughout the application prevents both first and second-order SQL injection.",
              nextStep: 1
            },
            {
              text: "Only sanitize output when displaying comments",
              correct: false,
              points: 10,
              feedback: "Output encoding prevents XSS but doesn't protect against second-order SQL injection from stored data.",
              nextStep: 1
            },
            {
              text: "Store comments in a separate database",
              correct: false,
              points: 5,
              feedback: "Database separation doesn't prevent SQL injection if the data is still used in queries unsafely.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What additional security measures should you implement for user-generated content?",
          choices: [
            {
              text: "Implement content validation, use prepared statements everywhere, and conduct security reviews",
              correct: true,
              points: 25,
              feedback: "Excellent! Multiple layers including input validation, consistent safe coding practices, and code review processes.",
              nextStep: 2
            },
            {
              text: "Limit comment length to prevent attacks",
              correct: false,
              points: 10,
              feedback: "Length limits help with some attacks but don't prevent SQL injection.",
              nextStep: 2
            },
            {
              text: "Only allow comments from verified users",
              correct: false,
              points: 5,
              feedback: "Authentication doesn't prevent SQL injection - the vulnerability is in code, not user trust.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Comment system secured! All user content now properly validated and stored with consistent use of parameterized queries.",
          choices: []
        }
      ]
    }
  },

  brokenAuthFresh: {
    id: 222,
    title: "JWT Token Revocation Vulnerability",
    difficulty: "Medium",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover that JWT tokens remain valid even after users logout or change passwords. What's the security risk?",
          choices: [
            {
              text: "Stolen tokens can be used indefinitely without revocation mechanism",
              correct: true,
              points: 15,
              feedback: "Critical finding! JWT tokens without revocation mechanisms allow attackers to use stolen tokens indefinitely.",
              nextStep: 1
            },
            {
              text: "Tokens might be too long for some browsers",
              correct: false,
              points: 5,
              feedback: "Token size is a technical limitation, not a security vulnerability.",
              nextStep: 0
            },
            {
              text: "User sessions might timeout too quickly",
              correct: false,
              points: 5,
              feedback: "Short timeouts are a security feature, not a vulnerability.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You obtain a valid JWT token and demonstrate it works after the user logs out. How do you show the session management risk?",
          choices: [
            {
              text: "Show how the token provides continued access despite logout and password changes",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating that tokens remain valid after security events shows critical session management flaws.",
              nextStep: 2
            },
            {
              text: "Actually access the user's account with the token",
              correct: false,
              points: -20,
              feedback: "Unauthorized account access is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the token expiration time",
              correct: false,
              points: 10,
              feedback: "Good for technical reporting, but demonstrating the revocation failure shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical authentication flaw! JWT tokens lack revocation mechanism, allowing indefinite use of stolen tokens.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing secure JWT token management. What's the essential mechanism for token revocation?",
          choices: [
            {
              text: "Maintain a server-side token blacklist and short token expiration times",
              correct: true,
              points: 15,
              feedback: "Essential! Server-side blacklists enable token revocation while short expirations limit the damage window.",
              nextStep: 1
            },
            {
              text: "Use longer token expiration for better user experience",
              correct: false,
              points: -10,
              feedback: "Longer tokens increase the risk window - balance security with usability.",
              nextStep: 1
            },
            {
              text: "Store tokens in local storage only",
              correct: false,
              points: 5,
              feedback: "Storage location doesn't solve the revocation problem.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive JWT security should you implement?",
          choices: [
            {
              text: "Implement token blacklisting, refresh token rotation, and secure storage",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including revocation, token rotation for active sessions, and client-side protection.",
              nextStep: 2
            },
            {
              text: "Use the same secret key for all environments",
              correct: false,
              points: -15,
              feedback: "Different environments should use different keys for security isolation.",
              nextStep: 2
            },
            {
              text: "Disable JWT and use sessions instead",
              correct: false,
              points: 10,
              feedback: "JWT can be secure with proper implementation - technology choice doesn't guarantee security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "JWT security established! All tokens now support revocation with blacklisting and proper token lifecycle management.",
          choices: []
        }
      ]
    }
  },

  cryptographicFailuresFresh: {
    id: 223,
    title: "Insecure Random Number Generation",
    difficulty: "Easy",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover an application using Math.random() for security-critical operations like password reset tokens. What's the risk?",
          choices: [
            {
              text: "Predictable random values allow attackers to guess security tokens",
              correct: true,
              points: 15,
              feedback: "Critical finding! Math.random() is not cryptographically secure and produces predictable values that can be guessed.",
              nextStep: 1
            },
            {
              text: "The application might run slower",
              correct: false,
              points: 5,
              feedback: "Performance is not the primary concern - security is compromised.",
              nextStep: 0
            },
            {
              text: "Only affects the user interface",
              correct: false,
              points: 5,
              feedback: "Insecure random generation affects all security mechanisms using those values.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate that password reset tokens follow predictable patterns. How do you show the account takeover risk?",
          choices: [
            {
              text: "Show how predictable tokens can be systematically guessed to reset passwords",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating token predictability shows how attackers can bypass authentication through systematic guessing.",
              nextStep: 2
            },
            {
              text: "Actually reset user passwords using guessed tokens",
              correct: false,
              points: -20,
              feedback: "Unauthorized password resets are illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the use of Math.random()",
              correct: false,
              points: 10,
              feedback: "Good for technical reporting, but demonstrating predictability shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical cryptographic failure! Insecure random number generation makes security tokens predictable and guessable.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing secure random number generation. What's the correct approach for security-critical operations?",
          choices: [
            {
              text: "Use cryptographically secure random APIs like crypto.getRandomValues()",
              correct: true,
              points: 15,
              feedback: "Essential! Cryptographically secure random number generators are specifically designed for security applications.",
              nextStep: 1
            },
            {
              text: "Use Math.random() with additional transformations",
              correct: false,
              points: -10,
              feedback: "Transformations don't make Math.random() secure - the underlying algorithm is still predictable.",
              nextStep: 1
            },
            {
              text: "Use system time as a random seed",
              correct: false,
              points: -15,
              feedback: "System time is predictable and doesn't provide real randomness.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive random number security should you implement?",
          choices: [
            {
              text: "Use secure random APIs, adequate entropy sources, and security reviews",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including proper APIs, sufficient entropy, and code review processes.",
              nextStep: 2
            },
            {
              text: "Use the same random seed for all operations",
              correct: false,
              points: -20,
              feedback: "Seed reuse creates patterns and predictability.",
              nextStep: 2
            },
            {
              text: "Generate random numbers client-side only",
              correct: false,
              points: 5,
              feedback: "Client-side generation is vulnerable to manipulation - server-side is more secure.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Random number generation secured! All security operations now use cryptographically secure random number generators.",
          choices: []
        }
      ]
    }
  },

  brokenAccessControlFresh: {
    id: 224,
    title: "Mass Assignment Vulnerability in API",
    difficulty: "Hard",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover a REST API that automatically binds request parameters to object properties. What vulnerability could this enable?",
          choices: [
            {
              text: "Mass assignment allowing attackers to set sensitive properties like isAdmin",
              correct: true,
              points: 20,
              feedback: "Correct! Mass assignment vulnerabilities occur when APIs automatically bind request data to object properties without filtering.",
              nextStep: 1
            },
            {
              text: "SQL injection through parameter manipulation",
              correct: false,
              points: 10,
              feedback: "SQL injection is different, though both involve parameter manipulation.",
              nextStep: 0
            },
            {
              text: "Rate limiting bypass through multiple parameters",
              correct: false,
              points: 5,
              feedback: "Rate limiting is a different security control.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully set admin privileges through mass assignment. How do you demonstrate the privilege escalation risk?",
          choices: [
            {
              text: "Show how any user can elevate privileges by setting protected properties",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating privilege escalation through mass assignment shows critical access control failure.",
              nextStep: 2
            },
            {
              text: "Actually create admin accounts and access sensitive data",
              correct: false,
              points: -25,
              feedback: "Unauthorized privilege escalation and data access are illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the automatic binding feature",
              correct: false,
              points: 15,
              feedback: "Good for technical reporting, but demonstrating escalation shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical mass assignment vulnerability! Automatic parameter binding allows privilege escalation and unauthorized property modification.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing API endpoints against mass assignment. What's the essential approach?",
          choices: [
            {
              text: "Use whitelists of allowed properties and explicitly bind only safe fields",
              correct: true,
              points: 20,
              feedback: "Essential! Explicit whitelisting ensures only intended properties can be set through API requests.",
              nextStep: 1
            },
            {
              text: "Use blacklists to block sensitive field names",
              correct: false,
              points: 10,
              feedback: "Blacklists can be bypassed with field name variations and are less secure than whitelists.",
              nextStep: 1
            },
            {
              text: "Encrypt all API request data",
              correct: false,
              points: 5,
              feedback: "Encryption protects data in transit but doesn't prevent mass assignment.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive API security should you implement?",
          choices: [
            {
              text: "Implement property whitelisting, input validation, and schema validation",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including explicit property control, input validation, and structural validation.",
              nextStep: 2
            },
            {
              text: "Disable automatic binding entirely",
              correct: false,
              points: 10,
              feedback: "Automatic binding is convenient - better to implement it securely.",
              nextStep: 2
            },
            {
              text: "Only allow property updates through admin interfaces",
              correct: false,
              points: 5,
              feedback: "Legitimate user property updates need to be supported securely.",
              nextStep: 2
            }
          ]
        },
        {
          text: "API security established! All endpoints now use explicit property whitelisting with comprehensive validation.",
          choices: []
        }
      ]
    }
  },

  securityMisconfigFresh: {
    id: 225,
    title: "Exposed AWS S3 Buckets",
    difficulty: "Medium",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover AWS S3 buckets with public read permissions containing sensitive files. What's the immediate data exposure risk?",
          choices: [
            {
              text: "Public access allows anyone to download confidential documents and data",
              correct: true,
              points: 15,
              feedback: "Critical finding! Public S3 buckets expose sensitive data to anyone on the internet without authentication.",
              nextStep: 1
            },
            {
              text: "Only affects bucket organization",
              correct: false,
              points: 5,
              feedback: "This is a data security issue, not an organizational concern.",
              nextStep: 0
            },
            {
              text: "Risk is limited to AWS account owners",
              correct: false,
              points: 5,
              feedback: "Public buckets are accessible to anyone with the URL, not just account users.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You access sensitive files from the public S3 bucket. How do you demonstrate the data breach risk?",
          choices: [
            {
              text: "Show how confidential documents are publicly accessible without authentication",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating unauthorized access to sensitive files shows critical data exposure.",
              nextStep: 2
            },
            {
              text: "Actually download and analyze the confidential files",
              correct: false,
              points: -20,
              feedback: "Accessing and analyzing confidential data without authorization is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the public bucket configuration",
              correct: false,
              points: 10,
              feedback: "Good for technical reporting, but demonstrating access shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical cloud misconfiguration! Public S3 buckets expose sensitive documents and data to unauthorized access.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing cloud storage configurations. What's the essential security principle for S3 buckets?",
          choices: [
            {
              text: "Apply principle of least privilege and block public access by default",
              correct: true,
              points: 15,
              feedback: "Essential! S3 buckets should be private by default, with access granted only to specific authorized principals.",
              nextStep: 1
            },
            {
              text: "Use complex bucket names to hide them",
              correct: false,
              points: 5,
              feedback: "Security through obscurity is not a reliable defense.",
              nextStep: 1
            },
            {
              text: "Enable public read for all buckets for easier access",
              correct: false,
              points: -15,
              feedback: "Public access should be the exception, not the rule, for security.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good principle! What comprehensive cloud storage security should you implement?",
          choices: [
            {
              text: "Use private buckets, IAM policies, encryption, and access logging",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including access control, identity management, data protection, and monitoring.",
              nextStep: 2
            },
            {
              text: "Store all data in public buckets with encryption",
              correct: false,
              points: -10,
              feedback: "Public buckets should be avoided for sensitive data regardless of encryption.",
              nextStep: 2
            },
            {
              text: "Use the same permissions for all buckets",
              correct: false,
              points: 5,
              feedback: "Different buckets may contain data with different sensitivity levels.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cloud storage secured! All S3 buckets now properly configured with least privilege and comprehensive security controls.",
          choices: []
        }
      ]
    }
  },

  insecureDeserializationFresh: {
    id: 226,
    title: "YAML Deserialization Attack",
    difficulty: "Hard",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover an application that deserializes YAML configuration files from untrusted sources. What's the specific risk with YAML deserialization?",
          choices: [
            {
              text: "YAML parsers can instantiate arbitrary objects leading to remote code execution",
              correct: true,
              points: 20,
              feedback: "Correct! YAML deserialization can execute arbitrary code through special tags that instantiate objects.",
              nextStep: 1
            },
            {
              text: "YAML files can be too large and cause memory issues",
              correct: false,
              points: 10,
              feedback: "Memory issues are operational, not the primary security risk.",
              nextStep: 0
            },
            {
              text: "Data format validation might fail",
              correct: false,
              points: 5,
              feedback: "Validation failures are operational issues, not the core deserialization vulnerability.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully trigger remote code execution through malicious YAML. What's the ethical demonstration?",
          choices: [
            {
              text: "Show code execution capability without causing system harm or accessing data",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating RCE potential without destructive actions maintains ethical testing boundaries.",
              nextStep: 2
            },
            {
              text: "Actually compromise the server and install backdoors",
              correct: false,
              points: -30,
              feedback: "Server compromise is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the YAML parsing usage",
              correct: false,
              points: 15,
              feedback: "Good for technical reporting, but demonstrating impact shows severity.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical YAML deserialization vulnerability! Untrusted YAML parsing allows remote code execution through object instantiation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing YAML processing in your application. What's the primary defense against deserialization attacks?",
          choices: [
            {
              text: "Use safe YAML parsers that disable object instantiation and use schema validation",
              correct: true,
              points: 20,
              feedback: "Essential! Safe YAML parsers prevent dangerous object instantiation while schema validation ensures data structure.",
              nextStep: 1
            },
            {
              text: "Validate YAML file size limits only",
              correct: false,
              points: 10,
              feedback: "Size limits help with resource exhaustion but don't prevent code execution.",
              nextStep: 1
            },
            {
              text: "Use base64 encoding for YAML data",
              correct: false,
              points: 5,
              feedback: "Encoding doesn't prevent deserialization attacks during parsing.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive YAML security should you implement?",
          choices: [
            {
              text: "Use safe loaders, input validation, and restrict YAML features",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including safe parsing, validation, and feature restriction.",
              nextStep: 2
            },
            {
              text: "Disable all YAML processing in the application",
              correct: false,
              points: 5,
              feedback: "Not practical for applications that need configuration files.",
              nextStep: 2
            },
            {
              text: "Use the latest YAML library version only",
              correct: false,
              points: 10,
              feedback: "Updates help but don't automatically fix insecure usage patterns.",
              nextStep: 2
            }
          ]
        },
        {
          text: "YAML processing secured! All YAML parsing now uses safe loaders with validation and restricted features.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponentsFresh: {
    id: 227,
    title: "Malicious PyPI Packages",
    difficulty: "Medium",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You're analyzing a Python application's dependencies and find a PyPI package with suspicious behavior. What's the supply chain risk?",
          choices: [
            {
              text: "Malicious packages can execute code during installation or contain backdoors",
              correct: true,
              points: 15,
              feedback: "Critical finding! Malicious PyPI packages can contain malware, credential stealers, or cryptocurrency miners.",
              nextStep: 1
            },
            {
              text: "Packages might be too large to download",
              correct: false,
              points: 5,
              feedback: "Size issues are operational, not security risks.",
              nextStep: 0
            },
            {
              text: "Only affects development environments",
              correct: false,
              points: 10,
              feedback: "Malicious packages affect both development and production environments.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You identify a PyPI package that exfiltrates environment variables. How do you demonstrate the data theft risk?",
          choices: [
            {
              text: "Show how the package can steal configuration and credentials without actual exfiltration",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating data exposure potential through malicious packages shows critical supply chain risk.",
              nextStep: 2
            },
            {
              text: "Actually let the package steal real credentials",
              correct: false,
              points: -25,
              feedback: "Allowing actual data theft is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the package name",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating the attack mechanism shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical supply chain vulnerability! Malicious PyPI packages can compromise Python applications and steal sensitive data.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing Python application dependencies. What's the essential practice for PyPI packages?",
          choices: [
            {
              text: "Use virtual environments, requirement files with pinned versions, and security scanning",
              correct: true,
              points: 15,
              feedback: "Essential! Virtual environments provide isolation, pinned versions prevent unexpected updates, and scanning detects known vulnerabilities.",
              nextStep: 1
            },
            {
              text: "Only use packages from the standard library",
              correct: false,
              points: 5,
              feedback: "Not practical for most applications that need third-party functionality.",
              nextStep: 1
            },
            {
              text: "Manually review all package source code",
              correct: false,
              points: 10,
              feedback: "Not practical for applications with many dependencies.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive Python supply chain security should you implement?",
          choices: [
            {
              text: "Implement dependency scanning, virtual environments, and signed packages",
              correct: true,
              points: 20,
              feedback: "Perfect! Comprehensive supply chain security including detection, isolation, and integrity verification.",
              nextStep: 2
            },
            {
              text: "Disable all package updates",
              correct: false,
              points: 5,
              feedback: "Regular updates are needed to patch vulnerabilities.",
              nextStep: 2
            },
            {
              text: "Use the latest versions of all packages",
              correct: false,
              points: 10,
              feedback: "Latest versions might introduce breaking changes or new vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Python supply chain security established! All dependencies now scanned and managed with comprehensive security controls.",
          choices: []
        }
      ]
    }
  },

  loggingFailuresFresh: {
    id: 228,
    title: "Missing Application Performance Monitoring",
    difficulty: "Easy",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover an application without proper performance monitoring or anomaly detection. What security risks does this create?",
          choices: [
            {
              text: "Performance-based attacks and resource exhaustion can go undetected",
              correct: true,
              points: 15,
              feedback: "Critical finding! Missing performance monitoring allows attacks like DoS, resource exhaustion, and performance-based vulnerabilities to proceed undetected.",
              nextStep: 1
            },
            {
              text: "Only affects user experience during peak loads",
              correct: false,
              points: 5,
              feedback: "This is a security monitoring failure, not just a user experience issue.",
              nextStep: 0
            },
            {
              text: "Risk is limited to development environments",
              correct: false,
              points: 5,
              feedback: "Production monitoring is essential for security incident detection.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate a slow DoS attack that consumes resources without triggering alerts. How do you show the detection gap?",
          choices: [
            {
              text: "Show how resource exhaustion attacks proceed without performance monitoring alerts",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating that performance attacks are invisible without proper monitoring shows critical detection failures.",
              nextStep: 2
            },
            {
              text: "Actually cause service degradation or downtime",
              correct: false,
              points: -20,
              feedback: "Causing actual service disruption is unethical and potentially damaging.",
              nextStep: 2
            },
            {
              text: "Just report the missing monitoring",
              correct: false,
              points: 10,
              feedback: "Good for technical reporting, but demonstrating the detection gap shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical monitoring failure! Missing performance monitoring allows resource exhaustion attacks to proceed undetected.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing application performance monitoring. What metrics are essential for security?",
          choices: [
            {
              text: "CPU usage, memory consumption, response times, and error rates",
              correct: true,
              points: 15,
              feedback: "Essential! These performance metrics provide early warning signs of attacks and security incidents.",
              nextStep: 1
            },
            {
              text: "Only monitor user login success rates",
              correct: false,
              points: 5,
              feedback: "Performance monitoring includes resource usage, not just authentication events.",
              nextStep: 1
            },
            {
              text: "Only track business transaction volumes",
              correct: false,
              points: 10,
              feedback: "Business metrics are important but don't replace technical performance monitoring.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good selection! What comprehensive performance monitoring should you implement?",
          choices: [
            {
              text: "Implement real-time monitoring, alerting, and baseline performance analysis",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including real-time visibility, proactive alerts, and behavioral analysis.",
              nextStep: 2
            },
            {
              text: "Only monitor during business hours",
              correct: false,
              points: -10,
              feedback: "Attacks can occur at any time - 24/7 monitoring is essential.",
              nextStep: 2
            },
            {
              text: "Store performance data locally on each server",
              correct: false,
              points: 5,
              feedback: "Centralized monitoring is essential for comprehensive visibility.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Performance monitoring established! All applications now monitored with real-time alerts and baseline analysis.",
          choices: []
        }
      ]
    }
  },

  ssrfFresh: {
    id: 229,
    title: "URL Redirector SSRF",
    difficulty: "Medium",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "You discover a URL redirector feature that fetches and redirects to user-provided URLs. How could this be exploited for SSRF?",
          choices: [
            {
              text: "Provide internal service URLs to make the server access its own network",
              correct: true,
              points: 15,
              feedback: "Correct! URL redirectors that fetch URLs before redirecting can be exploited for SSRF to internal networks.",
              nextStep: 1
            },
            {
              text: "Try open redirect attacks only",
              correct: false,
              points: 10,
              feedback: "Open redirect is different from SSRF - both should be tested but SSRF is more critical.",
              nextStep: 0
            },
            {
              text: "Check if redirects are cached properly",
              correct: false,
              points: 5,
              feedback: "Caching is a performance concern, not a security vulnerability.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully trigger requests to internal services through the redirector. The application shows response metadata. What's the impact?",
          choices: [
            {
              text: "Show how internal service information can be extracted through redirector responses",
              correct: true,
              points: 20,
              feedback: "Perfect! If redirector responses include service information, SSRF becomes an information disclosure vulnerability.",
              nextStep: 2
            },
            {
              text: "Actually access internal services and modify data",
              correct: false,
              points: -20,
              feedback: "Unauthorized access to internal services is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the internal network access",
              correct: false,
              points: 10,
              feedback: "Good start, but information extraction shows greater impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical URL redirector SSRF vulnerability! Internal network access and information disclosure possible through redirector feature.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing a URL redirector feature. What's the primary SSRF defense?",
          choices: [
            {
              text: "Implement URL allowlisting and avoid fetching URLs before redirecting",
              correct: true,
              points: 15,
              feedback: "Essential! Allowlisting ensures only approved domains are redirected to, and avoiding URL fetching prevents SSRF.",
              nextStep: 1
            },
            {
              text: "Validate URL format only",
              correct: false,
              points: 10,
              feedback: "Format validation doesn't prevent access to internal networks.",
              nextStep: 1
            },
            {
              text: "Add CAPTCHA to redirect requests",
              correct: false,
              points: 5,
              feedback: "CAPTCHA prevents automation but doesn't fix SSRF vulnerabilities.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive redirector security should you implement?",
          choices: [
            {
              text: "Use allowlists, avoid URL fetching, and implement redirect confirmation",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including access control, SSRF prevention, and user awareness.",
              nextStep: 2
            },
            {
              text: "Disable all URL redirects",
              correct: false,
              points: 5,
              feedback: "Not practical for applications that need legitimate redirect functionality.",
              nextStep: 2
            },
            {
              text: "Only allow redirects to same-domain URLs",
              correct: false,
              points: 10,
              feedback: "Too restrictive for legitimate use cases like OAuth callbacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "URL redirector secured! All redirects now use allowlists without URL fetching for SSRF protection.",
          choices: []
        }
      ]
    }
  },

  insecureDesignFresh: {
    id: 230,
    title: "Time-of-Check Time-of-Use Race Condition",
    difficulty: "Hard",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover a file processing system that checks file permissions before use, but there's a time gap between check and use. What design flaw exists?",
          choices: [
            {
              text: "TOCTOU race condition allowing file substitution between permission check and access",
              correct: true,
              points: 20,
              feedback: "Correct! Time-of-Check Time-of-Use vulnerabilities occur when system state changes between validation and usage.",
              nextStep: 1
            },
            {
              text: "The files might be too large to process",
              correct: false,
              points: 5,
              feedback: "Size limitations are operational, not design flaws.",
              nextStep: 0
            },
            {
              text: "File permissions might be set incorrectly",
              correct: false,
              points: 10,
              feedback: "Permission misconfiguration is different from TOCTOU design flaws.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully demonstrate TOCTOU by replacing a file between check and use. How do you show the security bypass risk?",
          choices: [
            {
              text: "Show how the design flaw allows bypassing security checks through timing attacks",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating that security checks can be bypassed through timing shows critical design failures.",
              nextStep: 2
            },
            {
              text: "Actually access sensitive files through the vulnerability",
              correct: false,
              points: -25,
              feedback: "Unauthorized file access is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the time gap between operations",
              correct: false,
              points: 15,
              feedback: "Good for technical reporting, but demonstrating the bypass shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical TOCTOU design flaw! Race condition between permission check and file use allows security bypass.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're designing secure file processing. What's the essential principle to prevent TOCTOU?",
          choices: [
            {
              text: "Use atomic operations that combine check and use into a single operation",
              correct: true,
              points: 20,
              feedback: "Essential! Atomic operations ensure that validation and usage happen as a single, uninterruptible operation.",
              nextStep: 1
            },
            {
              text: "Add delays between check and use operations",
              correct: false,
              points: 5,
              feedback: "Delays don't reliably prevent race conditions and hurt performance.",
              nextStep: 1
            },
            {
              text: "Use client-side file validation",
              correct: false,
              points: 10,
              feedback: "Client-side validation can be bypassed and doesn't prevent server-side race conditions.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good principle! What comprehensive file security should you implement?",
          choices: [
            {
              text: "Use atomic operations, file handles instead of paths, and secure temporary files",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including atomicity, secure file references, and safe temporary file practices.",
              nextStep: 2
            },
            {
              text: "Process all files in a single thread",
              correct: false,
              points: 10,
              feedback: "Single-threading hurts performance and doesn't guarantee atomicity.",
              nextStep: 2
            },
            {
              text: "Disable all file uploads",
              correct: false,
              points: 5,
              feedback: "Not practical for applications that need file processing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "File processing security established! All file operations now use atomic operations with secure handling.",
          choices: []
        }
      ]
    }
  },

    sqlInjectionBrandNew: {
    id: 231,
    title: "NoSQL Injection in MongoDB Operations",
    difficulty: "Medium",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover a Node.js application using MongoDB with user input directly in find() operations. What NoSQL injection approach would you test?",
          choices: [
            {
              text: "Send operator objects like {$ne: null} to bypass authentication",
              correct: true,
              points: 20,
              feedback: "Excellent! NoSQL injection uses MongoDB operators to manipulate queries, like using $ne to find documents where password is 'not equal' to null.",
              nextStep: 1
            },
            {
              text: "Try traditional SQL injection payloads",
              correct: false,
              points: 5,
              feedback: "Traditional SQL injection won't work on NoSQL databases - different techniques are needed.",
              nextStep: 0
            },
            {
              text: "Use JSON escape sequences",
              correct: false,
              points: 10,
              feedback: "JSON escaping is different from NoSQL operator injection.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully bypass authentication using NoSQL injection. How do you demonstrate the data exposure risk?",
          choices: [
            {
              text: "Show how operator injection can extract user data and bypass business logic",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating data extraction through NoSQL operators shows critical injection vulnerability in the database layer.",
              nextStep: 2
            },
            {
              text: "Actually extract and download the entire user database",
              correct: false,
              points: -25,
              feedback: "Unauthorized data extraction is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the MongoDB usage",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating the attack shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "NoSQL injection vulnerability confirmed! MongoDB operator injection allows authentication bypass and data extraction.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing MongoDB operations against NoSQL injection. What's the most effective approach?",
          choices: [
            {
              text: "Use MongoDB driver's built-in sanitization and validate input types",
              correct: true,
              points: 20,
              feedback: "Perfect! MongoDB drivers provide type-safe methods that prevent operator injection when used correctly.",
              nextStep: 1
            },
            {
              text: "Cast all inputs to strings",
              correct: false,
              points: 10,
              feedback: "Type casting doesn't prevent operator objects from being injected.",
              nextStep: 1
            },
            {
              text: "Use a WAF with NoSQL rules",
              correct: false,
              points: 5,
              feedback: "WAFs can help but don't address the root cause in application code.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive NoSQL security should you implement?",
          choices: [
            {
              text: "Use type-safe queries, input validation, and principle of least privilege",
              correct: true,
              points: 25,
              feedback: "Excellent! Multiple layers including type safety, validation, and minimal database permissions.",
              nextStep: 2
            },
            {
              text: "Switch to SQL database for better security",
              correct: false,
              points: 5,
              feedback: "Both SQL and NoSQL can be secure with proper implementation.",
              nextStep: 2
            },
            {
              text: "Encrypt all database fields",
              correct: false,
              points: 10,
              feedback: "Encryption protects data at rest but doesn't prevent injection.",
              nextStep: 2
            }
          ]
        },
        {
          text: "NoSQL security established! All MongoDB operations now use type-safe queries with proper input validation.",
          choices: []
        }
      ]
    }
  },

  brokenAuthBrandNew: {
    id: 232,
    title: "Session Fixation Attack",
    difficulty: "Hard",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover an application that doesn't regenerate session IDs after login. What session fixation vulnerability exists?",
          choices: [
            {
              text: "Attackers can pre-set session IDs and hijack user sessions after login",
              correct: true,
              points: 20,
              feedback: "Critical finding! Session fixation allows attackers to provide session IDs that become valid after user authentication.",
              nextStep: 1
            },
            {
              text: "Sessions might timeout too quickly",
              correct: false,
              points: 5,
              feedback: "Short timeouts are a security feature, not a vulnerability.",
              nextStep: 0
            },
            {
              text: "Session cookies aren't encrypted",
              correct: false,
              points: 10,
              feedback: "Cookie encryption is different from session fixation protection.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully demonstrate session fixation by pre-setting a session ID. How do you show the hijacking risk?",
          choices: [
            {
              text: "Show how fixed sessions allow account takeover after user authentication",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating session hijacking through fixation shows critical authentication flow vulnerability.",
              nextStep: 2
            },
            {
              text: "Actually take over user accounts with fixed sessions",
              correct: false,
              points: -30,
              feedback: "Unauthorized account access is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the session management approach",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating the attack shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical session fixation vulnerability! Lack of session regeneration allows session hijacking after authentication.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing secure session management. What's the essential defense against session fixation?",
          choices: [
            {
              text: "Regenerate session ID after any privilege change, especially login",
              correct: true,
              points: 20,
              feedback: "Essential! Session regeneration ensures old session IDs become invalid after authentication.",
              nextStep: 1
            },
            {
              text: "Use longer session IDs",
              correct: false,
              points: 10,
              feedback: "ID length doesn't prevent fixation - regeneration is key.",
              nextStep: 1
            },
            {
              text: "Store sessions in database only",
              correct: false,
              points: 5,
              feedback: "Storage location doesn't solve the fixation problem.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive session security should you implement?",
          choices: [
            {
              text: "Implement session regeneration, secure attributes, and proper expiration",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including regeneration, secure cookie flags, and timeout policies.",
              nextStep: 2
            },
            {
              text: "Use the same session for all user activities",
              correct: false,
              points: -15,
              feedback: "Session should be regenerated after privilege changes.",
              nextStep: 2
            },
            {
              text: "Disable sessions entirely",
              correct: false,
              points: 5,
              feedback: "Not practical for stateful web applications.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Session security established! All sessions now regenerate after authentication with comprehensive protection.",
          choices: []
        }
      ]
    }
  },

  cryptographicFailuresBrandNew: {
    id: 233,
    title: "Insecure Key Derivation Functions",
    difficulty: "Easy",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover an application using a fast hash function with low iteration counts for password hashing. What's the risk?",
          choices: [
            {
              text: "Weak key derivation allows efficient brute force and dictionary attacks",
              correct: true,
              points: 15,
              feedback: "Critical finding! Fast hash functions with low iterations make password cracking feasible with modern hardware.",
              nextStep: 1
            },
            {
              text: "Passwords might be too long to hash",
              correct: false,
              points: 5,
              feedback: "Password length limitations are operational, not cryptographic issues.",
              nextStep: 0
            },
            {
              text: "Only affects user registration",
              correct: false,
              points: 5,
              feedback: "Weak hashing affects all stored passwords, not just new registrations.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate that password hashes can be cracked quickly. How do you show the account compromise risk?",
          choices: [
            {
              text: "Show how weak hashing allows rapid password recovery through brute force",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating efficient password cracking shows the critical risk to user accounts.",
              nextStep: 2
            },
            {
              text: "Actually crack user passwords and access accounts",
              correct: false,
              points: -20,
              feedback: "Unauthorized password cracking and account access are illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the hash function used",
              correct: false,
              points: 10,
              feedback: "Good for technical reporting, but demonstrating cracking speed shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical cryptographic failure! Weak key derivation functions make password cracking efficient and practical.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing secure password hashing. What's the correct approach for key derivation?",
          choices: [
            {
              text: "Use adaptive functions like bcrypt or argon2 with appropriate work factors",
              correct: true,
              points: 15,
              feedback: "Essential! Adaptive functions are designed to be slow and resource-intensive to prevent efficient cracking.",
              nextStep: 1
            },
            {
              text: "Use SHA-256 with multiple rounds",
              correct: false,
              points: 10,
              feedback: "SHA-256 is designed for speed, not password hashing, even with multiple rounds.",
              nextStep: 1
            },
            {
              text: "Encrypt passwords instead of hashing",
              correct: false,
              points: -10,
              feedback: "Encryption is reversible - passwords should be hashed with one-way functions.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive password security should you implement?",
          choices: [
            {
              text: "Use adaptive hashing, proper salting, and regular security reviews",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including strong algorithms, unique salts, and ongoing assessment.",
              nextStep: 2
            },
            {
              text: "Use the same salt for all passwords",
              correct: false,
              points: -15,
              feedback: "Unique salts are essential to prevent rainbow table attacks.",
              nextStep: 2
            },
            {
              text: "Store passwords in plain text for faster verification",
              correct: false,
              points: -25,
              feedback: "Plain text storage is never acceptable for passwords.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Password security established! All passwords now hashed with adaptive functions and proper salting.",
          choices: []
        }
      ]
    }
  },

  brokenAccessControlBrandNew: {
    id: 234,
    title: "Cross-Origin Resource Sharing Misconfiguration",
    difficulty: "Medium",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover a REST API with permissive CORS headers allowing any origin. What access control risk does this create?",
          choices: [
            {
              text: "Malicious websites can make authenticated requests to the API from user browsers",
              correct: true,
              points: 15,
              feedback: "Critical finding! Permissive CORS allows any website to make cross-origin requests with user credentials.",
              nextStep: 1
            },
            {
              text: "API responses might be cached by proxies",
              correct: false,
              points: 5,
              feedback: "Caching is a performance concern, not the primary CORS security risk.",
              nextStep: 0
            },
            {
              text: "Only affects same-origin requests",
              correct: false,
              points: 5,
              feedback: "CORS specifically controls cross-origin requests, not same-origin.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate that malicious sites can access user data through permissive CORS. How do you show the data exposure risk?",
          choices: [
            {
              text: "Show how cross-origin requests can extract sensitive user data",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating data extraction through cross-origin requests shows critical access control failure.",
              nextStep: 2
            },
            {
              text: "Actually create a malicious site to steal user data",
              correct: false,
              points: -20,
              feedback: "Creating actual attack sites and stealing data is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the CORS headers",
              correct: false,
              points: 10,
              feedback: "Good for technical reporting, but demonstrating the attack shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical CORS misconfiguration! Permissive cross-origin policies allow data theft from malicious websites.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing secure CORS policies. What's the essential approach?",
          choices: [
            {
              text: "Use strict origin whitelisting and avoid wildcard origins",
              correct: true,
              points: 15,
              feedback: "Essential! CORS should only allow specific trusted origins, not any origin.",
              nextStep: 1
            },
            {
              text: "Allow all origins but require authentication",
              correct: false,
              points: -10,
              feedback: "Authentication doesn't prevent cross-origin requests from malicious sites.",
              nextStep: 1
            },
            {
              text: "Disable CORS entirely",
              correct: false,
              points: 5,
              feedback: "CORS is needed for legitimate cross-origin requests in web applications.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive CORS security should you implement?",
          choices: [
            {
              text: "Use origin whitelists, proper headers, and preflight validation",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including strict origins, secure headers, and request validation.",
              nextStep: 2
            },
            {
              text: "Use the same CORS policy for all environments",
              correct: false,
              points: 10,
              feedback: "Different environments may need different CORS policies.",
              nextStep: 2
            },
            {
              text: "Allow credentials with wildcard origins",
              correct: false,
              points: -15,
              feedback: "Credentials should never be allowed with wildcard origins.",
              nextStep: 2
            }
          ]
        },
        {
          text: "CORS security established! All APIs now use strict origin whitelisting with proper headers.",
          choices: []
        }
      ]
    }
  },

  securityMisconfigBrandNew: {
    id: 235,
    title: "Exposed Kubernetes Dashboard",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover a Kubernetes cluster with the dashboard exposed to the internet without authentication. What's the immediate risk?",
          choices: [
            {
              text: "Full cluster control allowing container manipulation and secret access",
              correct: true,
              points: 15,
              feedback: "Critical finding! Exposed Kubernetes dashboard provides complete control over the container orchestration environment.",
              nextStep: 1
            },
            {
              text: "Only affects container performance",
              correct: false,
              points: 5,
              feedback: "This is a security compromise risk, not a performance issue.",
              nextStep: 0
            },
            {
              text: "Risk is limited to viewing container logs",
              correct: false,
              points: 5,
              feedback: "Kubernetes dashboard allows full cluster management, not just log viewing.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You access the exposed Kubernetes dashboard. How do you demonstrate the cluster compromise risk?",
          choices: [
            {
              text: "Show how cluster resources and secrets can be accessed and manipulated",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating cluster control through the dashboard shows critical infrastructure risk.",
              nextStep: 2
            },
            {
              text: "Actually modify cluster configurations or deploy malicious containers",
              correct: false,
              points: -25,
              feedback: "Unauthorized cluster modifications are dangerous and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the exposed dashboard URL",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating access capabilities shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical Kubernetes misconfiguration! Exposed dashboard allows complete cluster compromise and data access.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing Kubernetes infrastructure. What's the essential security practice for the dashboard?",
          choices: [
            {
              text: "Restrict dashboard access with authentication and network policies",
              correct: true,
              points: 15,
              feedback: "Essential! Kubernetes dashboard should require authentication and be accessible only from authorized networks.",
              nextStep: 1
            },
            {
              text: "Use the dashboard only during development",
              correct: false,
              points: 5,
              feedback: "Dashboard access control is needed in all environments.",
              nextStep: 1
            },
            {
              text: "Change the dashboard to a non-standard port",
              correct: false,
              points: 5,
              feedback: "Security through obscurity is not a reliable defense.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive Kubernetes security should you implement?",
          choices: [
            {
              text: "Use RBAC, network policies, and secure dashboard configuration",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including access control, network security, and proper component configuration.",
              nextStep: 2
            },
            {
              text: "Disable the dashboard entirely",
              correct: false,
              points: 10,
              feedback: "Dashboard is useful for management - better to secure it properly.",
              nextStep: 2
            },
            {
              text: "Use the same credentials for all cluster components",
              correct: false,
              points: -15,
              feedback: "Different components should use different credentials for security isolation.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Kubernetes security established! All cluster components now properly secured with access controls.",
          choices: []
        }
      ]
    }
  },

  insecureDeserializationBrandNew: {
    id: 236,
    title: "Ruby Marshal Deserialization Attack",
    difficulty: "Hard",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover a Ruby application using Marshal.load with user-controlled data. What's the specific risk with Ruby marshaling?",
          choices: [
            {
              text: "Marshal can instantiate arbitrary objects leading to remote code execution",
              correct: true,
              points: 20,
              feedback: "Correct! Ruby Marshal can create any object, including those with dangerous side effects during initialization.",
              nextStep: 1
            },
            {
              text: "Marshaled data can be too large",
              correct: false,
              points: 10,
              feedback: "Size issues are operational, not the primary security risk.",
              nextStep: 0
            },
            {
              text: "Data format might be incompatible",
              correct: false,
              points: 5,
              feedback: "Compatibility issues are different from security vulnerabilities.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully trigger code execution through malicious Marshal data. What's the ethical demonstration?",
          choices: [
            {
              text: "Show RCE capability without causing system harm or accessing data",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating code execution potential without destructive actions maintains ethical boundaries.",
              nextStep: 2
            },
            {
              text: "Actually compromise the server and access files",
              correct: false,
              points: -30,
              feedback: "Server compromise is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the Marshal.load usage",
              correct: false,
              points: 15,
              feedback: "Good for technical reporting, but demonstrating impact shows severity.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical Ruby deserialization vulnerability! Marshal.load with untrusted data allows remote code execution.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing Ruby application data handling. What's the primary defense against Marshal attacks?",
          choices: [
            {
              text: "Avoid Marshal.load with untrusted data and use JSON with validation",
              correct: true,
              points: 20,
              feedback: "Essential! Marshal should never be used with untrusted input - safe formats like JSON are preferred.",
              nextStep: 1
            },
            {
              text: "Validate marshaled data size limits",
              correct: false,
              points: 10,
              feedback: "Size limits help but don't prevent object instantiation attacks.",
              nextStep: 1
            },
            {
              text: "Use base64 encoding for marshaled data",
              correct: false,
              points: 5,
              feedback: "Encoding doesn't prevent deserialization attacks.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive Ruby security should you implement?",
          choices: [
            {
              text: "Use safe data formats, input validation, and security patches",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including safe serialization, validation, and keeping dependencies updated.",
              nextStep: 2
            },
            {
              text: "Disable all serialization in the application",
              correct: false,
              points: 5,
              feedback: "Not practical for applications that need data serialization.",
              nextStep: 2
            },
            {
              text: "Use the latest Ruby version only",
              correct: false,
              points: 10,
              feedback: "Updates help but don't automatically fix insecure code patterns.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Ruby data handling secured! All serialization now uses safe formats with proper validation.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponentsBrandNew: {
    id: 237,
    title: "Docker Image Vulnerabilities",
    difficulty: "Medium",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover Docker images built from outdated base images with known vulnerabilities. What's the container security risk?",
          choices: [
            {
              text: "Vulnerable packages in base images can be exploited in running containers",
              correct: true,
              points: 15,
              feedback: "Critical finding! Vulnerabilities in base images affect all containers built from them, creating widespread risk.",
              nextStep: 1
            },
            {
              text: "Images might be too large to deploy",
              correct: false,
              points: 5,
              feedback: "Size issues are operational, not security vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Only affects image build times",
              correct: false,
              points: 5,
              feedback: "Base image vulnerabilities affect runtime security, not just build processes.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You identify exploitable vulnerabilities in container images. How do you demonstrate the compromise risk?",
          choices: [
            {
              text: "Show how image vulnerabilities can lead to container escape or privilege escalation",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating exploit potential from image vulnerabilities shows critical container security risk.",
              nextStep: 2
            },
            {
              text: "Actually exploit the vulnerabilities and break out of containers",
              correct: false,
              points: -25,
              feedback: "Container escape and system compromise are dangerous and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the vulnerable package names",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating exploit potential shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical container vulnerability! Outdated base images expose containers to known exploits and attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing Docker container images. What's the essential practice?",
          choices: [
            {
              text: "Use minimal base images and regularly scan for vulnerabilities",
              correct: true,
              points: 15,
              feedback: "Essential! Minimal images reduce attack surface, while regular scanning detects known vulnerabilities.",
              nextStep: 1
            },
            {
              text: "Use the latest base images without testing",
              correct: false,
              points: 10,
              feedback: "Latest images might have breaking changes - testing is still needed.",
              nextStep: 1
            },
            {
              text: "Build all software from source in images",
              correct: false,
              points: 5,
              feedback: "Source building doesn't automatically prevent vulnerabilities.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive container security should you implement?",
          choices: [
            {
              text: "Implement image scanning, minimal bases, and vulnerability management",
              correct: true,
              points: 20,
              feedback: "Perfect! Comprehensive container security including detection, minimal attack surface, and patch management.",
              nextStep: 2
            },
            {
              text: "Disable all package updates in images",
              correct: false,
              points: -10,
              feedback: "Regular updates are essential for security.",
              nextStep: 2
            },
            {
              text: "Use the same base image for all applications",
              correct: false,
              points: 10,
              feedback: "Different applications may have different base image requirements.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Container security established! All images now regularly scanned with minimal bases and vulnerability management.",
          choices: []
        }
      ]
    }
  },

  loggingFailuresBrandNew: {
    id: 238,
    title: "Missing Database Connection Monitoring",
    difficulty: "Easy",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover database connections aren't monitored for unusual patterns or failed attempts. What security risk does this create?",
          choices: [
            {
              text: "Database brute force attacks and connection abuse can go undetected",
              correct: true,
              points: 15,
              feedback: "Critical finding! Missing connection monitoring allows database attacks to proceed without detection.",
              nextStep: 1
            },
            {
              text: "Only affects database performance",
              correct: false,
              points: 5,
              feedback: "This is a security monitoring failure, not a performance issue.",
              nextStep: 0
            },
            {
              text: "Risk is limited to connection pool exhaustion",
              correct: false,
              points: 5,
              feedback: "Connection monitoring detects security attacks, not just resource issues.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate database connection attacks without triggering alerts. How do you show the detection gap?",
          choices: [
            {
              text: "Show how connection-based attacks proceed without monitoring alerts",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating that database attacks are invisible without connection monitoring shows critical detection failure.",
              nextStep: 2
            },
            {
              text: "Actually perform database brute force attacks",
              correct: false,
              points: -20,
              feedback: "Active database attacks are dangerous and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the missing monitoring",
              correct: false,
              points: 10,
              feedback: "Good for technical reporting, but demonstrating the detection gap shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical monitoring failure! Missing database connection monitoring allows attacks to proceed undetected.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing database security monitoring. What connection events are essential to monitor?",
          choices: [
            {
              text: "Failed authentications, connection sources, and unusual patterns",
              correct: true,
              points: 15,
              feedback: "Essential! These connection events provide crucial security monitoring data for database protection.",
              nextStep: 1
            },
            {
              text: "Only monitor successful connections",
              correct: false,
              points: 5,
              feedback: "Failed connections often indicate attack attempts and are equally important.",
              nextStep: 1
            },
            {
              text: "Only track connection duration",
              correct: false,
              points: 10,
              feedback: "Duration monitoring helps with performance but not security detection.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good selection! What comprehensive database monitoring should you implement?",
          choices: [
            {
              text: "Implement connection logging, anomaly detection, and real-time alerts",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including basic logging, behavioral analysis, and proactive alerting.",
              nextStep: 2
            },
            {
              text: "Log all connections without filtering",
              correct: false,
              points: 10,
              feedback: "Too much data can hide important events - focus on security-relevant patterns.",
              nextStep: 2
            },
            {
              text: "Only monitor during business hours",
              correct: false,
              points: -10,
              feedback: "Database attacks can occur at any time - 24/7 monitoring is essential.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Database monitoring established! All connections now monitored with anomaly detection and real-time alerts.",
          choices: []
        }
      ]
    }
  },

  ssrfBrandNew: {
    id: 239,
    title: "Email Server SSRF via Webhook Verification",
    difficulty: "Hard",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "You discover an email service that verifies domains by making HTTP requests to URLs provided in DNS TXT records. What SSRF risk exists?",
          choices: [
            {
              text: "DNS-controlled URLs can point to internal services for SSRF",
              correct: true,
              points: 20,
              feedback: "Advanced technique! DNS-controlled verification allows attackers to point domains to internal services for SSRF.",
              nextStep: 1
            },
            {
              text: "Email headers can be forged",
              correct: false,
              points: 10,
              feedback: "Header forgery is different from SSRF through DNS verification.",
              nextStep: 0
            },
            {
              text: "SMTP commands can be injected",
              correct: false,
              points: 5,
              feedback: "SMTP injection is different from HTTP-based SSRF.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully trigger internal service requests through DNS-controlled verification. What's the impact?",
          choices: [
            {
              text: "Show how internal services can be accessed through domain verification SSRF",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating internal service access through email verification shows sophisticated SSRF vulnerability.",
              nextStep: 2
            },
            {
              text: "Actually access and exploit internal services",
              correct: false,
              points: -30,
              feedback: "Unauthorized internal service access is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the verification mechanism",
              correct: false,
              points: 15,
              feedback: "Good for technical reporting, but demonstrating the SSRF shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical email verification SSRF! DNS-controlled URLs allow internal service access through domain verification.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing email domain verification. What's the essential SSRF defense?",
          choices: [
            {
              text: "Use allowlists for verification targets and restrict internal network access",
              correct: true,
              points: 20,
              feedback: "Essential! Allowlisting ensures only intended domains are verified, while network restrictions prevent internal access.",
              nextStep: 1
            },
            {
              text: "Verify domains through DNS lookups only",
              correct: false,
              points: 10,
              feedback: "DNS verification alone might not be sufficient for some authentication schemes.",
              nextStep: 1
            },
            {
              text: "Add CAPTCHA to email verification",
              correct: false,
              points: 5,
              feedback: "CAPTCHA prevents automation but doesn't fix SSRF vulnerabilities.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive email security should you implement?",
          choices: [
            {
              text: "Use allowlists, network segmentation, and secure verification methods",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including application controls, network security, and safe verification practices.",
              nextStep: 2
            },
            {
              text: "Disable domain verification entirely",
              correct: false,
              points: 5,
              feedback: "Domain verification is important for email security - better to implement it safely.",
              nextStep: 2
            },
            {
              text: "Only verify domains during business hours",
              correct: false,
              points: 10,
              feedback: "Time restrictions don't prevent SSRF attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Email verification secured! All domain checks now use allowlists with network restrictions.",
          choices: []
        }
      ]
    }
  },

   insecureDesignBrandNew: {
    id: 240,
    title: "Insecure Password Reset Design",
    difficulty: "Medium",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover a password reset feature that uses sequential reset tokens. What design flaw allows account takeover?",
          choices: [
            {
              text: "Predictable tokens allow attackers to reset any user's password",
              correct: true,
              points: 20,
              feedback: "Critical finding! Sequential or predictable reset tokens enable account takeover through token guessing.",
              nextStep: 1
            },
            {
              text: "Reset emails might be delayed",
              correct: false,
              points: 5,
              feedback: "Email delays are operational issues, not design flaws.",
              nextStep: 0
            },
            {
              text: "Password complexity requirements are weak",
              correct: false,
              points: 10,
              feedback: "Complexity rules are policy, not fundamental design issues.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully predict reset tokens and demonstrate account compromise. What's the ethical approach?",
          choices: [
            {
              text: "Show token predictability without actually resetting user passwords",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating token predictability proves the design flaw without harming user accounts.",
              nextStep: 2
            },
            {
              text: "Actually reset multiple user passwords to prove the issue",
              correct: false,
              points: -30,
              feedback: "Unauthorized password resets disrupt users and are unethical.",
              nextStep: 2
            },
            {
              text: "Just report the sequential token pattern",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating predictability shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical design flaw! Predictable password reset tokens enable systematic account takeover.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're redesigning the password reset system. What's the essential secure design principle?",
          choices: [
            {
              text: "Use cryptographically random tokens with expiration and one-time use",
              correct: true,
              points: 20,
              feedback: "Essential! Secure reset tokens must be unpredictable, time-limited, and single-use.",
              nextStep: 1
            },
            {
              text: "Use shorter tokens for user convenience",
              correct: false,
              points: -10,
              feedback: "Shorter tokens are easier to predict and compromise security.",
              nextStep: 1
            },
            {
              text: "Store tokens in URL parameters for easy access",
              correct: false,
              points: -15,
              feedback: "URL parameters can be leaked in logs and browser history.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive password reset security should you implement?",
          choices: [
            {
              text: "Random tokens, rate limiting, and confirmation before password change",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including secure tokens, abuse prevention, and user confirmation.",
              nextStep: 2
            },
            {
              text: "Allow unlimited reset attempts for user convenience",
              correct: false,
              points: -20,
              feedback: "Unlimited attempts enable brute force attacks.",
              nextStep: 2
            },
            {
              text: "Use the same token for multiple reset requests",
              correct: false,
              points: -25,
              feedback: "Tokens must be single-use to prevent replay attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure password reset design implemented! All tokens now cryptographically random with proper safeguards.",
          choices: []
        }
      ]
    }
  },

  cryptoFailuresNew: {
    id: 241,
    title: "Weak TLS Configuration in API Gateway",
    difficulty: "Hard",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover an API gateway supporting weak TLS 1.0 and outdated ciphers. What's the primary risk?",
          choices: [
            {
              text: "Man-in-the-middle attacks can decrypt sensitive API communications",
              correct: true,
              points: 20,
              feedback: "Critical finding! Weak TLS allows interception and decryption of sensitive API data in transit.",
              nextStep: 1
            },
            {
              text: "API responses might be slower",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the primary security concern.",
              nextStep: 0
            },
            {
              text: "Only affects mobile app connections",
              correct: false,
              points: 10,
              feedback: "Weak TLS affects all clients connecting to the API, not just mobile.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate TLS downgrade attacks are possible. How do you show the data exposure risk?",
          choices: [
            {
              text: "Show how weak ciphers allow traffic decryption without intercepting real data",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating decryption capability with weak ciphers shows critical data exposure risk.",
              nextStep: 2
            },
            {
              text: "Actually intercept and decrypt production API traffic",
              correct: false,
              points: -30,
              feedback: "Intercepting production traffic is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the TLS version support",
              correct: false,
              points: 15,
              feedback: "Good for technical reporting, but demonstrating decryption shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical TLS misconfiguration! Weak protocols and ciphers expose API communications to interception.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the API gateway TLS configuration. What's the minimum secure standard?",
          choices: [
            {
              text: "Enforce TLS 1.2+ with strong modern ciphers only",
              correct: true,
              points: 20,
              feedback: "Essential! TLS 1.2+ with strong ciphers provides adequate protection against modern attacks.",
              nextStep: 1
            },
            {
              text: "Support all TLS versions for compatibility",
              correct: false,
              points: -15,
              feedback: "Backward compatibility with weak TLS versions creates security risks.",
              nextStep: 1
            },
            {
              text: "Use the fastest ciphers regardless of strength",
              correct: false,
              points: -10,
              feedback: "Performance should not compromise cryptographic security.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive TLS security should you implement?",
          choices: [
            {
              text: "Modern TLS only, HSTS headers, and regular configuration reviews",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including protocol enforcement, browser security, and ongoing maintenance.",
              nextStep: 2
            },
            {
              text: "Disable TLS entirely for better performance",
              correct: false,
              points: -30,
              feedback: "TLS is essential for data protection in transit.",
              nextStep: 2
            },
            {
              text: "Use self-signed certificates to save costs",
              correct: false,
              points: -20,
              feedback: "Self-signed certificates break trust and enable MITM attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "TLS security established! API gateway now enforces modern TLS with strong cryptographic settings.",
          choices: []
        }
      ]
    }
  },

  injectionNew: {
    id: 242,
    title: "GraphQL Query Injection",
    difficulty: "Hard",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover a GraphQL endpoint without query cost limits or depth restrictions. What injection risk exists?",
          choices: [
            {
              text: "Malicious queries can cause resource exhaustion and data exposure",
              correct: true,
              points: 20,
              feedback: "Critical finding! Unlimited GraphQL queries enable denial of service and unauthorized data access.",
              nextStep: 1
            },
            {
              text: "GraphQL schemas might be poorly documented",
              correct: false,
              points: 5,
              feedback: "Documentation issues are different from injection vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Only affects query performance",
              correct: false,
              points: 10,
              feedback: "This is a security vulnerability, not just a performance issue.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You craft a complex GraphQL query that retrieves excessive data. What's the ethical demonstration?",
          choices: [
            {
              text: "Show how deep nesting and field duplication can overwhelm the API",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating query complexity attacks shows both DoS and data exposure risks.",
              nextStep: 2
            },
            {
              text: "Actually bring down the production API with malicious queries",
              correct: false,
              points: -35,
              feedback: "Denial of service attacks on production systems are harmful and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the lack of query limits",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating the attack shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical GraphQL injection! Unlimited query complexity enables data exposure and denial of service.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the GraphQL endpoint. What's the primary defense against query injection?",
          choices: [
            {
              text: "Implement query cost analysis, depth limits, and query whitelisting",
              correct: true,
              points: 20,
              feedback: "Essential! Multiple controls including cost calculation, structural limits, and approved queries.",
              nextStep: 1
            },
            {
              text: "Disable introspection in production",
              correct: false,
              points: 10,
              feedback: "Introspection helps attackers but doesn't prevent malicious queries.",
              nextStep: 1
            },
            {
              text: "Use query caching for performance",
              correct: false,
              points: 5,
              feedback: "Caching improves performance but doesn't prevent injection.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive GraphQL security should you implement?",
          choices: [
            {
              text: "Query limits, rate limiting, and proper error handling",
              correct: true,
              points: 25,
              feedback: "Perfect! Layered security including query controls, abuse prevention, and information disclosure protection.",
              nextStep: 2
            },
            {
              text: "Allow unlimited queries for flexible client access",
              correct: false,
              points: -20,
              feedback: "Unlimited queries create massive security risks.",
              nextStep: 2
            },
            {
              text: "Implement security only for authenticated users",
              correct: false,
              points: -15,
              feedback: "All endpoints need protection, regardless of authentication.",
              nextStep: 2
            }
          ]
        },
        {
          text: "GraphQL security established! All queries now have cost limits, depth restrictions, and rate controls.",
          choices: []
        }
      ]
    }
  },

  accessControlNew: {
    id: 243,
    title: "Mass Assignment in REST API",
    difficulty: "Medium",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover a REST API that accepts user updates without filtering request body fields. What access control risk exists?",
          choices: [
            {
              text: "Mass assignment allows updating privileged fields like role or permissions",
              correct: true,
              points: 20,
              feedback: "Critical finding! Mass assignment vulnerabilities enable privilege escalation through unfiltered field updates.",
              nextStep: 1
            },
            {
              text: "API might accept invalid data types",
              correct: false,
              points: 10,
              feedback: "Type validation is important but different from mass assignment.",
              nextStep: 0
            },
            {
              text: "Only affects user profile pictures",
              correct: false,
              points: 5,
              feedback: "Mass assignment can affect any sensitive field in the user object.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully escalate privileges by updating admin field. What's the ethical demonstration?",
          choices: [
            {
              text: "Show privilege escalation capability without accessing sensitive data",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating privilege escalation potential maintains ethical boundaries while showing critical risk.",
              nextStep: 2
            },
            {
              text: "Actually access admin functions with escalated privileges",
              correct: false,
              points: -30,
              feedback: "Unauthorized access to admin functions is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the unfiltered field acceptance",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating escalation shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical mass assignment vulnerability! Unfiltered field updates enable privilege escalation attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're fixing the mass assignment vulnerability. What's the primary defense approach?",
          choices: [
            {
              text: "Use allowlists for updatable fields and implement proper data binding",
              correct: true,
              points: 20,
              feedback: "Essential! Allowlisting ensures only intended fields can be updated, preventing privilege escalation.",
              nextStep: 1
            },
            {
              text: "Remove sensitive fields from API responses",
              correct: false,
              points: 10,
              feedback: "Response filtering doesn't prevent mass assignment in requests.",
              nextStep: 1
            },
            {
              text: "Use longer field names for sensitive data",
              correct: false,
              points: 5,
              feedback: "Security through obscurity is not a reliable defense.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good choice! What comprehensive API security should you implement?",
          choices: [
            {
              text: "Field allowlists, input validation, and role-based field access",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including structural validation, data integrity, and authorization controls.",
              nextStep: 2
            },
            {
              text: "Allow all fields for admin users only",
              correct: false,
              points: -15,
              feedback: "Even admin users should follow secure data binding practices.",
              nextStep: 2
            },
            {
              text: "Use client-side field filtering only",
              correct: false,
              points: -10,
              feedback: "Client-side controls can be bypassed - server validation is essential.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Mass assignment vulnerability fixed! All API endpoints now use field allowlists with proper authorization.",
          choices: []
        }
      ]
    }
  },

  securityMisconfigNew: {
    id: 244,
    title: "Exposed AWS S3 Bucket",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover an AWS S3 bucket with public read permissions containing sensitive files. What's the immediate risk?",
          choices: [
            {
              text: "Public access allows anyone to download sensitive data without authentication",
              correct: true,
              points: 15,
              feedback: "Critical finding! Public S3 buckets expose sensitive data to anyone on the internet.",
              nextStep: 1
            },
            {
              text: "Files might be too large to download",
              correct: false,
              points: 5,
              feedback: "Size limitations don't prevent data exposure.",
              nextStep: 0
            },
            {
              text: "Only affects file listing capabilities",
              correct: false,
              points: 5,
              feedback: "Public read access exposes file contents, not just directory listings.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You access sensitive files from the public S3 bucket. How do you demonstrate the data exposure?",
          choices: [
            {
              text: "Show file access capability and data exposure without downloading sensitive content",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating access to sensitive files shows critical data exposure risk.",
              nextStep: 2
            },
            {
              text: "Actually download and archive all exposed files",
              correct: false,
              points: -25,
              feedback: "Unauthorized file downloads constitute data theft and are illegal.",
              nextStep: 2
            },
            {
              text: "Just report the S3 bucket URL",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating access shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical S3 misconfiguration! Public bucket permissions expose sensitive data to unauthorized access.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the AWS S3 bucket. What's the essential permission model?",
          choices: [
            {
              text: "Principle of least privilege with no public access by default",
              correct: true,
              points: 15,
              feedback: "Essential! S3 buckets should be private by default, with access granted only to specific principals.",
              nextStep: 1
            },
            {
              text: "Use public read for non-sensitive files only",
              correct: false,
              points: -10,
              feedback: "Classification errors can lead to sensitive data exposure.",
              nextStep: 1
            },
            {
              text: "Rely on obscure bucket names for security",
              correct: false,
              points: -15,
              feedback: "Security through obscurity is not a reliable defense.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive S3 security should you implement?",
          choices: [
            {
              text: "Block public access, use IAM policies, and enable logging",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including access blocking, fine-grained permissions, and monitoring.",
              nextStep: 2
            },
            {
              text: "Allow public write for user uploads",
              correct: false,
              points: -25,
              feedback: "Public write enables bucket contamination and malware distribution.",
              nextStep: 2
            },
            {
              text: "Disable all bucket encryption for performance",
              correct: false,
              points: -20,
              feedback: "Encryption is essential for data protection at rest.",
              nextStep: 2
            }
          ]
        },
        {
          text: "S3 security established! All buckets now follow least privilege with comprehensive access controls.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponentsNew: {
    id: 245,
    title: "Outdated JavaScript Library with Known XSS",
    difficulty: "Medium",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover the application uses an outdated JavaScript library with known XSS vulnerabilities. What's the exploitation path?",
          choices: [
            {
              text: "Known XSS in the library can be triggered through crafted inputs",
              correct: true,
              points: 15,
              feedback: "Critical finding! Outdated libraries with known vulnerabilities provide reliable attack vectors.",
              nextStep: 1
            },
            {
              text: "Library might slow down page loading",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the security risk.",
              nextStep: 0
            },
            {
              text: "Only affects older browsers",
              correct: false,
              points: 5,
              feedback: "Client-side vulnerabilities affect all browsers that execute the vulnerable code.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully trigger the known XSS vulnerability. What's the ethical demonstration?",
          choices: [
            {
              text: "Show XSS execution without stealing data or harming users",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating XSS capability proves the vulnerability without causing harm.",
              nextStep: 2
            },
            {
              text: "Actually steal user sessions and access accounts",
              correct: false,
              points: -25,
              feedback: "Session theft and unauthorized access are illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the library version",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating the attack shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical vulnerable component! Outdated JavaScript library with known XSS enables client-side attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're addressing the vulnerable JavaScript library. What's the immediate action?",
          choices: [
            {
              text: "Update to the patched version or apply security patches",
              correct: true,
              points: 15,
              feedback: "Essential! Prompt updates fix known vulnerabilities and protect against published exploits.",
              nextStep: 1
            },
            {
              text: "Remove the library without replacement",
              correct: false,
              points: 10,
              feedback: "Removal might break functionality if the library is essential.",
              nextStep: 1
            },
            {
              text: "Add a WAF to block XSS attacks",
              correct: false,
              points: 5,
              feedback: "WAFs can help but don't fix the root vulnerability in the code.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good action! What comprehensive dependency management should you implement?",
          choices: [
            {
              text: "Regular vulnerability scanning, automated updates, and dependency review",
              correct: true,
              points: 20,
              feedback: "Perfect! Proactive security including detection, automation, and manual oversight.",
              nextStep: 2
            },
            {
              text: "Freeze all library versions to prevent breaking changes",
              correct: false,
              points: -15,
              feedback: "Frozen versions accumulate security vulnerabilities over time.",
              nextStep: 2
            },
            {
              text: "Use only the latest beta versions for newest features",
              correct: false,
              points: -10,
              feedback: "Beta versions may introduce instability and new vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Dependency security established! All libraries now regularly scanned and updated with secure practices.",
          choices: []
        }
      ]
    }
  },

  authFailureNew: {
    id: 246,
    title: "JWT Signature Verification Bypass",
    difficulty: "Hard",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover an application that doesn't verify JWT signatures properly. What authentication bypass exists?",
          choices: [
            {
              text: "Modified tokens with 'none' algorithm or invalid signatures are accepted",
              correct: true,
              points: 20,
              feedback: "Critical finding! Missing signature verification allows token forgery and authentication bypass.",
              nextStep: 1
            },
            {
              text: "Tokens might expire too quickly",
              correct: false,
              points: 5,
              feedback: "Short expiration is a security feature, not a vulnerability.",
              nextStep: 0
            },
            {
              text: "Token payloads are readable without decryption",
              correct: false,
              points: 10,
              feedback: "JWT payloads are typically base64 encoded, not encrypted.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully forge JWTs with modified claims. What's the ethical demonstration?",
          choices: [
            {
              text: "Show token forgery capability without accessing protected resources",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating token forgery proves authentication bypass without unauthorized access.",
              nextStep: 2
            },
            {
              text: "Actually access admin functions with forged tokens",
              correct: false,
              points: -30,
              feedback: "Unauthorized access with forged tokens is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the missing signature check",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating forgery shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical JWT vulnerability! Missing signature verification enables authentication bypass and privilege escalation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're fixing JWT validation. What's the essential security practice?",
          choices: [
            {
              text: "Always verify signatures and reject tokens with 'none' algorithm",
              correct: true,
              points: 20,
              feedback: "Essential! Proper JWT validation must include signature verification and algorithm validation.",
              nextStep: 1
            },
            {
              text: "Use shorter tokens for better performance",
              correct: false,
              points: 5,
              feedback: "Token length doesn't affect security if signatures aren't verified.",
              nextStep: 1
            },
            {
              text: "Store secrets in client-side code",
              correct: false,
              points: -20,
              feedback: "Client-side secrets can be easily discovered and misused.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive JWT security should you implement?",
          choices: [
            {
              text: "Signature verification, algorithm whitelisting, and proper secret management",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including cryptographic validation, algorithm control, and secure key storage.",
              nextStep: 2
            },
            {
              text: "Accept all algorithms for maximum compatibility",
              correct: false,
              points: -25,
              feedback: "Algorithm flexibility enables signature bypass attacks.",
              nextStep: 2
            },
            {
              text: "Use the same secret for all environments",
              correct: false,
              points: -15,
              feedback: "Shared secrets across environments increase breach impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "JWT security established! All tokens now properly validated with signature verification and algorithm checks.",
          choices: []
        }
      ]
    }
  },

  softwareIntegrityNew: {
    id: 247,
    title: "Insecure CI/CD Pipeline Configuration",
    difficulty: "Hard",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover a CI/CD pipeline that executes untrusted code from pull requests. What integrity risk exists?",
          choices: [
            {
              text: "Malicious code in PRs can compromise the build environment and artifacts",
              correct: true,
              points: 20,
              feedback: "Critical finding! Untrusted code execution in CI/CD enables supply chain attacks.",
              nextStep: 1
            },
            {
              text: "Builds might take longer to complete",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the security risk.",
              nextStep: 0
            },
            {
              text: "Only affects test environments",
              correct: false,
              points: 10,
              feedback: "Build environment compromise can affect production deployments.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate pipeline compromise through malicious PR. What's the ethical approach?",
          choices: [
            {
              text: "Show code execution capability without exfiltrating data or causing damage",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating pipeline compromise proves the vulnerability without harmful actions.",
              nextStep: 2
            },
            {
              text: "Actually deploy backdoored code to production",
              correct: false,
              points: -35,
              feedback: "Unauthorized production deployments are dangerous and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the pipeline configuration",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating compromise shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical CI/CD vulnerability! Untrusted code execution enables supply chain compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the CI/CD pipeline. What's the essential security control?",
          choices: [
            {
              text: "Run PR builds in isolated environments without sensitive access",
              correct: true,
              points: 20,
              feedback: "Essential! Isolation prevents PR code from accessing secrets or affecting production pipelines.",
              nextStep: 1
            },
            {
              text: "Allow all contributors to merge their own PRs",
              correct: false,
              points: -15,
              feedback: "Self-merging bypasses code review and increases risk.",
              nextStep: 1
            },
            {
              text: "Disable all security checks for faster builds",
              correct: false,
              points: -20,
              feedback: "Security checks are essential for pipeline integrity.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good control! What comprehensive pipeline security should you implement?",
          choices: [
            {
              text: "Isolated environments, code review, and artifact signing",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including environment security, human oversight, and integrity verification.",
              nextStep: 2
            },
            {
              text: "Use the same credentials for all pipeline stages",
              correct: false,
              points: -25,
              feedback: "Credential separation limits breach impact.",
              nextStep: 2
            },
            {
              text: "Disable branch protection for development speed",
              correct: false,
              points: -20,
              feedback: "Branch protection prevents unauthorized changes.",
              nextStep: 2
            }
          ]
        },
        {
          text: "CI/CD security established! All pipelines now use isolated environments with comprehensive integrity controls.",
          choices: []
        }
      ]
    }
  },

  loggingFailuresNew: {
    id: 248,
    title: "Missing API Security Event Monitoring",
    difficulty: "Medium",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover API endpoints don't log authentication failures or unusual access patterns. What detection gap exists?",
          choices: [
            {
              text: "API attacks and credential stuffing can proceed without detection",
              correct: true,
              points: 15,
              feedback: "Critical finding! Missing security event logging enables undetected API attacks.",
              nextStep: 1
            },
            {
              text: "API responses might be inconsistent",
              correct: false,
              points: 5,
              feedback: "Response consistency is a reliability issue, not a monitoring gap.",
              nextStep: 0
            },
            {
              text: "Only affects compliance reporting",
              correct: false,
              points: 5,
              feedback: "Missing security monitoring enables actual attacks, not just compliance issues.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate API attacks without triggering alerts. How do you show the detection failure?",
          choices: [
            {
              text: "Show attack patterns that proceed without security event logging",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating undetected attacks proves the monitoring gap.",
              nextStep: 2
            },
            {
              text: "Actually compromise API credentials through brute force",
              correct: false,
              points: -25,
              feedback: "Credential attacks are unethical and potentially illegal.",
              nextStep: 2
            },
            {
              text: "Just report the missing log statements",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating detection failure shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical monitoring failure! Missing API security event logging enables undetected attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing API security monitoring. What events are essential to log?",
          choices: [
            {
              text: "Authentication events, input validation failures, and access patterns",
              correct: true,
              points: 15,
              feedback: "Essential! These events provide crucial security visibility into API usage and attacks.",
              nextStep: 1
            },
            {
              text: "Only log successful API calls for performance",
              correct: false,
              points: -10,
              feedback: "Failure events often indicate attack attempts and are critical for security.",
              nextStep: 1
            },
            {
              text: "Log all request headers for debugging",
              correct: false,
              points: 5,
              feedback: "Excessive logging can hide important security events and create privacy issues.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good selection! What comprehensive API monitoring should you implement?",
          choices: [
            {
              text: "Security event logging, anomaly detection, and real-time alerting",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including basic logging, behavioral analysis, and proactive response.",
              nextStep: 2
            },
            {
              text: "Store logs locally on each API instance only",
              correct: false,
              points: -15,
              feedback: "Centralized logging is essential for correlation and analysis.",
              nextStep: 2
            },
            {
              text: "Disable monitoring during peak traffic",
              correct: false,
              points: -20,
              feedback: "Attacks often occur during peak traffic - continuous monitoring is essential.",
              nextStep: 2
            }
          ]
        },
        {
          text: "API monitoring established! All security events now logged with anomaly detection and alerting.",
          choices: []
        }
      ]
    }
  },

  ssrfNew: {
    id: 249,
    title: "Blind SSRF in Webhook Testing Feature",
    difficulty: "Hard",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "You discover a webhook testing feature that makes HTTP requests to user-provided URLs. What SSRF risk exists?",
          choices: [
            {
              text: "Blind SSRF allows internal network scanning and service interaction",
              correct: true,
              points: 20,
              feedback: "Critical finding! Blind SSRF enables internal network reconnaissance and service attacks.",
              nextStep: 1
            },
            {
              text: "Webhooks might be delivered slowly",
              correct: false,
              points: 5,
              feedback: "Delivery timing is operational, not a security vulnerability.",
              nextStep: 0
            },
            {
              text: "Only affects external webhook targets",
              correct: false,
              points: 10,
              feedback: "SSRF primarily risks internal network access, not external targets.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully trigger requests to internal services. What's the ethical demonstration?",
          choices: [
            {
              text: "Show internal service interaction through timing or error responses",
              correct: true,
              points: 25,
              feedback: "Perfect! Blind SSRF can be demonstrated through response timing or error patterns without data exfiltration.",
              nextStep: 2
            },
            {
              text: "Actually access internal service data through SSRF",
              correct: false,
              points: -30,
              feedback: "Unauthorized internal data access is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the webhook testing feature",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating SSRF shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical blind SSRF vulnerability! Webhook testing enables internal network reconnaissance and service attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the webhook testing feature. What's the primary SSRF defense?",
          choices: [
            {
              text: "Implement URL allowlisting and block internal network ranges",
              correct: true,
              points: 20,
              feedback: "Essential! Allowlisting ensures only intended targets, while network blocking prevents internal access.",
              nextStep: 1
            },
            {
              text: "Add CAPTCHA to webhook testing",
              correct: false,
              points: 5,
              feedback: "CAPTCHA prevents automation but doesn't fix SSRF vulnerabilities.",
              nextStep: 1
            },
            {
              text: "Use DNS resolution only for validation",
              correct: false,
              points: 10,
              feedback: "DNS doesn't prevent IP-based internal access.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good defense! What comprehensive webhook security should you implement?",
          choices: [
            {
              text: "URL validation, network restrictions, and outbound request monitoring",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including input validation, network security, and traffic monitoring.",
              nextStep: 2
            },
            {
              text: "Allow any URL for maximum flexibility",
              correct: false,
              points: -25,
              feedback: "Unrestricted URL access creates massive SSRF risks.",
              nextStep: 2
            },
            {
              text: "Disable webhook testing entirely",
              correct: false,
              points: 10,
              feedback: "Testing is valuable - better to implement it securely.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Webhook security established! All outbound requests now validated with network restrictions and monitoring.",
          choices: []
        }
      ]
    }
  },

  
  insecureDesign250: {
    id: 250,
    title: "Insecure API Versioning Design",
    difficulty: "Medium",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover an API that maintains multiple versions simultaneously without proper deprecation. What design flaw enables attacks?",
          choices: [
            {
              text: "Older vulnerable versions remain accessible, bypassing newer security controls",
              correct: true,
              points: 20,
              feedback: "Critical finding! Maintaining vulnerable API versions allows attackers to bypass security improvements in newer versions.",
              nextStep: 1
            },
            {
              text: "API documentation might be outdated",
              correct: false,
              points: 5,
              feedback: "Documentation issues are different from fundamental design flaws.",
              nextStep: 0
            },
            {
              text: "Version numbers could be confusing",
              correct: false,
              points: 10,
              feedback: "Naming confusion is a usability issue, not a security design flaw.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You find security vulnerabilities in older API versions still in use. What's the ethical demonstration?",
          choices: [
            {
              text: "Show how older versions lack security controls present in current versions",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating security regression in older versions proves the design flaw without exploitation.",
              nextStep: 2
            },
            {
              text: "Actually exploit the vulnerable older versions in production",
              correct: false,
              points: -30,
              feedback: "Exploiting production systems is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the version count",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating security differences shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical API design flaw! Maintaining vulnerable versions undermines security improvements and enables version-based attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're redesigning the API versioning strategy. What's the secure approach?",
          choices: [
            {
              text: "Implement strict version deprecation policies with security backports",
              correct: true,
              points: 20,
              feedback: "Essential! Proper version management includes timely deprecation and security fixes for supported versions.",
              nextStep: 1
            },
            {
              text: "Support all versions indefinitely for backward compatibility",
              correct: false,
              points: -15,
              feedback: "Indefinite support accumulates security debt and attack surface.",
              nextStep: 1
            },
            {
              text: "Hide older versions but keep them running",
              correct: false,
              points: -10,
              feedback: "Security through obscurity doesn't fix vulnerable code.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good strategy! What comprehensive API version security should you implement?",
          choices: [
            {
              text: "Version sunset policies, security backporting, and client migration support",
              correct: true,
              points: 25,
              feedback: "Perfect! Balanced approach including lifecycle management, security maintenance, and user transition.",
              nextStep: 2
            },
            {
              text: "Force all clients to immediately use latest version",
              correct: false,
              points: -20,
              feedback: "Forced migrations break client applications and cause service disruption.",
              nextStep: 2
            },
            {
              text: "Remove versioning entirely to simplify security",
              correct: false,
              points: -15,
              feedback: "Versioning is necessary for API evolution and client control.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure API versioning established! Clear deprecation policies with security maintenance for supported versions.",
          choices: []
        }
      ]
    }
  },

  cryptoFailures251: {
    id: 251,
    title: "Improper Certificate Validation in Microservices",
    difficulty: "Hard",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover microservices that disable SSL certificate validation for internal communication. What's the risk?",
          choices: [
            {
              text: "Man-in-the-middle attacks between services can intercept and modify data",
              correct: true,
              points: 20,
              feedback: "Critical finding! Disabled certificate validation allows interception of inter-service communication.",
              nextStep: 1
            },
            {
              text: "Service discovery might be slower",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the security risk.",
              nextStep: 0
            },
            {
              text: "Only affects external API endpoints",
              correct: false,
              points: 10,
              feedback: "Internal communication security is equally important for overall system integrity.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate intercepted communication between microservices. What's the ethical approach?",
          choices: [
            {
              text: "Show MITM capability without accessing sensitive inter-service data",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating interception potential proves the vulnerability without data compromise.",
              nextStep: 2
            },
            {
              text: "Actually modify service communication to change business logic",
              correct: false,
              points: -35,
              feedback: "Unauthorized modification of service communication is dangerous and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the disabled validation setting",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating interception shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical cryptographic failure! Disabled certificate validation enables interception of microservice communication.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing microservice communication. What's the essential certificate practice?",
          choices: [
            {
              text: "Implement proper certificate validation with internal PKI",
              correct: true,
              points: 20,
              feedback: "Essential! Proper certificate validation with managed PKI ensures secure service-to-service communication.",
              nextStep: 1
            },
            {
              text: "Use self-signed certificates without validation",
              correct: false,
              points: -20,
              feedback: "Self-signed certificates without validation provide no security benefit.",
              nextStep: 1
            },
            {
              text: "Disable encryption for better performance",
              correct: false,
              points: -25,
              feedback: "Unencrypted communication exposes all inter-service data.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive service mesh security should you implement?",
          choices: [
            {
              text: "Service identity, mutual TLS, and certificate automation",
              correct: true,
              points: 25,
              feedback: "Perfect! Comprehensive approach including identity, encryption, and operational efficiency.",
              nextStep: 2
            },
            {
              text: "Use the same certificate for all services",
              correct: false,
              points: -20,
              feedback: "Shared certificates prevent proper service identification and increase breach impact.",
              nextStep: 2
            },
            {
              text: "Manually manage certificates to maintain control",
              correct: false,
              points: -15,
              feedback: "Manual certificate management leads to errors and security gaps.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Microservice communication secured! All services now use mutual TLS with proper certificate validation.",
          choices: []
        }
      ]
    }
  },

  injection252: {
    id: 252,
    title: "Prototype Pollution in JavaScript Applications",
    difficulty: "Hard",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover a Node.js application that merges user input with objects using vulnerable functions. What injection risk exists?",
          choices: [
            {
              text: "Prototype pollution can modify object prototypes leading to RCE or privilege escalation",
              correct: true,
              points: 25,
              feedback: "Advanced finding! Prototype pollution enables modification of fundamental object behavior across the application.",
              nextStep: 1
            },
            {
              text: "Objects might become too large in memory",
              correct: false,
              points: 10,
              feedback: "Memory issues are different from prototype pollution risks.",
              nextStep: 0
            },
            {
              text: "Only affects client-side JavaScript",
              correct: false,
              points: 5,
              feedback: "Prototype pollution affects both Node.js server applications and client-side code.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully pollute object prototypes to modify application behavior. What's the ethical demonstration?",
          choices: [
            {
              text: "Show prototype modification without causing system damage or data access",
              correct: true,
              points: 30,
              feedback: "Perfect! Demonstrating prototype pollution potential proves the vulnerability while maintaining ethics.",
              nextStep: 2
            },
            {
              text: "Actually achieve remote code execution through pollution",
              correct: false,
              points: -40,
              feedback: "Achieving RCE is dangerous and crosses ethical boundaries.",
              nextStep: 2
            },
            {
              text: "Just report the object merge function usage",
              correct: false,
              points: 15,
              feedback: "Good for technical reporting, but demonstrating pollution shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical prototype pollution vulnerability! Object prototype modification enables application control and potential RCE.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing against prototype pollution. What's the primary defense?",
          choices: [
            {
              text: "Use safe object assignment and avoid recursive merges with user input",
              correct: true,
              points: 25,
              feedback: "Essential! Safe object handling and input validation prevent prototype pollution attacks.",
              nextStep: 1
            },
            {
              text: "Freeze all object prototypes in production",
              correct: false,
              points: 15,
              feedback: "Freezing helps but doesn't address the root cause in object merge operations.",
              nextStep: 1
            },
            {
              text: "Use JSON.parse(JSON.stringify()) for all object operations",
              correct: false,
              points: 10,
              feedback: "This approach loses functionality and doesn't prevent all pollution vectors.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good defense! What comprehensive JavaScript security should you implement?",
          choices: [
            {
              text: "Safe object operations, input validation, and security linters",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers including code patterns, data validation, and automated security checks.",
              nextStep: 2
            },
            {
              text: "Disable all object prototype features",
              correct: false,
              points: -20,
              feedback: "Prototypes are fundamental to JavaScript - disabling breaks functionality.",
              nextStep: 2
            },
            {
              text: "Use eval() for dynamic object operations",
              correct: false,
              points: -30,
              feedback: "eval() introduces even more severe security risks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Prototype pollution protection established! All object operations now use safe patterns with validation.",
          choices: []
        }
      ]
    }
  },

  accessControl253: {
    id: 253,
    title: "Insecure Direct Object Reference (IDOR) in File Downloads",
    difficulty: "Easy",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover file download endpoints using sequential numeric IDs without authorization checks. What access control risk exists?",
          choices: [
            {
              text: "IDOR allows downloading any user's files by guessing document IDs",
              correct: true,
              points: 15,
              feedback: "Critical finding! Sequential IDs without authorization enable access to all user files.",
              nextStep: 1
            },
            {
              text: "Files might be too large to download",
              correct: false,
              points: 5,
              feedback: "Size limitations are operational, not access control issues.",
              nextStep: 0
            },
            {
              text: "Only affects file metadata",
              correct: false,
              points: 5,
              feedback: "IDOR risks expose actual file content, not just metadata.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully access other users' files through IDOR. What's the ethical demonstration?",
          choices: [
            {
              text: "Show file access capability without viewing or downloading sensitive content",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating unauthorized access potential proves the vulnerability without data compromise.",
              nextStep: 2
            },
            {
              text: "Actually download and review other users' private files",
              correct: false,
              points: -25,
              feedback: "Accessing user files without authorization is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the sequential ID pattern",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating access shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical IDOR vulnerability! Sequential file IDs without authorization enable unauthorized data access.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're fixing the file download authorization. What's the essential control?",
          choices: [
            {
              text: "Implement proper authorization checks for each file access request",
              correct: true,
              points: 15,
              feedback: "Essential! Every file access must verify the user has permission for that specific file.",
              nextStep: 1
            },
            {
              text: "Use longer random-looking IDs without authorization",
              correct: false,
              points: -10,
              feedback: "Obfuscation doesn't replace proper authorization checks.",
              nextStep: 1
            },
            {
              text: "Rate limit download requests",
              correct: false,
              points: 5,
              feedback: "Rate limiting helps with abuse but doesn't prevent unauthorized access.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good control! What comprehensive file access security should you implement?",
          choices: [
            {
              text: "Authorization checks, random IDs, and access logging",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including permission verification, identifier security, and monitoring.",
              nextStep: 2
            },
            {
              text: "Use the same permission check for all file types",
              correct: false,
              points: -15,
              feedback: "Different file types may require different authorization logic.",
              nextStep: 2
            },
            {
              text: "Disable file downloads entirely",
              correct: false,
              points: 5,
              feedback: "Not practical for applications requiring file sharing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "File access control established! All downloads now require proper authorization with comprehensive logging.",
          choices: []
        }
      ]
    }
  },

  securityMisconfig254: {
    id: 254,
    title: "Exposed Docker Socket",
    difficulty: "Medium",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover a container with the Docker socket mounted inside without proper permissions. What's the immediate risk?",
          choices: [
            {
              text: "Container escape and host system compromise through Docker API access",
              correct: true,
              points: 20,
              feedback: "Critical finding! Docker socket access provides complete control over the host system and other containers.",
              nextStep: 1
            },
            {
              text: "Container might use more CPU resources",
              correct: false,
              points: 5,
              feedback: "Resource usage is not the security risk.",
              nextStep: 0
            },
            {
              text: "Only affects container logging",
              correct: false,
              points: 5,
              feedback: "Docker socket access enables full container management, not just logging.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate container escape through Docker socket access. What's the ethical approach?",
          choices: [
            {
              text: "Show escape capability without modifying host system or other containers",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating container escape potential proves the risk without causing damage.",
              nextStep: 2
            },
            {
              text: "Actually break out and access host file system",
              correct: false,
              points: -30,
              feedback: "Unauthorized host system access is dangerous and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the mounted socket",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating escape shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical Docker misconfiguration! Exposed socket enables container escape and host compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing container deployments. What's the proper Docker socket practice?",
          choices: [
            {
              text: "Avoid mounting Docker socket in containers; use alternative APIs when needed",
              correct: true,
              points: 20,
              feedback: "Essential! Docker socket should rarely be mounted; use dedicated APIs for container management.",
              nextStep: 1
            },
            {
              text: "Mount socket read-only for security",
              correct: false,
              points: -15,
              feedback: "Read-only mounting still exposes sensitive information and some attack vectors.",
              nextStep: 1
            },
            {
              text: "Use the socket only in development",
              correct: false,
              points: -10,
              feedback: "Development practices shouldn't differ dramatically from production security.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive container security should you implement?",
          choices: [
            {
              text: "Minimal privileges, no socket access, and security context constraints",
              correct: true,
              points: 25,
              feedback: "Perfect! Defense in depth including privilege reduction, API security, and runtime restrictions.",
              nextStep: 2
            },
            {
              text: "Mount socket in all containers for management flexibility",
              correct: false,
              points: -25,
              feedback: "Widespread socket access dramatically increases attack surface.",
              nextStep: 2
            },
            {
              text: "Run all containers as root for simplicity",
              correct: false,
              points: -20,
              feedback: "Root privileges increase the impact of container compromises.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Container security established! Docker socket access eliminated with proper privilege management.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponents255: {
    id: 255,
    title: "Vulnerable Container Dependencies",
    difficulty: "Medium",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover containers built with outdated system packages containing known vulnerabilities. What's the exploitation path?",
          choices: [
            {
              text: "Vulnerable system libraries can be exploited for container escape or RCE",
              correct: true,
              points: 20,
              feedback: "Critical finding! System-level vulnerabilities in containers provide reliable attack vectors.",
              nextStep: 1
            },
            {
              text: "Containers might have larger image sizes",
              correct: false,
              points: 5,
              feedback: "Image size is operational, not a security concern.",
              nextStep: 0
            },
            {
              text: "Only affects container startup time",
              correct: false,
              points: 5,
              feedback: "Vulnerabilities affect runtime security, not just startup performance.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You identify exploitable system vulnerabilities in containers. How do you demonstrate the risk?",
          choices: [
            {
              text: "Show exploit availability and impact without executing attacks",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating known exploits and their potential impact proves the risk without exploitation.",
              nextStep: 2
            },
            {
              text: "Actually exploit the vulnerabilities to compromise containers",
              correct: false,
              points: -30,
              feedback: "Exploiting production containers is dangerous and unethical.",
              nextStep: 2
            },
            {
              text: "Just list the vulnerable packages",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating exploit potential shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical container vulnerability! Outdated system packages with known exploits enable container compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing container builds. What's the essential practice for system packages?",
          choices: [
            {
              text: "Use minimal base images and regularly update system packages",
              correct: true,
              points: 20,
              feedback: "Essential! Minimal images reduce attack surface, while regular updates fix known vulnerabilities.",
              nextStep: 1
            },
            {
              text: "Freeze all package versions for stability",
              correct: false,
              points: -15,
              feedback: "Frozen versions accumulate security vulnerabilities over time.",
              nextStep: 1
            },
            {
              text: "Build from source to avoid package managers",
              correct: false,
              points: 10,
              feedback: "Source building doesn't automatically prevent vulnerabilities and increases complexity.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive container dependency security should you implement?",
          choices: [
            {
              text: "Automated scanning, minimal bases, and vulnerability management pipeline",
              correct: true,
              points: 25,
              feedback: "Perfect! End-to-end security including detection, prevention, and remediation processes.",
              nextStep: 2
            },
            {
              text: "Ignore non-critical severity vulnerabilities",
              correct: false,
              points: -20,
              feedback: "Low-severity vulnerabilities can chain together to create critical risks.",
              nextStep: 2
            },
            {
              text: "Disable package managers in production",
              correct: false,
              points: -10,
              feedback: "Package managers are needed for security updates in some scenarios.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Container dependency security established! Automated scanning and update processes now in place.",
          choices: []
        }
      ]
    }
  },

  authFailure256: {
    id: 256,
    title: "OAuth Implementation Flaws",
    difficulty: "Hard",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover an OAuth implementation that doesn't validate redirect URIs properly. What authentication bypass exists?",
          choices: [
            {
              text: "Open redirect allows stealing authorization codes and access tokens",
              correct: true,
              points: 25,
              feedback: "Critical finding! Improper redirect URI validation enables authorization code interception and account takeover.",
              nextStep: 1
            },
            {
              text: "OAuth flows might be slower",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the security risk.",
              nextStep: 0
            },
            {
              text: "Only affects social login features",
              correct: false,
              points: 10,
              feedback: "OAuth flaws can compromise any authentication relying on the implementation.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate redirect URI manipulation to intercept auth codes. What's the ethical approach?",
          choices: [
            {
              text: "Show interception capability without actually stealing tokens or accessing accounts",
              correct: true,
              points: 30,
              feedback: "Perfect! Demonstrating the attack vector proves the vulnerability without account compromise.",
              nextStep: 2
            },
            {
              text: "Actually use stolen tokens to access user accounts",
              correct: false,
              points: -35,
              feedback: "Unauthorized account access is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the redirect parameter",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating interception shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical OAuth vulnerability! Improper redirect validation enables authorization code interception and account takeover.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the OAuth implementation. What's the essential redirect URI validation?",
          choices: [
            {
              text: "Strict exact matching of redirect URIs against pre-registered values",
              correct: true,
              points: 25,
              feedback: "Essential! Exact redirect URI matching prevents open redirect attacks and token leakage.",
              nextStep: 1
            },
            {
              text: "Allow any redirect for development flexibility",
              correct: false,
              points: -20,
              feedback: "Open redirects create critical security vulnerabilities.",
              nextStep: 1
            },
            {
              text: "Validate only the domain part of redirect URIs",
              correct: false,
              points: -15,
              feedback: "Partial validation still allows path-based attacks and token theft.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good validation! What comprehensive OAuth security should you implement?",
          choices: [
            {
              text: "Strict redirect validation, PKCE, and proper token handling",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple OAuth security layers including redirect control, code protection, and token security.",
              nextStep: 2
            },
            {
              text: "Use implicit flow for all clients for simplicity",
              correct: false,
              points: -25,
              feedback: "Implicit flow is deprecated and less secure than authorization code flow with PKCE.",
              nextStep: 2
            },
            {
              text: "Store tokens in local storage for easy access",
              correct: false,
              points: -20,
              feedback: "Local storage is vulnerable to XSS attacks; use httpOnly cookies instead.",
              nextStep: 2
            }
          ]
        },
        {
          text: "OAuth security established! All flows now use strict redirect validation with PKCE protection.",
          choices: []
        }
      ]
    }
  },

  softwareIntegrity257: {
    id: 257,
    title: "Insecure Software Update Mechanism",
    difficulty: "Hard",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover a desktop application that downloads updates over HTTP without integrity verification. What's the risk?",
          choices: [
            {
              text: "Attackers can serve malicious updates leading to client system compromise",
              correct: true,
              points: 25,
              feedback: "Critical finding! Insecure update mechanisms enable supply chain attacks and mass client compromise.",
              nextStep: 1
            },
            {
              text: "Updates might download slower",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the security risk.",
              nextStep: 0
            },
            {
              text: "Only affects update notification features",
              correct: false,
              points: 10,
              feedback: "Update mechanisms affect the entire application integrity and security.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate update mechanism compromise. What's the ethical approach?",
          choices: [
            {
              text: "Show MITM capability without distributing malicious updates to users",
              correct: true,
              points: 30,
              feedback: "Perfect! Demonstrating update interception potential proves the vulnerability without harming users.",
              nextStep: 2
            },
            {
              text: "Actually serve malicious updates to test clients",
              correct: false,
              points: -40,
              feedback: "Distributing malicious software is illegal and highly unethical.",
              nextStep: 2
            },
            {
              text: "Just report the HTTP update URL",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating interception shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical software integrity failure! Insecure update mechanism enables supply chain attacks and mass compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the software update mechanism. What's the essential integrity control?",
          choices: [
            {
              text: "Use HTTPS with code signing and cryptographic verification",
              correct: true,
              points: 25,
              feedback: "Essential! Secure updates require encrypted transport, digital signatures, and integrity checks.",
              nextStep: 1
            },
            {
              text: "Use HTTP with MD5 checksums for compatibility",
              correct: false,
              points: -25,
              feedback: "HTTP exposes updates to interception, and MD5 is cryptographically broken.",
              nextStep: 1
            },
            {
              text: "Rely on firewalls to protect update servers",
              correct: false,
              points: -15,
              feedback: "Network controls don't protect against update server compromise or MITM attacks.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good controls! What comprehensive update security should you implement?",
          choices: [
            {
              text: "Secure transport, code signing, rollback protection, and update transparency",
              correct: true,
              points: 30,
              feedback: "Perfect! End-to-end update security including delivery, verification, safety, and auditability.",
              nextStep: 2
            },
            {
              text: "Force immediate updates without user consent",
              correct: false,
              points: -20,
              feedback: "Forced updates can disrupt users and bypass safety measures.",
              nextStep: 2
            },
            {
              text: "Disable update verification for faster installation",
              correct: false,
              points: -25,
              feedback: "Verification is essential for update integrity and security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Software update security established! All updates now use secure transport with cryptographic verification.",
          choices: []
        }
      ]
    }
  },

  loggingFailures258: {
    id: 258,
    title: "Missing Cloud Trail Logging for Critical Operations",
    difficulty: "Medium",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover AWS infrastructure changes aren't logged in CloudTrail. What detection gap exists?",
          choices: [
            {
              text: "Malicious infrastructure modifications can occur without detection or audit trail",
              correct: true,
              points: 20,
              feedback: "Critical finding! Missing CloudTrail logging enables undetected infrastructure attacks and configuration changes.",
              nextStep: 1
            },
            {
              text: "Cloud costs might be higher",
              correct: false,
              points: 5,
              feedback: "Cost management is different from security monitoring.",
              nextStep: 0
            },
            {
              text: "Only affects compliance reporting",
              correct: false,
              points: 5,
              feedback: "Missing logging enables actual attacks, not just compliance issues.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate infrastructure changes without CloudTrail records. How do you show the detection failure?",
          choices: [
            {
              text: "Show infrastructure modifications that don't appear in security logs",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating unlogged changes proves the monitoring gap and audit trail failure.",
              nextStep: 2
            },
            {
              text: "Actually modify production infrastructure to prove the point",
              correct: false,
              points: -30,
              feedback: "Unauthorized infrastructure changes are dangerous and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the missing CloudTrail configuration",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating the gap shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical cloud monitoring failure! Missing CloudTrail logging enables undetected infrastructure attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing cloud security monitoring. What's the essential CloudTrail configuration?",
          choices: [
            {
              text: "Enable organization-wide CloudTrail with integrity validation and secure storage",
              correct: true,
              points: 20,
              feedback: "Essential! Comprehensive CloudTrail coverage with integrity protection ensures complete audit capability.",
              nextStep: 1
            },
            {
              text: "Log only IAM events to reduce costs",
              correct: false,
              points: -15,
              feedback: "Selective logging misses critical security events from other services.",
              nextStep: 1
            },
            {
              text: "Store logs in public S3 buckets for easy access",
              correct: false,
              points: -25,
              feedback: "Public log storage exposes sensitive audit information.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good configuration! What comprehensive cloud monitoring should you implement?",
          choices: [
            {
              text: "Multi-region CloudTrail, log integrity, and automated alerting",
              correct: true,
              points: 25,
              feedback: "Perfect! Complete cloud monitoring including geographic coverage, data protection, and proactive detection.",
              nextStep: 2
            },
            {
              text: "Disable logging during maintenance windows",
              correct: false,
              points: -20,
              feedback: "Maintenance activities often require audit trails for security and compliance.",
              nextStep: 2
            },
            {
              text: "Use the same trail for all AWS accounts",
              correct: false,
              points: -15,
              feedback: "Account separation helps contain breaches and manage access.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cloud monitoring established! Comprehensive CloudTrail logging with integrity protection and alerting.",
          choices: []
        }
      ]
    }
  },

  ssrf259: {
    id: 259,
    title: "SSRF Through PDF Generation Service",
    difficulty: "Medium",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "You discover a PDF generation service that fetches user-provided URLs for inclusion in documents. What SSRF risk exists?",
          choices: [
            {
              text: "URL fetching enables internal service scanning and metadata endpoint access",
              correct: true,
              points: 20,
              feedback: "Critical finding! PDF generation SSRF can probe internal networks and access cloud metadata services.",
              nextStep: 1
            },
            {
              text: "PDF files might be too large",
              correct: false,
              points: 5,
              feedback: "File size is operational, not a security risk.",
              nextStep: 0
            },
            {
              text: "Only affects PDF formatting",
              correct: false,
              points: 5,
              feedback: "SSRF risks internal network access, not document formatting.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully trigger requests to internal services through PDF generation. What's the ethical demonstration?",
          choices: [
            {
              text: "Show internal service interaction through response timing or errors",
              correct: true,
              points: 25,
              feedback: "Perfect! Blind SSRF can be demonstrated through timing differences and error responses.",
              nextStep: 2
            },
            {
              text: "Actually access AWS metadata to get credentials",
              correct: false,
              points: -35,
              feedback: "Accessing cloud credentials through SSRF is dangerous and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the URL parameter",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating SSRF shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical PDF generation SSRF! URL fetching enables internal network reconnaissance and metadata access.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the PDF generation service. What's the primary SSRF defense?",
          choices: [
            {
              text: "Implement URL allowlisting and block internal IP ranges",
              correct: true,
              points: 20,
              feedback: "Essential! Allowlisting ensures only intended resources, while IP blocking prevents internal access.",
              nextStep: 1
            },
            {
              text: "Add CAPTCHA to PDF generation requests",
              correct: false,
              points: 5,
              feedback: "CAPTCHA prevents automation but doesn't fix SSRF vulnerabilities.",
              nextStep: 1
            },
            {
              text: "Use DNS filtering only",
              correct: false,
              points: -10,
              feedback: "DNS filtering doesn't prevent IP-based internal access.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good defense! What comprehensive PDF service security should you implement?",
          choices: [
            {
              text: "URL validation, network restrictions, and content sanitization",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including input control, network security, and output safety.",
              nextStep: 2
            },
            {
              text: "Allow any URL for maximum document flexibility",
              correct: false,
              points: -25,
              feedback: "Unrestricted URL access creates massive SSRF risks.",
              nextStep: 2
            },
            {
              text: "Disable remote URL fetching entirely",
              correct: false,
              points: 10,
              feedback: "Not practical for services requiring external content inclusion.",
              nextStep: 2
            }
          ]
        },
        {
          text: "PDF generation security established! All URL fetching now validated with network restrictions.",
          choices: []
        }
      ]
    }
  },

  
  insecureDesign260: {
    id: 260,
    title: "Broken Function Level Authorization in Microservices",
    difficulty: "Hard",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover a microservices architecture where internal service endpoints don't verify caller permissions. What access control risk exists?",
          choices: [
            {
              text: "Horizontal privilege escalation between microservices bypassing business logic",
              correct: true,
              points: 25,
              feedback: "Critical finding! Missing inter-service authorization allows services to call privileged endpoints they shouldn't access.",
              nextStep: 1
            },
            {
              text: "Services might communicate slower",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the security risk.",
              nextStep: 0
            },
            {
              text: "Only affects service discovery",
              correct: false,
              points: 10,
              feedback: "This affects data integrity and business logic enforcement across services.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate one service calling another's admin endpoints. What's the ethical approach?",
          choices: [
            {
              text: "Show unauthorized service calls without modifying data or disrupting operations",
              correct: true,
              points: 30,
              feedback: "Perfect! Demonstrating inter-service authorization bypass proves the design flaw without causing harm.",
              nextStep: 2
            },
            {
              text: "Actually call admin endpoints to modify production data",
              correct: false,
              points: -40,
              feedback: "Unauthorized data modification in production is dangerous and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the service communication pattern",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating the bypass shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical microservice design flaw! Missing inter-service authorization enables privilege escalation across service boundaries.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're designing microservice authorization. What's the essential security pattern?",
          choices: [
            {
              text: "Implement service-to-service authentication with role-based access control",
              correct: true,
              points: 25,
              feedback: "Essential! Each service must authenticate and authorize other services based on their roles and responsibilities.",
              nextStep: 1
            },
            {
              text: "Trust all internal network traffic implicitly",
              correct: false,
              points: -25,
              feedback: "Implicit trust enables lateral movement and privilege escalation attacks.",
              nextStep: 1
            },
            {
              text: "Use IP whitelisting only for service communication",
              correct: false,
              points: -15,
              feedback: "IP-based trust doesn't prevent compromised services from making unauthorized calls.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good pattern! What comprehensive microservice security should you implement?",
          choices: [
            {
              text: "Service mesh with mTLS, JWT tokens, and fine-grained authorization policies",
              correct: true,
              points: 30,
              feedback: "Perfect! Defense in depth including transport security, identity, and policy enforcement.",
              nextStep: 2
            },
            {
              text: "Allow all internal services full access to each other",
              correct: false,
              points: -30,
              feedback: "Full access violates principle of least privilege and enables widespread compromise.",
              nextStep: 2
            },
            {
              text: "Disable authentication for performance reasons",
              correct: false,
              points: -25,
              feedback: "Security should never be disabled for performance - optimize instead.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Microservice authorization established! All inter-service calls now authenticated and authorized with proper policies.",
          choices: []
        }
      ]
    }
  },

  cryptoFailures261: {
    id: 261,
    title: "Insecure Random Number Generation for Session IDs",
    difficulty: "Medium",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover an application using Math.random() for session ID generation. What cryptographic weakness exists?",
          choices: [
            {
              text: "Predictable random values enable session prediction and hijacking",
              correct: true,
              points: 20,
              feedback: "Critical finding! Cryptographically weak RNG enables session prediction attacks and account takeover.",
              nextStep: 1
            },
            {
              text: "Session IDs might be too long",
              correct: false,
              points: 5,
              feedback: "Length is not the issue - predictability is the vulnerability.",
              nextStep: 0
            },
            {
              text: "Only affects user experience",
              correct: false,
              points: 5,
              feedback: "This is a fundamental security vulnerability affecting all user sessions.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate session ID predictability. What's the ethical demonstration?",
          choices: [
            {
              text: "Show pattern in generated IDs without actually hijacking sessions",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating predictability proves the vulnerability without unauthorized access.",
              nextStep: 2
            },
            {
              text: "Actually predict and hijack active user sessions",
              correct: false,
              points: -35,
              feedback: "Session hijacking is illegal and violates user privacy.",
              nextStep: 2
            },
            {
              text: "Just report the Math.random() usage",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating predictability shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical cryptographic failure! Weak random number generation enables session prediction and hijacking.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're fixing session ID generation. What's the cryptographically secure approach?",
          choices: [
            {
              text: "Use crypto-grade random APIs like crypto.randomBytes() or SecureRandom",
              correct: true,
              points: 20,
              feedback: "Essential! Cryptographically secure random number generators are designed specifically for security purposes.",
              nextStep: 1
            },
            {
              text: "Use current timestamp as session seeds",
              correct: false,
              points: -20,
              feedback: "Timestamps are predictable and enable timing-based attacks.",
              nextStep: 1
            },
            {
              text: "Combine multiple weak random sources",
              correct: false,
              points: -15,
              feedback: "Combining weak sources doesn't create strong randomness - use proper crypto RNG.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good approach! What comprehensive session security should you implement?",
          choices: [
            {
              text: "Crypto RNG, sufficient entropy, and proper session management lifecycle",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including strong generation, adequate randomness, and full lifecycle security.",
              nextStep: 2
            },
            {
              text: "Reuse session IDs for returning users",
              correct: false,
              points: -25,
              feedback: "Session ID reuse enables replay attacks and reduces security.",
              nextStep: 2
            },
            {
              text: "Use shorter IDs for mobile compatibility",
              correct: false,
              points: -20,
              feedback: "Security should not be compromised for compatibility - find balanced solutions.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Session security established! All IDs now generated with cryptographically secure random number generators.",
          choices: []
        }
      ]
    }
  },

  injection262: {
    id: 262,
    title: "Command Injection in System Monitoring Dashboard",
    difficulty: "Easy",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover a monitoring dashboard that executes system commands with user-provided parameters. What injection risk exists?",
          choices: [
            {
              text: "Command injection allows arbitrary system command execution through parameter manipulation",
              correct: true,
              points: 15,
              feedback: "Critical finding! Unvalidated command execution enables complete server compromise.",
              nextStep: 1
            },
            {
              text: "Commands might run slower",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the security risk.",
              nextStep: 0
            },
            {
              text: "Only affects command output display",
              correct: false,
              points: 5,
              feedback: "This enables actual system command execution, not just output issues.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate command injection through parameter manipulation. What's the ethical approach?",
          choices: [
            {
              text: "Show harmless command execution like 'whoami' without system damage",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating command execution with harmless commands proves the vulnerability.",
              nextStep: 2
            },
            {
              text: "Actually delete system files or access sensitive data",
              correct: false,
              points: -30,
              feedback: "System modification or data access is destructive and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the command execution feature",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating execution shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical command injection vulnerability! Unvalidated command execution enables complete server compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the monitoring dashboard. What's the primary command injection defense?",
          choices: [
            {
              text: "Use parameterized commands and input validation with allowlists",
              correct: true,
              points: 15,
              feedback: "Essential! Parameterization and strict validation prevent command injection attacks.",
              nextStep: 1
            },
            {
              text: "Escape all special characters in user input",
              correct: false,
              points: 10,
              feedback: "Escaping helps but is error-prone; parameterization is more reliable.",
              nextStep: 1
            },
            {
              text: "Run commands with reduced privileges only",
              correct: false,
              points: 5,
              feedback: "Privilege reduction helps but doesn't prevent injection itself.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good defense! What comprehensive command execution security should you implement?",
          choices: [
            {
              text: "Parameterized commands, input validation, and principle of least privilege",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including safe execution patterns, input control, and minimal permissions.",
              nextStep: 2
            },
            {
              text: "Allow all commands for full monitoring capability",
              correct: false,
              points: -25,
              feedback: "Unrestricted command execution creates unacceptable security risks.",
              nextStep: 2
            },
            {
              text: "Use shell scripts for complex command sequences",
              correct: false,
              points: -15,
              feedback: "Shell scripts often introduce additional injection vectors.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Command execution secured! All system commands now use parameterization with strict input validation.",
          choices: []
        }
      ]
    }
  },

  insecureDesign263: {
    id: 263,
    title: "Insecure Data Export Design Without Rate Limiting",
    difficulty: "Medium",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover a data export feature that allows unlimited CSV downloads without rate limiting. What design flaw enables data scraping?",
          choices: [
            {
              text: "Unrestricted data export enables complete database scraping through automated requests",
              correct: true,
              points: 20,
              feedback: "Critical finding! Missing rate limits allow attackers to export entire datasets through automated tools.",
              nextStep: 1
            },
            {
              text: "CSV files might be poorly formatted",
              correct: false,
              points: 5,
              feedback: "Formatting issues are usability problems, not security design flaws.",
              nextStep: 0
            },
            {
              text: "Only affects server performance",
              correct: false,
              points: 10,
              feedback: "This enables data exfiltration, not just performance issues.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate automated data scraping through the export feature. What's the ethical approach?",
          choices: [
            {
              text: "Show scraping capability without actually exporting large datasets",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating automated export potential proves the design flaw without data theft.",
              nextStep: 2
            },
            {
              text: "Actually download the entire user database",
              correct: false,
              points: -35,
              feedback: "Mass data export constitutes data theft and is illegal.",
              nextStep: 2
            },
            {
              text: "Just report the missing rate limits",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating automation shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical design flaw! Unlimited data export enables complete database scraping and data exfiltration.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're redesigning the data export feature. What's the essential security control?",
          choices: [
            {
              text: "Implement strict rate limiting and data volume restrictions per user",
              correct: true,
              points: 20,
              feedback: "Essential! Rate and volume limits prevent automated data scraping while allowing legitimate use.",
              nextStep: 1
            },
            {
              text: "Use CAPTCHA for each export request",
              correct: false,
              points: 10,
              feedback: "CAPTCHA prevents automation but doesn't address the fundamental design issue.",
              nextStep: 1
            },
            {
              text: "Slow down export responses instead of limiting",
              correct: false,
              points: -15,
              feedback: "Performance degradation doesn't prevent determined attackers from scraping data.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good control! What comprehensive data export security should you implement?",
          choices: [
            {
              text: "Rate limits, volume caps, user quotas, and monitoring for abnormal patterns",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including prevention, restriction, and detection controls.",
              nextStep: 2
            },
            {
              text: "Allow unlimited exports for premium users only",
              correct: false,
              points: -20,
              feedback: "All users should have appropriate limits to prevent abuse.",
              nextStep: 2
            },
            {
              text: "Disable exports entirely for security",
              correct: false,
              points: 5,
              feedback: "Not practical for applications requiring data export functionality.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure data export design implemented! All exports now have strict rate limiting and volume controls.",
          choices: []
        }
      ]
    }
  },

  securityMisconfig264: {
    id: 264,
    title: "Exposed Git Directory in Web Root",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover a production web server with the .git directory accessible via HTTP. What's the immediate risk?",
          choices: [
            {
              text: "Source code exposure including API keys, database credentials, and business logic",
              correct: true,
              points: 15,
              feedback: "Critical finding! Exposed .git directories enable complete source code reconstruction and secret discovery.",
              nextStep: 1
            },
            {
              text: "Git operations might be slower",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the security risk.",
              nextStep: 0
            },
            {
              text: "Only affects version history",
              correct: false,
              points: 5,
              feedback: "This exposes current source code, configuration files, and sensitive secrets.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You access the exposed .git directory and reconstruct source code. What's the ethical demonstration?",
          choices: [
            {
              text: "Show source code access capability without extracting or using sensitive information",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating source code reconstruction proves the vulnerability without data misuse.",
              nextStep: 2
            },
            {
              text: "Actually extract and use discovered API keys and credentials",
              correct: false,
              points: -30,
              feedback: "Using exposed credentials is illegal and constitutes unauthorized access.",
              nextStep: 2
            },
            {
              text: "Just report the directory exposure",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating access shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical security misconfiguration! Exposed .git directory enables complete source code and secret exposure.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the web server deployment. What's the essential .git directory practice?",
          choices: [
            {
              text: "Exclude .git directory from web root in deployment process",
              correct: true,
              points: 15,
              feedback: "Essential! .git directories should never be deployed to production web servers.",
              nextStep: 1
            },
            {
              text: "Use .htaccess to block .git access",
              correct: false,
              points: 10,
              feedback: "Access controls help but don't address the root issue of deploying unnecessary files.",
              nextStep: 1
            },
            {
              text: "Rename .git directory to hide it",
              correct: false,
              points: -15,
              feedback: "Security through obscurity is not a reliable defense.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive deployment security should you implement?",
          choices: [
            {
              text: "Build artifacts instead of source code, security scanning, and deployment reviews",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including proper build processes, automated checks, and manual validation.",
              nextStep: 2
            },
            {
              text: "Deploy entire repository for debugging convenience",
              correct: false,
              points: -25,
              feedback: "Production deployments should only include necessary runtime files.",
              nextStep: 2
            },
            {
              text: "Use the same deployment for all environments",
              correct: false,
              points: -15,
              feedback: "Different environments have different security requirements.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Deployment security established! All production deployments now exclude source control and development artifacts.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponents265: {
    id: 265,
    title: "Vulnerable Machine Learning Model Dependencies",
    difficulty: "Hard",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover an AI application using outdated tensorflow/pytorch versions with known vulnerabilities. What's the exploitation path?",
          choices: [
            {
              text: "ML framework vulnerabilities enable model manipulation, data leakage, or RCE",
              correct: true,
              points: 25,
              feedback: "Critical finding! ML framework vulnerabilities can compromise model integrity, training data, and system security.",
              nextStep: 1
            },
            {
              text: "Models might have lower accuracy",
              correct: false,
              points: 5,
              feedback: "Accuracy issues are model quality concerns, not security vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Only affects training performance",
              correct: false,
              points: 10,
              feedback: "This affects both training and inference security in production systems.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You identify exploitable vulnerabilities in ML dependencies. How do you demonstrate the risk?",
          choices: [
            {
              text: "Show known exploits and impact without compromising models or data",
              correct: true,
              points: 30,
              feedback: "Perfect! Demonstrating known vulnerabilities and their potential impact proves the risk without exploitation.",
              nextStep: 2
            },
            {
              text: "Actually exploit the vulnerabilities to manipulate production models",
              correct: false,
              points: -40,
              feedback: "Manipulating production AI systems is dangerous and unethical.",
              nextStep: 2
            },
            {
              text: "Just list the vulnerable ML packages",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating exploit potential shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical ML dependency vulnerability! Outdated frameworks enable model compromise and system attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing ML application dependencies. What's the essential practice?",
          choices: [
            {
              text: "Regular vulnerability scanning and updates for ML frameworks and libraries",
              correct: true,
              points: 25,
              feedback: "Essential! ML dependencies require the same security maintenance as other software components.",
              nextStep: 1
            },
            {
              text: "Freeze ML versions once models are trained",
              correct: false,
              points: -20,
              feedback: "Frozen versions accumulate security vulnerabilities over time.",
              nextStep: 1
            },
            {
              text: "Use only CPU versions to avoid GPU driver issues",
              correct: false,
              points: 10,
              feedback: "Hardware choice doesn't address framework security vulnerabilities.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive ML security should you implement?",
          choices: [
            {
              text: "Dependency scanning, model signing, and secure inference endpoints",
              correct: true,
              points: 30,
              feedback: "Perfect! End-to-end ML security including component safety, model integrity, and deployment protection.",
              nextStep: 2
            },
            {
              text: "Ignore vulnerabilities in research-only components",
              correct: false,
              points: -25,
              feedback: "Research components often make their way to production - maintain security throughout.",
              nextStep: 2
            },
            {
              text: "Use custom-built ML frameworks for security",
              correct: false,
              points: -30,
              feedback: "Custom frameworks lack community scrutiny and may introduce new vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "ML dependency security established! All frameworks now regularly scanned and updated with secure practices.",
          choices: []
        }
      ]
    }
  },

  authFailure266: {
    id: 266,
    title: "JWT Token Revocation Vulnerability",
    difficulty: "Medium",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover a stateless JWT implementation without token revocation mechanism. What authentication risk exists?",
          choices: [
            {
              text: "Revoked users remain authenticated until token expiration enabling access despite account suspension",
              correct: true,
              points: 20,
              feedback: "Critical finding! Missing token revocation allows compromised or suspended accounts to maintain access.",
              nextStep: 1
            },
            {
              text: "Tokens might be too large",
              correct: false,
              points: 5,
              feedback: "Token size is not the security risk.",
              nextStep: 0
            },
            {
              text: "Only affects login performance",
              correct: false,
              points: 10,
              feedback: "This affects the fundamental ability to revoke access when needed.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate that revoked tokens remain valid. What's the ethical approach?",
          choices: [
            {
              text: "Show continued API access with revoked token without accessing sensitive data",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating that revocation doesn't work proves the authentication flaw.",
              nextStep: 2
            },
            {
              text: "Actually access user data with revoked tokens",
              correct: false,
              points: -35,
              feedback: "Unauthorized data access with revoked tokens is illegal.",
              nextStep: 2
            },
            {
              text: "Just report the stateless JWT implementation",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating the flaw shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical authentication failure! Missing token revocation enables persistent access despite account suspension.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing JWT token revocation. What's the effective approach?",
          choices: [
            {
              text: "Use token blacklisting or short expiration with refresh token rotation",
              correct: true,
              points: 20,
              feedback: "Essential! Token revocation requires either blacklisting mechanisms or short-lived tokens with secure refresh.",
              nextStep: 1
            },
            {
              text: "Increase token expiration to reduce revocation needs",
              correct: false,
              points: -25,
              feedback: "Longer expiration increases the window where revoked tokens remain valid.",
              nextStep: 1
            },
            {
              text: "Rely on client-side token deletion",
              correct: false,
              points: -20,
              feedback: "Client-side controls cannot be trusted for security enforcement.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good approach! What comprehensive token security should you implement?",
          choices: [
            {
              text: "Revocation lists, short expirations, and secure refresh token handling",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including revocation capability, limited token lifetime, and safe renewal.",
              nextStep: 2
            },
            {
              text: "Use the same secret for all token signing",
              correct: false,
              points: -30,
              feedback: "Shared secrets increase breach impact and reduce security isolation.",
              nextStep: 2
            },
            {
              text: "Disable token expiration for user convenience",
              correct: false,
              points: -25,
              feedback: "Never-expiring tokens create massive security risks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Token revocation established! All JWT tokens now support proper revocation with secure refresh mechanisms.",
          choices: []
        }
      ]
    }
  },

  softwareIntegrity267: {
    id: 267,
    title: "Insecure Firmware Update Process in IoT Devices",
    difficulty: "Hard",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover IoT devices that download firmware updates without signature verification. What integrity risk exists?",
          choices: [
            {
              text: "Malicious firmware can be deployed enabling device compromise and botnet recruitment",
              correct: true,
              points: 25,
              feedback: "Critical finding! Unsigned firmware updates enable complete device takeover and network compromise.",
              nextStep: 1
            },
            {
              text: "Updates might fail occasionally",
              correct: false,
              points: 5,
              feedback: "Reliability issues are different from integrity vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Only affects device performance",
              correct: false,
              points: 10,
              feedback: "This enables permanent device compromise and network attacks.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate firmware update manipulation. What's the ethical approach?",
          choices: [
            {
              text: "Show update interception capability without deploying malicious firmware",
              correct: true,
              points: 30,
              feedback: "Perfect! Demonstrating the update vulnerability proves the risk without device compromise.",
              nextStep: 2
            },
            {
              text: "Actually deploy backdoored firmware to test devices",
              correct: false,
              points: -45,
              feedback: "Deploying malicious firmware is destructive and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the unsigned update process",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating the vulnerability shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical firmware integrity failure! Unsigned updates enable complete IoT device compromise and botnet creation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing IoT firmware updates. What's the essential integrity control?",
          choices: [
            {
              text: "Implement cryptographic signing and verification for all firmware updates",
              correct: true,
              points: 25,
              feedback: "Essential! Firmware must be cryptographically signed and verified before installation.",
              nextStep: 1
            },
            {
              text: "Use checksums without cryptography for simplicity",
              correct: false,
              points: -25,
              feedback: "Checksums provide integrity but not authenticity - use proper signatures.",
              nextStep: 1
            },
            {
              text: "Distribute updates via secure networks only",
              correct: false,
              points: -15,
              feedback: "Network security doesn't prevent update server compromise or insider threats.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good control! What comprehensive IoT security should you implement?",
          choices: [
            {
              text: "Signed firmware, secure boot, and remote attestation capabilities",
              correct: true,
              points: 30,
              feedback: "Perfect! End-to-end IoT security including update integrity, boot protection, and runtime verification.",
              nextStep: 2
            },
            {
              text: "Allow manual firmware uploads for field debugging",
              correct: false,
              points: -30,
              feedback: "Manual updates bypass security controls and create vulnerabilities.",
              nextStep: 2
            },
            {
              text: "Use the same signing key for all device models",
              correct: false,
              points: -25,
              feedback: "Key separation limits breach impact across device families.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Firmware security established! All updates now cryptographically signed with secure verification.",
          choices: []
        }
      ]
    }
  },

  loggingFailures268: {
    id: 268,
    title: "Missing Database Query Logging for Security Incidents",
    difficulty: "Medium",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover database queries aren't logged for security analysis. What detection gap exists for SQL injection attacks?",
          choices: [
            {
              text: "SQL injection and data exfiltration attacks proceed without query-level visibility",
              correct: true,
              points: 20,
              feedback: "Critical finding! Missing query logging prevents detection of SQL injection and unauthorized data access.",
              nextStep: 1
            },
            {
              text: "Database performance might be unclear",
              correct: false,
              points: 5,
              feedback: "Performance monitoring is different from security detection.",
              nextStep: 0
            },
            {
              text: "Only affects compliance auditing",
              correct: false,
              points: 10,
              feedback: "This enables actual attacks to proceed undetected, not just compliance issues.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate SQL injection without triggering security alerts. How do you show the detection failure?",
          choices: [
            {
              text: "Show malicious queries that don't appear in security monitoring",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating that attack queries are invisible proves the monitoring gap.",
              nextStep: 2
            },
            {
              text: "Actually extract large datasets to prove the point",
              correct: false,
              points: -35,
              feedback: "Unauthorized data extraction constitutes data theft.",
              nextStep: 2
            },
            {
              text: "Just report the missing query logging",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating the detection gap shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical logging failure! Missing database query monitoring enables undetected SQL injection and data theft.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing database security monitoring. What query events are essential to log?",
          choices: [
            {
              text: "All data modification queries and suspicious read patterns with parameters",
              correct: true,
              points: 20,
              feedback: "Essential! Security logging must capture data changes and unusual access patterns with context.",
              nextStep: 1
            },
            {
              text: "Log only authentication-related queries",
              correct: false,
              points: -15,
              feedback: "Limited logging misses the majority of attack patterns.",
              nextStep: 1
            },
            {
              text: "Log all queries without filtering for completeness",
              correct: false,
              points: 10,
              feedback: "Excessive logging can hide important events and create performance issues.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good selection! What comprehensive database security monitoring should you implement?",
          choices: [
            {
              text: "Query logging, anomaly detection, and real-time alerting for suspicious patterns",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including basic logging, behavioral analysis, and proactive response.",
              nextStep: 2
            },
            {
              text: "Disable logging during peak hours for performance",
              correct: false,
              points: -25,
              feedback: "Attacks often occur during peak traffic - continuous monitoring is essential.",
              nextStep: 2
            },
            {
              text: "Log only successful queries to reduce noise",
              correct: false,
              points: -20,
              feedback: "Failed queries often indicate attack attempts and are critical for security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Database security monitoring established! All security-relevant queries now logged with anomaly detection.",
          choices: []
        }
      ]
    }
  },

  ssrf269: {
    id: 269,
    title: "SSRF Through Document Conversion Service",
    difficulty: "Hard",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "You discover a document conversion service that fetches user-provided URLs to convert web pages to PDF. What SSRF risk exists?",
          choices: [
            {
              text: "URL fetching enables internal service access and cloud metadata endpoint exploitation",
              correct: true,
              points: 25,
              feedback: "Critical finding! Document conversion SSRF can probe internal networks and access sensitive endpoints.",
              nextStep: 1
            },
            {
              text: "Document formatting might be incorrect",
              correct: false,
              points: 5,
              feedback: "Formatting issues are quality problems, not security vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Only affects conversion accuracy",
              correct: false,
              points: 10,
              feedback: "This enables internal network reconnaissance and service compromise.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully trigger internal service requests through document conversion. What's the ethical demonstration?",
          choices: [
            {
              text: "Show internal service interaction through response analysis without data access",
              correct: true,
              points: 30,
              feedback: "Perfect! Blind SSRF can be demonstrated through timing and error analysis without exploitation.",
              nextStep: 2
            },
            {
              text: "Actually access internal data through the SSRF vulnerability",
              correct: false,
              points: -40,
              feedback: "Unauthorized internal data access is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the URL fetching feature",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating SSRF shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical document conversion SSRF! URL fetching enables internal network reconnaissance and metadata access.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the document conversion service. What's the primary SSRF defense?",
          choices: [
            {
              text: "Implement URL allowlisting and network segmentation for conversion services",
              correct: true,
              points: 25,
              feedback: "Essential! Allowlisting controls target resources, while network segmentation limits access scope.",
              nextStep: 1
            },
            {
              text: "Add CAPTCHA to conversion requests",
              correct: false,
              points: 5,
              feedback: "CAPTCHA prevents automation but doesn't fix SSRF vulnerabilities.",
              nextStep: 1
            },
            {
              text: "Use DNS filtering without IP restrictions",
              correct: false,
              points: -20,
              feedback: "DNS-based controls don't prevent IP-based internal access.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good defense! What comprehensive conversion service security should you implement?",
          choices: [
            {
              text: "URL validation, network restrictions, and outbound request monitoring",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers including input control, network security, and traffic analysis.",
              nextStep: 2
            },
            {
              text: "Allow any URL for maximum conversion flexibility",
              correct: false,
              points: -35,
              feedback: "Unrestricted URL access creates massive SSRF risks.",
              nextStep: 2
            },
            {
              text: "Disable web page conversion entirely",
              correct: false,
              points: 10,
              feedback: "Not practical for services requiring web content conversion.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Document conversion security established! All URL fetching now validated with strict network controls.",
          choices: []
        }
      ]
    }
  },

    accessControl270: {
    id: 270,
    title: "Insecure Direct Object Reference in GraphQL API",
    difficulty: "Hard",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover a GraphQL API that exposes internal object IDs without authorization checks. What access control risk exists?",
          choices: [
            {
              text: "IDOR allows data enumeration and unauthorized access through predictable GraphQL queries",
              correct: true,
              points: 25,
              feedback: "Critical finding! GraphQL IDOR enables systematic data extraction through query manipulation.",
              nextStep: 1
            },
            {
              text: "GraphQL queries might be too complex",
              correct: false,
              points: 5,
              feedback: "Query complexity is a performance issue, not an access control vulnerability.",
              nextStep: 0
            },
            {
              text: "Only affects query response size",
              correct: false,
              points: 10,
              feedback: "This enables unauthorized data access, not just response size issues.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully access other users' data through GraphQL IDOR. What's the ethical demonstration?",
          choices: [
            {
              text: "Show unauthorized data access capability without viewing sensitive information",
              correct: true,
              points: 30,
              feedback: "Perfect! Demonstrating access to other users' data proves the vulnerability without privacy violation.",
              nextStep: 2
            },
            {
              text: "Actually extract and download other users' private data",
              correct: false,
              points: -40,
              feedback: "Unauthorized data extraction violates privacy laws and ethics.",
              nextStep: 2
            },
            {
              text: "Just report the GraphQL endpoint exposure",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating access shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical GraphQL IDOR vulnerability! Missing authorization checks enable systematic data enumeration and unauthorized access.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the GraphQL API. What's the essential access control approach?",
          choices: [
            {
              text: "Implement field-level authorization and object-level permission checks",
              correct: true,
              points: 25,
              feedback: "Essential! GraphQL requires both field-level and object-level authorization for proper security.",
              nextStep: 1
            },
            {
              text: "Disable introspection in production only",
              correct: false,
              points: 10,
              feedback: "Introspection control helps but doesn't prevent IDOR attacks.",
              nextStep: 1
            },
            {
              text: "Use random UUIDs without authorization checks",
              correct: false,
              points: -20,
              feedback: "Obfuscation doesn't replace proper authorization enforcement.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good approach! What comprehensive GraphQL security should you implement?",
          choices: [
            {
              text: "Field-level auth, query depth limits, and query cost analysis",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers including authorization, structural limits, and resource protection.",
              nextStep: 2
            },
            {
              text: "Allow unlimited query depth for flexibility",
              correct: false,
              points: -25,
              feedback: "Unlimited depth enables denial of service and data over-fetching.",
              nextStep: 2
            },
            {
              text: "Use the same permission model for all queries",
              correct: false,
              points: -15,
              feedback: "Different queries and mutations require different authorization logic.",
              nextStep: 2
            }
          ]
        },
        {
          text: "GraphQL security established! All queries now enforce field-level and object-level authorization.",
          choices: []
        }
      ]
    }
  },

  cryptoFailures271: {
    id: 271,
    title: "Insecure Data Encryption at Rest",
    difficulty: "Medium",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover sensitive data encrypted with deprecated algorithms like DES or RC4. What cryptographic risk exists?",
          choices: [
            {
              text: "Weak encryption enables practical data decryption through brute force or cryptanalysis",
              correct: true,
              points: 20,
              feedback: "Critical finding! Deprecated encryption algorithms can be broken with modern computing power.",
              nextStep: 1
            },
            {
              text: "Encrypted data might be larger",
              correct: false,
              points: 5,
              feedback: "Data size is not the security risk.",
              nextStep: 0
            },
            {
              text: "Only affects data transfer speed",
              correct: false,
              points: 5,
              feedback: "This affects data confidentiality at rest, not transfer performance.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate weak encryption vulnerability. What's the ethical approach?",
          choices: [
            {
              text: "Show decryption feasibility without actually decrypting sensitive data",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating the vulnerability without data access maintains ethical boundaries.",
              nextStep: 2
            },
            {
              text: "Actually decrypt production data to prove the point",
              correct: false,
              points: -35,
              feedback: "Unauthorized data decryption violates privacy and security policies.",
              nextStep: 2
            },
            {
              text: "Just report the algorithm names",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating feasibility shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical cryptographic failure! Weak encryption algorithms expose sensitive data to practical decryption attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing secure data encryption. What's the modern standard?",
          choices: [
            {
              text: "Use AES-256-GCM or ChaCha20-Poly1305 with proper key management",
              correct: true,
              points: 20,
              feedback: "Essential! Modern authenticated encryption provides both confidentiality and integrity.",
              nextStep: 1
            },
            {
              text: "Use AES-128 for better performance",
              correct: false,
              points: 10,
              feedback: "AES-128 is acceptable but AES-256 provides better long-term security.",
              nextStep: 1
            },
            {
              text: "Use custom encryption for specific needs",
              correct: false,
              points: -25,
              feedback: "Custom encryption is prone to vulnerabilities - use well-vetted standards.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good standard! What comprehensive encryption strategy should you implement?",
          choices: [
            {
              text: "Modern algorithms, proper key rotation, and hardware security modules",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including algorithm choice, key lifecycle management, and secure storage.",
              nextStep: 2
            },
            {
              text: "Use the same encryption key for all data",
              correct: false,
              points: -30,
              feedback: "Key separation limits breach impact and follows security best practices.",
              nextStep: 2
            },
            {
              text: "Store keys with encrypted data for convenience",
              correct: false,
              points: -25,
              feedback: "Keys must be stored separately from encrypted data.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Data encryption secured! All sensitive data now encrypted with modern algorithms and proper key management.",
          choices: []
        }
      ]
    }
  },

  injection272: {
    id: 272,
    title: "Server-Side Template Injection (SSTI)",
    difficulty: "Hard",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover a web application that renders user input in server-side templates. What template injection risk exists?",
          choices: [
            {
              text: "SSTI enables arbitrary code execution in template engine context",
              correct: true,
              points: 25,
              feedback: "Critical finding! Server-side template injection can lead to remote code execution on the server.",
              nextStep: 1
            },
            {
              text: "Templates might render slowly",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the security risk.",
              nextStep: 0
            },
            {
              text: "Only affects page layout",
              correct: false,
              points: 10,
              feedback: "This enables server compromise, not just visual issues.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully demonstrate SSTI through template expression injection. What's the ethical approach?",
          choices: [
            {
              text: "Show code execution capability without system modification or data access",
              correct: true,
              points: 30,
              feedback: "Perfect! Demonstrating SSTI potential proves the vulnerability without causing harm.",
              nextStep: 2
            },
            {
              text: "Actually execute system commands to access server data",
              correct: false,
              points: -40,
              feedback: "Unauthorized server access is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the template engine usage",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating execution shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical SSTI vulnerability! Template engine code execution enables complete server compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing template rendering. What's the primary SSTI defense?",
          choices: [
            {
              text: "Use logic-less templates or strict sandboxing with input validation",
              correct: true,
              points: 25,
              feedback: "Essential! Logic-less templates prevent code execution, while sandboxing limits damage.",
              nextStep: 1
            },
            {
              text: "Escape all user input in templates",
              correct: false,
              points: 15,
              feedback: "Escaping helps for XSS but doesn't prevent template expression injection.",
              nextStep: 1
            },
            {
              text: "Disable template caching for security",
              correct: false,
              points: 5,
              feedback: "Caching configuration doesn't address template injection vulnerabilities.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good defense! What comprehensive template security should you implement?",
          choices: [
            {
              text: "Logic-less templates, strict data binding, and template sandboxing",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers including safe templates, controlled data flow, and execution isolation.",
              nextStep: 2
            },
            {
              text: "Allow template expressions for dynamic content",
              correct: false,
              points: -25,
              feedback: "Dynamic expressions in user input create SSTI vulnerabilities.",
              nextStep: 2
            },
            {
              text: "Use eval() for complex template logic",
              correct: false,
              points: -35,
              feedback: "eval() introduces severe security risks and should be avoided.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Template security established! All rendering now uses logic-less templates with proper data binding.",
          choices: []
        }
      ]
    }
  },

  insecureDesign273: {
    id: 273,
    title: "Insecure Password Recovery Design",
    difficulty: "Easy",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover a password recovery system that reveals whether email addresses exist in the database. What design flaw enables enumeration?",
          choices: [
            {
              text: "Username enumeration allows attackers to identify valid user accounts for targeting",
              correct: true,
              points: 15,
              feedback: "Critical finding! Account enumeration enables targeted attacks and user database mapping.",
              nextStep: 1
            },
            {
              text: "Recovery emails might be delayed",
              correct: false,
              points: 5,
              feedback: "Timing issues are operational, not design flaws.",
              nextStep: 0
            },
            {
              text: "Only affects user experience",
              correct: false,
              points: 5,
              feedback: "This enables systematic user discovery and targeted attacks.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate user enumeration through password recovery. What's the ethical approach?",
          choices: [
            {
              text: "Show enumeration capability without actually recovering passwords",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating user discovery proves the design flaw without account compromise.",
              nextStep: 2
            },
            {
              text: "Actually reset passwords for discovered accounts",
              correct: false,
              points: -30,
              feedback: "Unauthorized password resets disrupt users and are unethical.",
              nextStep: 2
            },
            {
              text: "Just report the different response messages",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating enumeration shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical design flaw! Password recovery system enables user account enumeration and targeted attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're redesigning password recovery. What's the secure design principle?",
          choices: [
            {
              text: "Use identical responses and timing for all recovery attempts",
              correct: true,
              points: 15,
              feedback: "Essential! Identical responses prevent attackers from distinguishing between valid and invalid accounts.",
              nextStep: 1
            },
            {
              text: "Show different messages for user guidance",
              correct: false,
              points: -15,
              feedback: "Different messages enable account enumeration attacks.",
              nextStep: 1
            },
            {
              text: "Add CAPTCHA only for failed attempts",
              correct: false,
              points: -10,
              feedback: "Differential treatment still reveals account validity.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good principle! What comprehensive recovery security should you implement?",
          choices: [
            {
              text: "Identical responses, rate limiting, and secure token handling",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including response consistency, abuse prevention, and token security.",
              nextStep: 2
            },
            {
              text: "Allow unlimited recovery attempts for user convenience",
              correct: false,
              points: -25,
              feedback: "Unlimited attempts enable brute force enumeration.",
              nextStep: 2
            },
            {
              text: "Use email content to indicate account validity",
              correct: false,
              points: -20,
              feedback: "Any differential treatment enables enumeration.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure password recovery designed! All responses now identical with comprehensive abuse protection.",
          choices: []
        }
      ]
    }
  },

  securityMisconfig274: {
    id: 274,
    title: "Exposed AWS CloudFormation Templates",
    difficulty: "Medium",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover CloudFormation templates in public S3 buckets containing hardcoded secrets. What's the immediate risk?",
          choices: [
            {
              text: "Infrastructure secrets exposure enables cloud account compromise and resource manipulation",
              correct: true,
              points: 20,
              feedback: "Critical finding! Exposed CloudFormation templates reveal infrastructure secrets and architecture.",
              nextStep: 1
            },
            {
              text: "Templates might be out of date",
              correct: false,
              points: 5,
              feedback: "Version control is different from security exposure.",
              nextStep: 0
            },
            {
              text: "Only affects template validation",
              correct: false,
              points: 5,
              feedback: "This enables cloud account takeover and infrastructure attacks.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You access exposed CloudFormation templates with secrets. What's the ethical demonstration?",
          choices: [
            {
              text: "Show template access and secret exposure without using discovered credentials",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating secret exposure proves the risk without unauthorized cloud access.",
              nextStep: 2
            },
            {
              text: "Actually use exposed credentials to access cloud resources",
              correct: false,
              points: -35,
              feedback: "Unauthorized cloud access is illegal and violates service agreements.",
              nextStep: 2
            },
            {
              text: "Just report the public S3 bucket",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating exposure shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical cloud misconfiguration! Exposed CloudFormation templates reveal infrastructure secrets and enable account compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing infrastructure-as-code templates. What's the essential practice?",
          choices: [
            {
              text: "Use parameter stores or secrets managers instead of hardcoded values",
              correct: true,
              points: 20,
              feedback: "Essential! Infrastructure templates should reference external secrets, not contain them.",
              nextStep: 1
            },
            {
              text: "Encrypt secrets within templates",
              correct: false,
              points: 10,
              feedback: "Encryption in templates still exposes secrets if keys are accessible.",
              nextStep: 1
            },
            {
              text: "Use separate templates for different environments",
              correct: false,
              points: 5,
              feedback: "Environment separation doesn't address hardcoded secret issues.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive infrastructure security should you implement?",
          choices: [
            {
              text: "Secrets management, template scanning, and private artifact storage",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including secret protection, code analysis, and secure distribution.",
              nextStep: 2
            },
            {
              text: "Store templates in public repos for collaboration",
              correct: false,
              points: -25,
              feedback: "Public storage exposes infrastructure details and potential secrets.",
              nextStep: 2
            },
            {
              text: "Use the same secrets across all environments",
              correct: false,
              points: -20,
              feedback: "Secret separation limits breach impact across environments.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Infrastructure security established! All templates now use external secrets with secure storage.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponents275: {
    id: 275,
    title: "Vulnerable Serverless Function Dependencies",
    difficulty: "Hard",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover serverless functions with outdated npm packages containing known vulnerabilities. What's the exploitation path?",
          choices: [
            {
              text: "Function dependencies can be exploited for privilege escalation or data access",
              correct: true,
              points: 25,
              feedback: "Critical finding! Serverless function vulnerabilities can compromise cloud resources and data.",
              nextStep: 1
            },
            {
              text: "Functions might have cold start issues",
              correct: false,
              points: 5,
              feedback: "Performance characteristics are not security vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Only affects function execution time",
              correct: false,
              points: 10,
              feedback: "This enables cloud resource compromise and data breaches.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You identify exploitable vulnerabilities in serverless dependencies. How do you demonstrate the risk?",
          choices: [
            {
              text: "Show known exploits and potential impact without actual exploitation",
              correct: true,
              points: 30,
              feedback: "Perfect! Demonstrating vulnerability impact proves the risk without cloud resource compromise.",
              nextStep: 2
            },
            {
              text: "Actually exploit the vulnerabilities to access cloud services",
              correct: false,
              points: -45,
              feedback: "Unauthorized cloud service access violates security policies and laws.",
              nextStep: 2
            },
            {
              text: "Just list the vulnerable package versions",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating impact shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical serverless vulnerability! Outdated function dependencies enable cloud resource compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing serverless functions. What's the essential dependency practice?",
          choices: [
            {
              text: "Regular dependency scanning and automated updates with testing",
              correct: true,
              points: 25,
              feedback: "Essential! Serverless functions require continuous dependency management due to rapid deployment cycles.",
              nextStep: 1
            },
            {
              text: "Freeze dependencies after initial deployment",
              correct: false,
              points: -20,
              feedback: "Frozen dependencies accumulate security vulnerabilities over time.",
              nextStep: 1
            },
            {
              text: "Use latest versions without testing",
              correct: false,
              points: -15,
              feedback: "Untested updates can introduce breaking changes and new vulnerabilities.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive serverless security should you implement?",
          choices: [
            {
              text: "Dependency scanning, minimal permissions, and runtime protection",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers including component safety, least privilege, and execution security.",
              nextStep: 2
            },
            {
              text: "Allow full cloud access for function flexibility",
              correct: false,
              points: -35,
              feedback: "Excessive permissions enable widespread compromise if functions are exploited.",
              nextStep: 2
            },
            {
              text: "Disable logging for better performance",
              correct: false,
              points: -25,
              feedback: "Logging is essential for security monitoring and incident response.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Serverless security established! All functions now have secure dependencies with minimal permissions.",
          choices: []
        }
      ]
    }
  },

  authFailure276: {
    id: 276,
    title: "Insecure Multi-Factor Authentication Implementation",
    difficulty: "Medium",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover an MFA implementation that allows unlimited verification attempts. What authentication bypass risk exists?",
          choices: [
            {
              text: "Brute force attacks can bypass MFA through automated code guessing",
              correct: true,
              points: 20,
              feedback: "Critical finding! Unlimited MFA attempts enable practical brute force attacks.",
              nextStep: 1
            },
            {
              text: "MFA codes might be delivered slowly",
              correct: false,
              points: 5,
              feedback: "Delivery timing is operational, not a security vulnerability.",
              nextStep: 0
            },
            {
              text: "Only affects user convenience",
              correct: false,
              points: 10,
              feedback: "This enables MFA bypass and account compromise.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate MFA brute force vulnerability. What's the ethical approach?",
          choices: [
            {
              text: "Show brute force feasibility without actually bypassing MFA",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating the vulnerability without account access maintains ethical boundaries.",
              nextStep: 2
            },
            {
              text: "Actually brute force MFA to access test accounts",
              correct: false,
              points: -35,
              feedback: "Unauthorized account access violates security testing ethics.",
              nextStep: 2
            },
            {
              text: "Just report the missing attempt limits",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating feasibility shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical MFA vulnerability! Unlimited verification attempts enable practical brute force attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing MFA implementation. What's the essential attempt control?",
          choices: [
            {
              text: "Implement strict attempt limits with account lockout after failures",
              correct: true,
              points: 20,
              feedback: "Essential! MFA must have attempt limits to prevent brute force attacks.",
              nextStep: 1
            },
            {
              text: "Use longer codes without attempt limits",
              correct: false,
              points: -15,
              feedback: "Code length doesn't prevent brute force without attempt limits.",
              nextStep: 1
            },
            {
              text: "Slow down responses after each attempt",
              correct: false,
              points: 10,
              feedback: "Rate limiting helps but doesn't replace proper attempt limits.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good control! What comprehensive MFA security should you implement?",
          choices: [
            {
              text: "Attempt limits, secure code generation, and phishing-resistant methods",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including abuse prevention, code security, and advanced authentication.",
              nextStep: 2
            },
            {
              text: "Allow code reuse for user convenience",
              correct: false,
              points: -25,
              feedback: "Code reuse enables replay attacks and reduces security.",
              nextStep: 2
            },
            {
              text: "Use SMS exclusively for all users",
              correct: false,
              points: -20,
              feedback: "SMS-based MFA is vulnerable to SIM swapping and interception.",
              nextStep: 2
            }
          ]
        },
        {
          text: "MFA security established! All verification now has strict attempt limits with secure code handling.",
          choices: []
        }
      ]
    }
  },

  softwareIntegrity277: {
    id: 277,
    title: "Insecure CI/CD Pipeline Artifact Signing",
    difficulty: "Hard",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover CI/CD pipelines that don't sign build artifacts before deployment. What integrity risk exists?",
          choices: [
            {
              text: "Unsigned artifacts enable malicious code injection into production deployments",
              correct: true,
              points: 25,
              feedback: "Critical finding! Missing artifact signing enables supply chain attacks and unauthorized deployments.",
              nextStep: 1
            },
            {
              text: "Builds might take longer",
              correct: false,
              points: 5,
              feedback: "Build performance is not the security risk.",
              nextStep: 0
            },
            {
              text: "Only affects build reproducibility",
              correct: false,
              points: 10,
              feedback: "This enables complete compromise of deployment integrity.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate artifact manipulation in CI/CD pipeline. What's the ethical approach?",
          choices: [
            {
              text: "Show manipulation capability without deploying to production",
              correct: true,
              points: 30,
              feedback: "Perfect! Demonstrating the integrity vulnerability proves the risk without production impact.",
              nextStep: 2
            },
            {
              text: "Actually deploy modified artifacts to staging environment",
              correct: false,
              points: -40,
              feedback: "Unauthorized deployments even to staging are unethical.",
              nextStep: 2
            },
            {
              text: "Just report the missing signing process",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating manipulation shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical integrity failure! Unsigned CI/CD artifacts enable supply chain attacks and unauthorized deployments.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing CI/CD artifact security. What's the essential integrity control?",
          choices: [
            {
              text: "Implement cryptographic signing and verification for all build artifacts",
              correct: true,
              points: 25,
              feedback: "Essential! Artifact signing ensures deployment integrity and prevents unauthorized modifications.",
              nextStep: 1
            },
            {
              text: "Use checksums without cryptographic signing",
              correct: false,
              points: -20,
              feedback: "Checksums provide integrity but not authenticity - use proper signatures.",
              nextStep: 1
            },
            {
              text: "Sign only production artifacts",
              correct: false,
              points: -15,
              feedback: "All environments should use signed artifacts for consistent security.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good control! What comprehensive pipeline security should you implement?",
          choices: [
            {
              text: "Artifact signing, environment isolation, and deployment policies",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers including integrity protection, access control, and governance.",
              nextStep: 2
            },
            {
              text: "Allow manual artifact uploads for emergency fixes",
              correct: false,
              points: -35,
              feedback: "Manual uploads bypass security controls and create vulnerabilities.",
              nextStep: 2
            },
            {
              text: "Use the same signing key for all projects",
              correct: false,
              points: -25,
              feedback: "Key separation limits breach impact across projects.",
              nextStep: 2
            }
          ]
        },
        {
          text: "CI/CD integrity established! All artifacts now cryptographically signed with proper verification.",
          choices: []
        }
      ]
    }
  },

  loggingFailures278: {
    id: 278,
    title: "Missing API Gateway Security Logging",
    difficulty: "Easy",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover API Gateway endpoints without access logging enabled. What detection gap exists?",
          choices: [
            {
              text: "API attacks and abuse proceed without request visibility or audit trail",
              correct: true,
              points: 15,
              feedback: "Critical finding! Missing API Gateway logging enables undetected attacks and policy violations.",
              nextStep: 1
            },
            {
              text: "API responses might be inconsistent",
              correct: false,
              points: 5,
              feedback: "Response consistency is a reliability issue, not a logging gap.",
              nextStep: 0
            },
            {
              text: "Only affects performance monitoring",
              correct: false,
              points: 5,
              feedback: "This enables security incidents to proceed undetected.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate API attacks without gateway logging. How do you show the detection failure?",
          choices: [
            {
              text: "Show attack requests that don't appear in security monitoring",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating invisible attacks proves the monitoring gap.",
              nextStep: 2
            },
            {
              text: "Actually perform destructive API attacks",
              correct: false,
              points: -30,
              feedback: "Destructive attacks are unethical and potentially illegal.",
              nextStep: 2
            },
            {
              text: "Just report the missing logging configuration",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating the gap shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical logging failure! Missing API Gateway logging enables undetected attacks and policy violations.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing API Gateway security monitoring. What's the essential logging configuration?",
          choices: [
            {
              text: "Enable full request logging with security-focused fields and CloudWatch integration",
              correct: true,
              points: 15,
              feedback: "Essential! Comprehensive API Gateway logging provides visibility into attacks and abuse patterns.",
              nextStep: 1
            },
            {
              text: "Log only errors to reduce volume",
              correct: false,
              points: -10,
              feedback: "Limited logging misses successful attacks and normal abuse patterns.",
              nextStep: 1
            },
            {
              text: "Use default logging settings only",
              correct: false,
              points: -15,
              feedback: "Default settings often miss critical security information.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good configuration! What comprehensive API monitoring should you implement?",
          choices: [
            {
              text: "Full request logging, WAF integration, and real-time alerting",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including detailed logging, attack prevention, and proactive detection.",
              nextStep: 2
            },
            {
              text: "Disable logging during high traffic periods",
              correct: false,
              points: -25,
              feedback: "Continuous logging is essential as attacks often occur during peak traffic.",
              nextStep: 2
            },
            {
              text: "Log only successful API calls",
              correct: false,
              points: -20,
              feedback: "Failed requests often indicate attack attempts and are critical for security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "API Gateway monitoring established! All requests now logged with security-focused fields and alerting.",
          choices: []
        }
      ]
    }
  },

  ssrf279: {
    id: 279,
    title: "SSRF Through Webhook Validation Service",
    difficulty: "Medium",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "You discover a webhook validation service that tests URLs by making HTTP requests. What SSRF risk exists?",
          choices: [
            {
              text: "URL testing enables internal network scanning and metadata service access",
              correct: true,
              points: 20,
              feedback: "Critical finding! Webhook validation SSRF can probe internal services and cloud metadata.",
              nextStep: 1
            },
            {
              text: "Webhooks might be delivered unreliably",
              correct: false,
              points: 5,
              feedback: "Delivery reliability is operational, not a security vulnerability.",
              nextStep: 0
            },
            {
              text: "Only affects webhook configuration",
              correct: false,
              points: 5,
              feedback: "This enables internal network reconnaissance and service compromise.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully trigger internal requests through webhook validation. What's the ethical demonstration?",
          choices: [
            {
              text: "Show internal service interaction through timing analysis without data access",
              correct: true,
              points: 25,
              feedback: "Perfect! Blind SSRF can be demonstrated through timing differences and error patterns.",
              nextStep: 2
            },
            {
              text: "Actually access internal data through the SSRF vulnerability",
              correct: false,
              points: -35,
              feedback: "Unauthorized internal data access is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the URL testing feature",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating SSRF shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical webhook SSRF vulnerability! URL validation enables internal network reconnaissance and metadata access.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the webhook validation service. What's the primary SSRF defense?",
          choices: [
            {
              text: "Implement URL allowlisting and network egress filtering",
              correct: true,
              points: 20,
              feedback: "Essential! Allowlisting controls target resources, while egress filtering limits network access.",
              nextStep: 1
            },
            {
              text: "Add CAPTCHA to webhook configuration",
              correct: false,
              points: 5,
              feedback: "CAPTCHA prevents automation but doesn't fix SSRF vulnerabilities.",
              nextStep: 1
            },
            {
              text: "Validate URLs through DNS resolution only",
              correct: false,
              points: -15,
              feedback: "DNS validation doesn't prevent IP-based internal access.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good defense! What comprehensive webhook security should you implement?",
          choices: [
            {
              text: "URL validation, network restrictions, and request signing",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including input control, network security, and authentication.",
              nextStep: 2
            },
            {
              text: "Allow any URL for maximum integration flexibility",
              correct: false,
              points: -30,
              feedback: "Unrestricted URL access creates massive SSRF risks.",
              nextStep: 2
            },
            {
              text: "Disable webhook testing entirely",
              correct: false,
              points: 10,
              feedback: "Testing is valuable - implement it securely instead of disabling.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Webhook security established! All URL validation now uses allowlists with network restrictions.",
          choices: []
        }
      ]
    }
  },

    accessControl280: {
    id: 280,
    title: "Insecure Function Chaining in Microservices",
    difficulty: "Hard",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover microservices that call each other without verifying if the original caller has permission for the chained operation. What access control risk exists?",
          choices: [
            {
              text: "Privilege escalation through service chain where low-privilege services trigger high-privilege operations",
              correct: true,
              points: 25,
              feedback: "Critical finding! Missing chain-of-trust verification enables privilege escalation across service boundaries.",
              nextStep: 1
            },
            {
              text: "Services might have circular dependencies",
              correct: false,
              points: 5,
              feedback: "Architectural issues are different from access control vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Only affects system performance",
              correct: false,
              points: 10,
              feedback: "This enables unauthorized access to privileged functionality, not just performance issues.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate privilege escalation through service chaining. What's the ethical approach?",
          choices: [
            {
              text: "Show how low-privilege services can trigger admin operations without actual execution",
              correct: true,
              points: 30,
              feedback: "Perfect! Demonstrating the escalation path proves the vulnerability without unauthorized actions.",
              nextStep: 2
            },
            {
              text: "Actually perform admin operations through service chaining",
              correct: false,
              points: -40,
              feedback: "Unauthorized admin operations are destructive and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the service communication pattern",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating escalation shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical access control failure! Missing chain-of-trust verification enables privilege escalation across microservices.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing microservice function chaining. What's the essential security control?",
          choices: [
            {
              text: "Propagate original user context and verify permissions at each service boundary",
              correct: true,
              points: 25,
              feedback: "Essential! Each service must verify the original caller's permissions, not just trust the immediate caller.",
              nextStep: 1
            },
            {
              text: "Trust all internal service calls implicitly",
              correct: false,
              points: -25,
              feedback: "Implicit trust enables lateral movement and privilege escalation.",
              nextStep: 1
            },
            {
              text: "Use API keys for service authentication only",
              correct: false,
              points: -15,
              feedback: "Authentication doesn't replace authorization - both are needed.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good control! What comprehensive service chain security should you implement?",
          choices: [
            {
              text: "Context propagation, distributed tracing, and service mesh authorization",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers including identity propagation, visibility, and policy enforcement.",
              nextStep: 2
            },
            {
              text: "Allow all internal services full access to each other",
              correct: false,
              points: -30,
              feedback: "Full access violates principle of least privilege and enables widespread compromise.",
              nextStep: 2
            },
            {
              text: "Disable inter-service communication for security",
              correct: false,
              points: -20,
              feedback: "Not practical for microservices architecture - secure it instead.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Service chain security established! All inter-service calls now verify original caller permissions with proper context propagation.",
          choices: []
        }
      ]
    }
  },

  cryptoFailures281: {
    id: 281,
    title: "Insecure Password Hashing in Legacy Systems",
    difficulty: "Medium",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover a legacy system using unsalted MD5 for password hashing. What cryptographic weakness exists?",
          choices: [
            {
              text: "Unsalted weak hashes enable rainbow table attacks and efficient password cracking",
              correct: true,
              points: 20,
              feedback: "Critical finding! MD5 without salts is vulnerable to precomputed attacks and rapid password recovery.",
              nextStep: 1
            },
            {
              text: "Passwords might be stored in wrong format",
              correct: false,
              points: 5,
              feedback: "Format issues are different from cryptographic weaknesses.",
              nextStep: 0
            },
            {
              text: "Only affects password change operations",
              correct: false,
              points: 5,
              feedback: "This affects all stored passwords, not just new ones.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate password cracking feasibility. What's the ethical approach?",
          choices: [
            {
              text: "Show cracking speed on test hashes without accessing real user passwords",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating cracking feasibility proves the vulnerability without privacy violations.",
              nextStep: 2
            },
            {
              text: "Actually crack and access user passwords",
              correct: false,
              points: -35,
              feedback: "Unauthorized password access violates user privacy and security.",
              nextStep: 2
            },
            {
              text: "Just report the MD5 usage",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating cracking shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical cryptographic failure! Unsalted MD5 enables rapid password cracking and account compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're migrating from legacy password hashing. What's the secure migration strategy?",
          choices: [
            {
              text: "Use adaptive hashing like bcrypt/Argon2 and migrate passwords on next login",
              correct: true,
              points: 20,
              feedback: "Essential! Adaptive hashing with gradual migration balances security and user experience.",
              nextStep: 1
            },
            {
              text: "Keep MD5 but add salt to existing hashes",
              correct: false,
              points: -15,
              feedback: "MD5 is cryptographically broken - upgrade to modern algorithms.",
              nextStep: 1
            },
            {
              text: "Force all users to reset passwords immediately",
              correct: false,
              points: 10,
              feedback: "Mass password resets disrupt users and may not be necessary with proper migration.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good strategy! What comprehensive password security should you implement?",
          choices: [
            {
              text: "Adaptive hashing, proper salting, and regular security assessments",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including strong algorithms, unique salts, and ongoing evaluation.",
              nextStep: 2
            },
            {
              text: "Use the same salt for all passwords for simplicity",
              correct: false,
              points: -25,
              feedback: "Unique salts are essential to prevent rainbow table attacks.",
              nextStep: 2
            },
            {
              text: "Store passwords in encrypted format instead of hashed",
              correct: false,
              points: -20,
              feedback: "Encryption is reversible - passwords should be hashed with one-way functions.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Password security upgraded! All passwords now hashed with modern adaptive algorithms and proper salting.",
          choices: []
        }
      ]
    }
  },

  injection282: {
    id: 282,
    title: "XPath Injection in XML Processing",
    difficulty: "Hard",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover an application that builds XPath queries with user input for XML data processing. What injection risk exists?",
          choices: [
            {
              text: "XPath injection enables unauthorized XML data access and structure manipulation",
              correct: true,
              points: 25,
              feedback: "Critical finding! XPath injection can bypass authentication and extract entire XML databases.",
              nextStep: 1
            },
            {
              text: "XML files might be too large",
              correct: false,
              points: 5,
              feedback: "File size is operational, not a security vulnerability.",
              nextStep: 0
            },
            {
              text: "Only affects XML validation",
              correct: false,
              points: 10,
              feedback: "This enables data extraction and system compromise, not just validation issues.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully demonstrate XPath injection to access unauthorized data. What's the ethical approach?",
          choices: [
            {
              text: "Show data access capability without viewing or extracting sensitive information",
              correct: true,
              points: 30,
              feedback: "Perfect! Demonstrating unauthorized access potential proves the vulnerability without data compromise.",
              nextStep: 2
            },
            {
              text: "Actually extract and download the entire XML database",
              correct: false,
              points: -40,
              feedback: "Unauthorized data extraction constitutes data theft.",
              nextStep: 2
            },
            {
              text: "Just report the XPath query construction",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating access shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical XPath injection vulnerability! Unvalidated XPath queries enable complete XML data compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing XML data processing. What's the primary XPath injection defense?",
          choices: [
            {
              text: "Use parameterized XPath queries and input validation with allowlists",
              correct: true,
              points: 25,
              feedback: "Essential! Parameterized XPath prevents injection, similar to SQL parameterization.",
              nextStep: 1
            },
            {
              text: "Escape special characters in user input",
              correct: false,
              points: 15,
              feedback: "Escaping helps but is error-prone; parameterization is more reliable.",
              nextStep: 1
            },
            {
              text: "Use XSLT transformations instead of XPath",
              correct: false,
              points: 10,
              feedback: "XSLT has its own injection risks - the issue is input validation, not technology choice.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good defense! What comprehensive XML security should you implement?",
          choices: [
            {
              text: "Parameterized queries, input validation, and XML external entity protection",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers including injection prevention, data validation, and XXE protection.",
              nextStep: 2
            },
            {
              text: "Allow all XPath expressions for flexibility",
              correct: false,
              points: -25,
              feedback: "Unrestricted XPath enables injection and data exposure.",
              nextStep: 2
            },
            {
              text: "Use string concatenation for complex queries",
              correct: false,
              points: -30,
              feedback: "String concatenation is the root cause of injection vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "XML processing secured! All XPath queries now use parameterization with comprehensive input validation.",
          choices: []
        }
      ]
    }
  },

  insecureDesign283: {
    id: 283,
    title: "Insecure Data Archiving Design",
    difficulty: "Medium",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover a data archiving system that retains sensitive information indefinitely without access controls. What design flaw exists?",
          choices: [
            {
              text: "Indefinite data retention creates expanding attack surface and compliance violations",
              correct: true,
              points: 20,
              feedback: "Critical finding! Unlimited data retention violates privacy principles and creates permanent risk.",
              nextStep: 1
            },
            {
              text: "Archived data might be compressed poorly",
              correct: false,
              points: 5,
              feedback: "Compression efficiency is operational, not a design flaw.",
              nextStep: 0
            },
            {
              text: "Only affects storage costs",
              correct: false,
              points: 10,
              feedback: "This creates legal, compliance, and security risks beyond storage costs.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate access to improperly retained sensitive data. What's the ethical approach?",
          choices: [
            {
              text: "Show data access capability without viewing or using sensitive information",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating access to outdated data proves the design flaw without privacy violations.",
              nextStep: 2
            },
            {
              text: "Actually access and use archived sensitive data",
              correct: false,
              points: -35,
              feedback: "Accessing sensitive archived data violates privacy and may be illegal.",
              nextStep: 2
            },
            {
              text: "Just report the archive retention policy",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating access shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical design flaw! Indefinite data retention creates expanding attack surface and compliance violations.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're designing a secure data archiving system. What's the essential principle?",
          choices: [
            {
              text: "Implement data lifecycle management with automatic expiration and deletion",
              correct: true,
              points: 20,
              feedback: "Essential! Data should have defined retention periods and automatic disposal mechanisms.",
              nextStep: 1
            },
            {
              text: "Archive all data forever for historical analysis",
              correct: false,
              points: -20,
              feedback: "Indefinite retention creates unlimited liability and attack surface.",
              nextStep: 1
            },
            {
              text: "Let users decide when to delete their data",
              correct: false,
              points: -15,
              feedback: "Users often don't delete data - automated policies are necessary.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good principle! What comprehensive data governance should you implement?",
          choices: [
            {
              text: "Retention policies, access controls, and automated data lifecycle management",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including policy definition, security controls, and automated enforcement.",
              nextStep: 2
            },
            {
              text: "Keep all data for potential future needs",
              correct: false,
              points: -25,
              feedback: "Data hoarding violates privacy principles and creates security risks.",
              nextStep: 2
            },
            {
              text: "Use the same retention period for all data types",
              correct: false,
              points: -20,
              feedback: "Different data types have different legal and business retention requirements.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure data archiving established! All data now has defined retention periods with automatic lifecycle management.",
          choices: []
        }
      ]
    }
  },

  securityMisconfig284: {
    id: 284,
    title: "Exposed Docker Registry",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover a Docker registry exposed to the internet without authentication. What's the immediate risk?",
          choices: [
            {
              text: "Image theft, manipulation, and supply chain attacks through registry access",
              correct: true,
              points: 15,
              feedback: "Critical finding! Exposed Docker registry enables image compromise and supply chain attacks.",
              nextStep: 1
            },
            {
              text: "Images might have large file sizes",
              correct: false,
              points: 5,
              feedback: "Image size is operational, not a security risk.",
              nextStep: 0
            },
            {
              text: "Only affects image pull performance",
              correct: false,
              points: 5,
              feedback: "This enables complete compromise of container deployment pipeline.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You access the exposed Docker registry and discover sensitive images. What's the ethical demonstration?",
          choices: [
            {
              text: "Show registry access capability without downloading or modifying images",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating unauthorized access proves the vulnerability without image compromise.",
              nextStep: 2
            },
            {
              text: "Actually download and analyze proprietary container images",
              correct: false,
              points: -30,
              feedback: "Unauthorized image access constitutes intellectual property theft.",
              nextStep: 2
            },
            {
              text: "Just report the exposed registry endpoint",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating access shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical Docker misconfiguration! Exposed registry enables supply chain attacks and intellectual property theft.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the Docker registry. What's the essential security practice?",
          choices: [
            {
              text: "Implement authentication, TLS encryption, and network access controls",
              correct: true,
              points: 15,
              feedback: "Essential! Docker registry must require authentication and encryption with network isolation.",
              nextStep: 1
            },
            {
              text: "Use the same credentials for all registry users",
              correct: false,
              points: -20,
              feedback: "Shared credentials prevent accountability and increase breach impact.",
              nextStep: 1
            },
            {
              text: "Rely on complex registry URLs for security",
              correct: false,
              points: -15,
              feedback: "Security through obscurity is not a reliable defense.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive registry security should you implement?",
          choices: [
            {
              text: "Authentication, image signing, vulnerability scanning, and access logging",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including access control, integrity verification, security scanning, and monitoring.",
              nextStep: 2
            },
            {
              text: "Allow anonymous pull access for convenience",
              correct: false,
              points: -25,
              feedback: "Anonymous access enables image theft and analysis.",
              nextStep: 2
            },
            {
              text: "Disable TLS for internal network traffic",
              correct: false,
              points: -20,
              feedback: "Internal traffic should also be encrypted to prevent interception.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Docker registry secured! All access now requires authentication with comprehensive security controls.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponents285: {
    id: 285,
    title: "Vulnerable Container Runtime Dependencies",
    difficulty: "Hard",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover container runtimes using outdated versions with known vulnerabilities. What's the exploitation path?",
          choices: [
            {
              text: "Runtime vulnerabilities enable container escape and host system compromise",
              correct: true,
              points: 25,
              feedback: "Critical finding! Container runtime vulnerabilities can lead to host system compromise and cluster-wide attacks.",
              nextStep: 1
            },
            {
              text: "Containers might start slower",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the security risk.",
              nextStep: 0
            },
            {
              text: "Only affects container networking",
              correct: false,
              points: 10,
              feedback: "This enables complete host system compromise, not just networking issues.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You identify exploitable runtime vulnerabilities. How do you demonstrate the risk?",
          choices: [
            {
              text: "Show known exploits and impact without attempting container escape",
              correct: true,
              points: 30,
              feedback: "Perfect! Demonstrating vulnerability impact proves the risk without host system compromise.",
              nextStep: 2
            },
            {
              text: "Actually exploit the vulnerabilities to escape containers",
              correct: false,
              points: -45,
              feedback: "Container escape attempts can damage production systems and are unethical.",
              nextStep: 2
            },
            {
              text: "Just list the vulnerable runtime versions",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating impact shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical container runtime vulnerability! Outdated runtimes enable container escape and host system compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing container runtimes. What's the essential maintenance practice?",
          choices: [
            {
              text: "Regular runtime updates and security patch management",
              correct: true,
              points: 25,
              feedback: "Essential! Container runtimes require continuous security updates like any critical infrastructure.",
              nextStep: 1
            },
            {
              text: "Freeze runtime versions after initial deployment",
              correct: false,
              points: -25,
              feedback: "Frozen versions accumulate security vulnerabilities over time.",
              nextStep: 1
            },
            {
              text: "Use the same runtime version across all clusters",
              correct: false,
              points: 10,
              feedback: "Consistency helps but doesn't address vulnerability management.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive runtime security should you implement?",
          choices: [
            {
              text: "Runtime updates, security benchmarks, and runtime protection tools",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers including patch management, configuration hardening, and additional protection.",
              nextStep: 2
            },
            {
              text: "Disable runtime security features for performance",
              correct: false,
              points: -35,
              feedback: "Security should never be disabled for performance - optimize instead.",
              nextStep: 2
            },
            {
              text: "Use unsupported runtime versions for legacy compatibility",
              correct: false,
              points: -30,
              feedback: "Unsupported versions don't receive security updates and create massive risks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Container runtime security established! All runtimes now regularly updated with comprehensive protection.",
          choices: []
        }
      ]
    }
  },

  authFailure286: {
    id: 286,
    title: "Insecure API Key Rotation",
    difficulty: "Medium",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover API keys that never expire or rotate. What authentication risk exists?",
          choices: [
            {
              text: "Compromised keys provide permanent access without expiration or automatic revocation",
              correct: true,
              points: 20,
              feedback: "Critical finding! Non-rotating API keys create permanent backdoors if compromised.",
              nextStep: 1
            },
            {
              text: "Keys might be too long to remember",
              correct: false,
              points: 5,
              feedback: "Key length is a usability issue, not a security vulnerability.",
              nextStep: 0
            },
            {
              text: "Only affects key generation",
              correct: false,
              points: 10,
              feedback: "This affects the entire lifecycle security of API access.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate that compromised keys remain valid indefinitely. What's the ethical approach?",
          choices: [
            {
              text: "Show key validity over time without using compromised credentials",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating permanent validity proves the vulnerability without unauthorized access.",
              nextStep: 2
            },
            {
              text: "Actually use old keys to access API resources",
              correct: false,
              points: -35,
              feedback: "Unauthorized API access violates security policies.",
              nextStep: 2
            },
            {
              text: "Just report the missing expiration dates",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating permanence shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical authentication failure! Non-rotating API keys enable permanent access if compromised.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing API key management. What's the essential rotation policy?",
          choices: [
            {
              text: "Regular key rotation with overlapping validity periods for smooth transition",
              correct: true,
              points: 20,
              feedback: "Essential! Regular rotation with overlap balances security and service continuity.",
              nextStep: 1
            },
            {
              text: "Use keys without expiration for stability",
              correct: false,
              points: -25,
              feedback: "Permanent keys create unacceptable security risks.",
              nextStep: 1
            },
            {
              text: "Rotate keys only when compromised",
              correct: false,
              points: -20,
              feedback: "Proactive rotation prevents damage from undetected compromises.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good policy! What comprehensive API key security should you implement?",
          choices: [
            {
              text: "Regular rotation, usage monitoring, and automated revocation",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including lifecycle management, activity monitoring, and emergency response.",
              nextStep: 2
            },
            {
              text: "Use the same key for multiple services",
              correct: false,
              points: -30,
              feedback: "Key separation limits breach impact across services.",
              nextStep: 2
            },
            {
              text: "Store keys in source code for easy access",
              correct: false,
              points: -25,
              feedback: "Keys in source code are exposed through version control and builds.",
              nextStep: 2
            }
          ]
        },
        {
          text: "API key security established! All keys now have regular rotation with comprehensive monitoring.",
          choices: []
        }
      ]
    }
  },

  softwareIntegrity287: {
    id: 287,
    title: "Insecure Mobile App Code Obfuscation",
    difficulty: "Hard",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover a mobile app without code obfuscation or anti-tampering protections. What integrity risk exists?",
          choices: [
            {
              text: "Reverse engineering enables intellectual property theft and security bypass",
              correct: true,
              points: 25,
              feedback: "Critical finding! Unprotected mobile apps can be easily reverse engineered and modified.",
              nextStep: 1
            },
            {
              text: "App might have larger download size",
              correct: false,
              points: 5,
              feedback: "App size is operational, not an integrity vulnerability.",
              nextStep: 0
            },
            {
              text: "Only affects app startup time",
              correct: false,
              points: 10,
              feedback: "This enables complete analysis and modification of app logic and security controls.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully reverse engineer the mobile app. What's the ethical demonstration?",
          choices: [
            {
              text: "Show reverse engineering capability without extracting or using proprietary code",
              correct: true,
              points: 30,
              feedback: "Perfect! Demonstrating analysis capability proves the vulnerability without intellectual property theft.",
              nextStep: 2
            },
            {
              text: "Actually extract and use proprietary algorithms",
              correct: false,
              points: -40,
              feedback: "Intellectual property theft is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the lack of obfuscation",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating reverse engineering shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical integrity failure! Missing code protection enables reverse engineering and intellectual property theft.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing mobile app distribution. What's the essential code protection?",
          choices: [
            {
              text: "Implement code obfuscation, anti-tampering, and runtime protection",
              correct: true,
              points: 25,
              feedback: "Essential! Mobile apps require multiple layers of protection against reverse engineering.",
              nextStep: 1
            },
            {
              text: "Rely on app store security only",
              correct: false,
              points: -20,
              feedback: "App stores don't prevent determined attackers from analyzing downloaded apps.",
              nextStep: 1
            },
            {
              text: "Use simple name mangling for obfuscation",
              correct: false,
              points: -15,
              feedback: "Basic obfuscation is easily reversed - use advanced techniques.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good protection! What comprehensive mobile app security should you implement?",
          choices: [
            {
              text: "Code obfuscation, integrity checks, and certificate pinning",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers including code protection, tamper detection, and communication security.",
              nextStep: 2
            },
            {
              text: "Disable protection for debugging builds only",
              correct: false,
              points: -25,
              feedback: "Protection should be consistent across all distribution builds.",
              nextStep: 2
            },
            {
              text: "Use the same obfuscation for all app versions",
              correct: false,
              points: -20,
              feedback: "Varying protection techniques makes reverse engineering more difficult.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Mobile app protection established! All distributed apps now have comprehensive code protection and integrity checks.",
          choices: []
        }
      ]
    }
  },

  loggingFailures288: {
    id: 288,
    title: "Missing Kubernetes Audit Logging",
    difficulty: "Medium",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover Kubernetes clusters without audit logging enabled. What detection gap exists?",
          choices: [
            {
              text: "Cluster attacks and policy violations proceed without API server visibility",
              correct: true,
              points: 20,
              feedback: "Critical finding! Missing Kubernetes audit logs enable undetected cluster compromise and misuse.",
              nextStep: 1
            },
            {
              text: "Pods might have logging inconsistencies",
              correct: false,
              points: 5,
              feedback: "Pod logging is different from cluster-level audit logging.",
              nextStep: 0
            },
            {
              text: "Only affects performance monitoring",
              correct: false,
              points: 10,
              feedback: "This enables security incidents to proceed undetected at the cluster level.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate cluster operations without audit trail. How do you show the detection failure?",
          choices: [
            {
              text: "Show cluster modifications that don't appear in security monitoring",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating invisible cluster operations proves the monitoring gap.",
              nextStep: 2
            },
            {
              text: "Actually perform destructive cluster operations",
              correct: false,
              points: -35,
              feedback: "Destructive cluster operations can damage production environments.",
              nextStep: 2
            },
            {
              text: "Just report the missing audit policy",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating the gap shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical Kubernetes logging failure! Missing audit logging enables undetected cluster attacks and policy violations.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing Kubernetes security monitoring. What's the essential audit logging configuration?",
          choices: [
            {
              text: "Enable comprehensive audit policy covering security-sensitive operations",
              correct: true,
              points: 20,
              feedback: "Essential! Kubernetes audit logs must capture security-critical API operations and access patterns.",
              nextStep: 1
            },
            {
              text: "Log only authentication events to reduce volume",
              correct: false,
              points: -15,
              feedback: "Limited logging misses critical security events and attack patterns.",
              nextStep: 1
            },
            {
              text: "Use default audit settings for simplicity",
              correct: false,
              points: -10,
              feedback: "Default settings often miss important security events.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good configuration! What comprehensive Kubernetes monitoring should you implement?",
          choices: [
            {
              text: "Audit logging, security context, and runtime security monitoring",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including API visibility, configuration security, and container protection.",
              nextStep: 2
            },
            {
              text: "Disable audit logging during cluster maintenance",
              correct: false,
              points: -25,
              feedback: "Maintenance activities require audit trails for security and compliance.",
              nextStep: 2
            },
            {
              text: "Log only failed API requests",
              correct: false,
              points: -20,
              feedback: "Successful requests often indicate successful attacks and are critical for security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Kubernetes monitoring established! All cluster operations now logged with comprehensive audit policies.",
          choices: []
        }
      ]
    }
  },

  ssrf289: {
    id: 289,
    title: "SSRF Through Image Processing Service",
    difficulty: "Hard",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "You discover an image processing service that downloads images from user-provided URLs. What SSRF risk exists?",
          choices: [
            {
              text: "Image URL fetching enables internal service access and protocol scheme attacks",
              correct: true,
              points: 25,
              feedback: "Critical finding! Image processing SSRF can access internal services and use different protocols.",
              nextStep: 1
            },
            {
              text: "Images might be processed slowly",
              correct: false,
              points: 5,
              feedback: "Processing speed is operational, not a security vulnerability.",
              nextStep: 0
            },
            {
              text: "Only affects image quality",
              correct: false,
              points: 10,
              feedback: "This enables internal network reconnaissance and service compromise.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully trigger internal requests through image processing. What's the ethical demonstration?",
          choices: [
            {
              text: "Show internal service interaction through response analysis without data access",
              correct: true,
              points: 30,
              feedback: "Perfect! Blind SSRF can be demonstrated through timing and error analysis without exploitation.",
              nextStep: 2
            },
            {
              text: "Actually access internal data through the SSRF vulnerability",
              correct: false,
              points: -40,
              feedback: "Unauthorized internal data access is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the image URL parameter",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating SSRF shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical image processing SSRF! URL fetching enables internal network reconnaissance and service attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the image processing service. What's the primary SSRF defense?",
          choices: [
            {
              text: "Implement URL validation, scheme restrictions, and network egress controls",
              correct: true,
              points: 25,
              feedback: "Essential! Multiple controls including URL validation, protocol restrictions, and network segmentation.",
              nextStep: 1
            },
            {
              text: "Add CAPTCHA to image uploads",
              correct: false,
              points: 5,
              feedback: "CAPTCHA prevents automation but doesn't fix SSRF vulnerabilities.",
              nextStep: 1
            },
            {
              text: "Use DNS filtering without IP validation",
              correct: false,
              points: -20,
              feedback: "DNS-based controls don't prevent IP-based internal access.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good defense! What comprehensive image processing security should you implement?",
          choices: [
            {
              text: "URL validation, format verification, and processing sandboxing",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers including input control, content verification, and execution isolation.",
              nextStep: 2
            },
            {
              text: "Allow any image URL for maximum compatibility",
              correct: false,
              points: -35,
              feedback: "Unrestricted URL access creates massive SSRF risks.",
              nextStep: 2
            },
            {
              text: "Disable remote image fetching entirely",
              correct: false,
              points: 10,
              feedback: "Not practical for services requiring image processing from URLs.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Image processing security established! All URL fetching now validated with comprehensive security controls.",
          choices: []
        }
      ]
    }
  },

    accessControl290: {
    id: 290,
    title: "Insecure Direct Object Reference in File Paths",
    difficulty: "Easy",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover a file management system that uses user-provided paths without validation. What access control risk exists?",
          choices: [
            {
              text: "Path traversal allows accessing files outside intended directories",
              correct: true,
              points: 15,
              feedback: "Critical finding! Unvalidated file paths enable directory traversal and unauthorized file access.",
              nextStep: 1
            },
            {
              text: "Files might have incorrect permissions",
              correct: false,
              points: 5,
              feedback: "File permissions are different from path validation vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Only affects file naming conventions",
              correct: false,
              points: 5,
              feedback: "This enables access to sensitive system files, not just naming issues.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully access system files through path traversal. What's the ethical approach?",
          choices: [
            {
              text: "Show file access capability without reading or modifying sensitive content",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating unauthorized file access proves the vulnerability without data compromise.",
              nextStep: 2
            },
            {
              text: "Actually read and download system configuration files",
              correct: false,
              points: -25,
              feedback: "Accessing system files violates security policies and may be illegal.",
              nextStep: 2
            },
            {
              text: "Just report the path parameter",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating access shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical path traversal vulnerability! Unvalidated file paths enable unauthorized system file access.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing file path handling. What's the essential validation approach?",
          choices: [
            {
              text: "Use allowlists for valid paths and normalize inputs before processing",
              correct: true,
              points: 15,
              feedback: "Essential! Path allowlisting and normalization prevent directory traversal attacks.",
              nextStep: 1
            },
            {
              text: "Block only common traversal patterns like '../'",
              correct: false,
              points: -10,
              feedback: "Blacklisting is incomplete - attackers can use encoding or alternative patterns.",
              nextStep: 1
            },
            {
              text: "Use relative paths for flexibility",
              correct: false,
              points: -15,
              feedback: "Relative paths enable traversal - use absolute paths with base directory restrictions.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good approach! What comprehensive file security should you implement?",
          choices: [
            {
              text: "Path validation, file permission checks, and access logging",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including input validation, system security, and monitoring.",
              nextStep: 2
            },
            {
              text: "Allow any path for user convenience",
              correct: false,
              points: -25,
              feedback: "Unrestricted path access creates massive security risks.",
              nextStep: 2
            },
            {
              text: "Use the same base directory for all users",
              correct: false,
              points: -20,
              feedback: "User isolation is essential for multi-user systems.",
              nextStep: 2
            }
          ]
        },
        {
          text: "File path security established! All file operations now use validated paths with proper access controls.",
          choices: []
        }
      ]
    }
  },

  cryptoFailures291: {
    id: 291,
    title: "Insecure Cryptographic Storage in Mobile Apps",
    difficulty: "Hard",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover a mobile app storing sensitive data using hardcoded encryption keys. What cryptographic risk exists?",
          choices: [
            {
              text: "Hardcoded keys enable data decryption through reverse engineering",
              correct: true,
              points: 25,
              feedback: "Critical finding! Hardcoded keys in mobile apps can be easily extracted and used to decrypt stored data.",
              nextStep: 1
            },
            {
              text: "Encrypted data might be larger",
              correct: false,
              points: 5,
              feedback: "Data size is operational, not a cryptographic vulnerability.",
              nextStep: 0
            },
            {
              text: "Only affects data transfer",
              correct: false,
              points: 10,
              feedback: "This affects data confidentiality at rest on the device.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You extract and use hardcoded keys to decrypt app data. What's the ethical approach?",
          choices: [
            {
              text: "Show key extraction capability without accessing real user data",
              correct: true,
              points: 30,
              feedback: "Perfect! Demonstrating key extraction proves the vulnerability without privacy violations.",
              nextStep: 2
            },
            {
              text: "Actually decrypt and analyze user data from production apps",
              correct: false,
              points: -40,
              feedback: "Accessing user data violates privacy laws and ethical boundaries.",
              nextStep: 2
            },
            {
              text: "Just report the hardcoded key pattern",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating extraction shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical cryptographic failure! Hardcoded keys enable complete data compromise through reverse engineering.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing mobile app data storage. What's the proper key management approach?",
          choices: [
            {
              text: "Use platform keychain services and generate keys at runtime",
              correct: true,
              points: 25,
              feedback: "Essential! Platform keychains provide secure storage, and runtime key generation prevents hardcoding.",
              nextStep: 1
            },
            {
              text: "Obfuscate keys within the source code",
              correct: false,
              points: -20,
              feedback: "Obfuscation doesn't prevent determined attackers from extracting keys.",
              nextStep: 1
            },
            {
              text: "Use the same key across all app installations",
              correct: false,
              points: -25,
              feedback: "Shared keys enable mass compromise if one instance is breached.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good approach! What comprehensive mobile data security should you implement?",
          choices: [
            {
              text: "Platform keychains, biometric authentication, and data minimization",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers including secure storage, user authentication, and privacy protection.",
              nextStep: 2
            },
            {
              text: "Store keys in app preferences for easy access",
              correct: false,
              points: -30,
              feedback: "App preferences are not secure storage for cryptographic keys.",
              nextStep: 2
            },
            {
              text: "Disable encryption for better performance",
              correct: false,
              points: -35,
              feedback: "Security should never be disabled for performance gains.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Mobile data security established! All sensitive data now protected with platform keychains and proper key management.",
          choices: []
        }
      ]
    }
  },

  injection292: {
    id: 292,
    title: "LDAP Injection in Directory Services",
    difficulty: "Medium",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover an application that builds LDAP queries with user input for directory authentication. What injection risk exists?",
          choices: [
            {
              text: "LDAP injection enables unauthorized directory access and information disclosure",
              correct: true,
              points: 20,
              feedback: "Critical finding! LDAP injection can bypass authentication and extract sensitive directory information.",
              nextStep: 1
            },
            {
              text: "LDAP queries might be slow",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the security risk.",
              nextStep: 0
            },
            {
              text: "Only affects user lookup operations",
              correct: false,
              points: 10,
              feedback: "This enables complete directory compromise, not just lookup issues.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully bypass authentication using LDAP injection. What's the ethical approach?",
          choices: [
            {
              text: "Show authentication bypass without accessing protected resources",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating authentication bypass proves the vulnerability without unauthorized access.",
              nextStep: 2
            },
            {
              text: "Actually access user accounts and directory data",
              correct: false,
              points: -35,
              feedback: "Unauthorized directory access violates security policies and privacy.",
              nextStep: 2
            },
            {
              text: "Just report the LDAP query construction",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating bypass shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical LDAP injection vulnerability! Unvalidated LDAP queries enable authentication bypass and directory compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing LDAP directory access. What's the primary injection defense?",
          choices: [
            {
              text: "Use parameterized LDAP queries and input validation with escaping",
              correct: true,
              points: 20,
              feedback: "Essential! Parameterized LDAP queries prevent injection similar to SQL parameterization.",
              nextStep: 1
            },
            {
              text: "Escape only special characters in user input",
              correct: false,
              points: 10,
              feedback: "Escaping helps but parameterization is more reliable and comprehensive.",
              nextStep: 1
            },
            {
              text: "Use LDAPS protocol for encryption",
              correct: false,
              points: 5,
              feedback: "Encryption protects data in transit but doesn't prevent injection attacks.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good defense! What comprehensive directory security should you implement?",
          choices: [
            {
              text: "Parameterized queries, input validation, and least privilege access",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including injection prevention, data validation, and access control.",
              nextStep: 2
            },
            {
              text: "Allow wildcard searches for user convenience",
              correct: false,
              points: -20,
              feedback: "Wildcard searches can be abused for information disclosure.",
              nextStep: 2
            },
            {
              text: "Use the same bind DN for all applications",
              correct: false,
              points: -25,
              feedback: "Application-specific accounts provide better security isolation.",
              nextStep: 2
            }
          ]
        },
        {
          text: "LDAP security established! All directory queries now use parameterization with comprehensive validation.",
          choices: []
        }
      ]
    }
  },

  insecureDesign293: {
    id: 293,
    title: "Insecure Feature Flag Design",
    difficulty: "Medium",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover feature flags that expose unfinished or privileged functionality to all users. What design flaw exists?",
          choices: [
            {
              text: "Feature flags enable unauthorized access to incomplete or admin-only features",
              correct: true,
              points: 20,
              feedback: "Critical finding! Improperly secured feature flags can expose hidden functionality and privileged operations.",
              nextStep: 1
            },
            {
              text: "Features might have bugs",
              correct: false,
              points: 5,
              feedback: "Buggy features are quality issues, not design flaws.",
              nextStep: 0
            },
            {
              text: "Only affects user interface",
              correct: false,
              points: 10,
              feedback: "This can expose backend functionality and security controls.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You access hidden features through manipulated feature flags. What's the ethical approach?",
          choices: [
            {
              text: "Show feature access capability without using privileged functionality",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating unauthorized feature access proves the design flaw without exploitation.",
              nextStep: 2
            },
            {
              text: "Actually use admin features to modify system configuration",
              correct: false,
              points: -35,
              feedback: "Unauthorized system modifications are destructive and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the feature flag names",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating access shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical design flaw! Insecure feature flags expose hidden functionality and privileged operations.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're designing secure feature flag management. What's the essential security principle?",
          choices: [
            {
              text: "Implement role-based flag access and secure flag evaluation",
              correct: true,
              points: 20,
              feedback: "Essential! Feature flags must respect user roles and have secure evaluation mechanisms.",
              nextStep: 1
            },
            {
              text: "Use client-side flag evaluation for performance",
              correct: false,
              points: -15,
              feedback: "Client-side evaluation enables flag manipulation - evaluate server-side.",
              nextStep: 1
            },
            {
              text: "Hide flag names but keep functionality accessible",
              correct: false,
              points: -20,
              feedback: "Security through obscurity doesn't prevent determined attackers.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good principle! What comprehensive feature flag security should you implement?",
          choices: [
            {
              text: "Server-side evaluation, audit logging, and secure default states",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including secure evaluation, monitoring, and safe defaults.",
              nextStep: 2
            },
            {
              text: "Allow users to enable any feature for testing",
              correct: false,
              points: -25,
              feedback: "User-controlled features can expose security vulnerabilities.",
              nextStep: 2
            },
            {
              text: "Use the same flags across all environments",
              correct: false,
              points: -20,
              feedback: "Environment-specific flags prevent production exposure of unfinished features.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure feature management established! All flags now use server-side evaluation with proper access controls.",
          choices: []
        }
      ]
    }
  },

  securityMisconfig294: {
    id: 294,
    title: "Exposed Application Metrics Endpoints",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover Prometheus metrics endpoints exposed without authentication. What's the immediate risk?",
          choices: [
            {
              text: "Metrics exposure reveals application internals, performance data, and potential secrets",
              correct: true,
              points: 15,
              feedback: "Critical finding! Exposed metrics can leak sensitive application data and system information.",
              nextStep: 1
            },
            {
              text: "Metrics might be inaccurate",
              correct: false,
              points: 5,
              feedback: "Data accuracy is operational, not a security risk.",
              nextStep: 0
            },
            {
              text: "Only affects monitoring systems",
              correct: false,
              points: 5,
              feedback: "This enables information gathering for targeted attacks.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You access exposed metrics containing sensitive application data. What's the ethical demonstration?",
          choices: [
            {
              text: "Show metrics access capability without collecting or using sensitive data",
              correct: true,
              points: 20,
              feedback: "Perfect! Demonstrating metrics exposure proves the vulnerability without data misuse.",
              nextStep: 2
            },
            {
              text: "Actually collect and analyze all exposed metrics data",
              correct: false,
              points: -25,
              feedback: "Collecting production metrics without authorization violates security policies.",
              nextStep: 2
            },
            {
              text: "Just report the metrics endpoint",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but demonstrating access shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical metrics exposure! Unauthenticated metrics endpoints leak application internals and sensitive data.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing application metrics. What's the essential access control?",
          choices: [
            {
              text: "Implement authentication and network restrictions for metrics endpoints",
              correct: true,
              points: 15,
              feedback: "Essential! Metrics endpoints must require authentication and be network-restricted.",
              nextStep: 1
            },
            {
              text: "Expose metrics on non-standard ports only",
              correct: false,
              points: -10,
              feedback: "Security through obscurity is not a reliable defense.",
              nextStep: 1
            },
            {
              text: "Use the same credentials for all monitoring tools",
              correct: false,
              points: -15,
              feedback: "Credential separation limits breach impact.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good control! What comprehensive metrics security should you implement?",
          choices: [
            {
              text: "Authentication, network policies, and sensitive data filtering",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including access control, network security, and data protection.",
              nextStep: 2
            },
            {
              text: "Allow public metrics for external monitoring",
              correct: false,
              points: -25,
              feedback: "Public metrics expose internal application details to attackers.",
              nextStep: 2
            },
            {
              text: "Disable metrics collection for security",
              correct: false,
              points: 5,
              feedback: "Metrics are valuable for operations - secure them instead of disabling.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Metrics security established! All monitoring endpoints now require authentication with network restrictions.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponents295: {
    id: 295,
    title: "Vulnerable AI/ML Model Dependencies",
    difficulty: "Hard",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover AI services using outdated tensorflow/pytorch versions with model poisoning vulnerabilities. What's the risk?",
          choices: [
            {
              text: "Vulnerable ML frameworks enable model manipulation and adversarial attacks",
              correct: true,
              points: 25,
              feedback: "Critical finding! ML framework vulnerabilities can compromise model integrity and enable poisoning attacks.",
              nextStep: 1
            },
            {
              text: "Models might have lower accuracy",
              correct: false,
              points: 5,
              feedback: "Accuracy issues are model quality concerns, not security vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Only affects training speed",
              correct: false,
              points: 10,
              feedback: "This affects model security and inference reliability in production.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate model vulnerability through framework exploits. What's the ethical approach?",
          choices: [
            {
              text: "Show exploit potential without compromising production models or data",
              correct: true,
              points: 30,
              feedback: "Perfect! Demonstrating vulnerability impact proves the risk without AI system compromise.",
              nextStep: 2
            },
            {
              text: "Actually poison production models through vulnerabilities",
              correct: false,
              points: -45,
              feedback: "Model poisoning attacks can cause real-world harm and are unethical.",
              nextStep: 2
            },
            {
              text: "Just list the vulnerable ML packages",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating impact shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical AI dependency vulnerability! Outdated ML frameworks enable model compromise and adversarial attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing AI/ML infrastructure. What's the essential dependency practice?",
          choices: [
            {
              text: "Regular ML framework updates and model integrity verification",
              correct: true,
              points: 25,
              feedback: "Essential! ML frameworks require continuous updates and models need integrity checks.",
              nextStep: 1
            },
            {
              text: "Freeze ML dependencies after model training",
              correct: false,
              points: -25,
              feedback: "Frozen dependencies accumulate security vulnerabilities over time.",
              nextStep: 1
            },
            {
              text: "Use only CPU versions to avoid complexity",
              correct: false,
              points: 10,
              feedback: "Hardware choice doesn't address framework security vulnerabilities.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive AI security should you implement?",
          choices: [
            {
              text: "Dependency management, model signing, and adversarial robustness testing",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers including component safety, integrity protection, and security testing.",
              nextStep: 2
            },
            {
              text: "Ignore vulnerabilities in research models",
              correct: false,
              points: -30,
              feedback: "Research models often transition to production - maintain security throughout.",
              nextStep: 2
            },
            {
              text: "Use custom ML frameworks for security",
              correct: false,
              points: -35,
              feedback: "Custom frameworks lack community scrutiny and may introduce new vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "AI security established! All ML frameworks now regularly updated with model integrity verification.",
          choices: []
        }
      ]
    }
  },

  authFailure296: {
    id: 296,
    title: "Insecure Single Sign-On (SSO) Implementation",
    difficulty: "Hard",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover an SSO implementation that doesn't properly validate SAML assertions. What authentication risk exists?",
          choices: [
            {
              text: "SAML validation flaws enable identity spoofing and unauthorized access",
              correct: true,
              points: 25,
              feedback: "Critical finding! SAML validation vulnerabilities can allow attackers to impersonate any user.",
              nextStep: 1
            },
            {
              text: "SSO might be slower than local auth",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the security risk.",
              nextStep: 0
            },
            {
              text: "Only affects login process",
              correct: false,
              points: 10,
              feedback: "This enables complete account takeover across all connected applications.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate SAML assertion forgery to impersonate users. What's the ethical approach?",
          choices: [
            {
              text: "Show assertion manipulation capability without accessing user accounts",
              correct: true,
              points: 30,
              feedback: "Perfect! Demonstrating SAML forgery proves the vulnerability without unauthorized access.",
              nextStep: 2
            },
            {
              text: "Actually access applications using forged SAML assertions",
              correct: false,
              points: -40,
              feedback: "Unauthorized application access violates security policies and laws.",
              nextStep: 2
            },
            {
              text: "Just report the SAML processing",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating forgery shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical SSO vulnerability! SAML validation flaws enable identity spoofing and account takeover.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing SSO implementation. What's the essential SAML validation?",
          choices: [
            {
              text: "Validate signatures, timestamps, and issuer for all SAML assertions",
              correct: true,
              points: 25,
              feedback: "Essential! Comprehensive SAML validation includes cryptographic signatures, time validity, and trusted issuers.",
              nextStep: 1
            },
            {
              text: "Trust any SAML response from identity provider domain",
              correct: false,
              points: -30,
              feedback: "Domain-based trust is insufficient - validate each assertion cryptographically.",
              nextStep: 1
            },
            {
              text: "Use SAML for authentication without encryption",
              correct: false,
              points: -25,
              feedback: "SAML assertions must be encrypted to prevent interception and manipulation.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good validation! What comprehensive SSO security should you implement?",
          choices: [
            {
              text: "Cryptographic validation, replay protection, and certificate management",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers including signature verification, attack prevention, and key security.",
              nextStep: 2
            },
            {
              text: "Allow unsigned assertions for testing",
              correct: false,
              points: -35,
              feedback: "Unsigned assertions enable forgery attacks - require signatures in all environments.",
              nextStep: 2
            },
            {
              text: "Use the same certificates for all environments",
              correct: false,
              points: -30,
              feedback: "Certificate separation prevents test credentials from working in production.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSO security established! All SAML assertions now properly validated with comprehensive security checks.",
          choices: []
        }
      ]
    }
  },

  softwareIntegrity297: {
    id: 297,
    title: "Insecure Blockchain Smart Contract Deployment",
    difficulty: "Hard",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover smart contracts deployed without proper auditing or vulnerability testing. What integrity risk exists?",
          choices: [
            {
              text: "Unaudited smart contracts enable financial losses and blockchain manipulation",
              correct: true,
              points: 25,
              feedback: "Critical finding! Unaudited smart contracts can contain vulnerabilities leading to fund theft and system compromise.",
              nextStep: 1
            },
            {
              text: "Contracts might use more gas",
              correct: false,
              points: 5,
              feedback: "Gas efficiency is economic, not an integrity vulnerability.",
              nextStep: 0
            },
            {
              text: "Only affects transaction speed",
              correct: false,
              points: 10,
              feedback: "This enables complete financial system compromise on the blockchain.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You identify vulnerabilities in unaudited smart contracts. What's the ethical approach?",
          choices: [
            {
              text: "Show vulnerability analysis without exploiting or causing financial harm",
              correct: true,
              points: 30,
              feedback: "Perfect! Demonstrating smart contract vulnerabilities proves the risk without financial impact.",
              nextStep: 2
            },
            {
              text: "Actually exploit vulnerabilities to test contract behavior",
              correct: false,
              points: -50,
              feedback: "Exploiting live smart contracts can cause irreversible financial losses.",
              nextStep: 2
            },
            {
              text: "Just report the lack of auditing",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating vulnerabilities shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical blockchain integrity failure! Unaudited smart contracts enable financial system compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing smart contract deployment. What's the essential security practice?",
          choices: [
            {
              text: "Implement comprehensive auditing, testing, and gradual deployment",
              correct: true,
              points: 25,
              feedback: "Essential! Smart contracts require multiple security reviews and safe deployment strategies.",
              nextStep: 1
            },
            {
              text: "Deploy contracts directly to mainnet for real testing",
              correct: false,
              points: -40,
              feedback: "Mainnet deployment without testing risks irreversible financial losses.",
              nextStep: 1
            },
            {
              text: "Use the same contract code for all deployments",
              correct: false,
              points: -25,
              feedback: "Each deployment should be individually audited and tested.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive blockchain security should you implement?",
          choices: [
            {
              text: "Multiple audits, bug bounties, and upgradeable contract patterns",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers including professional review, community testing, and safe evolution.",
              nextStep: 2
            },
            {
              text: "Disable contract upgrades for immutability",
              correct: false,
              points: -20,
              feedback: "Upgrade patterns allow security fixes while maintaining core functionality.",
              nextStep: 2
            },
            {
              text: "Use experimental compiler versions for features",
              correct: false,
              points: -30,
              feedback: "Stable, well-tested compilers reduce introduction of new vulnerabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Blockchain security established! All smart contracts now undergo comprehensive auditing with safe deployment.",
          choices: []
        }
      ]
    }
  },

  loggingFailures298: {
    id: 298,
    title: "Missing Database Audit Trail for Compliance",
    difficulty: "Medium",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover database operations aren't logged for regulatory compliance requirements. What detection gap exists?",
          choices: [
            {
              text: "Compliance violations and data breaches proceed without audit trail or accountability",
              correct: true,
              points: 20,
              feedback: "Critical finding! Missing database audit trails prevent compliance monitoring and breach investigation.",
              nextStep: 1
            },
            {
              text: "Database queries might be unoptimized",
              correct: false,
              points: 5,
              feedback: "Query performance is operational, not a logging failure.",
              nextStep: 0
            },
            {
              text: "Only affects backup procedures",
              correct: false,
              points: 10,
              feedback: "This affects legal compliance and security incident response.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate data access without audit records. How do you show the compliance gap?",
          choices: [
            {
              text: "Show data operations that don't appear in compliance reports",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating missing audit trails proves the compliance and monitoring failure.",
              nextStep: 2
            },
            {
              text: "Actually violate compliance regulations to prove the point",
              correct: false,
              points: -35,
              feedback: "Intentional compliance violations can have legal consequences.",
              nextStep: 2
            },
            {
              text: "Just report the missing logging",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating the gap shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical compliance failure! Missing database audit trails prevent regulatory compliance and security monitoring.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing database compliance logging. What's the essential audit requirement?",
          choices: [
            {
              text: "Log all data modifications, access patterns, and administrative changes",
              correct: true,
              points: 20,
              feedback: "Essential! Compliance logging must capture data changes, access patterns, and administrative actions.",
              nextStep: 1
            },
            {
              text: "Log only successful transactions for clarity",
              correct: false,
              points: -15,
              feedback: "Failed operations often indicate attack attempts and are required for compliance.",
              nextStep: 1
            },
            {
              text: "Use application logs instead of database logs",
              correct: false,
              points: -20,
              feedback: "Application logs don't capture all database operations and can be bypassed.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good requirement! What comprehensive compliance monitoring should you implement?",
          choices: [
            {
              text: "Database auditing, log protection, and regular compliance reviews",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including comprehensive logging, log security, and ongoing validation.",
              nextStep: 2
            },
            {
              text: "Disable logging during system maintenance",
              correct: false,
              points: -25,
              feedback: "Maintenance activities require audit trails for compliance.",
              nextStep: 2
            },
            {
              text: "Store logs with the database for convenience",
              correct: false,
              points: -30,
              feedback: "Logs should be stored separately to prevent tampering and ensure availability.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Compliance monitoring established! All database operations now logged with comprehensive audit trails.",
          choices: []
        }
      ]
    }
  },

  ssrf299: {
    id: 299,
    title: "SSRF Through URL Preview Generation",
    difficulty: "Medium",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "You discover a social media platform that generates URL previews by fetching user-provided links. What SSRF risk exists?",
          choices: [
            {
              text: "URL preview generation enables internal network scanning and service interaction",
              correct: true,
              points: 20,
              feedback: "Critical finding! URL preview SSRF can probe internal networks and interact with cloud services.",
              nextStep: 1
            },
            {
              text: "Previews might load slowly",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the security risk.",
              nextStep: 0
            },
            {
              text: "Only affects user interface",
              correct: false,
              points: 5,
              feedback: "This enables internal network reconnaissance and potential service compromise.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully trigger internal requests through URL previews. What's the ethical demonstration?",
          choices: [
            {
              text: "Show internal service interaction through timing analysis without data access",
              correct: true,
              points: 25,
              feedback: "Perfect! Blind SSRF can be demonstrated through timing differences and error responses.",
              nextStep: 2
            },
            {
              text: "Actually access internal data through the SSRF vulnerability",
              correct: false,
              points: -35,
              feedback: "Unauthorized internal data access is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the preview generation feature",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating SSRF shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical URL preview SSRF! Link fetching enables internal network reconnaissance and service attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing URL preview generation. What's the primary SSRF defense?",
          choices: [
            {
              text: "Implement URL allowlisting, content type verification, and network egress controls",
              correct: true,
              points: 20,
              feedback: "Essential! Multiple controls including URL validation, content checking, and network restrictions.",
              nextStep: 1
            },
            {
              text: "Add CAPTCHA to URL submission",
              correct: false,
              points: 5,
              feedback: "CAPTCHA prevents automation but doesn't fix SSRF vulnerabilities.",
              nextStep: 1
            },
            {
              text: "Use DNS-based validation only",
              correct: false,
              points: -15,
              feedback: "DNS validation doesn't prevent IP-based internal access.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good defense! What comprehensive preview security should you implement?",
          choices: [
            {
              text: "URL validation, content sanitization, and request timeout limits",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including input control, output safety, and resource protection.",
              nextStep: 2
            },
            {
              text: "Allow any URL for rich previews",
              correct: false,
              points: -30,
              feedback: "Unrestricted URL access creates massive SSRF risks.",
              nextStep: 2
            },
            {
              text: "Disable previews entirely for security",
              correct: false,
              points: 10,
              feedback: "Previews are valuable user features - implement them securely instead.",
              nextStep: 2
            }
          ]
        },
        {
          text: "URL preview security established! All link fetching now validated with comprehensive security controls.",
          choices: []
        }
      ]
    }
  },

  
  accessControl300: {
    id: 300,
    title: "Insecure Business Logic Access Control",
    difficulty: "Medium",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover an e-commerce application where users can modify cart prices before checkout by manipulating API requests. What access control concept is violated?",
          choices: [
            {
              text: "Business logic bypass - modifying prices without proper server-side validation",
              correct: true,
              points: 20,
              feedback: "Critical finding! Business logic flaws allow bypassing intended workflow and price validation.",
              nextStep: 1
            },
            {
              text: "Session management issues causing price miscalculations",
              correct: false,
              points: 5,
              feedback: "Session issues are different from deliberate business logic bypass.",
              nextStep: 0
            },
            {
              text: "UI rendering problems showing wrong prices",
              correct: false,
              points: 5,
              feedback: "This is a server-side validation issue, not client-side display problem.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully demonstrate price manipulation. What's the core security concept violated here?",
          choices: [
            {
              text: "Never trust client-side controls - all business logic must be validated server-side",
              correct: true,
              points: 25,
              feedback: "Perfect! This demonstrates the fundamental principle: client-side controls can always be bypassed.",
              nextStep: 2
            },
            {
              text: "Actually complete purchases with manipulated prices",
              correct: false,
              points: -30,
              feedback: "Completing fraudulent transactions is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the API endpoint",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but understanding the core concept is crucial for prevention.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical business logic flaw! Client-side price validation enables financial fraud and revenue loss.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing secure price validation. What's the fundamental principle?",
          choices: [
            {
              text: "All business logic and validations must be enforced server-side",
              correct: true,
              points: 20,
              feedback: "Essential! Server-side validation is the cornerstone of secure business logic.",
              nextStep: 1
            },
            {
              text: "Use cryptographic signatures for client-side data",
              correct: false,
              points: 10,
              feedback: "Cryptography helps but doesn't replace server-side business logic validation.",
              nextStep: 1
            },
            {
              text: "Hide API endpoints from users",
              correct: false,
              points: -15,
              feedback: "Security through obscurity doesn't work - assume attackers know your endpoints.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good principle! What comprehensive business logic security should you implement?",
          choices: [
            {
              text: "Server-side validation, workflow integrity checks, and audit logging",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including validation, process integrity, and monitoring.",
              nextStep: 2
            },
            {
              text: "Trust client-side validations for better performance",
              correct: false,
              points: -25,
              feedback: "Performance should never compromise security - client-side can always be bypassed.",
              nextStep: 2
            },
            {
              text: "Use the same validation for all user roles",
              correct: false,
              points: -20,
              feedback: "Different user roles may require different validation logic.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Business logic security established! All validations now enforced server-side with workflow integrity checks.",
          choices: []
        }
      ]
    }
  },

  cryptoFailures301: {
    id: 301,
    title: "Insecure Data-in-Transit Protection",
    difficulty: "Easy",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover a web application transmitting sensitive data over HTTP instead of HTTPS. What fundamental cryptographic concept is violated?",
          choices: [
            {
              text: "Confidentiality - unencrypted communication exposes data to interception",
              correct: true,
              points: 15,
              feedback: "Critical finding! HTTP transmits data in plaintext, violating confidentiality principles.",
              nextStep: 1
            },
            {
              text: "Data might be corrupted during transmission",
              correct: false,
              points: 5,
              feedback: "Data corruption is a reliability issue, not primarily a cryptographic failure.",
              nextStep: 0
            },
            {
              text: "Only affects large file transfers",
              correct: false,
              points: 5,
              feedback: "This affects all sensitive data transmitted, regardless of size.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate data interception through network sniffing. What's the core security principle?",
          choices: [
            {
              text: "Always encrypt sensitive data in transit using TLS/SSL",
              correct: true,
              points: 20,
              feedback: "Perfect! This demonstrates the fundamental principle: encrypt all sensitive data in transit.",
              nextStep: 2
            },
            {
              text: "Actually intercept and steal user credentials",
              correct: false,
              points: -25,
              feedback: "Unauthorized data interception violates privacy laws and ethics.",
              nextStep: 2
            },
            {
              text: "Just report the HTTP usage",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but understanding the core concept prevents future mistakes.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical cryptographic failure! Unencrypted HTTP exposes all transmitted data to interception.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing secure data transmission. What's the fundamental requirement?",
          choices: [
            {
              text: "Use HTTPS (TLS/SSL) for all web traffic, especially sensitive data",
              correct: true,
              points: 15,
              feedback: "Essential! HTTPS provides encryption, authentication, and data integrity for web communications.",
              nextStep: 1
            },
            {
              text: "Use HTTP for non-sensitive pages only",
              correct: false,
              points: -10,
              feedback: "All pages should use HTTPS to prevent mixed content issues and session hijacking.",
              nextStep: 1
            },
            {
              text: "Implement custom encryption for sensitive data",
              correct: false,
              points: -15,
              feedback: "Custom encryption is error-prone - use well-established protocols like TLS.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good requirement! What comprehensive transport security should you implement?",
          choices: [
            {
              text: "HTTPS everywhere, HSTS headers, and certificate management",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including encryption enforcement, browser security, and certificate lifecycle.",
              nextStep: 2
            },
            {
              text: "Use self-signed certificates to save costs",
              correct: false,
              points: -25,
              feedback: "Self-signed certificates break trust and enable man-in-the-middle attacks.",
              nextStep: 2
            },
            {
              text: "Disable TLS for internal network traffic",
              correct: false,
              points: -20,
              feedback: "Internal traffic should also be encrypted to prevent insider threats.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Transport security established! All web traffic now uses HTTPS with proper certificate management.",
          choices: []
        }
      ]
    }
  },

  injection302: {
    id: 302,
    title: "SQL Injection Fundamentals",
    difficulty: "Easy",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover a login form that concatenates user input directly into SQL queries. What fundamental injection concept is demonstrated?",
          choices: [
            {
              text: "String concatenation in SQL queries enables command injection",
              correct: true,
              points: 15,
              feedback: "Critical finding! String concatenation is the root cause of SQL injection vulnerabilities.",
              nextStep: 1
            },
            {
              text: "The database might be too slow",
              correct: false,
              points: 5,
              feedback: "Performance issues are different from injection vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Only affects user authentication",
              correct: false,
              points: 5,
              feedback: "SQL injection can affect all database operations, not just authentication.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You bypass authentication using SQL injection. What's the core security principle violated?",
          choices: [
            {
              text: "Never concatenate user input into queries - use parameterized statements",
              correct: true,
              points: 20,
              feedback: "Perfect! This demonstrates the fundamental principle: separate code from data using parameterization.",
              nextStep: 2
            },
            {
              text: "Actually access and download the user database",
              correct: false,
              points: -30,
              feedback: "Unauthorized database access constitutes data theft and is illegal.",
              nextStep: 2
            },
            {
              text: "Just report the login form",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but understanding the core concept prevents all injection attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical SQL injection vulnerability! String concatenation enables complete database compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're preventing SQL injection. What's the fundamental defense approach?",
          choices: [
            {
              text: "Use parameterized queries (prepared statements) instead of string concatenation",
              correct: true,
              points: 15,
              feedback: "Essential! Parameterized queries separate SQL code from data, preventing injection.",
              nextStep: 1
            },
            {
              text: "Escape all user input before using in queries",
              correct: false,
              points: 10,
              feedback: "Escaping helps but is error-prone; parameterization is more reliable.",
              nextStep: 1
            },
            {
              text: "Use stored procedures for all database access",
              correct: false,
              points: 5,
              feedback: "Stored procedures can still be vulnerable if they use dynamic SQL.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good approach! What comprehensive SQL injection prevention should you implement?",
          choices: [
            {
              text: "Parameterized queries, input validation, and principle of least privilege",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including secure coding, input control, and database permissions.",
              nextStep: 2
            },
            {
              text: "Allow only numeric input where possible",
              correct: false,
              points: -15,
              feedback: "Input type restriction helps but doesn't address the root cause.",
              nextStep: 2
            },
            {
              text: "Use the same database user for all applications",
              correct: false,
              points: -20,
              feedback: "Application-specific database users limit breach impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SQL injection protection established! All database access now uses parameterized queries with proper validation.",
          choices: []
        }
      ]
    }
  },

  insecureDesign303: {
    id: 303,
    title: "Insecure Default Configurations",
    difficulty: "Medium",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover a new application installation with default admin credentials (admin/admin). What design principle is violated?",
          choices: [
            {
              text: "Secure by default - systems should not ship with weak default credentials",
              correct: true,
              points: 20,
              feedback: "Critical finding! Insecure defaults violate the 'secure by default' design principle.",
              nextStep: 1
            },
            {
              text: "The application might be poorly documented",
              correct: false,
              points: 5,
              feedback: "Documentation issues are different from security design flaws.",
              nextStep: 0
            },
            {
              text: "Only affects initial setup",
              correct: false,
              points: 10,
              feedback: "Insecure defaults create immediate security risks upon installation.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You access the system using default credentials. What's the core security concept?",
          choices: [
            {
              text: "Systems must be secure by default and require explicit configuration to reduce security",
              correct: true,
              points: 25,
              feedback: "Perfect! This demonstrates the 'secure by default' principle - the safest configuration should be the default.",
              nextStep: 2
            },
            {
              text: "Actually modify system configuration using default admin access",
              correct: false,
              points: -35,
              feedback: "Unauthorized system modifications are destructive and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the default credentials",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but understanding the design principle prevents similar issues.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical design flaw! Insecure defaults enable immediate system compromise upon installation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're designing secure software defaults. What's the fundamental principle?",
          choices: [
            {
              text: "Secure by default - maximum security should be the out-of-box configuration",
              correct: true,
              points: 20,
              feedback: "Essential! Secure by default means the safest configuration is the starting point.",
              nextStep: 1
            },
            {
              text: "Provide easy installation with minimal security",
              correct: false,
              points: -20,
              feedback: "Ease of use should never compromise security fundamentals.",
              nextStep: 1
            },
            {
              text: "Use the same defaults for all installations",
              correct: false,
              points: -15,
              feedback: "Some defaults (like passwords) should be unique per installation.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good principle! What comprehensive secure design should you implement?",
          choices: [
            {
              text: "Secure defaults, mandatory initial configuration, and security guidance",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including safe defaults, required setup, and user education.",
              nextStep: 2
            },
            {
              text: "Allow insecure modes for backward compatibility",
              correct: false,
              points: -25,
              feedback: "Backward compatibility should not force insecure configurations.",
              nextStep: 2
            },
            {
              text: "Document defaults but don't change them",
              correct: false,
              points: -20,
              feedback: "Documentation doesn't fix insecure defaults - change the defaults themselves.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure design established! All systems now ship with secure defaults and mandatory security configuration.",
          choices: []
        }
      ]
    }
  },

  securityMisconfig304: {
    id: 304,
    title: "Verbose Error Messages",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover an application revealing detailed database errors to users. What information disclosure concept is demonstrated?",
          choices: [
            {
              text: "Information leakage - error messages reveal system internals to attackers",
              correct: true,
              points: 15,
              feedback: "Critical finding! Verbose errors leak sensitive information about the application and infrastructure.",
              nextStep: 1
            },
            {
              text: "The application has debugging enabled",
              correct: false,
              points: 5,
              feedback: "Debugging mode is a specific case of the broader information leakage problem.",
              nextStep: 0
            },
            {
              text: "Only affects application usability",
              correct: false,
              points: 5,
              feedback: "This enables attackers to understand the system and plan targeted attacks.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You extract database structure information from error messages. What's the core security principle?",
          choices: [
            {
              text: "Never reveal system details in errors - use generic messages for users",
              correct: true,
              points: 20,
              feedback: "Perfect! This demonstrates the principle: errors should be user-friendly but not reveal system internals.",
              nextStep: 2
            },
            {
              text: "Actually use the information to perform SQL injection attacks",
              correct: false,
              points: -25,
              feedback: "Using leaked information for attacks crosses ethical boundaries.",
              nextStep: 2
            },
            {
              text: "Just report the error messages",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but understanding the principle prevents information leakage.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical information leakage! Verbose error messages reveal system architecture and database structure.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing secure error handling. What's the fundamental approach?",
          choices: [
            {
              text: "Use generic error messages for users and detailed logs for administrators",
              correct: true,
              points: 15,
              feedback: "Essential! Users get helpful but generic messages, while admins get detailed logs for debugging.",
              nextStep: 1
            },
            {
              text: "Disable all error messages for security",
              correct: false,
              points: -10,
              feedback: "Users need some error feedback - make it helpful but not revealing.",
              nextStep: 1
            },
            {
              text: "Show full errors to authenticated users only",
              correct: false,
              points: -15,
              feedback: "Even authenticated users shouldn't see system internals in errors.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good approach! What comprehensive error handling should you implement?",
          choices: [
            {
              text: "Generic user messages, detailed admin logs, and error monitoring",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including user communication, admin visibility, and system monitoring.",
              nextStep: 2
            },
            {
              text: "Use the same error detail in all environments",
              correct: false,
              points: -20,
              feedback: "Development can have more detail, production should be minimal.",
              nextStep: 2
            },
            {
              text: "Log errors to public directories for easy access",
              correct: false,
              points: -25,
              feedback: "Error logs contain sensitive information and must be protected.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure error handling established! All errors now use generic user messages with detailed admin logging.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponents305: {
    id: 305,
    title: "Unmaintained Third-Party Libraries",
    difficulty: "Medium",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover a web application using jQuery 1.4.2 with known security vulnerabilities. What dependency management concept is violated?",
          choices: [
            {
              text: "Software supply chain risk - outdated dependencies introduce known vulnerabilities",
              correct: true,
              points: 20,
              feedback: "Critical finding! Unmaintained dependencies are a major source of security vulnerabilities.",
              nextStep: 1
            },
            {
              text: "The application might have compatibility issues",
              correct: false,
              points: 5,
              feedback: "Compatibility is different from security vulnerability management.",
              nextStep: 0
            },
            {
              text: "Only affects frontend functionality",
              correct: false,
              points: 10,
              feedback: "Vulnerable dependencies can compromise the entire application.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You identify known exploits for the outdated jQuery version. What's the core security principle?",
          choices: [
            {
              text: "Regularly update dependencies and monitor for security vulnerabilities",
              correct: true,
              points: 25,
              feedback: "Perfect! This demonstrates the principle: proactive dependency management is essential for security.",
              nextStep: 2
            },
            {
              text: "Actually exploit the jQuery vulnerabilities in the application",
              correct: false,
              points: -35,
              feedback: "Exploiting known vulnerabilities in production systems is unethical.",
              nextStep: 2
            },
            {
              text: "Just report the jQuery version",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but understanding dependency management prevents future issues.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical supply chain vulnerability! Outdated dependencies with known exploits enable application compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing dependency management. What's the fundamental practice?",
          choices: [
            {
              text: "Regular vulnerability scanning and timely dependency updates",
              correct: true,
              points: 20,
              feedback: "Essential! Continuous monitoring and updating of dependencies is crucial for security.",
              nextStep: 1
            },
            {
              text: "Freeze dependencies to avoid breaking changes",
              correct: false,
              points: -20,
              feedback: "Frozen dependencies accumulate security vulnerabilities over time.",
              nextStep: 1
            },
            {
              text: "Use only the latest versions without testing",
              correct: false,
              points: -15,
              feedback: "Updates should be tested to ensure they don't break functionality.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive dependency security should you implement?",
          choices: [
            {
              text: "Automated scanning, update policies, and vulnerability management",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including detection, process, and response management.",
              nextStep: 2
            },
            {
              text: "Ignore vulnerabilities in minor dependencies",
              correct: false,
              points: -25,
              feedback: "All dependencies should be monitored, as minor ones can be attack vectors.",
              nextStep: 2
            },
            {
              text: "Use the same versions across all projects",
              correct: false,
              points: -20,
              feedback: "Each project should have appropriate, updated dependencies.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Dependency security established! All components now regularly scanned and updated with security patches.",
          choices: []
        }
      ]
    }
  },

  authFailure306: {
    id: 306,
    title: "Weak Password Policies",
    difficulty: "Easy",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover an application allowing passwords like 'password123' and '123456'. What authentication concept is violated?",
          choices: [
            {
              text: "Password strength - weak passwords are vulnerable to brute force attacks",
              correct: true,
              points: 15,
              feedback: "Critical finding! Weak password policies enable practical password guessing attacks.",
              nextStep: 1
            },
            {
              text: "The application has no password hashing",
              correct: false,
              points: 5,
              feedback: "Password storage is different from password strength requirements.",
              nextStep: 0
            },
            {
              text: "Only affects user account security",
              correct: false,
              points: 5,
              feedback: "Weak passwords can lead to complete system compromise through account takeover.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate brute force attacks against weak passwords. What's the core security principle?",
          choices: [
            {
              text: "Enforce strong password policies and implement account lockout mechanisms",
              correct: true,
              points: 20,
              feedback: "Perfect! This demonstrates the principle: strong passwords and attack prevention are both essential.",
              nextStep: 2
            },
            {
              text: "Actually crack user passwords and access accounts",
              correct: false,
              points: -30,
              feedback: "Unauthorized account access violates security policies and ethics.",
              nextStep: 2
            },
            {
              text: "Just report the weak passwords",
              correct: false,
              points: 10,
              feedback: "Good for reporting, but understanding authentication fundamentals prevents account compromise.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical authentication failure! Weak password policies enable practical brute force attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing strong authentication. What's the fundamental password policy?",
          choices: [
            {
              text: "Minimum length, complexity requirements, and common password rejection",
              correct: true,
              points: 15,
              feedback: "Essential! Strong passwords require length, complexity, and exclusion of common patterns.",
              nextStep: 1
            },
            {
              text: "Allow any password for user convenience",
              correct: false,
              points: -20,
              feedback: "User convenience should not compromise security fundamentals.",
              nextStep: 1
            },
            {
              text: "Require frequent password changes",
              correct: false,
              points: 5,
              feedback: "Frequent changes can lead to weaker passwords - focus on initial strength.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good policy! What comprehensive authentication security should you implement?",
          choices: [
            {
              text: "Strong passwords, rate limiting, and multi-factor authentication",
              correct: true,
              points: 20,
              feedback: "Perfect! Multiple layers including password strength, attack prevention, and additional factors.",
              nextStep: 2
            },
            {
              text: "Use the same password policy for all user types",
              correct: false,
              points: -15,
              feedback: "Admin accounts may require stronger policies than regular users.",
              nextStep: 2
            },
            {
              text: "Store password hints with user accounts",
              correct: false,
              points: -25,
              feedback: "Password hints can help attackers guess passwords - avoid them.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Authentication security established! All accounts now require strong passwords with attack protection.",
          choices: []
        }
      ]
    }
  },

  softwareIntegrity307: {
    id: 307,
    title: "Missing Integrity Checks",
    difficulty: "Hard",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover an application that downloads and executes scripts from external sources without verification. What integrity concept is violated?",
          choices: [
            {
              text: "Code integrity - external code should be verified before execution",
              correct: true,
              points: 25,
              feedback: "Critical finding! Executing unverified external code enables supply chain attacks.",
              nextStep: 1
            },
            {
              text: "The application might have performance issues",
              correct: false,
              points: 5,
              feedback: "Performance is different from integrity verification.",
              nextStep: 0
            },
            {
              text: "Only affects script functionality",
              correct: false,
              points: 10,
              feedback: "This enables complete system compromise through malicious code injection.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate code injection through unverified script execution. What's the core security principle?",
          choices: [
            {
              text: "Always verify integrity of external code using signatures or hashes",
              correct: true,
              points: 30,
              feedback: "Perfect! This demonstrates the principle: trust but verify all external code.",
              nextStep: 2
            },
            {
              text: "Actually inject and execute malicious code in the system",
              correct: false,
              points: -40,
              feedback: "Executing malicious code can damage systems and is unethical.",
              nextStep: 2
            },
            {
              text: "Just report the external script usage",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but understanding integrity checks prevents supply chain attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical integrity failure! Unverified code execution enables supply chain attacks and system compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing code integrity verification. What's the fundamental approach?",
          choices: [
            {
              text: "Use cryptographic signatures or hashes to verify external code",
              correct: true,
              points: 25,
              feedback: "Essential! Cryptographic verification ensures code hasn't been tampered with.",
              nextStep: 1
            },
            {
              text: "Trust code from reputable sources without verification",
              correct: false,
              points: -25,
              feedback: "Even reputable sources can be compromised - always verify.",
              nextStep: 1
            },
            {
              text: "Use checksums without cryptography",
              correct: false,
              points: -20,
              feedback: "Checksums provide integrity but not authenticity - use proper signatures.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good approach! What comprehensive integrity security should you implement?",
          choices: [
            {
              text: "Code signing, hash verification, and secure update mechanisms",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers including cryptographic verification and secure distribution.",
              nextStep: 2
            },
            {
              text: "Allow unsigned code for development flexibility",
              correct: false,
              points: -30,
              feedback: "All environments should enforce code integrity checks.",
              nextStep: 2
            },
            {
              text: "Use the same signing key for all components",
              correct: false,
              points: -25,
              feedback: "Key separation limits impact if one key is compromised.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Integrity security established! All external code now verified with cryptographic signatures.",
          choices: []
        }
      ]
    }
  },

  loggingFailures308: {
    id: 308,
    title: "Insufficient Security Logging",
    difficulty: "Medium",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover an application that only logs successful operations, not failures or security events. What logging concept is violated?",
          choices: [
            {
              text: "Security monitoring - failed attempts often indicate attack patterns",
              correct: true,
              points: 20,
              feedback: "Critical finding! Missing failure logging enables undetected attack attempts.",
              nextStep: 1
            },
            {
              text: "The application has too many log files",
              correct: false,
              points: 5,
              feedback: "Log volume management is different from security event coverage.",
              nextStep: 0
            },
            {
              text: "Only affects system debugging",
              correct: false,
              points: 10,
              feedback: "This affects security incident detection and response capability.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate attack attempts that don't generate security alerts. What's the core security principle?",
          choices: [
            {
              text: "Log security-relevant events including failures and suspicious activities",
              correct: true,
              points: 25,
              feedback: "Perfect! This demonstrates the principle: security monitoring requires comprehensive event logging.",
              nextStep: 2
            },
            {
              text: "Actually perform destructive attacks to test monitoring",
              correct: false,
              points: -35,
              feedback: "Destructive testing can damage systems and is unethical.",
              nextStep: 2
            },
            {
              text: "Just report the missing log entries",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but understanding logging principles enables proper security monitoring.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical logging failure! Insufficient security event logging enables undetected attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing security logging. What's the fundamental coverage requirement?",
          choices: [
            {
              text: "Log authentication events, access attempts, and security decisions",
              correct: true,
              points: 20,
              feedback: "Essential! Security logging must cover authentication, authorization, and security-related actions.",
              nextStep: 1
            },
            {
              text: "Log only errors to reduce volume",
              correct: false,
              points: -15,
              feedback: "Security monitoring requires both success and failure events.",
              nextStep: 1
            },
            {
              text: "Use the same log level for all events",
              correct: false,
              points: -10,
              feedback: "Different events may require different log levels for effective monitoring.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good requirement! What comprehensive security monitoring should you implement?",
          choices: [
            {
              text: "Comprehensive logging, log protection, and real-time alerting",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including event collection, log security, and proactive detection.",
              nextStep: 2
            },
            {
              text: "Store logs with application data for convenience",
              correct: false,
              points: -25,
              feedback: "Logs should be stored separately to prevent tampering.",
              nextStep: 2
            },
            {
              text: "Disable logging during high traffic",
              correct: false,
              points: -30,
              feedback: "Continuous logging is essential as attacks often occur during peak loads.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Security monitoring established! All security events now logged with comprehensive coverage and alerting.",
          choices: []
        }
      ]
    }
  },

  ssrf309: {
    id: 309,
    title: "SSRF Through Webhook Callbacks",
    difficulty: "Hard",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "You discover an API that makes callbacks to user-provided URLs for webhook notifications. What SSRF concept is demonstrated?",
          choices: [
            {
              text: "Server-side request forgery - application makes requests to attacker-controlled URLs",
              correct: true,
              points: 25,
              feedback: "Critical finding! User-controlled callback URLs enable SSRF attacks against internal networks.",
              nextStep: 1
            },
            {
              text: "The API might have rate limiting issues",
              correct: false,
              points: 5,
              feedback: "Rate limiting is different from SSRF vulnerability.",
              nextStep: 0
            },
            {
              text: "Only affects notification delivery",
              correct: false,
              points: 10,
              feedback: "This enables internal network reconnaissance and service interaction.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate internal service access through webhook callbacks. What's the core security principle?",
          choices: [
            {
              text: "Validate and restrict all outbound requests, especially user-provided URLs",
              correct: true,
              points: 30,
              feedback: "Perfect! This demonstrates the principle: control all outbound requests, especially those influenced by users.",
              nextStep: 2
            },
            {
              text: "Actually access internal services and extract data",
              correct: false,
              points: -40,
              feedback: "Unauthorized internal access violates network security policies.",
              nextStep: 2
            },
            {
              text: "Just report the callback parameter",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but understanding SSRF principles prevents network boundary breaches.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical SSRF vulnerability! User-controlled callbacks enable internal network access and reconnaissance.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're preventing SSRF attacks. What's the fundamental defense?",
          choices: [
            {
              text: "Use allowlists for permitted domains and block internal IP ranges",
              correct: true,
              points: 25,
              feedback: "Essential! Allowlisting and network segmentation are primary defenses against SSRF.",
              nextStep: 1
            },
            {
              text: "Validate URLs using DNS resolution only",
              correct: false,
              points: -20,
              feedback: "DNS doesn't prevent IP-based internal access - use IP validation.",
              nextStep: 1
            },
            {
              text: "Allow any URL but add authentication",
              correct: false,
              points: -25,
              feedback: "Authentication doesn't prevent SSRF - the request still comes from your server.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good defense! What comprehensive SSRF protection should you implement?",
          choices: [
            {
              text: "URL validation, network egress controls, and request filtering",
              correct: true,
              points: 30,
              feedback: "Perfect! Multiple layers including input validation, network security, and request inspection.",
              nextStep: 2
            },
            {
              text: "Allow localhost URLs for development",
              correct: false,
              points: -30,
              feedback: "Localhost access can be abused - restrict even in development.",
              nextStep: 2
            },
            {
              text: "Use the same validation for all environments",
              correct: false,
              points: -25,
              feedback: "Production may need stricter controls than development.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF protection established! All outbound requests now validated with network restrictions.",
          choices: []
        }
      ]
    }
  },

  
  accessControl310: {
    id: 310,
    title: "Insecure Direct Object Reference in API Endpoints",
    difficulty: "Medium",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover REST API endpoints that use sequential user IDs (e.g., /api/users/123/profile) without verifying if the authenticated user owns that resource. What access control flaw exists?",
          choices: [
            {
              text: "Horizontal privilege escalation - users can access other users' data by changing IDs",
              correct: true,
              points: 20,
              feedback: "Critical finding! Missing ownership verification allows users to access any user's data by manipulating object IDs.",
              nextStep: 1
            },
            {
              text: "The API might have rate limiting issues",
              correct: false,
              points: 5,
              feedback: "Rate limiting is different from access control vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Only affects API response formatting",
              correct: false,
              points: 10,
              feedback: "This enables unauthorized data access, not just formatting issues.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully access another user's profile data by modifying the user ID in the API call. What's the ethical demonstration approach?",
          choices: [
            {
              text: "Show unauthorized data access capability without viewing or storing sensitive information",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating access to other users' data proves the vulnerability without privacy violations.",
              nextStep: 2
            },
            {
              text: "Actually download and analyze other users' private data",
              correct: false,
              points: -35,
              feedback: "Accessing and storing user data without authorization violates privacy laws.",
              nextStep: 2
            },
            {
              text: "Just report the API endpoint pattern",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating the vulnerability shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical IDOR vulnerability! Missing ownership checks enable unauthorized access to any user's data through API manipulation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the REST API endpoints. What's the essential access control mechanism?",
          choices: [
            {
              text: "Verify resource ownership for each request using the authenticated user's context",
              correct: true,
              points: 20,
              feedback: "Essential! Every API request must verify that the authenticated user owns or has permission to access the requested resource.",
              nextStep: 1
            },
            {
              text: "Use random UUIDs instead of sequential IDs",
              correct: false,
              points: 10,
              feedback: "Obfuscation doesn't replace proper authorization checks - always verify permissions.",
              nextStep: 1
            },
            {
              text: "Rate limit API requests to prevent scanning",
              correct: false,
              points: 5,
              feedback: "Rate limiting helps with abuse but doesn't prevent unauthorized access.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good approach! What comprehensive API access control should you implement?",
          choices: [
            {
              text: "Resource ownership checks, role-based access, and proper error handling",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including ownership verification, role permissions, and secure error messages.",
              nextStep: 2
            },
            {
              text: "Allow users to access any data they can guess the ID for",
              correct: false,
              points: -25,
              feedback: "This violates the fundamental principle of access control - verify all access attempts.",
              nextStep: 2
            },
            {
              text: "Use the same permission model for all API endpoints",
              correct: false,
              points: -15,
              feedback: "Different endpoints and resources may require different authorization logic.",
              nextStep: 2
            }
          ]
        },
        {
          text: "API access control established! All endpoints now verify resource ownership with proper authorization checks.",
          choices: []
        }
      ]
    }
  },

  cryptoFailures311: {
    id: 311,
    title: "Insecure Session Management with Predictable Tokens",
    difficulty: "Medium",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover a web application using sequentially generated session tokens. What cryptographic weakness enables session prediction?",
          choices: [
            {
              text: "Predictable token generation allows attackers to guess valid session IDs",
              correct: true,
              points: 20,
              feedback: "Critical finding! Sequential or predictable session tokens enable session hijacking through token guessing.",
              nextStep: 1
            },
            {
              text: "Session tokens might be too short",
              correct: false,
              points: 10,
              feedback: "Length is a factor, but predictability is the core vulnerability.",
              nextStep: 0
            },
            {
              text: "Only affects user convenience",
              correct: false,
              points: 5,
              feedback: "This enables account takeover and unauthorized access.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully predict and hijack user sessions. What's the ethical demonstration approach?",
          choices: [
            {
              text: "Show session prediction capability without actually accessing user accounts",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating token predictability proves the vulnerability without unauthorized access.",
              nextStep: 2
            },
            {
              text: "Actually take over user sessions and access their data",
              correct: false,
              points: -40,
              feedback: "Session hijacking and unauthorized access are illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the sequential token pattern",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating prediction shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical session management failure! Predictable tokens enable session hijacking and account takeover.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing secure session management. What's the essential token generation requirement?",
          choices: [
            {
              text: "Use cryptographically secure random number generators for session tokens",
              correct: true,
              points: 20,
              feedback: "Essential! Session tokens must be unpredictable and generated using cryptographically secure methods.",
              nextStep: 1
            },
            {
              text: "Use timestamps as session tokens for uniqueness",
              correct: false,
              points: -20,
              feedback: "Timestamps are predictable and enable timing-based attacks.",
              nextStep: 1
            },
            {
              text: "Reuse session tokens for returning users",
              correct: false,
              points: -25,
              feedback: "Session tokens should be unique per session and not reused.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good requirement! What comprehensive session security should you implement?",
          choices: [
            {
              text: "Secure token generation, proper expiration, and secure cookie attributes",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including secure generation, lifecycle management, and transport protection.",
              nextStep: 2
            },
            {
              text: "Use the same session token across multiple devices",
              correct: false,
              points: -30,
              feedback: "Each device and session should have unique tokens for security isolation.",
              nextStep: 2
            },
            {
              text: "Disable session expiration for better user experience",
              correct: false,
              points: -25,
              feedback: "Session expiration is essential for security - balance with user convenience.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Session security established! All tokens now generated with cryptographic randomness and proper expiration.",
          choices: []
        }
      ]
    }
  },

  injection312: {
    id: 312,
    title: "OS Command Injection in System Administration Interface",
    difficulty: "Medium",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover a system administration dashboard that executes shell commands with user-provided parameters for server management. What injection risk exists?",
          choices: [
            {
              text: "Command injection enables arbitrary system command execution through parameter manipulation",
              correct: true,
              points: 20,
              feedback: "Critical finding! Unvalidated command execution allows attackers to run any system command.",
              nextStep: 1
            },
            {
              text: "Commands might execute with incorrect permissions",
              correct: false,
              points: 10,
              feedback: "Permission issues are different from command injection vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Only affects command output display",
              correct: false,
              points: 5,
              feedback: "This enables complete server compromise, not just output issues.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully execute system commands through the admin interface. What's the ethical demonstration approach?",
          choices: [
            {
              text: "Show command execution capability with harmless commands like 'whoami' or 'pwd'",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating command execution with safe commands proves the vulnerability without system harm.",
              nextStep: 2
            },
            {
              text: "Actually run destructive commands or access sensitive files",
              correct: false,
              points: -45,
              feedback: "Running destructive commands can damage systems and is unethical.",
              nextStep: 2
            },
            {
              text: "Just report the command execution feature",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating execution shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical command injection vulnerability! Unvalidated command execution enables complete server compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the system administration interface. What's the primary command injection defense?",
          choices: [
            {
              text: "Use parameterized command execution and strict input validation with allowlists",
              correct: true,
              points: 20,
              feedback: "Essential! Parameterization and allowlisting prevent command injection attacks.",
              nextStep: 1
            },
            {
              text: "Escape all special characters in user input",
              correct: false,
              points: 10,
              feedback: "Escaping helps but is error-prone; parameterization is more reliable.",
              nextStep: 1
            },
            {
              text: "Run commands with reduced privileges only",
              correct: false,
              points: 5,
              feedback: "Privilege reduction helps but doesn't prevent injection itself.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good defense! What comprehensive command execution security should you implement?",
          choices: [
            {
              text: "Parameterized commands, input validation, and execution sandboxing",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including safe execution patterns, input control, and environment isolation.",
              nextStep: 2
            },
            {
              text: "Allow any command for administrative flexibility",
              correct: false,
              points: -35,
              feedback: "Unrestricted command execution creates unacceptable security risks.",
              nextStep: 2
            },
            {
              text: "Use shell scripts for complex command sequences",
              correct: false,
              points: -20,
              feedback: "Shell scripts often introduce additional injection vectors.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Command execution secured! All system commands now use parameterization with strict validation.",
          choices: []
        }
      ]
    }
  },

  insecureDesign313: {
    id: 313,
    title: "Insecure Password Reset Mechanism Design",
    difficulty: "Medium",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover a password reset system that reveals whether an email address is registered through different error messages. What design flaw enables user enumeration?",
          choices: [
            {
              text: "Differential responses allow attackers to identify valid user accounts",
              correct: true,
              points: 20,
              feedback: "Critical finding! Different error messages for valid vs invalid emails enable user enumeration attacks.",
              nextStep: 1
            },
            {
              text: "Reset emails might be delayed",
              correct: false,
              points: 5,
              feedback: "Timing issues are operational, not design flaws.",
              nextStep: 0
            },
            {
              text: "Only affects email delivery reliability",
              correct: false,
              points: 10,
              feedback: "This enables targeted attacks against known user accounts.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully enumerate valid user accounts through the password reset feature. What's the ethical demonstration approach?",
          choices: [
            {
              text: "Show enumeration capability without actually resetting any passwords",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating user discovery proves the design flaw without account disruption.",
              nextStep: 2
            },
            {
              text: "Actually reset passwords for discovered accounts",
              correct: false,
              points: -40,
              feedback: "Unauthorized password resets disrupt users and are unethical.",
              nextStep: 2
            },
            {
              text: "Just report the different error messages",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating enumeration shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical design flaw! Password reset system enables user enumeration and targeted attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're redesigning the password reset system. What's the essential security principle?",
          choices: [
            {
              text: "Use identical responses and timing for all reset attempts, regardless of email validity",
              correct: true,
              points: 20,
              feedback: "Essential! Identical responses prevent attackers from distinguishing between valid and invalid accounts.",
              nextStep: 1
            },
            {
              text: "Show different messages to help users understand the process",
              correct: false,
              points: -20,
              feedback: "User guidance should not compromise security by enabling enumeration.",
              nextStep: 1
            },
            {
              text: "Add CAPTCHA only for invalid email attempts",
              correct: false,
              points: -15,
              feedback: "Differential treatment still reveals account validity through CAPTCHA triggering.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good principle! What comprehensive password reset security should you implement?",
          choices: [
            {
              text: "Identical responses, rate limiting, and secure token handling",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including response consistency, abuse prevention, and token security.",
              nextStep: 2
            },
            {
              text: "Allow unlimited reset attempts for user convenience",
              correct: false,
              points: -30,
              feedback: "Unlimited attempts enable brute force enumeration attacks.",
              nextStep: 2
            },
            {
              text: "Use email content to indicate account validity",
              correct: false,
              points: -25,
              feedback: "Any differential treatment, even in emails, enables enumeration.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure password reset designed! All responses now identical with comprehensive abuse protection.",
          choices: []
        }
      ]
    }
  },

  securityMisconfig314: {
    id: 314,
    title: "Exposed Database Administration Interface",
    difficulty: "Medium",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover a database administration interface like phpMyAdmin or Adminer exposed to the internet with default credentials. What's the immediate risk?",
          choices: [
            {
              text: "Direct database access enables data theft, manipulation, and complete system compromise",
              correct: true,
              points: 20,
              feedback: "Critical finding! Exposed database interfaces provide direct access to all stored data and database functions.",
              nextStep: 1
            },
            {
              text: "Database queries might be slow",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the security risk.",
              nextStep: 0
            },
            {
              text: "Only affects database performance monitoring",
              correct: false,
              points: 10,
              feedback: "This enables complete database compromise and data breach.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You access the exposed database interface. What's the ethical demonstration approach?",
          choices: [
            {
              text: "Show interface access capability without accessing or modifying any data",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating unauthorized access proves the vulnerability without data compromise.",
              nextStep: 2
            },
            {
              text: "Actually browse and export database tables",
              correct: false,
              points: -45,
              feedback: "Unauthorized database access constitutes data breach and is illegal.",
              nextStep: 2
            },
            {
              text: "Just report the exposed interface URL",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating access shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical security misconfiguration! Exposed database interface enables complete data compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing database administration access. What's the essential security practice?",
          choices: [
            {
              text: "Restrict database interfaces to internal networks and use strong authentication",
              correct: true,
              points: 20,
              feedback: "Essential! Database admin interfaces should never be exposed to the internet and must require strong authentication.",
              nextStep: 1
            },
            {
              text: "Use default credentials but change the port number",
              correct: false,
              points: -25,
              feedback: "Security through obscurity doesn't work - use proper authentication.",
              nextStep: 1
            },
            {
              text: "Allow internet access with IP whitelisting only",
              correct: false,
              points: -15,
              feedback: "Even with IP whitelisting, database interfaces shouldn't be internet-facing due to risk of credential compromise.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive database security should you implement?",
          choices: [
            {
              text: "Network segmentation, strong authentication, and database hardening",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including network security, access control, and system hardening.",
              nextStep: 2
            },
            {
              text: "Use the same database credentials for all applications",
              correct: false,
              points: -30,
              feedback: "Application-specific database users limit breach impact.",
              nextStep: 2
            },
            {
              text: "Disable database logging for better performance",
              correct: false,
              points: -25,
              feedback: "Database logging is essential for security monitoring and audit trails.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Database security established! All admin interfaces now restricted to internal networks with strong authentication.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponents315: {
    id: 315,
    title: "Vulnerable WordPress Plugins",
    difficulty: "Medium",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover a WordPress site using outdated plugins with known security vulnerabilities. What's the exploitation path?",
          choices: [
            {
              text: "Plugin vulnerabilities enable website compromise, data theft, and malware injection",
              correct: true,
              points: 20,
              feedback: "Critical finding! Vulnerable WordPress plugins are a common attack vector for website compromise.",
              nextStep: 1
            },
            {
              text: "Plugins might have compatibility issues",
              correct: false,
              points: 5,
              feedback: "Compatibility issues are different from security vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Only affects website performance",
              correct: false,
              points: 10,
              feedback: "This enables complete website takeover and data breach.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You identify known exploits for the outdated plugins. How do you demonstrate the risk?",
          choices: [
            {
              text: "Show known vulnerabilities and potential impact without actual exploitation",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating vulnerability impact proves the risk without website compromise.",
              nextStep: 2
            },
            {
              text: "Actually exploit the vulnerabilities to take over the website",
              correct: false,
              points: -50,
              feedback: "Website compromise is destructive and unethical.",
              nextStep: 2
            },
            {
              text: "Just list the vulnerable plugin names",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating impact shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical WordPress vulnerability! Outdated plugins with known exploits enable website compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the WordPress installation. What's the essential plugin management practice?",
          choices: [
            {
              text: "Regularly update plugins and remove unused or vulnerable components",
              correct: true,
              points: 20,
              feedback: "Essential! Continuous plugin updates and cleanup are crucial for WordPress security.",
              nextStep: 1
            },
            {
              text: "Freeze plugin versions to avoid breaking changes",
              correct: false,
              points: -25,
              feedback: "Frozen plugins accumulate security vulnerabilities over time.",
              nextStep: 1
            },
            {
              text: "Use only plugins from trusted authors",
              correct: false,
              points: 10,
              feedback: "Even trusted authors can have vulnerable plugins - still need updates.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good practice! What comprehensive WordPress security should you implement?",
          choices: [
            {
              text: "Plugin updates, security scanning, and principle of least privilege",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including component safety, vulnerability detection, and access control.",
              nextStep: 2
            },
            {
              text: "Install many plugins for maximum functionality",
              correct: false,
              points: -30,
              feedback: "Minimize plugins to reduce attack surface - only use what you need.",
              nextStep: 2
            },
            {
              text: "Use admin accounts for all WordPress operations",
              correct: false,
              points: -35,
              feedback: "Use principle of least privilege - different roles for different tasks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "WordPress security established! All plugins now regularly updated with security monitoring.",
          choices: []
        }
      ]
    }
  },

  authFailure316: {
    id: 316,
    title: "Insecure Remember Me Functionality",
    difficulty: "Medium",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover a \"Remember Me\" feature that stores user credentials in a persistent cookie without proper security. What authentication risk exists?",
          choices: [
            {
              text: "Persistent authentication tokens enable account access without re-authentication",
              correct: true,
              points: 20,
              feedback: "Critical finding! Insecure \"Remember Me\" functionality can provide long-term access to user accounts.",
              nextStep: 1
            },
            {
              text: "Cookies might be too large",
              correct: false,
              points: 5,
              feedback: "Cookie size is not the security risk.",
              nextStep: 0
            },
            {
              text: "Only affects user convenience",
              correct: false,
              points: 10,
              feedback: "This enables persistent account access if tokens are compromised.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate access to user accounts through compromised \"Remember Me\" tokens. What's the ethical approach?",
          choices: [
            {
              text: "Show token access capability without actually accessing user accounts",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating token vulnerability proves the risk without unauthorized access.",
              nextStep: 2
            },
            {
              text: "Actually access user accounts using stolen tokens",
              correct: false,
              points: -40,
              feedback: "Unauthorized account access violates security policies and ethics.",
              nextStep: 2
            },
            {
              text: "Just report the persistent cookie usage",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating the vulnerability shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical authentication failure! Insecure \"Remember Me\" tokens enable persistent account access.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing secure \"Remember Me\" functionality. What's the essential security control?",
          choices: [
            {
              text: "Use secure random tokens with expiration and require re-authentication for sensitive operations",
              correct: true,
              points: 20,
              feedback: "Essential! \"Remember Me\" tokens must be secure, time-limited, and restricted for sensitive actions.",
              nextStep: 1
            },
            {
              text: "Store user passwords in encrypted cookies",
              correct: false,
              points: -30,
              feedback: "Never store passwords in cookies, even encrypted - use tokens instead.",
              nextStep: 1
            },
            {
              text: "Use the same token indefinitely for returning users",
              correct: false,
              points: -25,
              feedback: "Tokens should expire and be rotated regularly.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good control! What comprehensive persistent authentication security should you implement?",
          choices: [
            {
              text: "Secure tokens, limited lifetime, and sensitive action re-authentication",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including token security, lifecycle management, and critical action protection.",
              nextStep: 2
            },
            {
              text: "Allow \"Remember Me\" for all user actions",
              correct: false,
              points: -35,
              feedback: "Sensitive operations like password changes should always require re-authentication.",
              nextStep: 2
            },
            {
              text: "Use simple incrementing tokens for easy management",
              correct: false,
              points: -30,
              feedback: "Tokens must be cryptographically secure and unpredictable.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Persistent authentication secured! All \"Remember Me\" tokens now use secure generation with proper restrictions.",
          choices: []
        }
      ]
    }
  },

  softwareIntegrity317: {
    id: 317,
    title: "Insecure File Upload Validation",
    difficulty: "Medium",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover a file upload feature that accepts any file type without proper validation. What integrity risk exists?",
          choices: [
            {
              text: "Malicious file upload enables server compromise through web shell execution",
              correct: true,
              points: 20,
              feedback: "Critical finding! Unrestricted file upload can allow attackers to upload and execute malicious files.",
              nextStep: 1
            },
            {
              text: "Files might be stored with wrong permissions",
              correct: false,
              points: 10,
              feedback: "Permission issues are different from file validation vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Only affects storage capacity",
              correct: false,
              points: 5,
              feedback: "This enables complete server compromise, not just storage issues.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully upload and execute a malicious file. What's the ethical demonstration approach?",
          choices: [
            {
              text: "Show file upload and execution capability with harmless test files",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating unrestricted upload proves the vulnerability without system harm.",
              nextStep: 2
            },
            {
              text: "Actually upload and execute a web shell to control the server",
              correct: false,
              points: -50,
              feedback: "Server compromise is destructive and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the file upload feature",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating the vulnerability shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical file upload vulnerability! Unrestricted file acceptance enables server compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the file upload feature. What's the essential validation approach?",
          choices: [
            {
              text: "Use file type verification, extension filtering, and content scanning",
              correct: true,
              points: 20,
              feedback: "Essential! Multiple validation layers including type checking, extension control, and content analysis.",
              nextStep: 1
            },
            {
              text: "Trust client-side file type validation only",
              correct: false,
              points: -25,
              feedback: "Client-side controls can be bypassed - always validate server-side.",
              nextStep: 1
            },
            {
              text: "Allow any file but store in isolated directories",
              correct: false,
              points: -20,
              feedback: "Isolation helps but doesn't prevent execution if files are accessible via web.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good approach! What comprehensive file upload security should you implement?",
          choices: [
            {
              text: "File validation, secure storage, and execution prevention",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including input validation, storage security, and execution control.",
              nextStep: 2
            },
            {
              text: "Allow any file type for user convenience",
              correct: false,
              points: -35,
              feedback: "Unrestricted file upload creates massive security risks.",
              nextStep: 2
            },
            {
              text: "Use the same validation for all user roles",
              correct: false,
              points: -15,
              feedback: "Different user roles may require different upload permissions.",
              nextStep: 2
            }
          ]
        },
        {
          text: "File upload security established! All uploads now validated with multiple security layers.",
          choices: []
        }
      ]
    }
  },

  loggingFailures318: {
    id: 318,
    title: "Missing Application Security Event Monitoring",
    difficulty: "Medium",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover an application that doesn't log security events like failed logins or access violations. What detection gap exists?",
          choices: [
            {
              text: "Security incidents proceed without detection or audit trail for investigation",
              correct: true,
              points: 20,
              feedback: "Critical finding! Missing security event logging prevents attack detection and incident response.",
              nextStep: 1
            },
            {
              text: "Application errors might not be recorded",
              correct: false,
              points: 10,
              feedback: "Error logging is different from security event monitoring.",
              nextStep: 0
            },
            {
              text: "Only affects performance troubleshooting",
              correct: false,
              points: 5,
              feedback: "This affects security incident detection and compliance requirements.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate security attacks that don't generate any logs. How do you show the monitoring gap?",
          choices: [
            {
              text: "Show attack patterns that proceed without security event recording",
              correct: true,
              points: 25,
              feedback: "Perfect! Demonstrating invisible attacks proves the monitoring failure.",
              nextStep: 2
            },
            {
              text: "Actually perform destructive attacks to prove no logging occurs",
              correct: false,
              points: -40,
              feedback: "Destructive attacks are unethical and potentially illegal.",
              nextStep: 2
            },
            {
              text: "Just report the missing log configuration",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating the gap shows real risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical monitoring failure! Missing security event logging enables undetected attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing application security monitoring. What events are essential to log?",
          choices: [
            {
              text: "Authentication events, access violations, and security policy changes",
              correct: true,
              points: 20,
              feedback: "Essential! Security monitoring must capture authentication, authorization, and security configuration changes.",
              nextStep: 1
            },
            {
              text: "Log only successful security events for clarity",
              correct: false,
              points: -20,
              feedback: "Failed security events often indicate attack attempts and are critical for detection.",
              nextStep: 1
            },
            {
              text: "Use application logs instead of dedicated security logs",
              correct: false,
              points: -15,
              feedback: "Security events should be in dedicated logs for easier monitoring and analysis.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good selection! What comprehensive security monitoring should you implement?",
          choices: [
            {
              text: "Security event logging, real-time alerting, and log analysis",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including event collection, proactive detection, and analysis capabilities.",
              nextStep: 2
            },
            {
              text: "Disable security logging during maintenance",
              correct: false,
              points: -30,
              feedback: "Maintenance activities require security monitoring for audit and detection.",
              nextStep: 2
            },
            {
              text: "Store logs with application data for convenience",
              correct: false,
              points: -25,
              feedback: "Security logs should be stored separately to prevent tampering.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Security monitoring established! All security events now logged with real-time alerting.",
          choices: []
        }
      ]
    }
  },

  ssrf319: {
    id: 319,
    title: "SSRF Through Document Processing Service",
    difficulty: "Medium",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "You discover a document processing service that fetches files from user-provided URLs for conversion or analysis. What SSRF risk exists?",
          choices: [
            {
              text: "URL fetching enables internal network access and cloud metadata exploitation",
              correct: true,
              points: 20,
              feedback: "Critical finding! Document processing SSRF can probe internal networks and access cloud services.",
              nextStep: 1
            },
            {
              text: "Documents might be processed incorrectly",
              correct: false,
              points: 5,
              feedback: "Processing errors are quality issues, not security vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Only affects document conversion quality",
              correct: false,
              points: 10,
              feedback: "This enables internal network reconnaissance and potential service compromise.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully trigger requests to internal services through document processing. What's the ethical demonstration?",
          choices: [
            {
              text: "Show internal service interaction through timing analysis without data access",
              correct: true,
              points: 25,
              feedback: "Perfect! Blind SSRF can be demonstrated through timing differences and error patterns.",
              nextStep: 2
            },
            {
              text: "Actually access internal data through the SSRF vulnerability",
              correct: false,
              points: -45,
              feedback: "Unauthorized internal data access is illegal and unethical.",
              nextStep: 2
            },
            {
              text: "Just report the URL fetching feature",
              correct: false,
              points: 15,
              feedback: "Good for reporting, but demonstrating SSRF shows real impact.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical document processing SSRF! URL fetching enables internal network reconnaissance and metadata access.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing the document processing service. What's the primary SSRF defense?",
          choices: [
            {
              text: "Implement URL allowlisting and network egress controls",
              correct: true,
              points: 20,
              feedback: "Essential! Allowlisting controls target resources, while egress filtering limits network access.",
              nextStep: 1
            },
            {
              text: "Add CAPTCHA to document uploads",
              correct: false,
              points: 5,
              feedback: "CAPTCHA prevents automation but doesn't fix SSRF vulnerabilities.",
              nextStep: 1
            },
            {
              text: "Use DNS-based validation without IP checks",
              correct: false,
              points: -20,
              feedback: "DNS validation doesn't prevent IP-based internal access.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good defense! What comprehensive document processing security should you implement?",
          choices: [
            {
              text: "URL validation, content verification, and processing isolation",
              correct: true,
              points: 25,
              feedback: "Perfect! Multiple layers including input control, content safety, and execution isolation.",
              nextStep: 2
            },
            {
              text: "Allow any URL for maximum compatibility",
              correct: false,
              points: -35,
              feedback: "Unrestricted URL access creates massive SSRF risks.",
              nextStep: 2
            },
            {
              text: "Disable remote file fetching entirely",
              correct: false,
              points: 10,
              feedback: "Not practical for services requiring document processing from URLs.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Document processing security established! All URL fetching now validated with network restrictions.",
          choices: []
        }
      ]
    }
  },

  
  accessControl320: {
    id: 320,
    title: "Insecure Function-Level Authorization in Microservices",
    difficulty: "Hard",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover a microservices architecture where internal service endpoints don't verify if the calling service has permission for specific operations. What access control concept is violated?",
          choices: [
            {
              text: "Service-to-service authorization - missing verification of service permissions for inter-service calls",
              correct: true,
              points: 25,
              feedback: "Critical finding! Missing service-level authorization enables privilege escalation between microservices.",
              nextStep: 1
            },
            {
              text: "The services might have network connectivity issues",
              correct: false,
              points: 5,
              feedback: "Network issues are infrastructure problems, not access control vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Only affects service discovery mechanisms",
              correct: false,
              points: 10,
              feedback: "This affects data integrity and business logic enforcement across service boundaries.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate how one microservice can call privileged endpoints of another service. What's the professional testing approach?",
          choices: [
            {
              text: "Show unauthorized service calls in a controlled environment without affecting production data",
              correct: true,
              points: 30,
              feedback: "Professional approach! Demonstrating inter-service authorization bypass in a test environment proves the vulnerability safely.",
              nextStep: 2
            },
            {
              text: "Actually modify production data through unauthorized service calls",
              correct: false,
              points: -50,
              feedback: "Modifying production data through unauthorized channels is destructive and unprofessional.",
              nextStep: 2
            },
            {
              text: "Just document the service communication patterns",
              correct: false,
              points: 15,
              feedback: "Documentation is good, but demonstrating the vulnerability shows concrete risk.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical microservice authorization flaw! Missing service-level access control enables horizontal privilege escalation across the architecture.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're designing secure microservice communication. What's the essential authorization pattern?",
          choices: [
            {
              text: "Implement service mesh with mutual TLS and service identity-based authorization",
              correct: true,
              points: 25,
              feedback: "Professional solution! Service mesh with mTLS provides strong service identity and authorization enforcement.",
              nextStep: 1
            },
            {
              text: "Trust all internal network traffic between services",
              correct: false,
              points: -30,
              feedback: "Zero-trust architecture requires verification of all service communications, even internal ones.",
              nextStep: 1
            },
            {
              text: "Use API keys without service identity verification",
              correct: false,
              points: -20,
              feedback: "API keys alone don't provide strong service identity or fine-grained authorization.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good pattern! What comprehensive microservice security should you implement?",
          choices: [
            {
              text: "Service identity, policy-based authorization, and distributed tracing for audit",
              correct: true,
              points: 30,
              feedback: "Enterprise-grade solution! Multiple layers including identity, policy enforcement, and comprehensive observability.",
              nextStep: 2
            },
            {
              text: "Allow all internal services full access to each other",
              correct: false,
              points: -40,
              feedback: "This violates the principle of least privilege and creates massive attack surface.",
              nextStep: 2
            },
            {
              text: "Use the same service account for all microservices",
              correct: false,
              points: -35,
              feedback: "Each service should have unique identity for proper authorization and accountability.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Microservice authorization established! All inter-service calls now authenticated and authorized with service mesh security.",
          choices: []
        }
      ]
    }
  },

  cryptoFailures321: {
    id: 321,
    title: "Insecure Cryptographic Key Management in Cloud",
    difficulty: "Hard",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover cloud applications storing encryption keys in environment variables or code repositories. What key management principle is violated?",
          choices: [
            {
              text: "Secure key storage - keys should be managed by dedicated key management services",
              correct: true,
              points: 25,
              feedback: "Critical finding! Storing keys in code or environment variables exposes them to unauthorized access.",
              nextStep: 1
            },
            {
              text: "The encryption algorithm might be weak",
              correct: false,
              points: 10,
              feedback: "Algorithm strength is different from key management vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Only affects key generation process",
              correct: false,
              points: 5,
              feedback: "This affects the entire cryptographic system security through key exposure.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You extract encryption keys from source code. What's the professional assessment approach?",
          choices: [
            {
              text: "Document key exposure without using the keys to access encrypted data",
              correct: true,
              points: 30,
              feedback: "Professional approach! Identifying key exposure proves the vulnerability without data compromise.",
              nextStep: 2
            },
            {
              text: "Actually decrypt production data using extracted keys",
              correct: false,
              points: -60,
              feedback: "Decrypting production data without authorization violates privacy and security policies.",
              nextStep: 2
            },
            {
              text: "Ignore the finding if the keys are in private repositories",
              correct: false,
              points: -25,
              feedback: "Private repositories can still be compromised - keys should never be in code.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical key management failure! Encryption keys exposed in code repositories enable complete data compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing enterprise key management. What's the cloud-native approach?",
          choices: [
            {
              text: "Use cloud key management services (KMS) with automatic key rotation",
              correct: true,
              points: 25,
              feedback: "Enterprise solution! Cloud KMS provides secure key storage, access control, and automated lifecycle management.",
              nextStep: 1
            },
            {
              text: "Store keys in encrypted configuration files",
              correct: false,
              points: -20,
              feedback: "This still requires another key to decrypt, creating a key management problem.",
              nextStep: 1
            },
            {
              text: "Use the same encryption key for all environments",
              correct: false,
              points: -30,
              feedback: "Different environments should use different keys to limit breach impact.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good approach! What comprehensive cryptographic governance should you implement?",
          choices: [
            {
              text: "Key management service, key rotation policies, and access auditing",
              correct: true,
              points: 30,
              feedback: "Enterprise cryptographic governance! Includes secure storage, lifecycle management, and compliance monitoring.",
              nextStep: 2
            },
            {
              text: "Allow developers to manage their own encryption keys",
              correct: false,
              points: -40,
              feedback: "Key management should be centralized and governed by security policies.",
              nextStep: 2
            },
            {
              text: "Disable key rotation to avoid application changes",
              correct: false,
              points: -35,
              feedback: "Regular key rotation is essential for long-term cryptographic security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Enterprise key management established! All cryptographic keys now managed through cloud KMS with proper governance.",
          choices: []
        }
      ]
    }
  },

  injection322: {
    id: 322,
    title: "NoSQL Injection in Modern API Architectures",
    difficulty: "Hard",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover a GraphQL API that directly passes user input to MongoDB queries without validation. What NoSQL injection technique would you test?",
          choices: [
            {
              text: "Operator injection - using MongoDB operators like $ne, $where to manipulate queries",
              correct: true,
              points: 25,
              feedback: "Advanced finding! NoSQL injection uses database operators to bypass authentication and extract data.",
              nextStep: 1
            },
            {
              text: "Traditional SQL injection payloads",
              correct: false,
              points: 10,
              feedback: "SQL injection techniques don't work on NoSQL databases - different approach needed.",
              nextStep: 0
            },
            {
              text: "Buffer overflow attacks",
              correct: false,
              points: 5,
              feedback: "Buffer overflows are memory corruption issues, not injection vulnerabilities.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully bypass authentication using NoSQL operator injection. What's the professional testing methodology?",
          choices: [
            {
              text: "Demonstrate authentication bypass in a controlled environment and document the attack vector",
              correct: true,
              points: 30,
              feedback: "Professional methodology! Controlled testing proves the vulnerability without unauthorized access to production data.",
              nextStep: 2
            },
            {
              text: "Actually access user data in production to prove the impact",
              correct: false,
              points: -55,
              feedback: "Accessing production data without authorization violates security policies and laws.",
              nextStep: 2
            },
            {
              text: "Only test during off-peak hours to minimize impact",
              correct: false,
              points: -20,
              feedback: "Testing should be done in controlled environments, not production systems.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical NoSQL injection vulnerability! Unvalidated user input in MongoDB queries enables complete database compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're securing a GraphQL API with MongoDB. What's the professional input validation approach?",
          choices: [
            {
              text: "Use type-safe query builders and input validation schemas",
              correct: true,
              points: 25,
              feedback: "Professional defense! Type-safe queries and schema validation prevent NoSQL injection at the architectural level.",
              nextStep: 1
            },
            {
              text: "Escape special characters in user input",
              correct: false,
              points: 15,
              feedback: "Character escaping is less reliable for NoSQL - type safety is more robust.",
              nextStep: 1
            },
            {
              text: "Use stored procedures for all database operations",
              correct: false,
              points: 10,
              feedback: "MongoDB doesn't use stored procedures like SQL databases.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good approach! What comprehensive API security should you implement?",
          choices: [
            {
              text: "Input validation, query depth limiting, and security testing in CI/CD",
              correct: true,
              points: 30,
              feedback: "Enterprise API security! Multiple layers including validation, abuse prevention, and security automation.",
              nextStep: 2
            },
            {
              text: "Allow unlimited query complexity for flexibility",
              correct: false,
              points: -35,
              feedback: "Query complexity limits are essential to prevent denial of service and data exposure.",
              nextStep: 2
            },
            {
              text: "Use the same validation for all GraphQL operations",
              correct: false,
              points: -25,
              feedback: "Different operations may require different validation rules based on sensitivity.",
              nextStep: 2
            }
          ]
        },
        {
          text: "GraphQL API security established! All queries now use type-safe validation with comprehensive security controls.",
          choices: []
        }
      ]
    }
  },

  insecureDesign323: {
    id: 323,
    title: "Insecure CI/CD Pipeline Design",
    difficulty: "Hard",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover a CI/CD pipeline that executes code from pull requests without proper sandboxing. What supply chain risk exists?",
          choices: [
            {
              text: "Build pipeline compromise - malicious code in PRs can compromise the entire pipeline",
              correct: true,
              points: 25,
              feedback: "Critical finding! Unsandboxed PR execution enables supply chain attacks through the build process.",
              nextStep: 1
            },
            {
              text: "The pipeline might have performance issues",
              correct: false,
              points: 5,
              feedback: "Performance is operational, not a security design flaw.",
              nextStep: 0
            },
            {
              text: "Only affects build time reliability",
              correct: false,
              points: 10,
              feedback: "This enables complete compromise of the software delivery process.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate pipeline compromise through a malicious pull request. What's the professional testing scope?",
          choices: [
            {
              text: "Test in a isolated pipeline environment and document the attack chain",
              correct: true,
              points: 30,
              feedback: "Professional scope! Isolated testing proves the vulnerability without affecting production pipelines.",
              nextStep: 2
            },
            {
              text: "Actually compromise the production pipeline to show impact",
              correct: false,
              points: -65,
              feedback: "Compromising production pipelines can disrupt software delivery and introduce vulnerabilities.",
              nextStep: 2
            },
            {
              text: "Only review the pipeline configuration without testing",
              correct: false,
              points: 15,
              feedback: "Configuration review is good, but testing proves exploitability.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical CI/CD design flaw! Unsandboxed PR execution enables supply chain attacks and pipeline compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're designing a secure CI/CD pipeline. What's the essential security principle?",
          choices: [
            {
              text: "Implement pipeline isolation and least privilege execution environments",
              correct: true,
              points: 25,
              feedback: "Enterprise principle! Pipeline isolation and least privilege prevent lateral movement and limit damage.",
              nextStep: 1
            },
            {
              text: "Allow PR authors to approve their own changes",
              correct: false,
              points: -35,
              feedback: "This creates conflict of interest and bypasses security review.",
              nextStep: 1
            },
            {
              text: "Use the same credentials for all pipeline stages",
              correct: false,
              points: -30,
              feedback: "Credential separation limits breach impact across pipeline stages.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good principle! What comprehensive pipeline security should you implement?",
          choices: [
            {
              text: "Pipeline isolation, artifact signing, and security gates",
              correct: true,
              points: 30,
              feedback: "Enterprise DevSecOps! Includes environment security, integrity verification, and quality gates.",
              nextStep: 2
            },
            {
              text: "Disable security checks for faster deployments",
              correct: false,
              points: -45,
              feedback: "Security should be integrated into the pipeline, not bypassed for speed.",
              nextStep: 2
            },
            {
              text: "Allow direct production deployments from feature branches",
              correct: false,
              points: -40,
              feedback: "Production deployments should follow strict change management processes.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure CI/CD pipeline established! All builds now use isolated environments with comprehensive security controls.",
          choices: []
        }
      ]
    }
  },

  securityMisconfig324: {
    id: 324,
    title: "Kubernetes Cluster Misconfiguration",
    difficulty: "Hard",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover a Kubernetes cluster with overly permissive RBAC policies and exposed dashboard. What container orchestration risks exist?",
          choices: [
            {
              text: "Cluster privilege escalation and container escape through misconfigured permissions",
              correct: true,
              points: 25,
              feedback: "Critical finding! Kubernetes misconfigurations can lead to cluster-wide compromise and container escape.",
              nextStep: 1
            },
            {
              text: "Containers might have resource constraints",
              correct: false,
              points: 5,
              feedback: "Resource management is operational, not a security misconfiguration.",
              nextStep: 0
            },
            {
              text: "Only affects container scheduling",
              correct: false,
              points: 10,
              feedback: "This enables complete cluster compromise and workload manipulation.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You identify multiple Kubernetes security misconfigurations. What's the professional assessment approach?",
          choices: [
            {
              text: "Use automated scanning tools and document findings with CIS benchmark comparisons",
              correct: true,
              points: 30,
              feedback: "Professional approach! Automated scanning with industry benchmarks provides comprehensive risk assessment.",
              nextStep: 2
            },
            {
              text: "Manually exploit each misconfiguration in production",
              correct: false,
              points: -60,
              feedback: "Exploiting production clusters can cause service disruption and data breach.",
              nextStep: 2
            },
            {
              text: "Only review the Kubernetes version",
              correct: false,
              points: 10,
              feedback: "Version review is insufficient - comprehensive configuration assessment is needed.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical Kubernetes misconfiguration! Overly permissive RBAC and exposed components enable cluster compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're hardening a Kubernetes cluster. What's the essential security framework?",
          choices: [
            {
              text: "Implement CIS Kubernetes benchmarks and Pod Security Standards",
              correct: true,
              points: 25,
              feedback: "Enterprise framework! CIS benchmarks and PSS provide proven security baselines for Kubernetes.",
              nextStep: 1
            },
            {
              text: "Disable all admission controllers for simplicity",
              correct: false,
              points: -35,
              feedback: "Admission controllers are essential for enforcing security policies.",
              nextStep: 1
            },
            {
              text: "Use the same service account for all pods",
              correct: false,
              points: -30,
              feedback: "Each pod should have minimal required permissions following least privilege.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good framework! What comprehensive Kubernetes security should you implement?",
          choices: [
            {
              text: "RBAC hardening, network policies, and runtime security monitoring",
              correct: true,
              points: 30,
              feedback: "Enterprise Kubernetes security! Includes access control, network segmentation, and runtime protection.",
              nextStep: 2
            },
            {
              text: "Allow privileged containers for development convenience",
              correct: false,
              points: -40,
              feedback: "Privileged containers significantly increase attack surface and should be avoided.",
              nextStep: 2
            },
            {
              text: "Disable audit logging to reduce storage costs",
              correct: false,
              points: -35,
              feedback: "Audit logging is essential for security monitoring and compliance.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Kubernetes security established! Cluster now hardened with CIS benchmarks and comprehensive security controls.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponents325: {
    id: 325,
    title: "Software Composition Analysis Failure",
    difficulty: "Hard",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover an organization without software composition analysis (SCA) in their SDLC. What supply chain risk assessment is missing?",
          choices: [
            {
              text: "Dependency vulnerability management - unknown vulnerabilities in third-party components",
              correct: true,
              points: 25,
              feedback: "Critical finding! Missing SCA leaves organizations blind to vulnerabilities in their software supply chain.",
              nextStep: 1
            },
            {
              text: "The code might have quality issues",
              correct: false,
              points: 10,
              feedback: "Code quality is different from third-party vulnerability management.",
              nextStep: 0
            },
            {
              text: "Only affects application performance",
              correct: false,
              points: 5,
              feedback: "This affects the entire application security posture through inherited vulnerabilities.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You identify multiple vulnerable dependencies in their applications. What's the professional reporting approach?",
          choices: [
            {
              text: "Provide detailed SCA reports with CVSS scores and remediation guidance",
              correct: true,
              points: 30,
              feedback: "Professional reporting! Detailed analysis with risk scoring and actionable remediation enables effective response.",
              nextStep: 2
            },
            {
              text: "Only report critical vulnerabilities to avoid overwhelming the team",
              correct: false,
              points: -20,
              feedback: "All vulnerabilities should be reported, with proper prioritization and context.",
              nextStep: 2
            },
            {
              text: "Exploit the vulnerabilities to demonstrate impact",
              correct: false,
              points: -50,
              feedback: "Exploitation without authorization is unethical and potentially harmful.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical software supply chain risk! Missing SCA leaves applications vulnerable to known third-party vulnerabilities.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing software composition analysis. What's the enterprise approach?",
          choices: [
            {
              text: "Integrate SCA into CI/CD with automated vulnerability scanning and policy enforcement",
              correct: true,
              points: 25,
              feedback: "Enterprise approach! CI/CD integration with policy enforcement provides continuous supply chain security.",
              nextStep: 1
            },
            {
              text: "Manually review dependencies during major releases only",
              correct: false,
              points: -25,
              feedback: "Manual reviews are insufficient - automated continuous scanning is essential.",
              nextStep: 1
            },
            {
              text: "Only scan production dependencies",
              correct: false,
              points: -20,
              feedback: "All dependencies, including development and test, should be scanned.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good approach! What comprehensive software supply chain security should you implement?",
          choices: [
            {
              text: "SCA integration, vulnerability management process, and SBOM generation",
              correct: true,
              points: 30,
              feedback: "Enterprise supply chain security! Includes automation, process governance, and software transparency.",
              nextStep: 2
            },
            {
              text: "Ignore vulnerabilities in development dependencies",
              correct: false,
              points: -35,
              feedback: "Development dependencies can still be exploited and should be secured.",
              nextStep: 2
            },
            {
              text: "Use the same SCA tool for all programming languages",
              correct: false,
              points: -25,
              feedback: "Different languages may require specialized SCA tools for comprehensive coverage.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Software supply chain security established! SCA now integrated into SDLC with comprehensive vulnerability management.",
          choices: []
        }
      ]
    }
  },

  authFailure326: {
    id: 326,
    title: "OAuth 2.0 Implementation Flaws",
    difficulty: "Hard",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover an OAuth 2.0 implementation missing proper state parameter validation and PKCE. What authorization flow risks exist?",
          choices: [
            {
              text: "Authorization code interception and CSRF attacks through missing security controls",
              correct: true,
              points: 25,
              feedback: "Critical finding! Missing state validation and PKCE enables authorization code interception and account takeover.",
              nextStep: 1
            },
            {
              text: "The OAuth provider might be unreliable",
              correct: false,
              points: 5,
              feedback: "Provider reliability is operational, not an implementation flaw.",
              nextStep: 0
            },
            {
              text: "Only affects login performance",
              correct: false,
              points: 10,
              feedback: "This enables complete account compromise through OAuth flow manipulation.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate OAuth flow manipulation to hijack authorization codes. What's the professional testing methodology?",
          choices: [
            {
              text: "Test in a controlled OAuth environment and document the attack vectors",
              correct: true,
              points: 30,
              feedback: "Professional methodology! Controlled testing identifies OAuth vulnerabilities without affecting real users.",
              nextStep: 2
            },
            {
              text: "Actually hijack user sessions in production",
              correct: false,
              points: -70,
              feedback: "Session hijacking in production violates user privacy and security policies.",
              nextStep: 2
            },
            {
              text: "Only review the OAuth configuration",
              correct: false,
              points: 15,
              feedback: "Configuration review is insufficient - flow testing is essential.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical OAuth implementation flaw! Missing state validation and PKCE enables authorization code interception attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing secure OAuth 2.0. What's the essential security controls?",
          choices: [
            {
              text: "State parameter validation, PKCE, and strict redirect URI validation",
              correct: true,
              points: 25,
              feedback: "Enterprise OAuth security! Multiple controls to prevent code interception and authorization hijacking.",
              nextStep: 1
            },
            {
              text: "Use implicit flow for all clients",
              correct: false,
              points: -35,
              feedback: "Implicit flow is deprecated and less secure than authorization code flow with PKCE.",
              nextStep: 1
            },
            {
              text: "Allow wildcard redirect URIs for development",
              correct: false,
              points: -30,
              feedback: "Redirect URIs must be explicitly registered and validated.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good controls! What comprehensive OAuth security should you implement?",
          choices: [
            {
              text: "PKCE, state validation, and OAuth token management best practices",
              correct: true,
              points: 30,
              feedback: "Enterprise identity security! Includes modern OAuth protections and token lifecycle management.",
              nextStep: 2
            },
            {
              text: "Store access tokens in local storage for easy access",
              correct: false,
              points: -40,
              feedback: "Access tokens should be stored securely, typically in httpOnly cookies.",
              nextStep: 2
            },
            {
              text: "Use the same client secret for all environments",
              correct: false,
              points: -35,
              feedback: "Client secrets should be unique per environment and properly secured.",
              nextStep: 2
            }
          ]
        },
        {
          text: "OAuth security established! All flows now use PKCE with comprehensive security controls.",
          choices: []
        }
      ]
    }
  },

  softwareIntegrity327: {
    id: 327,
    title: "Insecure Software Update Mechanism",
    difficulty: "Hard",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover a desktop application that downloads updates over HTTP without cryptographic verification. What software distribution risks exist?",
          choices: [
            {
              text: "Software supply chain attack - malicious updates can be injected during distribution",
              correct: true,
              points: 25,
              feedback: "Critical finding! Unverified software updates enable supply chain attacks and malware distribution.",
              nextStep: 1
            },
            {
              text: "Updates might fail to install",
              correct: false,
              points: 5,
              feedback: "Installation reliability is operational, not an integrity vulnerability.",
              nextStep: 0
            },
            {
              text: "Only affects update download speed",
              correct: false,
              points: 10,
              feedback: "This enables complete client compromise through malicious updates.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate update mechanism compromise. What's the professional assessment approach?",
          choices: [
            {
              text: "Analyze the update protocol and document integrity verification gaps",
              correct: true,
              points: 30,
              feedback: "Professional assessment! Protocol analysis identifies integrity vulnerabilities without distributing malicious updates.",
              nextStep: 2
            },
            {
              text: "Actually distribute a malicious update to test clients",
              correct: false,
              points: -75,
              feedback: "Distributing malicious software is illegal and highly unethical.",
              nextStep: 2
            },
            {
              text: "Only check if HTTPS is used",
              correct: false,
              points: 15,
              feedback: "HTTPS provides transport security but doesn't replace code signing and verification.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical software integrity failure! Unverified updates enable supply chain attacks and client compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're designing a secure software update system. What's the essential integrity control?",
          choices: [
            {
              text: "Implement code signing and cryptographic verification of all updates",
              correct: true,
              points: 25,
              feedback: "Enterprise solution! Code signing and cryptographic verification ensure update integrity and authenticity.",
              nextStep: 1
            },
            {
              text: "Use checksums without cryptographic signatures",
              correct: false,
              points: -30,
              feedback: "Checksums provide integrity but not authenticity - cryptographic signatures are essential.",
              nextStep: 1
            },
            {
              text: "Distribute updates via torrent for reliability",
              correct: false,
              points: -25,
              feedback: "Distribution method doesn't replace integrity verification mechanisms.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good control! What comprehensive update security should you implement?",
          choices: [
            {
              text: "Code signing, update transparency, and rollback protection",
              correct: true,
              points: 30,
              feedback: "Enterprise update security! Includes integrity, transparency, and safety mechanisms.",
              nextStep: 2
            },
            {
              text: "Allow unsigned updates for emergency patches",
              correct: false,
              points: -45,
              feedback: "All updates must be signed, even emergency patches.",
              nextStep: 2
            },
            {
              text: "Use the same signing key for all products",
              correct: false,
              points: -35,
              feedback: "Key separation limits impact if a signing key is compromised.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Software update security established! All updates now cryptographically signed with proper verification.",
          choices: []
        }
      ]
    }
  },

  loggingFailures328: {
    id: 328,
    title: "Missing Cloud Security Monitoring",
    difficulty: "Hard",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover a cloud environment without security monitoring for privileged operations and API activities. What detection capability gap exists?",
          choices: [
            {
              text: "Cloud security monitoring - missing detection of malicious activities and policy violations",
              correct: true,
              points: 25,
              feedback: "Critical finding! Missing cloud security monitoring enables undetected attacks and policy violations.",
              nextStep: 1
            },
            {
              text: "The cloud bills might be inaccurate",
              correct: false,
              points: 5,
              feedback: "Billing accuracy is financial, not a security monitoring gap.",
              nextStep: 0
            },
            {
              text: "Only affects performance monitoring",
              correct: false,
              points: 10,
              feedback: "This affects security incident detection and response capability in the cloud.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You identify multiple undetectable attack scenarios in the cloud environment. What's the professional risk assessment approach?",
          choices: [
            {
              text: "Map attack scenarios to missing detection capabilities and provide coverage recommendations",
              correct: true,
              points: 30,
              feedback: "Professional risk assessment! Attack mapping identifies detection gaps and enables targeted monitoring improvements.",
              nextStep: 2
            },
            {
              text: "Actually perform attacks to prove they're undetected",
              correct: false,
              points: -65,
              feedback: "Performing actual attacks in production environments is unethical and potentially harmful.",
              nextStep: 2
            },
            {
              text: "Only check if basic logging is enabled",
              correct: false,
              points: 15,
              feedback: "Basic logging is insufficient - security monitoring requires dedicated detection capabilities.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical cloud security monitoring failure! Missing detection capabilities enable undetected attacks and policy violations.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're implementing cloud security monitoring. What's the enterprise framework?",
          choices: [
            {
              text: "Implement Cloud Security Posture Management (CSPM) and Cloud Workload Protection Platform (CWPP)",
              correct: true,
              points: 25,
              feedback: "Enterprise cloud security framework! CSPM and CWPP provide comprehensive cloud security monitoring and protection.",
              nextStep: 1
            },
            {
              text: "Rely on cloud provider basic monitoring only",
              correct: false,
              points: -30,
              feedback: "Cloud provider basic monitoring is insufficient for security detection and response.",
              nextStep: 1
            },
            {
              text: "Use the same monitoring for all cloud accounts",
              correct: false,
              points: -25,
              feedback: "Different accounts and environments may require different monitoring rules.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good framework! What comprehensive cloud security operations should you implement?",
          choices: [
            {
              text: "CSPM, cloud SIEM, and automated response playbooks",
              correct: true,
              points: 30,
              feedback: "Enterprise cloud SecOps! Includes posture management, security analytics, and automated response.",
              nextStep: 2
            },
            {
              text: "Disable cloud trail to reduce costs",
              correct: false,
              points: -45,
              feedback: "Cloud trail is essential for security auditing and should not be disabled.",
              nextStep: 2
            },
            {
              text: "Monitor only production environments",
              correct: false,
              points: -35,
              feedback: "All environments should have appropriate security monitoring.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cloud security monitoring established! Comprehensive monitoring now implemented with automated detection and response.",
          choices: []
        }
      ]
    }
  },

  ssrf329: {
    id: 329,
    title: "SSRF in Cloud Metadata Services",
    difficulty: "Hard",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "You discover a web application that can be exploited to access cloud metadata services (like AWS IMDS). What cloud-specific SSRF risk exists?",
          choices: [
            {
              text: "Cloud metadata access - retrieving temporary credentials and instance metadata",
              correct: true,
              points: 25,
              feedback: "Critical finding! Cloud metadata SSRF can lead to credential theft and complete cloud account compromise.",
              nextStep: 1
            },
            {
              text: "The application might have network latency",
              correct: false,
              points: 5,
              feedback: "Network performance is operational, not an SSRF vulnerability.",
              nextStep: 0
            },
            {
              text: "Only affects internal service discovery",
              correct: false,
              points: 10,
              feedback: "This enables complete cloud environment compromise through credential theft.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate cloud metadata access through SSRF. What's the professional testing boundary?",
          choices: [
            {
              text: "Test in a controlled cloud environment and document the attack impact",
              correct: true,
              points: 30,
              feedback: "Professional boundary! Controlled testing proves the vulnerability without compromising production cloud assets.",
              nextStep: 2
            },
            {
              text: "Actually retrieve production cloud credentials",
              correct: false,
              points: -80,
              feedback: "Accessing production cloud credentials can lead to complete environment compromise.",
              nextStep: 2
            },
            {
              text: "Only check if the application makes external requests",
              correct: false,
              points: 15,
              feedback: "External request checking is insufficient - specific cloud metadata testing is needed.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical cloud SSRF vulnerability! Application can access cloud metadata services, enabling credential theft and account compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're protecting against cloud metadata SSRF. What's the essential cloud security control?",
          choices: [
            {
              text: "Implement IMDSv2 and network restrictions for metadata service access",
              correct: true,
              points: 25,
              feedback: "Enterprise cloud security! IMDSv2 with network restrictions prevents unauthorized metadata access.",
              nextStep: 1
            },
            {
              text: "Disable metadata service entirely",
              correct: false,
              points: -20,
              feedback: "Metadata service is essential for cloud operations - secure it instead of disabling.",
              nextStep: 1
            },
            {
              text: "Use the same IAM role for all instances",
              correct: false,
              points: -35,
              feedback: "Each instance should have minimal required permissions following least privilege.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good control! What comprehensive cloud SSRF protection should you implement?",
          choices: [
            {
              text: "IMDSv2, outbound traffic control, and application input validation",
              correct: true,
              points: 30,
              feedback: "Enterprise defense-in-depth! Multiple layers including metadata security, network controls, and application validation.",
              nextStep: 2
            },
            {
              text: "Allow applications to make any outbound requests",
              correct: false,
              points: -40,
              feedback: "Outbound traffic should be controlled and monitored for security.",
              nextStep: 2
            },
            {
              text: "Use IMDSv1 for backward compatibility",
              correct: false,
              points: -35,
              feedback: "IMDSv1 is vulnerable to SSRF - migrate to IMDSv2 exclusively.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cloud SSRF protection established! IMDSv2 implemented with comprehensive network and application controls.",
          choices: []
        }
      ]
    }
  },

  accessControl330: {
    id: 330,
    title: "Insecure Direct Object Reference in User Profiles",
    difficulty: "Easy",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover a social media app where users can view any profile by changing the user ID in the URL. What access control problem exists?",
          choices: [
            {
              text: "Users can access private profiles without permission",
              correct: true,
              points: 15,
              feedback: "Correct! Changing IDs in URLs allows unauthorized access to other users' private information.",
              nextStep: 1
            },
            {
              text: "Profile pictures might not load properly",
              correct: false,
              points: 5,
              feedback: "Image loading issues are different from access control problems.",
              nextStep: 0
            },
            {
              text: "The app might run slower",
              correct: false,
              points: 5,
              feedback: "Performance issues are not related to access control vulnerabilities.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully view another user's private profile by changing the ID. What should you do next?",
          choices: [
            {
              text: "Report the issue without saving or sharing any private information",
              correct: true,
              points: 20,
              feedback: "Good! Ethical hackers report vulnerabilities without violating user privacy.",
              nextStep: 2
            },
            {
              text: "Share the private profiles with others to prove the bug",
              correct: false,
              points: -25,
              feedback: "Never share private information - this violates user trust and privacy laws.",
              nextStep: 2
            },
            {
              text: "Ignore it since it's just viewing profiles",
              correct: false,
              points: -10,
              feedback: "Privacy violations should always be reported and fixed.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Access control vulnerability found! Users can view any profile by manipulating URLs, violating privacy.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you fix this profile access issue?",
          choices: [
            {
              text: "Check if the logged-in user has permission to view each profile",
              correct: true,
              points: 15,
              feedback: "Correct! Always verify permissions before showing private information.",
              nextStep: 1
            },
            {
              text: "Make all profiles public to avoid the problem",
              correct: false,
              points: -15,
              feedback: "This removes user privacy choices - better to implement proper access control.",
              nextStep: 1
            },
            {
              text: "Use longer user IDs to make guessing harder",
              correct: false,
              points: -10,
              feedback: "Security through obscurity doesn't work - always check permissions.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the best way to implement secure profile access?",
          choices: [
            {
              text: "Verify ownership or friendship before showing private profile data",
              correct: true,
              points: 20,
              feedback: "Excellent! Check relationships and permissions for each profile access request.",
              nextStep: 2
            },
            {
              text: "Only hide sensitive information like email addresses",
              correct: false,
              points: -15,
              feedback: "All private information should be protected, not just some fields.",
              nextStep: 2
            },
            {
              text: "Rate limit how many profiles a user can view",
              correct: false,
              points: 5,
              feedback: "Rate limiting helps with abuse but doesn't fix the access control problem.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Profile security fixed! All profile accesses now properly checked for permissions.",
          choices: []
        }
      ]
    }
  },

  cryptoFailures331: {
    id: 331,
    title: "Plain Text Password Storage",
    difficulty: "Easy",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover a website that stores user passwords in plain text in the database. What's the main security risk?",
          choices: [
            {
              text: "If the database is stolen, all passwords are immediately exposed",
              correct: true,
              points: 15,
              feedback: "Correct! Plain text passwords are extremely dangerous if the database is compromised.",
              nextStep: 1
            },
            {
              text: "Passwords take up too much storage space",
              correct: false,
              points: 5,
              feedback: "Storage space is not the main security concern here.",
              nextStep: 0
            },
            {
              text: "Users might forget their passwords",
              correct: false,
              points: 5,
              feedback: "Password memory issues are different from storage security.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You find a database backup with plain text passwords. What's the ethical response?",
          choices: [
            {
              text: "Report the issue immediately without accessing any user accounts",
              correct: true,
              points: 20,
              feedback: "Good! Report security issues without exploiting them.",
              nextStep: 2
            },
            {
              text: "Test some passwords to confirm they work",
              correct: false,
              points: -20,
              feedback: "Never test passwords on real accounts - this is unauthorized access.",
              nextStep: 2
            },
            {
              text: "Tell users their passwords are stored insecurely",
              correct: false,
              points: -15,
              feedback: "Report to the company first, don't contact users directly.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical cryptographic failure! Passwords stored in plain text put all user accounts at risk.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "What's the correct way to store passwords?",
          choices: [
            {
              text: "Hash passwords with a strong algorithm like bcrypt",
              correct: true,
              points: 15,
              feedback: "Correct! Password hashing protects users even if the database is stolen.",
              nextStep: 1
            },
            {
              text: "Encrypt passwords with a secret key",
              correct: false,
              points: -10,
              feedback: "Encryption can be reversed - hashing is one-way and more secure for passwords.",
              nextStep: 1
            },
            {
              text: "Store passwords in a separate database",
              correct: false,
              points: -5,
              feedback: "Location doesn't matter if they're still stored in plain text.",
              nextStep: 1
            }
          ]
        },
        {
          text: "How should you handle existing plain text passwords?",
          choices: [
            {
              text: "Force password reset and hash all new passwords",
              correct: true,
              points: 20,
              feedback: "Excellent! This ensures all passwords become secure immediately.",
              nextStep: 2
            },
            {
              text: "Encrypt the existing plain text passwords",
              correct: false,
              points: -15,
              feedback: "Don't keep plain text passwords - start fresh with hashed passwords.",
              nextStep: 2
            },
            {
              text: "Only hash passwords for new users",
              correct: false,
              points: -20,
              feedback: "All users deserve security - protect existing accounts too.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Password security implemented! All passwords now securely hashed and protected.",
          choices: []
        }
      ]
    }
  },

  injection332: {
    id: 332,
    title: "Search Box SQL Injection",
    difficulty: "Easy",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover a website search box that shows database errors when you enter special characters. What type of vulnerability might this indicate?",
          choices: [
            {
              text: "SQL injection - user input is being used directly in database queries",
              correct: true,
              points: 15,
              feedback: "Correct! Database errors often mean user input isn't being properly handled.",
              nextStep: 1
            },
            {
              text: "The search feature is broken",
              correct: false,
              points: 5,
              feedback: "While it might be broken, the error messages suggest a security issue.",
              nextStep: 0
            },
            {
              text: "The website is under maintenance",
              correct: false,
              points: 5,
              feedback: "Maintenance messages are different from database errors.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You test the search box with a simple SQL injection payload. What's the safe approach?",
          choices: [
            {
              text: "Use basic test payloads that don't damage the database",
              correct: true,
              points: 20,
              feedback: "Good! Test safely without causing harm to the system.",
              nextStep: 2
            },
            {
              text: "Try to delete database tables to prove the vulnerability",
              correct: false,
              points: -30,
              feedback: "Never attempt destructive actions - this could cause real damage.",
              nextStep: 2
            },
            {
              text: "Ignore it since it's just a search box",
              correct: false,
              points: -10,
              feedback: "Search boxes can be entry points for serious attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SQL injection vulnerability found! User input in search can manipulate database queries.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you fix SQL injection in the search feature?",
          choices: [
            {
              text: "Use parameterized queries instead of string concatenation",
              correct: true,
              points: 15,
              feedback: "Correct! Parameterized queries separate code from data safely.",
              nextStep: 1
            },
            {
              text: "Block special characters in search input",
              correct: false,
              points: -10,
              feedback: "Blocking characters can break legitimate searches and isn't reliable.",
              nextStep: 1
            },
            {
              text: "Hide error messages from users",
              correct: false,
              points: 5,
              feedback: "Hiding errors helps but doesn't fix the underlying vulnerability.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the best practice for handling user input in searches?",
          choices: [
            {
              text: "Use prepared statements and validate/sanitize all input",
              correct: true,
              points: 20,
              feedback: "Excellent! Multiple layers of protection make applications more secure.",
              nextStep: 2
            },
            {
              text: "Only allow short search queries",
              correct: false,
              points: -5,
              feedback: "Length restrictions don't prevent SQL injection attacks.",
              nextStep: 2
            },
            {
              text: "Use a different database system",
              correct: false,
              points: -15,
              feedback: "All databases can have injection issues if not used properly.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Search security fixed! All user input now properly handled with parameterized queries.",
          choices: []
        }
      ]
    }
  },

  insecureDesign333: {
    id: 333,
    title: "No Rate Limiting on Login",
    difficulty: "Easy",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover a login page that allows unlimited password attempts. What security problem does this create?",
          choices: [
            {
              text: "Brute force attacks can guess passwords through repeated attempts",
              correct: true,
              points: 15,
              feedback: "Correct! Unlimited attempts make password guessing practical for attackers.",
              nextStep: 1
            },
            {
              text: "The login page might load slowly",
              correct: false,
              points: 5,
              feedback: "Performance is different from security design issues.",
              nextStep: 0
            },
            {
              text: "Users might get confused by too many attempts",
              correct: false,
              points: 5,
              feedback: "User confusion is a usability issue, not the main security concern.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You test the login page with multiple rapid attempts. What's the responsible approach?",
          choices: [
            {
              text: "Test with a test account you control, not real user accounts",
              correct: true,
              points: 20,
              feedback: "Good! Always use test accounts you own for security testing.",
              nextStep: 2
            },
            {
              text: "Try to guess real user passwords to prove the risk",
              correct: false,
              points: -25,
              feedback: "Never attempt to access real user accounts without permission.",
              nextStep: 2
            },
            {
              text: "Make thousands of attempts to see what happens",
              correct: false,
              points: -15,
              feedback: "Excessive testing could be seen as an attack - be reasonable.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Design flaw found! Unlimited login attempts enable brute force password attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you protect the login page from brute force attacks?",
          choices: [
            {
              text: "Implement rate limiting and account lockout after several failures",
              correct: true,
              points: 15,
              feedback: "Correct! Rate limiting and lockouts prevent automated password guessing.",
              nextStep: 1
            },
            {
              text: "Make passwords more complicated",
              correct: false,
              points: 5,
              feedback: "Complex passwords help but don't prevent brute force attacks.",
              nextStep: 1
            },
            {
              text: "Add a CAPTCHA after every attempt",
              correct: false,
              points: -10,
              feedback: "CAPTCHAS after every attempt create poor user experience.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's a balanced approach to login security?",
          choices: [
            {
              text: "Gradual protection: CAPTCHA after few attempts, then temporary lockouts",
              correct: true,
              points: 20,
              feedback: "Excellent! Gradual security maintains usability while preventing attacks.",
              nextStep: 2
            },
            {
              text: "Permanent account lock after 3 wrong attempts",
              correct: false,
              points: -20,
              feedback: "Permanent locks are too harsh for legitimate users who make mistakes.",
              nextStep: 2
            },
            {
              text: "No protection - let users try as much as they want",
              correct: false,
              points: -25,
              feedback: "This leaves accounts vulnerable to simple attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Login security improved! Rate limiting and progressive protection now in place.",
          choices: []
        }
      ]
    }
  },

  securityMisconfig334: {
    id: 334,
    title: "Exposed Administrator Panel",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover an admin login page at a common URL like /admin that anyone can access. What's the security risk?",
          choices: [
            {
              text: "Attackers can try to guess admin passwords or find other vulnerabilities",
              correct: true,
              points: 15,
              feedback: "Correct! Exposed admin panels give attackers a target to focus on.",
              nextStep: 1
            },
            {
              text: "The admin page might have broken features",
              correct: false,
              points: 5,
              feedback: "Functionality issues are different from security exposure.",
              nextStep: 0
            },
            {
              text: "Regular users might accidentally find it",
              correct: false,
              points: 5,
              feedback: "While true, the main risk is intentional attacks, not accidents.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You find the exposed admin panel. What should you do?",
          choices: [
            {
              text: "Report the exposed endpoint without attempting to login",
              correct: true,
              points: 20,
              feedback: "Good! Report security issues without testing unauthorized access.",
              nextStep: 2
            },
            {
              text: "Try common admin passwords to see if it's vulnerable",
              correct: false,
              points: -20,
              feedback: "Never attempt unauthorized access, even for testing.",
              nextStep: 2
            },
            {
              text: "Bookmark it for later use",
              correct: false,
              points: -15,
              feedback: "Don't keep records of security vulnerabilities you find.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Security misconfiguration found! Admin panel exposed to the public internet.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you secure the admin panel?",
          choices: [
            {
              text: "Restrict access to specific IP addresses and use VPN",
              correct: true,
              points: 15,
              feedback: "Correct! Network restrictions and VPN add important security layers.",
              nextStep: 1
            },
            {
              text: "Change the URL to something else",
              correct: false,
              points: -10,
              feedback: "Security through obscurity doesn't work - attackers can find new URLs.",
              nextStep: 1
            },
            {
              text: "Add a warning message on the login page",
              correct: false,
              points: -5,
              feedback: "Warnings don't prevent determined attackers.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What additional security measures should you consider?",
          choices: [
            {
              text: "Multi-factor authentication and strong password requirements",
              correct: true,
              points: 20,
              feedback: "Excellent! Multiple security layers protect admin access effectively.",
              nextStep: 2
            },
            {
              text: "Remove the admin panel completely",
              correct: false,
              points: -15,
              feedback: "Admin panels are necessary - just need to be secured properly.",
              nextStep: 2
            },
            {
              text: "Only allow access during business hours",
              correct: false,
              points: 5,
              feedback: "Time restrictions help but aren't sufficient on their own.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Admin panel secured! Now protected with network restrictions and strong authentication.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponents335: {
    id: 335,
    title: "Outdated jQuery Library",
    difficulty: "Easy",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover a website using an old version of jQuery with known security vulnerabilities. What risk does this create?",
          choices: [
            {
              text: "Known exploits can attack the website through the vulnerable library",
              correct: true,
              points: 15,
              feedback: "Correct! Attackers can use published exploits against known vulnerabilities.",
              nextStep: 1
            },
            {
              text: "The website might look outdated",
              correct: false,
              points: 5,
              feedback: "Appearance is different from security risk.",
              nextStep: 0
            },
            {
              text: "Newer browsers might not support it",
              correct: false,
              points: 5,
              feedback: "Browser compatibility is a different concern.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You identify the vulnerable jQuery version. How should you proceed?",
          choices: [
            {
              text: "Report the outdated library with its version number",
              correct: true,
              points: 20,
              feedback: "Good! Specific version information helps developers fix the issue quickly.",
              nextStep: 2
            },
            {
              text: "Try known exploits against the website",
              correct: false,
              points: -25,
              feedback: "Never attempt exploits against systems you don't own.",
              nextStep: 2
            },
            {
              text: "Ignore it since it's just a JavaScript library",
              correct: false,
              points: -10,
              feedback: "JavaScript vulnerabilities can lead to serious security issues.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Vulnerable component found! Outdated jQuery version with known security issues.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you address the vulnerable jQuery version?",
          choices: [
            {
              text: "Update to the latest secure version and test for compatibility",
              correct: true,
              points: 15,
              feedback: "Correct! Regular updates are essential for security.",
              nextStep: 1
            },
            {
              text: "Remove jQuery entirely from the website",
              correct: false,
              points: -15,
              feedback: "Removing might break functionality - better to update securely.",
              nextStep: 1
            },
            {
              text: "Block attacks with a web application firewall",
              correct: false,
              points: 5,
              feedback: "WAFs help but don't fix the root vulnerability.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the best practice for managing third-party libraries?",
          choices: [
            {
              text: "Regularly check for updates and security patches",
              correct: true,
              points: 20,
              feedback: "Excellent! Proactive maintenance prevents security issues.",
              nextStep: 2
            },
            {
              text: "Use the same versions forever to avoid changes",
              correct: false,
              points: -20,
              feedback: "Frozen versions accumulate security vulnerabilities over time.",
              nextStep: 2
            },
            {
              text: "Only update when adding new features",
              correct: false,
              points: -10,
              feedback: "Security updates should happen regardless of new features.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Component security improved! jQuery updated and maintenance process established.",
          choices: []
        }
      ]
    }
  },

  authFailure336: {
    id: 336,
    title: "No Password Confirmation for Sensitive Actions",
    difficulty: "Easy",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover that changing email address or password doesn't require current password confirmation. What security issue exists?",
          choices: [
            {
              text: "Anyone with temporary access can permanently take over the account",
              correct: true,
              points: 15,
              feedback: "Correct! Without re-authentication, account takeover is easy.",
              nextStep: 1
            },
            {
              text: "Users might change settings by accident",
              correct: false,
              points: 5,
              feedback: "Accidental changes are a usability issue, not the main security risk.",
              nextStep: 0
            },
            {
              text: "The changes might not save properly",
              correct: false,
              points: 5,
              feedback: "Data saving issues are different from authentication problems.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You test the account settings without being asked for password confirmation. What's the right approach?",
          choices: [
            {
              text: "Document the issue without actually changing any settings",
              correct: true,
              points: 20,
              feedback: "Good! Test security without making actual changes to accounts.",
              nextStep: 2
            },
            {
              text: "Change the email on a test account to prove the issue",
              correct: false,
              points: -15,
              feedback: "Even test changes can cause problems - just document the vulnerability.",
              nextStep: 2
            },
            {
              text: "Assume it's not important since it requires login",
              correct: false,
              points: -10,
              feedback: "Sensitive actions always need extra protection.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Authentication flaw found! Sensitive account changes don't require password confirmation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you protect sensitive account actions?",
          choices: [
            {
              text: "Require current password confirmation for important changes",
              correct: true,
              points: 15,
              feedback: "Correct! Re-authentication prevents account takeover.",
              nextStep: 1
            },
            {
              text: "Send email notifications after changes",
              correct: false,
              points: 5,
              feedback: "Notifications are good but don't prevent unauthorized changes.",
              nextStep: 1
            },
            {
              text: "Only allow changes from certain devices",
              correct: false,
              points: -10,
              feedback: "Device restrictions aren't reliable security measures.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What actions should require password confirmation?",
          choices: [
            {
              text: "Password changes, email changes, and payment modifications",
              correct: true,
              points: 20,
              feedback: "Excellent! Any action that could lead to account takeover needs protection.",
              nextStep: 2
            },
            {
              text: "Only password changes need confirmation",
              correct: false,
              points: -15,
              feedback: "Email changes can also lead to account takeover.",
              nextStep: 2
            },
            {
              text: "All profile changes need password confirmation",
              correct: false,
              points: -5,
              feedback: "Only sensitive changes need extra protection to avoid user frustration.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Account security enhanced! Sensitive actions now require password confirmation.",
          choices: []
        }
      ]
    }
  },

  softwareIntegrity337: {
    id: 337,
    title: "No File Type Validation on Uploads",
    difficulty: "Easy",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover a file upload feature that accepts any file type, including executable files. What's the main risk?",
          choices: [
            {
              text: "Malicious files can be uploaded and might execute on the server",
              correct: true,
              points: 15,
              feedback: "Correct! Executable files can harm the server or other users.",
              nextStep: 1
            },
            {
              text: "The server might run out of storage space",
              correct: false,
              points: 5,
              feedback: "Storage management is different from security risks.",
              nextStep: 0
            },
            {
              text: "Users might upload inappropriate content",
              correct: false,
              points: 5,
              feedback: "Content moderation is a separate concern from security vulnerabilities.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You test uploading different file types. What's the safe testing method?",
          choices: [
            {
              text: "Upload harmless test files to confirm the vulnerability",
              correct: true,
              points: 20,
              feedback: "Good! Use safe files that demonstrate the issue without causing harm.",
              nextStep: 2
            },
            {
              text: "Upload real malware to see if it's blocked",
              correct: false,
              points: -30,
              feedback: "Never upload malicious software - this could harm the system.",
              nextStep: 2
            },
            {
              text: "Upload very large files to test limits",
              correct: false,
              points: -10,
              feedback: "Size testing is different from file type validation testing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "File upload vulnerability found! No validation of file types being uploaded.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you secure the file upload feature?",
          choices: [
            {
              text: "Create an allowlist of permitted file types",
              correct: true,
              points: 15,
              feedback: "Correct! Only allow specific, safe file types.",
              nextStep: 1
            },
            {
              text: "Block known dangerous file extensions",
              correct: false,
              points: -10,
              feedback: "Blocklists can be bypassed - allowlists are more secure.",
              nextStep: 1
            },
            {
              text: "Scan files after upload for viruses",
              correct: false,
              points: 5,
              feedback: "Scanning helps but doesn't prevent the upload of dangerous files.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the best practice for file upload security?",
          choices: [
            {
              text: "Validate file type, scan for malware, and store files securely",
              correct: true,
              points: 20,
              feedback: "Excellent! Multiple security layers protect against various threats.",
              nextStep: 2
            },
            {
              text: "Only allow image files from trusted users",
              correct: false,
              points: -15,
              feedback: "All users should follow the same security rules.",
              nextStep: 2
            },
            {
              text: "Disable file uploads completely",
              correct: false,
              points: -20,
              feedback: "File uploads are often necessary - just need to be secured properly.",
              nextStep: 2
            }
          ]
        },
        {
          text: "File upload security implemented! Now validates file types and scans for threats.",
          choices: []
        }
      ]
    }
  },

  loggingFailures338: {
    id: 338,
    title: "No Login Attempt Logging",
    difficulty: "Easy",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover that failed login attempts aren't being logged. What security problem does this create?",
          choices: [
            {
              text: "Attackers can try passwords without being detected",
              correct: true,
              points: 15,
              feedback: "Correct! Without logging, brute force attacks can go unnoticed.",
              nextStep: 1
            },
            {
              text: "Users won't know if they typed wrong passwords",
              correct: false,
              points: 5,
              feedback: "Users get immediate feedback - logging is for security monitoring.",
              nextStep: 0
            },
            {
              text: "The application might crash during login",
              correct: false,
              points: 5,
              feedback: "Crashing is a stability issue, not a logging problem.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You test multiple failed logins and check for logging. What's the proper approach?",
          choices: [
            {
              text: "Use test accounts and check if attempts appear in access logs",
              correct: true,
              points: 20,
              feedback: "Good! Test with accounts you control and verify logging works.",
              nextStep: 2
            },
            {
              text: "Try many real user accounts to generate log data",
              correct: false,
              points: -25,
              feedback: "Never use real user accounts for security testing.",
              nextStep: 2
            },
            {
              text: "Assume logging works if the login fails",
              correct: false,
              points: -10,
              feedback: "Always verify that security mechanisms are actually working.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Logging failure found! Failed login attempts not being recorded for security monitoring.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "What login events should be logged for security?",
          choices: [
            {
              text: "Both successful and failed login attempts",
              correct: true,
              points: 15,
              feedback: "Correct! Both types of events provide important security information.",
              nextStep: 1
            },
            {
              text: "Only successful logins to reduce log size",
              correct: false,
              points: -15,
              feedback: "Failed attempts often indicate attack attempts and are crucial.",
              nextStep: 1
            },
            {
              text: "Only logins from unusual locations",
              correct: false,
              points: -10,
              feedback: "All login attempts should be logged for complete monitoring.",
              nextStep: 1
            }
          ]
        },
        {
          text: "How should login logs be protected and used?",
          choices: [
            {
              text: "Store securely, monitor for patterns, and set up alerts for suspicious activity",
              correct: true,
              points: 20,
              feedback: "Excellent! Proper log management includes storage, analysis, and alerting.",
              nextStep: 2
            },
            {
              text: "Keep logs for one day to save space",
              correct: false,
              points: -20,
              feedback: "Logs need to be kept longer for investigation of past incidents.",
              nextStep: 2
            },
            {
              text: "Only review logs when there's a problem",
              correct: false,
              points: -15,
              feedback: "Proactive monitoring helps detect attacks early.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Login logging implemented! All authentication events now properly recorded and monitored.",
          choices: []
        }
      ]
    }
  },

  ssrf339: {
    id: 339,
    title: "SSRF in Image URL Import",
    difficulty: "Easy",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "You discover a feature that lets users import profile pictures by providing a URL. The server downloads images from any URL. What risk exists?",
          choices: [
            {
              text: "The server can be made to access internal systems or malicious sites",
              correct: true,
              points: 15,
              feedback: "Correct! Server-side requests can reach internal networks or harmful destinations.",
              nextStep: 1
            },
            {
              text: "Users might upload inappropriate images",
              correct: false,
              points: 5,
              feedback: "Content moderation is different from SSRF vulnerability.",
              nextStep: 0
            },
            {
              text: "The images might not load properly",
              correct: false,
              points: 5,
              feedback: "Loading issues are functional, not security problems.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You test the image import with different URLs. What's the safe testing method?",
          choices: [
            {
              text: "Use public image URLs and monitor server behavior",
              correct: true,
              points: 20,
              feedback: "Good! Test with safe, public resources to understand the vulnerability.",
              nextStep: 2
            },
            {
              text: "Try to access internal company servers",
              correct: false,
              points: -25,
              feedback: "Never attempt to access internal systems without authorization.",
              nextStep: 2
            },
            {
              text: "Point to large files to crash the server",
              correct: false,
              points: -20,
              feedback: "Don't attempt denial of service during security testing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF vulnerability found! Server can be made to request any URL during image import.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you secure the image import feature?",
          choices: [
            {
              text: "Validate URLs and restrict to specific domains or IP ranges",
              correct: true,
              points: 15,
              feedback: "Correct! Control where the server can make requests.",
              nextStep: 1
            },
            {
              text: "Only allow URLs from popular image sites",
              correct: false,
              points: -10,
              feedback: "Popular sites can still be abused - use proper validation.",
              nextStep: 1
            },
            {
              text: "Add a CAPTCHA before image import",
              correct: false,
              points: 5,
              feedback: "CAPTCHA prevents automation but doesn't fix SSRF.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What comprehensive SSRF protection should you implement?",
          choices: [
            {
              text: "URL validation, network restrictions, and content verification",
              correct: true,
              points: 20,
              feedback: "Excellent! Multiple layers prevent various SSRF attack vectors.",
              nextStep: 2
            },
            {
              text: "Disable URL imports completely",
              correct: false,
              points: -15,
              feedback: "The feature is useful - just needs to be secured properly.",
              nextStep: 2
            },
            {
              text: "Only allow http:// URLs for safety",
              correct: false,
              points: -20,
              feedback: "HTTP URLs can still be dangerous - need proper validation.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF protection implemented! Image imports now validated and restricted securely.",
          choices: []
        }
      ]
    }
  },

  
  accessControl340: {
    id: 340,
    title: "Insecure Direct Object Reference in Order History",
    difficulty: "Easy",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover an e-commerce site where users can view order details by changing the order ID in the URL. What access control concept is violated?",
          choices: [
            {
              text: "Users can view other customers' order information and personal details",
              correct: true,
              points: 15,
              feedback: "Correct! Manipulating order IDs allows unauthorized access to sensitive customer data.",
              nextStep: 1
            },
            {
              text: "Order pages might load slowly",
              correct: false,
              points: 5,
              feedback: "Performance issues are different from access control problems.",
              nextStep: 0
            },
            {
              text: "The order IDs are too sequential",
              correct: false,
              points: 5,
              feedback: "While sequential IDs make guessing easier, the real issue is missing authorization checks.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You find you can access other users' orders by changing the order number. What's the responsible action?",
          choices: [
            {
              text: "Report the vulnerability without viewing any sensitive customer data",
              correct: true,
              points: 20,
              feedback: "Good! Ethical testing means finding vulnerabilities without accessing private information.",
              nextStep: 2
            },
            {
              text: "View several orders to understand the scope of the issue",
              correct: false,
              points: -20,
              feedback: "Never access real customer data - this violates privacy and trust.",
              nextStep: 2
            },
            {
              text: "Assume it's not important since it's just order history",
              correct: false,
              points: -15,
              feedback: "Order history contains personal information and should be protected.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Access control vulnerability found! Order history exposes other customers' personal information.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you secure the order history feature?",
          choices: [
            {
              text: "Verify the logged-in user owns the order before showing details",
              correct: true,
              points: 15,
              feedback: "Correct! Always check ownership or permissions for each resource access.",
              nextStep: 1
            },
            {
              text: "Use random order numbers instead of sequential ones",
              correct: false,
              points: -10,
              feedback: "Obfuscation doesn't replace proper authorization checks.",
              nextStep: 1
            },
            {
              text: "Hide sensitive information but show basic order details",
              correct: false,
              points: -15,
              feedback: "All order details should be protected from unauthorized access.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the best practice for resource access control?",
          choices: [
            {
              text: "Implement ownership checks for all user-specific resources",
              correct: true,
              points: 20,
              feedback: "Excellent! Every request for user data should verify the requester has permission.",
              nextStep: 2
            },
            {
              text: "Only protect financial information in orders",
              correct: false,
              points: -20,
              feedback: "All personal information in orders deserves protection.",
              nextStep: 2
            },
            {
              text: "Rate limit order history requests",
              correct: false,
              points: 5,
              feedback: "Rate limiting helps with abuse but doesn't fix authorization problems.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Order security implemented! All order accesses now verify user ownership.",
          choices: []
        }
      ]
    }
  },

  cryptoFailures341: {
    id: 341,
    title: "Missing HTTPS on Login Page",
    difficulty: "Easy",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover a login page that uses HTTP instead of HTTPS. What specific risk does this create?",
          choices: [
            {
              text: "Passwords are sent in plain text and can be intercepted",
              correct: true,
              points: 15,
              feedback: "Correct! HTTP transmits all data including passwords in readable form.",
              nextStep: 1
            },
            {
              text: "The login page might not work properly",
              correct: false,
              points: 5,
              feedback: "Functionality issues are different from security risks.",
              nextStep: 0
            },
            {
              text: "Users might see security warnings",
              correct: false,
              points: 5,
              feedback: "Browser warnings are a symptom, not the core security problem.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You confirm the login page uses HTTP. What's the appropriate next step?",
          choices: [
            {
              text: "Report the missing HTTPS protection on the login form",
              correct: true,
              points: 20,
              feedback: "Good! Login pages absolutely require HTTPS to protect credentials.",
              nextStep: 2
            },
            {
              text: "Capture network traffic to demonstrate password exposure",
              correct: false,
              points: -25,
              feedback: "Never intercept real user traffic - this violates privacy.",
              nextStep: 2
            },
            {
              text: "Assume it's okay if other pages use HTTPS",
              correct: false,
              points: -15,
              feedback: "Login pages are the most critical pages needing HTTPS protection.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cryptographic failure found! Login page transmits passwords over unencrypted HTTP.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you fix the HTTP login page issue?",
          choices: [
            {
              text: "Implement HTTPS and redirect all HTTP traffic to HTTPS",
              correct: true,
              points: 15,
              feedback: "Correct! HTTPS encrypts all communication between browser and server.",
              nextStep: 1
            },
            {
              text: "Add a warning message about using HTTP",
              correct: false,
              points: -15,
              feedback: "Warnings don't protect data - encryption is necessary.",
              nextStep: 1
            },
            {
              text: "Use JavaScript to encrypt passwords before sending",
              correct: false,
              points: -10,
              feedback: "Client-side encryption is complex and doesn't replace HTTPS.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What additional HTTPS security measures should you implement?",
          choices: [
            {
              text: "HSTS header to enforce HTTPS and secure cookie flags",
              correct: true,
              points: 20,
              feedback: "Excellent! HSTS prevents SSL stripping attacks and secure cookies protect sessions.",
              nextStep: 2
            },
            {
              text: "Only use HTTPS for the login process",
              correct: false,
              points: -20,
              feedback: "All pages should use HTTPS to protect sessions and prevent mixed content issues.",
              nextStep: 2
            },
            {
              text: "Use self-signed certificates to save money",
              correct: false,
              points: -25,
              feedback: "Self-signed certificates break trust and cause browser warnings.",
              nextStep: 2
            }
          ]
        },
        {
          text: "HTTPS security implemented! All pages now use encrypted connections with HSTS enforcement.",
          choices: []
        }
      ]
    }
  },

  injection342: {
    id: 342,
    title: "Cross-Site Scripting in Comment System",
    difficulty: "Easy",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover a blog comment system that doesn't sanitize user input. What happens when you enter HTML tags in comments?",
          choices: [
            {
              text: "The HTML executes in other users' browsers, enabling XSS attacks",
              correct: true,
              points: 15,
              feedback: "Correct! Unsanitized HTML can run scripts in victims' browsers.",
              nextStep: 1
            },
            {
              text: "The comment might not display properly",
              correct: false,
              points: 5,
              feedback: "Display issues are minor compared to security risks.",
              nextStep: 0
            },
            {
              text: "The website might block your comment",
              correct: false,
              points: 5,
              feedback: "If the site blocks it, that would be a protection, not a vulnerability.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You test the comment system with simple HTML. What's the safe testing approach?",
          choices: [
            {
              text: "Use harmless HTML like <b>test</b> to confirm the vulnerability",
              correct: true,
              points: 20,
              feedback: "Good! Use safe payloads that demonstrate the issue without causing harm.",
              nextStep: 2
            },
            {
              text: "Try to steal other users' cookies with malicious scripts",
              correct: false,
              points: -30,
              feedback: "Never attempt to steal real user data during testing.",
              nextStep: 2
            },
            {
              text: "Post many comments with scripts to see if they're blocked",
              correct: false,
              points: -15,
              feedback: "Excessive testing could be considered spam or abuse.",
              nextStep: 2
            }
          ]
        },
        {
          text: "XSS vulnerability found! Comment system executes unsanitized HTML from users.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you secure the comment system against XSS?",
          choices: [
            {
              text: "HTML encode all user input before displaying it",
              correct: true,
              points: 15,
              feedback: "Correct! Encoding converts special characters to safe equivalents.",
              nextStep: 1
            },
            {
              text: "Block all HTML tags in comments",
              correct: false,
              points: -10,
              feedback: "This might be too restrictive - better to sanitize properly.",
              nextStep: 1
            },
            {
              text: "Use a WAF to filter malicious input",
              correct: false,
              points: 5,
              feedback: "WAFs help but don't replace proper input sanitization in code.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive approach to prevent XSS?",
          choices: [
            {
              text: "Input validation, output encoding, and Content Security Policy",
              correct: true,
              points: 20,
              feedback: "Excellent! Multiple layers provide defense in depth against XSS.",
              nextStep: 2
            },
            {
              text: "Only allow plain text in comments",
              correct: false,
              points: -15,
              feedback: "This limits functionality - better to allow safe HTML with proper sanitization.",
              nextStep: 2
            },
            {
              text: "Trust users to not write malicious code",
              correct: false,
              points: -25,
              feedback: "Never trust user input - always validate and sanitize.",
              nextStep: 2
            }
          ]
        },
        {
          text: "XSS protection implemented! All user input now properly sanitized and encoded.",
          choices: []
        }
      ]
    }
  },

  insecureDesign343: {
    id: 343,
    title: "Predictable Username Generation",
    difficulty: "Easy",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover a system that creates usernames using firstname.lastname pattern. What design flaw enables user enumeration?",
          choices: [
            {
              text: "Predictable usernames make it easy to guess valid accounts",
              correct: true,
              points: 15,
              feedback: "Correct! Predictable naming conventions help attackers identify real users.",
              nextStep: 1
            },
            {
              text: "Usernames might be too long",
              correct: false,
              points: 5,
              feedback: "Length issues are usability problems, not security design flaws.",
              nextStep: 0
            },
            {
              text: "Users might forget their usernames",
              correct: false,
              points: 5,
              feedback: "Memory issues are different from security concerns.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You can guess usernames based on common names. What's the ethical testing approach?",
          choices: [
            {
              text: "Document the predictable pattern without testing real accounts",
              correct: true,
              points: 20,
              feedback: "Good! Identify the design flaw without attempting to access accounts.",
              nextStep: 2
            },
            {
              text: "Try to login with guessed usernames to confirm they exist",
              correct: false,
              points: -20,
              feedback: "Never attempt unauthorized access to user accounts.",
              nextStep: 2
            },
            {
              text: "Create many accounts to analyze the pattern",
              correct: false,
              points: -15,
              feedback: "Creating fake accounts could be considered abuse.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Design flaw found! Predictable username generation enables user enumeration attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you design a secure username system?",
          choices: [
            {
              text: "Let users choose unique usernames or use random identifiers",
              correct: true,
              points: 15,
              feedback: "Correct! User-chosen or random usernames prevent predictability.",
              nextStep: 1
            },
            {
              text: "Use email addresses as usernames exclusively",
              correct: false,
              points: -10,
              feedback: "Email addresses are also predictable and reveal personal information.",
              nextStep: 1
            },
            {
              text: "Add numbers to common names to make them unique",
              correct: false,
              points: -5,
              feedback: "This still follows a predictable pattern that can be guessed.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the best practice for user identification?",
          choices: [
            {
              text: "Use random internal IDs and allow custom display names",
              correct: true,
              points: 20,
              feedback: "Excellent! Separate internal identification from user-facing names.",
              nextStep: 2
            },
            {
              text: "Require unique usernames that are hard to guess",
              correct: false,
              points: -15,
              feedback: "Users often choose predictable usernames - better to use random IDs internally.",
              nextStep: 2
            },
            {
              text: "Use the same username pattern for all systems",
              correct: false,
              points: -20,
              feedback: "Different systems should have different identification approaches.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Username design improved! Now uses random internal IDs with user-chosen display names.",
          choices: []
        }
      ]
    }
  },

  securityMisconfig344: {
    id: 344,
    title: "Default Error Pages Revealing Server Information",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover that application errors show detailed technical information including server version and file paths. What information disclosure risk exists?",
          choices: [
            {
              text: "Attackers learn about the server setup and can plan targeted attacks",
              correct: true,
              points: 15,
              feedback: "Correct! Detailed errors give attackers valuable information about the system.",
              nextStep: 1
            },
            {
              text: "Users might be confused by technical messages",
              correct: false,
              points: 5,
              feedback: "User confusion is a usability issue, not the main security risk.",
              nextStep: 0
            },
            {
              text: "The errors take up too much screen space",
              correct: false,
              points: 5,
              feedback: "Layout issues are different from information disclosure problems.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You trigger an error and see server details. What's the proper response?",
          choices: [
            {
              text: "Document what information is exposed without exploiting it",
              correct: true,
              points: 20,
              feedback: "Good! Identify the information leak without using it for attacks.",
              nextStep: 2
            },
            {
              text: "Use the information to try specific version exploits",
              correct: false,
              points: -25,
              feedback: "Never attempt to exploit vulnerabilities you discover.",
              nextStep: 2
            },
            {
              text: "Ignore it since errors don't happen often",
              correct: false,
              points: -15,
              feedback: "Even rare errors can be triggered intentionally by attackers.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Security misconfiguration found! Error pages expose sensitive server information.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you configure error handling securely?",
          choices: [
            {
              text: "Show user-friendly error messages while logging details internally",
              correct: true,
              points: 15,
              feedback: "Correct! Users get helpful messages while admins get technical details for debugging.",
              nextStep: 1
            },
            {
              text: "Disable all error messages completely",
              correct: false,
              points: -15,
              feedback: "Users need some error feedback - just make it secure and helpful.",
              nextStep: 1
            },
            {
              text: "Only show detailed errors to logged-in users",
              correct: false,
              points: -10,
              feedback: "Even authenticated users shouldn't see sensitive server details.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive error handling strategy?",
          choices: [
            {
              text: "Custom error pages, proper logging, and environment-specific configurations",
              correct: true,
              points: 20,
              feedback: "Excellent! Different environments can have different error detail levels.",
              nextStep: 2
            },
            {
              text: "Use the same error detail level everywhere",
              correct: false,
              points: -20,
              feedback: "Development needs more detail than production for debugging.",
              nextStep: 2
            },
            {
              text: "Block access to error pages with firewall rules",
              correct: false,
              points: -15,
              feedback: "Errors will still occur - better to handle them properly.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Error handling secured! Now shows user-friendly messages while logging technical details.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponents345: {
    id: 345,
    title: "Outdated WordPress Core Version",
    difficulty: "Easy",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover a WordPress website running an old version with known security vulnerabilities. What risk does this create?",
          choices: [
            {
              text: "Attackers can use published exploits to compromise the website",
              correct: true,
              points: 15,
              feedback: "Correct! Known vulnerabilities have publicly available exploit code.",
              nextStep: 1
            },
            {
              text: "The website might have compatibility issues",
              correct: false,
              points: 5,
              feedback: "Compatibility is different from security risk.",
              nextStep: 0
            },
            {
              text: "New features might not be available",
              correct: false,
              points: 5,
              feedback: "Feature availability is not a security concern.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You identify the outdated WordPress version. What's the responsible action?",
          choices: [
            {
              text: "Report the outdated version and recommend updating",
              correct: true,
              points: 20,
              feedback: "Good! Keeping software updated is crucial for security.",
              nextStep: 2
            },
            {
              text: "Try known exploits to demonstrate the risk",
              correct: false,
              points: -30,
              feedback: "Never attempt to exploit vulnerabilities in systems you don't own.",
              nextStep: 2
            },
            {
              text: "Assume the hosting provider will handle updates",
              correct: false,
              points: -15,
              feedback: "Website owners are responsible for keeping their software updated.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Vulnerable component found! Outdated WordPress version with known security issues.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you manage WordPress updates?",
          choices: [
            {
              text: "Enable automatic updates and regularly check for security patches",
              correct: true,
              points: 15,
              feedback: "Correct! Automatic updates help ensure timely security fixes.",
              nextStep: 1
            },
            {
              text: "Only update when adding new features",
              correct: false,
              points: -20,
              feedback: "Security updates should happen regardless of new features.",
              nextStep: 1
            },
            {
              text: "Wait for others to test updates before applying them",
              correct: false,
              points: -10,
              feedback: "Security updates should be applied promptly, with proper testing procedures.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the best practice for WordPress maintenance?",
          choices: [
            {
              text: "Regular updates, security scanning, and backups before changes",
              correct: true,
              points: 20,
              feedback: "Excellent! Comprehensive maintenance includes updates, monitoring, and recovery planning.",
              nextStep: 2
            },
            {
              text: "Disable updates to avoid breaking changes",
              correct: false,
              points: -25,
              feedback: "This leaves the site vulnerable to known attacks.",
              nextStep: 2
            },
            {
              text: "Only update the WordPress core, not plugins",
              correct: false,
              points: -20,
              feedback: "Plugins often have vulnerabilities and need updates too.",
              nextStep: 2
            }
          ]
        },
        {
          text: "WordPress maintenance established! Now using automatic updates with regular security checks.",
          choices: []
        }
      ]
    }
  },

  authFailure346: {
    id: 346,
    title: "No Session Timeout",
    difficulty: "Easy",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover that user sessions never expire, even after days of inactivity. What authentication risk does this create?",
          choices: [
            {
              text: "Stolen devices or sessions provide indefinite access to accounts",
              correct: true,
              points: 15,
              feedback: "Correct! Unlimited sessions mean stolen login sessions work forever.",
              nextStep: 1
            },
            {
              text: "Users might forget they're logged in",
              correct: false,
              points: 5,
              feedback: "This is a minor convenience issue, not the main security risk.",
              nextStep: 0
            },
            {
              text: "Server memory might fill up with old sessions",
              correct: false,
              points: 5,
              feedback: "Server resource issues are different from authentication security.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You confirm sessions don't expire. What's the ethical testing approach?",
          choices: [
            {
              text: "Document the missing session timeout without accessing real accounts",
              correct: true,
              points: 20,
              feedback: "Good! Identify the security issue without prolonged unauthorized access.",
              nextStep: 2
            },
            {
              text: "Leave a session open for weeks to prove it doesn't expire",
              correct: false,
              points: -15,
              feedback: "This could be seen as maintaining unauthorized access.",
              nextStep: 2
            },
            {
              text: "Test with multiple user accounts simultaneously",
              correct: false,
              points: -20,
              feedback: "Never use multiple real accounts for security testing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Authentication failure found! User sessions never expire, allowing indefinite access.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you implement session timeouts?",
          choices: [
            {
              text: "Set reasonable inactivity timeouts and absolute session limits",
              correct: true,
              points: 15,
              feedback: "Correct! Both inactivity and absolute timeouts provide layered security.",
              nextStep: 1
            },
            {
              text: "Make users re-login every time they visit",
              correct: false,
              points: -15,
              feedback: "This creates poor user experience - balance security with usability.",
              nextStep: 1
            },
            {
              text: "Only timeout sessions on sensitive actions",
              correct: false,
              points: -10,
              feedback: "All sessions should timeout to prevent indefinite access.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the balanced approach to session management?",
          choices: [
            {
              text: "Reasonable timeouts with remember-me options for convenience",
              correct: true,
              points: 20,
              feedback: "Excellent! Balance security with user convenience through thoughtful design.",
              nextStep: 2
            },
            {
              text: "No timeouts for better user experience",
              correct: false,
              points: -25,
              feedback: "This sacrifices security for convenience - find a middle ground.",
              nextStep: 2
            },
            {
              text: "Very short timeouts for maximum security",
              correct: false,
              points: -20,
              feedback: "Too frequent logins frustrate users and may lead to password reuse.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Session management improved! Now uses reasonable timeouts with user-friendly options.",
          choices: []
        }
      ]
    }
  },

  softwareIntegrity347: {
    id: 347,
    title: "No File Size Validation on Uploads",
    difficulty: "Easy",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover a file upload feature that accepts files of any size without limits. What integrity risk does this create?",
          choices: [
            {
              text: "Large files can fill server storage or cause service disruption",
              correct: true,
              points: 15,
              feedback: "Correct! Unlimited file sizes can lead to denial of service through resource exhaustion.",
              nextStep: 1
            },
            {
              text: "Large files might take longer to upload",
              correct: false,
              points: 5,
              feedback: "Upload time is a performance issue, not the main security risk.",
              nextStep: 0
            },
            {
              text: "Users might upload unnecessary large files",
              correct: false,
              points: 5,
              feedback: "This is a storage management issue, not the core integrity concern.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You test uploading large files. What's the safe testing method?",
          choices: [
            {
              text: "Use large but harmless test files to demonstrate the issue",
              correct: true,
              points: 20,
              feedback: "Good! Test with safe files that won't damage the system.",
              nextStep: 2
            },
            {
              text: "Upload extremely large files to crash the server",
              correct: false,
              points: -30,
              feedback: "Never attempt to disrupt service during security testing.",
              nextStep: 2
            },
            {
              text: "Upload many small files rapidly",
              correct: false,
              points: -15,
              feedback: "This tests a different type of limit - focus on the specific vulnerability.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Integrity vulnerability found! File uploads have no size limits, risking resource exhaustion.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you implement file size limits?",
          choices: [
            {
              text: "Set reasonable size limits based on actual needs",
              correct: true,
              points: 15,
              feedback: "Correct! Limits should be practical for the application's purpose.",
              nextStep: 1
            },
            {
              text: "Allow any size but compress files automatically",
              correct: false,
              points: -10,
              feedback: "Compression has limits and doesn't prevent extremely large uploads.",
              nextStep: 1
            },
            {
              text: "Only limit sizes for certain file types",
              correct: false,
              points: -15,
              feedback: "All file types should have reasonable size limits.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive file upload security approach?",
          choices: [
            {
              text: "Size limits, type validation, and malware scanning",
              correct: true,
              points: 20,
              feedback: "Excellent! Multiple security layers protect against various file upload threats.",
              nextStep: 2
            },
            {
              text: "Only rely on client-side size checks",
              correct: false,
              points: -25,
              feedback: "Client-side checks can be bypassed - always validate server-side.",
              nextStep: 2
            },
            {
              text: "Set very small limits to be safe",
              correct: false,
              points: -20,
              feedback: "Limits should be reasonable for the application's functionality.",
              nextStep: 2
            }
          ]
        },
        {
          text: "File upload security implemented! Now has reasonable size limits with comprehensive validation.",
          choices: []
        }
      ]
    }
  },

  loggingFailures348: {
    id: 348,
    title: "No Audit Trail for User Actions",
    difficulty: "Easy",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover that user actions like profile changes or settings modifications aren't logged. What monitoring gap exists?",
          choices: [
            {
              text: "Unauthorized changes can't be detected or investigated",
              correct: true,
              points: 15,
              feedback: "Correct! Without logging, there's no record of what happened for investigation.",
              nextStep: 1
            },
            {
              text: "Users might not remember what they changed",
              correct: false,
              points: 5,
              feedback: "User memory is a convenience issue, not a security monitoring gap.",
              nextStep: 0
            },
            {
              text: "The application might use more memory",
              correct: false,
              points: 5,
              feedback: "Resource usage is different from security monitoring.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You confirm user actions aren't being logged. What's the proper documentation approach?",
          choices: [
            {
              text: "List the types of user actions that should be logged for security",
              correct: true,
              points: 20,
              feedback: "Good! Specific recommendations help developers implement proper logging.",
              nextStep: 2
            },
            {
              text: "Make unauthorized changes to prove they're not logged",
              correct: false,
              points: -25,
              feedback: "Never make unauthorized changes, even for testing.",
              nextStep: 2
            },
            {
              text: "Assume logging isn't important for user actions",
              correct: false,
              points: -15,
              feedback: "User action logging is crucial for security investigations.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Logging failure found! User actions aren't recorded, preventing security monitoring.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "What user actions should be logged for security?",
          choices: [
            {
              text: "Login/logout, password changes, and sensitive data modifications",
              correct: true,
              points: 15,
              feedback: "Correct! These are critical security events that need monitoring.",
              nextStep: 1
            },
            {
              text: "Only failed login attempts",
              correct: false,
              points: -15,
              feedback: "Successful security-related actions also need logging.",
              nextStep: 1
            },
            {
              text: "Every single user action regardless of importance",
              correct: false,
              points: -10,
              feedback: "Focus on security-relevant actions to avoid log overload.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the best practice for security logging?",
          choices: [
            {
              text: "Log security events with timestamps, user info, and action details",
              correct: true,
              points: 20,
              feedback: "Excellent! Comprehensive logging provides context for investigations.",
              nextStep: 2
            },
            {
              text: "Only log events during business hours",
              correct: false,
              points: -25,
              feedback: "Security events can happen anytime - logging should be continuous.",
              nextStep: 2
            },
            {
              text: "Store logs with the application data",
              correct: false,
              points: -20,
              feedback: "Logs should be stored separately for security and integrity.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Security logging implemented! Critical user actions now properly recorded and monitored.",
          choices: []
        }
      ]
    }
  },

  ssrf349: {
    id: 349,
    title: "SSRF in Avatar URL Import",
    difficulty: "Easy",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "You discover a profile system that lets users set avatars by providing image URLs. The server downloads from any URL provided. What SSRF risk exists?",
          choices: [
            {
              text: "The server can be tricked into accessing internal services or malicious sites",
              correct: true,
              points: 15,
              feedback: "Correct! Server-side requests can reach places users normally can't access.",
              nextStep: 1
            },
            {
              text: "Users might set inappropriate avatars",
              correct: false,
              points: 5,
              feedback: "Content moderation is different from SSRF vulnerability.",
              nextStep: 0
            },
            {
              text: "Avatar images might not load properly",
              correct: false,
              points: 5,
              feedback: "Loading issues are functional problems, not security risks.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You test the avatar URL feature. What's the safe testing approach?",
          choices: [
            {
              text: "Use public image URLs to confirm the server makes the requests",
              correct: true,
              points: 20,
              feedback: "Good! Test with safe, public resources to understand the vulnerability.",
              nextStep: 2
            },
            {
              text: "Try to access internal company servers",
              correct: false,
              points: -30,
              feedback: "Never attempt to access internal systems without authorization.",
              nextStep: 2
            },
            {
              text: "Point to non-image files to see what happens",
              correct: false,
              points: -15,
              feedback: "This could cause unexpected behavior - stick to safe testing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF vulnerability found! Avatar import feature allows server to request any URL.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you secure the avatar URL import feature?",
          choices: [
            {
              text: "Validate URLs and restrict to specific domains or image hosts",
              correct: true,
              points: 15,
              feedback: "Correct! Control where the server can make requests for images.",
              nextStep: 1
            },
            {
              text: "Only allow URLs from popular social media sites",
              correct: false,
              points: -10,
              feedback: "Even popular sites can be abused - use proper validation.",
              nextStep: 1
            },
            {
              text: "Add a warning about appropriate image URLs",
              correct: false,
              points: -5,
              feedback: "Warnings don't prevent SSRF attacks - technical controls are needed.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive SSRF protection strategy?",
          choices: [
            {
              text: "URL validation, network restrictions, and content type verification",
              correct: true,
              points: 20,
              feedback: "Excellent! Multiple layers prevent various SSRF attack vectors.",
              nextStep: 2
            },
            {
              text: "Disable URL imports completely",
              correct: false,
              points: -15,
              feedback: "The feature is useful - just needs to be secured properly.",
              nextStep: 2
            },
            {
              text: "Only allow data URLs for avatars",
              correct: false,
              points: -20,
              feedback: "This limits functionality - better to allow external URLs with proper security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF protection implemented! Avatar imports now validated and restricted securely.",
          choices: []
        }
      ]
    }
  },
  
  
  accessControl340: {
    id: 340,
    title: "Insecure Direct Object Reference in Order History",
    difficulty: "Easy",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover an e-commerce site where users can view order details by changing the order ID in the URL. What access control concept is violated?",
          choices: [
            {
              text: "Users can view other customers' order information and personal details",
              correct: true,
              points: 15,
              feedback: "Correct! Manipulating order IDs allows unauthorized access to sensitive customer data.",
              nextStep: 1
            },
            {
              text: "Order pages might load slowly",
              correct: false,
              points: 5,
              feedback: "Performance issues are different from access control problems.",
              nextStep: 0
            },
            {
              text: "The order IDs are too sequential",
              correct: false,
              points: 5,
              feedback: "While sequential IDs make guessing easier, the real issue is missing authorization checks.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You find you can access other users' orders by changing the order number. What's the responsible action?",
          choices: [
            {
              text: "Report the vulnerability without viewing any sensitive customer data",
              correct: true,
              points: 20,
              feedback: "Good! Ethical testing means finding vulnerabilities without accessing private information.",
              nextStep: 2
            },
            {
              text: "View several orders to understand the scope of the issue",
              correct: false,
              points: -20,
              feedback: "Never access real customer data - this violates privacy and trust.",
              nextStep: 2
            },
            {
              text: "Assume it's not important since it's just order history",
              correct: false,
              points: -15,
              feedback: "Order history contains personal information and should be protected.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Access control vulnerability found! Order history exposes other customers' personal information.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you secure the order history feature?",
          choices: [
            {
              text: "Verify the logged-in user owns the order before showing details",
              correct: true,
              points: 15,
              feedback: "Correct! Always check ownership or permissions for each resource access.",
              nextStep: 1
            },
            {
              text: "Use random order numbers instead of sequential ones",
              correct: false,
              points: -10,
              feedback: "Obfuscation doesn't replace proper authorization checks.",
              nextStep: 1
            },
            {
              text: "Hide sensitive information but show basic order details",
              correct: false,
              points: -15,
              feedback: "All order details should be protected from unauthorized access.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the best practice for resource access control?",
          choices: [
            {
              text: "Implement ownership checks for all user-specific resources",
              correct: true,
              points: 20,
              feedback: "Excellent! Every request for user data should verify the requester has permission.",
              nextStep: 2
            },
            {
              text: "Only protect financial information in orders",
              correct: false,
              points: -20,
              feedback: "All personal information in orders deserves protection.",
              nextStep: 2
            },
            {
              text: "Rate limit order history requests",
              correct: false,
              points: 5,
              feedback: "Rate limiting helps with abuse but doesn't fix authorization problems.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Order security implemented! All order accesses now verify user ownership.",
          choices: []
        }
      ]
    }
  },

  cryptoFailures341: {
    id: 341,
    title: "Missing HTTPS on Login Page",
    difficulty: "Easy",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover a login page that uses HTTP instead of HTTPS. What specific risk does this create?",
          choices: [
            {
              text: "Passwords are sent in plain text and can be intercepted",
              correct: true,
              points: 15,
              feedback: "Correct! HTTP transmits all data including passwords in readable form.",
              nextStep: 1
            },
            {
              text: "The login page might not work properly",
              correct: false,
              points: 5,
              feedback: "Functionality issues are different from security risks.",
              nextStep: 0
            },
            {
              text: "Users might see security warnings",
              correct: false,
              points: 5,
              feedback: "Browser warnings are a symptom, not the core security problem.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You confirm the login page uses HTTP. What's the appropriate next step?",
          choices: [
            {
              text: "Report the missing HTTPS protection on the login form",
              correct: true,
              points: 20,
              feedback: "Good! Login pages absolutely require HTTPS to protect credentials.",
              nextStep: 2
            },
            {
              text: "Capture network traffic to demonstrate password exposure",
              correct: false,
              points: -25,
              feedback: "Never intercept real user traffic - this violates privacy.",
              nextStep: 2
            },
            {
              text: "Assume it's okay if other pages use HTTPS",
              correct: false,
              points: -15,
              feedback: "Login pages are the most critical pages needing HTTPS protection.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cryptographic failure found! Login page transmits passwords over unencrypted HTTP.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you fix the HTTP login page issue?",
          choices: [
            {
              text: "Implement HTTPS and redirect all HTTP traffic to HTTPS",
              correct: true,
              points: 15,
              feedback: "Correct! HTTPS encrypts all communication between browser and server.",
              nextStep: 1
            },
            {
              text: "Add a warning message about using HTTP",
              correct: false,
              points: -15,
              feedback: "Warnings don't protect data - encryption is necessary.",
              nextStep: 1
            },
            {
              text: "Use JavaScript to encrypt passwords before sending",
              correct: false,
              points: -10,
              feedback: "Client-side encryption is complex and doesn't replace HTTPS.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What additional HTTPS security measures should you implement?",
          choices: [
            {
              text: "HSTS header to enforce HTTPS and secure cookie flags",
              correct: true,
              points: 20,
              feedback: "Excellent! HSTS prevents SSL stripping attacks and secure cookies protect sessions.",
              nextStep: 2
            },
            {
              text: "Only use HTTPS for the login process",
              correct: false,
              points: -20,
              feedback: "All pages should use HTTPS to protect sessions and prevent mixed content issues.",
              nextStep: 2
            },
            {
              text: "Use self-signed certificates to save money",
              correct: false,
              points: -25,
              feedback: "Self-signed certificates break trust and cause browser warnings.",
              nextStep: 2
            }
          ]
        },
        {
          text: "HTTPS security implemented! All pages now use encrypted connections with HSTS enforcement.",
          choices: []
        }
      ]
    }
  },

  injection342: {
    id: 342,
    title: "Cross-Site Scripting in Comment System",
    difficulty: "Easy",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover a blog comment system that doesn't sanitize user input. What happens when you enter HTML tags in comments?",
          choices: [
            {
              text: "The HTML executes in other users' browsers, enabling XSS attacks",
              correct: true,
              points: 15,
              feedback: "Correct! Unsanitized HTML can run scripts in victims' browsers.",
              nextStep: 1
            },
            {
              text: "The comment might not display properly",
              correct: false,
              points: 5,
              feedback: "Display issues are minor compared to security risks.",
              nextStep: 0
            },
            {
              text: "The website might block your comment",
              correct: false,
              points: 5,
              feedback: "If the site blocks it, that would be a protection, not a vulnerability.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You test the comment system with simple HTML. What's the safe testing approach?",
          choices: [
            {
              text: "Use harmless HTML like <b>test</b> to confirm the vulnerability",
              correct: true,
              points: 20,
              feedback: "Good! Use safe payloads that demonstrate the issue without causing harm.",
              nextStep: 2
            },
            {
              text: "Try to steal other users' cookies with malicious scripts",
              correct: false,
              points: -30,
              feedback: "Never attempt to steal real user data during testing.",
              nextStep: 2
            },
            {
              text: "Post many comments with scripts to see if they're blocked",
              correct: false,
              points: -15,
              feedback: "Excessive testing could be considered spam or abuse.",
              nextStep: 2
            }
          ]
        },
        {
          text: "XSS vulnerability found! Comment system executes unsanitized HTML from users.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you secure the comment system against XSS?",
          choices: [
            {
              text: "HTML encode all user input before displaying it",
              correct: true,
              points: 15,
              feedback: "Correct! Encoding converts special characters to safe equivalents.",
              nextStep: 1
            },
            {
              text: "Block all HTML tags in comments",
              correct: false,
              points: -10,
              feedback: "This might be too restrictive - better to sanitize properly.",
              nextStep: 1
            },
            {
              text: "Use a WAF to filter malicious input",
              correct: false,
              points: 5,
              feedback: "WAFs help but don't replace proper input sanitization in code.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive approach to prevent XSS?",
          choices: [
            {
              text: "Input validation, output encoding, and Content Security Policy",
              correct: true,
              points: 20,
              feedback: "Excellent! Multiple layers provide defense in depth against XSS.",
              nextStep: 2
            },
            {
              text: "Only allow plain text in comments",
              correct: false,
              points: -15,
              feedback: "This limits functionality - better to allow safe HTML with proper sanitization.",
              nextStep: 2
            },
            {
              text: "Trust users to not write malicious code",
              correct: false,
              points: -25,
              feedback: "Never trust user input - always validate and sanitize.",
              nextStep: 2
            }
          ]
        },
        {
          text: "XSS protection implemented! All user input now properly sanitized and encoded.",
          choices: []
        }
      ]
    }
  },

  insecureDesign343: {
    id: 343,
    title: "Predictable Username Generation",
    difficulty: "Easy",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover a system that creates usernames using firstname.lastname pattern. What design flaw enables user enumeration?",
          choices: [
            {
              text: "Predictable usernames make it easy to guess valid accounts",
              correct: true,
              points: 15,
              feedback: "Correct! Predictable naming conventions help attackers identify real users.",
              nextStep: 1
            },
            {
              text: "Usernames might be too long",
              correct: false,
              points: 5,
              feedback: "Length issues are usability problems, not security design flaws.",
              nextStep: 0
            },
            {
              text: "Users might forget their usernames",
              correct: false,
              points: 5,
              feedback: "Memory issues are different from security concerns.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You can guess usernames based on common names. What's the ethical testing approach?",
          choices: [
            {
              text: "Document the predictable pattern without testing real accounts",
              correct: true,
              points: 20,
              feedback: "Good! Identify the design flaw without attempting to access accounts.",
              nextStep: 2
            },
            {
              text: "Try to login with guessed usernames to confirm they exist",
              correct: false,
              points: -20,
              feedback: "Never attempt unauthorized access to user accounts.",
              nextStep: 2
            },
            {
              text: "Create many accounts to analyze the pattern",
              correct: false,
              points: -15,
              feedback: "Creating fake accounts could be considered abuse.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Design flaw found! Predictable username generation enables user enumeration attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you design a secure username system?",
          choices: [
            {
              text: "Let users choose unique usernames or use random identifiers",
              correct: true,
              points: 15,
              feedback: "Correct! User-chosen or random usernames prevent predictability.",
              nextStep: 1
            },
            {
              text: "Use email addresses as usernames exclusively",
              correct: false,
              points: -10,
              feedback: "Email addresses are also predictable and reveal personal information.",
              nextStep: 1
            },
            {
              text: "Add numbers to common names to make them unique",
              correct: false,
              points: -5,
              feedback: "This still follows a predictable pattern that can be guessed.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the best practice for user identification?",
          choices: [
            {
              text: "Use random internal IDs and allow custom display names",
              correct: true,
              points: 20,
              feedback: "Excellent! Separate internal identification from user-facing names.",
              nextStep: 2
            },
            {
              text: "Require unique usernames that are hard to guess",
              correct: false,
              points: -15,
              feedback: "Users often choose predictable usernames - better to use random IDs internally.",
              nextStep: 2
            },
            {
              text: "Use the same username pattern for all systems",
              correct: false,
              points: -20,
              feedback: "Different systems should have different identification approaches.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Username design improved! Now uses random internal IDs with user-chosen display names.",
          choices: []
        }
      ]
    }
  },

  securityMisconfig344: {
    id: 344,
    title: "Default Error Pages Revealing Server Information",
    difficulty: "Easy",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover that application errors show detailed technical information including server version and file paths. What information disclosure risk exists?",
          choices: [
            {
              text: "Attackers learn about the server setup and can plan targeted attacks",
              correct: true,
              points: 15,
              feedback: "Correct! Detailed errors give attackers valuable information about the system.",
              nextStep: 1
            },
            {
              text: "Users might be confused by technical messages",
              correct: false,
              points: 5,
              feedback: "User confusion is a usability issue, not the main security risk.",
              nextStep: 0
            },
            {
              text: "The errors take up too much screen space",
              correct: false,
              points: 5,
              feedback: "Layout issues are different from information disclosure problems.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You trigger an error and see server details. What's the proper response?",
          choices: [
            {
              text: "Document what information is exposed without exploiting it",
              correct: true,
              points: 20,
              feedback: "Good! Identify the information leak without using it for attacks.",
              nextStep: 2
            },
            {
              text: "Use the information to try specific version exploits",
              correct: false,
              points: -25,
              feedback: "Never attempt to exploit vulnerabilities you discover.",
              nextStep: 2
            },
            {
              text: "Ignore it since errors don't happen often",
              correct: false,
              points: -15,
              feedback: "Even rare errors can be triggered intentionally by attackers.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Security misconfiguration found! Error pages expose sensitive server information.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you configure error handling securely?",
          choices: [
            {
              text: "Show user-friendly error messages while logging details internally",
              correct: true,
              points: 15,
              feedback: "Correct! Users get helpful messages while admins get technical details for debugging.",
              nextStep: 1
            },
            {
              text: "Disable all error messages completely",
              correct: false,
              points: -15,
              feedback: "Users need some error feedback - just make it secure and helpful.",
              nextStep: 1
            },
            {
              text: "Only show detailed errors to logged-in users",
              correct: false,
              points: -10,
              feedback: "Even authenticated users shouldn't see sensitive server details.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive error handling strategy?",
          choices: [
            {
              text: "Custom error pages, proper logging, and environment-specific configurations",
              correct: true,
              points: 20,
              feedback: "Excellent! Different environments can have different error detail levels.",
              nextStep: 2
            },
            {
              text: "Use the same error detail level everywhere",
              correct: false,
              points: -20,
              feedback: "Development needs more detail than production for debugging.",
              nextStep: 2
            },
            {
              text: "Block access to error pages with firewall rules",
              correct: false,
              points: -15,
              feedback: "Errors will still occur - better to handle them properly.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Error handling secured! Now shows user-friendly messages while logging technical details.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponents345: {
    id: 345,
    title: "Outdated WordPress Core Version",
    difficulty: "Easy",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover a WordPress website running an old version with known security vulnerabilities. What risk does this create?",
          choices: [
            {
              text: "Attackers can use published exploits to compromise the website",
              correct: true,
              points: 15,
              feedback: "Correct! Known vulnerabilities have publicly available exploit code.",
              nextStep: 1
            },
            {
              text: "The website might have compatibility issues",
              correct: false,
              points: 5,
              feedback: "Compatibility is different from security risk.",
              nextStep: 0
            },
            {
              text: "New features might not be available",
              correct: false,
              points: 5,
              feedback: "Feature availability is not a security concern.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You identify the outdated WordPress version. What's the responsible action?",
          choices: [
            {
              text: "Report the outdated version and recommend updating",
              correct: true,
              points: 20,
              feedback: "Good! Keeping software updated is crucial for security.",
              nextStep: 2
            },
            {
              text: "Try known exploits to demonstrate the risk",
              correct: false,
              points: -30,
              feedback: "Never attempt to exploit vulnerabilities in systems you don't own.",
              nextStep: 2
            },
            {
              text: "Assume the hosting provider will handle updates",
              correct: false,
              points: -15,
              feedback: "Website owners are responsible for keeping their software updated.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Vulnerable component found! Outdated WordPress version with known security issues.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you manage WordPress updates?",
          choices: [
            {
              text: "Enable automatic updates and regularly check for security patches",
              correct: true,
              points: 15,
              feedback: "Correct! Automatic updates help ensure timely security fixes.",
              nextStep: 1
            },
            {
              text: "Only update when adding new features",
              correct: false,
              points: -20,
              feedback: "Security updates should happen regardless of new features.",
              nextStep: 1
            },
            {
              text: "Wait for others to test updates before applying them",
              correct: false,
              points: -10,
              feedback: "Security updates should be applied promptly, with proper testing procedures.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the best practice for WordPress maintenance?",
          choices: [
            {
              text: "Regular updates, security scanning, and backups before changes",
              correct: true,
              points: 20,
              feedback: "Excellent! Comprehensive maintenance includes updates, monitoring, and recovery planning.",
              nextStep: 2
            },
            {
              text: "Disable updates to avoid breaking changes",
              correct: false,
              points: -25,
              feedback: "This leaves the site vulnerable to known attacks.",
              nextStep: 2
            },
            {
              text: "Only update the WordPress core, not plugins",
              correct: false,
              points: -20,
              feedback: "Plugins often have vulnerabilities and need updates too.",
              nextStep: 2
            }
          ]
        },
        {
          text: "WordPress maintenance established! Now using automatic updates with regular security checks.",
          choices: []
        }
      ]
    }
  },

  authFailure346: {
    id: 346,
    title: "No Session Timeout",
    difficulty: "Easy",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover that user sessions never expire, even after days of inactivity. What authentication risk does this create?",
          choices: [
            {
              text: "Stolen devices or sessions provide indefinite access to accounts",
              correct: true,
              points: 15,
              feedback: "Correct! Unlimited sessions mean stolen login sessions work forever.",
              nextStep: 1
            },
            {
              text: "Users might forget they're logged in",
              correct: false,
              points: 5,
              feedback: "This is a minor convenience issue, not the main security risk.",
              nextStep: 0
            },
            {
              text: "Server memory might fill up with old sessions",
              correct: false,
              points: 5,
              feedback: "Server resource issues are different from authentication security.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You confirm sessions don't expire. What's the ethical testing approach?",
          choices: [
            {
              text: "Document the missing session timeout without accessing real accounts",
              correct: true,
              points: 20,
              feedback: "Good! Identify the security issue without prolonged unauthorized access.",
              nextStep: 2
            },
            {
              text: "Leave a session open for weeks to prove it doesn't expire",
              correct: false,
              points: -15,
              feedback: "This could be seen as maintaining unauthorized access.",
              nextStep: 2
            },
            {
              text: "Test with multiple user accounts simultaneously",
              correct: false,
              points: -20,
              feedback: "Never use multiple real accounts for security testing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Authentication failure found! User sessions never expire, allowing indefinite access.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you implement session timeouts?",
          choices: [
            {
              text: "Set reasonable inactivity timeouts and absolute session limits",
              correct: true,
              points: 15,
              feedback: "Correct! Both inactivity and absolute timeouts provide layered security.",
              nextStep: 1
            },
            {
              text: "Make users re-login every time they visit",
              correct: false,
              points: -15,
              feedback: "This creates poor user experience - balance security with usability.",
              nextStep: 1
            },
            {
              text: "Only timeout sessions on sensitive actions",
              correct: false,
              points: -10,
              feedback: "All sessions should timeout to prevent indefinite access.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the balanced approach to session management?",
          choices: [
            {
              text: "Reasonable timeouts with remember-me options for convenience",
              correct: true,
              points: 20,
              feedback: "Excellent! Balance security with user convenience through thoughtful design.",
              nextStep: 2
            },
            {
              text: "No timeouts for better user experience",
              correct: false,
              points: -25,
              feedback: "This sacrifices security for convenience - find a middle ground.",
              nextStep: 2
            },
            {
              text: "Very short timeouts for maximum security",
              correct: false,
              points: -20,
              feedback: "Too frequent logins frustrate users and may lead to password reuse.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Session management improved! Now uses reasonable timeouts with user-friendly options.",
          choices: []
        }
      ]
    }
  },

  softwareIntegrity347: {
    id: 347,
    title: "No File Size Validation on Uploads",
    difficulty: "Easy",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover a file upload feature that accepts files of any size without limits. What integrity risk does this create?",
          choices: [
            {
              text: "Large files can fill server storage or cause service disruption",
              correct: true,
              points: 15,
              feedback: "Correct! Unlimited file sizes can lead to denial of service through resource exhaustion.",
              nextStep: 1
            },
            {
              text: "Large files might take longer to upload",
              correct: false,
              points: 5,
              feedback: "Upload time is a performance issue, not the main security risk.",
              nextStep: 0
            },
            {
              text: "Users might upload unnecessary large files",
              correct: false,
              points: 5,
              feedback: "This is a storage management issue, not the core integrity concern.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You test uploading large files. What's the safe testing method?",
          choices: [
            {
              text: "Use large but harmless test files to demonstrate the issue",
              correct: true,
              points: 20,
              feedback: "Good! Test with safe files that won't damage the system.",
              nextStep: 2
            },
            {
              text: "Upload extremely large files to crash the server",
              correct: false,
              points: -30,
              feedback: "Never attempt to disrupt service during security testing.",
              nextStep: 2
            },
            {
              text: "Upload many small files rapidly",
              correct: false,
              points: -15,
              feedback: "This tests a different type of limit - focus on the specific vulnerability.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Integrity vulnerability found! File uploads have no size limits, risking resource exhaustion.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you implement file size limits?",
          choices: [
            {
              text: "Set reasonable size limits based on actual needs",
              correct: true,
              points: 15,
              feedback: "Correct! Limits should be practical for the application's purpose.",
              nextStep: 1
            },
            {
              text: "Allow any size but compress files automatically",
              correct: false,
              points: -10,
              feedback: "Compression has limits and doesn't prevent extremely large uploads.",
              nextStep: 1
            },
            {
              text: "Only limit sizes for certain file types",
              correct: false,
              points: -15,
              feedback: "All file types should have reasonable size limits.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive file upload security approach?",
          choices: [
            {
              text: "Size limits, type validation, and malware scanning",
              correct: true,
              points: 20,
              feedback: "Excellent! Multiple security layers protect against various file upload threats.",
              nextStep: 2
            },
            {
              text: "Only rely on client-side size checks",
              correct: false,
              points: -25,
              feedback: "Client-side checks can be bypassed - always validate server-side.",
              nextStep: 2
            },
            {
              text: "Set very small limits to be safe",
              correct: false,
              points: -20,
              feedback: "Limits should be reasonable for the application's functionality.",
              nextStep: 2
            }
          ]
        },
        {
          text: "File upload security implemented! Now has reasonable size limits with comprehensive validation.",
          choices: []
        }
      ]
    }
  },

  loggingFailures348: {
    id: 348,
    title: "No Audit Trail for User Actions",
    difficulty: "Easy",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover that user actions like profile changes or settings modifications aren't logged. What monitoring gap exists?",
          choices: [
            {
              text: "Unauthorized changes can't be detected or investigated",
              correct: true,
              points: 15,
              feedback: "Correct! Without logging, there's no record of what happened for investigation.",
              nextStep: 1
            },
            {
              text: "Users might not remember what they changed",
              correct: false,
              points: 5,
              feedback: "User memory is a convenience issue, not a security monitoring gap.",
              nextStep: 0
            },
            {
              text: "The application might use more memory",
              correct: false,
              points: 5,
              feedback: "Resource usage is different from security monitoring.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You confirm user actions aren't being logged. What's the proper documentation approach?",
          choices: [
            {
              text: "List the types of user actions that should be logged for security",
              correct: true,
              points: 20,
              feedback: "Good! Specific recommendations help developers implement proper logging.",
              nextStep: 2
            },
            {
              text: "Make unauthorized changes to prove they're not logged",
              correct: false,
              points: -25,
              feedback: "Never make unauthorized changes, even for testing.",
              nextStep: 2
            },
            {
              text: "Assume logging isn't important for user actions",
              correct: false,
              points: -15,
              feedback: "User action logging is crucial for security investigations.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Logging failure found! User actions aren't recorded, preventing security monitoring.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "What user actions should be logged for security?",
          choices: [
            {
              text: "Login/logout, password changes, and sensitive data modifications",
              correct: true,
              points: 15,
              feedback: "Correct! These are critical security events that need monitoring.",
              nextStep: 1
            },
            {
              text: "Only failed login attempts",
              correct: false,
              points: -15,
              feedback: "Successful security-related actions also need logging.",
              nextStep: 1
            },
            {
              text: "Every single user action regardless of importance",
              correct: false,
              points: -10,
              feedback: "Focus on security-relevant actions to avoid log overload.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the best practice for security logging?",
          choices: [
            {
              text: "Log security events with timestamps, user info, and action details",
              correct: true,
              points: 20,
              feedback: "Excellent! Comprehensive logging provides context for investigations.",
              nextStep: 2
            },
            {
              text: "Only log events during business hours",
              correct: false,
              points: -25,
              feedback: "Security events can happen anytime - logging should be continuous.",
              nextStep: 2
            },
            {
              text: "Store logs with the application data",
              correct: false,
              points: -20,
              feedback: "Logs should be stored separately for security and integrity.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Security logging implemented! Critical user actions now properly recorded and monitored.",
          choices: []
        }
      ]
    }
  },

  ssrf349: {
    id: 349,
    title: "SSRF in Avatar URL Import",
    difficulty: "Easy",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "You discover a profile system that lets users set avatars by providing image URLs. The server downloads from any URL provided. What SSRF risk exists?",
          choices: [
            {
              text: "The server can be tricked into accessing internal services or malicious sites",
              correct: true,
              points: 15,
              feedback: "Correct! Server-side requests can reach places users normally can't access.",
              nextStep: 1
            },
            {
              text: "Users might set inappropriate avatars",
              correct: false,
              points: 5,
              feedback: "Content moderation is different from SSRF vulnerability.",
              nextStep: 0
            },
            {
              text: "Avatar images might not load properly",
              correct: false,
              points: 5,
              feedback: "Loading issues are functional problems, not security risks.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You test the avatar URL feature. What's the safe testing approach?",
          choices: [
            {
              text: "Use public image URLs to confirm the server makes the requests",
              correct: true,
              points: 20,
              feedback: "Good! Test with safe, public resources to understand the vulnerability.",
              nextStep: 2
            },
            {
              text: "Try to access internal company servers",
              correct: false,
              points: -30,
              feedback: "Never attempt to access internal systems without authorization.",
              nextStep: 2
            },
            {
              text: "Point to non-image files to see what happens",
              correct: false,
              points: -15,
              feedback: "This could cause unexpected behavior - stick to safe testing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF vulnerability found! Avatar import feature allows server to request any URL.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you secure the avatar URL import feature?",
          choices: [
            {
              text: "Validate URLs and restrict to specific domains or image hosts",
              correct: true,
              points: 15,
              feedback: "Correct! Control where the server can make requests for images.",
              nextStep: 1
            },
            {
              text: "Only allow URLs from popular social media sites",
              correct: false,
              points: -10,
              feedback: "Even popular sites can be abused - use proper validation.",
              nextStep: 1
            },
            {
              text: "Add a warning about appropriate image URLs",
              correct: false,
              points: -5,
              feedback: "Warnings don't prevent SSRF attacks - technical controls are needed.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive SSRF protection strategy?",
          choices: [
            {
              text: "URL validation, network restrictions, and content type verification",
              correct: true,
              points: 20,
              feedback: "Excellent! Multiple layers prevent various SSRF attack vectors.",
              nextStep: 2
            },
            {
              text: "Disable URL imports completely",
              correct: false,
              points: -15,
              feedback: "The feature is useful - just needs to be secured properly.",
              nextStep: 2
            },
            {
              text: "Only allow data URLs for avatars",
              correct: false,
              points: -20,
              feedback: "This limits functionality - better to allow external URLs with proper security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF protection implemented! Avatar imports now validated and restricted securely.",
          choices: []
        }
      ]
    }
  },

  
  accessControl350: {
    id: 350,
    title: "Insecure Business Logic in Auction Bidding System",
    difficulty: "Medium",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover an auction platform where users can modify bid amounts by intercepting and altering API requests before they reach the server. What business logic flaw exists?",
          choices: [
            {
              text: "Client-side bid validation allows users to submit any bid amount regardless of rules",
              correct: true,
              points: 20,
              feedback: "Critical finding! Client-side controls can be bypassed, enabling bid manipulation and auction fraud.",
              nextStep: 1
            },
            {
              text: "The bidding interface might have usability issues",
              correct: false,
              points: 5,
              feedback: "Usability problems are different from business logic vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Bid amounts might not display correctly",
              correct: false,
              points: 5,
              feedback: "Display issues are visual, not business logic flaws.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully submit an invalid bid by modifying the API request. What's the professional testing approach?",
          choices: [
            {
              text: "Demonstrate the vulnerability in a test environment without affecting real auctions",
              correct: true,
              points: 25,
              feedback: "Professional approach! Testing in controlled environments proves the vulnerability without harm.",
              nextStep: 2
            },
            {
              text: "Actually manipulate bids in a live auction to prove impact",
              correct: false,
              points: -40,
              feedback: "Never interfere with real business transactions or financial systems.",
              nextStep: 2
            },
            {
              text: "Only report the API endpoint without testing",
              correct: false,
              points: 10,
              feedback: "Testing is necessary to confirm the vulnerability, but do it safely.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Business logic vulnerability found! Client-side bid validation enables auction manipulation and financial fraud.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you secure the auction bidding system?",
          choices: [
            {
              text: "Implement server-side validation for all bid rules and amounts",
              correct: true,
              points: 20,
              feedback: "Essential! All business logic must be enforced server-side where it can't be bypassed.",
              nextStep: 1
            },
            {
              text: "Add cryptographic signatures to client requests",
              correct: false,
              points: 10,
              feedback: "Signatures help but don't replace server-side business logic validation.",
              nextStep: 1
            },
            {
              text: "Use thicker client with obfuscated validation logic",
              correct: false,
              points: -15,
              feedback: "Client-side protections can always be bypassed - trust the server.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What comprehensive auction security should you implement?",
          choices: [
            {
              text: "Server-side validation, bid history auditing, and real-time fraud detection",
              correct: true,
              points: 25,
              feedback: "Enterprise solution! Multiple layers including validation, audit trails, and proactive monitoring.",
              nextStep: 2
            },
            {
              text: "Allow any bids but review them manually later",
              correct: false,
              points: -30,
              feedback: "Manual review doesn't prevent real-time auction manipulation.",
              nextStep: 2
            },
            {
              text: "Use the same validation rules for all auction types",
              correct: false,
              points: -20,
              feedback: "Different auction types may require different business rules.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Auction security established! All bids now validated server-side with comprehensive business rules.",
          choices: []
        }
      ]
    }
  },

  cryptoFailures351: {
    id: 351,
    title: "Insecure Session Token Storage in Mobile App",
    difficulty: "Medium",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover a mobile app storing session tokens in plain text in shared preferences. What cryptographic risk exists?",
          choices: [
            {
              text: "Tokens can be easily extracted from device storage, enabling account takeover",
              correct: true,
              points: 20,
              feedback: "Critical finding! Plain text token storage allows easy extraction from compromised devices.",
              nextStep: 1
            },
            {
              text: "The app might use too much device storage",
              correct: false,
              points: 5,
              feedback: "Storage usage is operational, not a cryptographic vulnerability.",
              nextStep: 0
            },
            {
              text: "Tokens might expire too quickly",
              correct: false,
              points: 5,
              feedback: "Expiration timing is a session management issue, not storage security.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You extract session tokens from the app's storage. What's the ethical demonstration approach?",
          choices: [
            {
              text: "Document the extraction method without using the tokens to access accounts",
              correct: true,
              points: 25,
              feedback: "Professional approach! Prove vulnerability existence without unauthorized access.",
              nextStep: 2
            },
            {
              text: "Use extracted tokens to login and confirm they work",
              correct: false,
              points: -35,
              feedback: "Never use stolen tokens to access real user accounts.",
              nextStep: 2
            },
            {
              text: "Only report the storage location without proving extraction",
              correct: false,
              points: 10,
              feedback: "Demonstrating the extraction proves the vulnerability's severity.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cryptographic failure found! Session tokens stored in plain text, enabling easy account compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you securely store session tokens in mobile apps?",
          choices: [
            {
              text: "Use platform secure storage like Android Keystore or iOS Keychain",
              correct: true,
              points: 20,
              feedback: "Essential! Platform secure storage provides hardware-backed protection where available.",
              nextStep: 1
            },
            {
              text: "Encrypt tokens with a hardcoded key in the app",
              correct: false,
              points: -20,
              feedback: "Hardcoded keys can be extracted - use platform security features.",
              nextStep: 1
            },
            {
              text: "Store tokens in memory only during app usage",
              correct: false,
              points: -15,
              feedback: "This breaks user experience when apps restart - use proper secure storage.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What comprehensive mobile app security should you implement?",
          choices: [
            {
              text: "Secure storage, certificate pinning, and root/jailbreak detection",
              correct: true,
              points: 25,
              feedback: "Enterprise mobile security! Multiple layers including storage protection, communication security, and device integrity checks.",
              nextStep: 2
            },
            {
              text: "Use the same token storage method for all mobile platforms",
              correct: false,
              points: -25,
              feedback: "Different platforms have different secure storage APIs - use them appropriately.",
              nextStep: 2
            },
            {
              text: "Disable token persistence for security",
              correct: false,
              points: -20,
              feedback: "This creates poor user experience - implement secure persistence instead.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Mobile app security established! All sensitive data now stored using platform secure storage.",
          choices: []
        }
      ]
    }
  },

  injection352: {
    id: 352,
    title: "LDAP Injection in Employee Directory",
    difficulty: "Medium",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover an employee directory that builds LDAP queries with user input for searching people. What injection risk exists?",
          choices: [
            {
              text: "LDAP injection can bypass search filters and extract sensitive employee information",
              correct: true,
              points: 20,
              feedback: "Critical finding! LDAP injection can expose directory information and bypass access controls.",
              nextStep: 1
            },
            {
              text: "Search results might be incomplete",
              correct: false,
              points: 5,
              feedback: "Result completeness is a functionality issue, not an injection vulnerability.",
              nextStep: 0
            },
            {
              text: "The directory might respond slowly to complex queries",
              correct: false,
              points: 5,
              feedback: "Performance issues are different from security vulnerabilities.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully extract hidden employee data through LDAP injection. What's the professional testing scope?",
          choices: [
            {
              text: "Test in a development directory environment and document the attack vector",
              correct: true,
              points: 25,
              feedback: "Professional scope! Use test environments to prove vulnerabilities without accessing production data.",
              nextStep: 2
            },
            {
              text: "Extract real employee data to demonstrate the impact",
              correct: false,
              points: -45,
              feedback: "Never access real employee or user data during security testing.",
              nextStep: 2
            },
            {
              text: "Only test with simple search terms",
              correct: false,
              points: 10,
              feedback: "Comprehensive testing is needed, but do it safely in appropriate environments.",
              nextStep: 2
            }
          ]
        },
        {
          text: "LDAP injection vulnerability found! User input in directory searches enables information disclosure.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you prevent LDAP injection in directory searches?",
          choices: [
            {
              text: "Use parameterized LDAP queries and input validation with escaping",
              correct: true,
              points: 20,
              feedback: "Essential! Parameterized queries separate LDAP code from user data safely.",
              nextStep: 1
            },
            {
              text: "Escape only special characters in user input",
              correct: false,
              points: 10,
              feedback: "Escaping helps but parameterization is more reliable and comprehensive.",
              nextStep: 1
            },
            {
              text: "Use client-side validation to filter search terms",
              correct: false,
              points: -20,
              feedback: "Client-side controls can be bypassed - always validate server-side.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What comprehensive directory security should you implement?",
          choices: [
            {
              text: "Parameterized queries, search result filtering, and access auditing",
              correct: true,
              points: 25,
              feedback: "Enterprise directory security! Includes injection prevention, data protection, and activity monitoring.",
              nextStep: 2
            },
            {
              text: "Allow unlimited wildcard searches for flexibility",
              correct: false,
              points: -30,
              feedback: "Wildcard searches can be abused for information harvesting.",
              nextStep: 2
            },
            {
              text: "Use the same LDAP bind account for all applications",
              correct: false,
              points: -25,
              feedback: "Application-specific accounts provide better security isolation.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Directory security established! All LDAP queries now use parameterization with proper access controls.",
          choices: []
        }
      ]
    }
  },

  insecureDesign353: {
    id: 353,
    title: "Insecure Password Recovery Questions",
    difficulty: "Medium",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover a password recovery system using common security questions with limited possible answers. What design flaw enables account takeover?",
          choices: [
            {
              text: "Predictable answers and limited options make questions easy to guess",
              correct: true,
              points: 20,
              feedback: "Critical finding! Common security questions often have easily researchable or guessable answers.",
              nextStep: 1
            },
            {
              text: "Users might forget their answers",
              correct: false,
              points: 5,
              feedback: "User memory issues are usability problems, not design flaws.",
              nextStep: 0
            },
            {
              text: "The questions might be too personal",
              correct: false,
              points: 5,
              feedback: "Personal nature is different from security predictability.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You demonstrate guessing security question answers through research. What's the ethical approach?",
          choices: [
            {
              text: "Document the predictability without actually recovering any accounts",
              correct: true,
              points: 25,
              feedback: "Professional approach! Prove the design flaw without compromising real accounts.",
              nextStep: 2
            },
            {
              text: "Actually recover test accounts to prove the vulnerability",
              correct: false,
              points: -30,
              feedback: "Even test account recovery could have unintended consequences.",
              nextStep: 2
            },
            {
              text: "Only analyze the question patterns statistically",
              correct: false,
              points: 10,
              feedback: "Statistical analysis is good but should be combined with practical assessment.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Design flaw found! Insecure password recovery questions enable account takeover through guessing.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you design a secure password recovery system?",
          choices: [
            {
              text: "Use multi-factor authentication and time-limited recovery links",
              correct: true,
              points: 20,
              feedback: "Essential! Multi-factor recovery is more secure than knowledge-based questions.",
              nextStep: 1
            },
            {
              text: "Add more security questions for better protection",
              correct: false,
              points: -15,
              feedback: "More weak factors don't create strong security - use different approaches.",
              nextStep: 1
            },
            {
              text: "Make security questions more obscure and complex",
              correct: false,
              points: -10,
              feedback: "Complex questions often lead to users forgetting answers or writing them down.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the modern approach to account recovery?",
          choices: [
            {
              text: "Email/SMS verification, backup codes, and account recovery time delays",
              correct: true,
              points: 25,
              feedback: "Modern account security! Includes multiple verification methods and anti-hammering protections.",
              nextStep: 2
            },
            {
              text: "Use the same recovery method for all user types",
              correct: false,
              points: -20,
              feedback: "Different user risk levels may require different recovery methods.",
              nextStep: 2
            },
            {
              text: "Allow instant recovery for user convenience",
              correct: false,
              points: -25,
              feedback: "Recovery time delays help prevent account takeover attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Password recovery security redesigned! Now uses multi-factor verification with proper safeguards.",
          choices: []
        }
      ]
    }
  },

  securityMisconfig354: {
    id: 354,
    title: "Exposed Docker API Endpoint",
    difficulty: "Medium",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover a Docker daemon API endpoint exposed to the network without authentication. What container security risk exists?",
          choices: [
            {
              text: "Complete container control enabling container escape and host compromise",
              correct: true,
              points: 20,
              feedback: "Critical finding! Exposed Docker API provides full control over containers and potentially the host system.",
              nextStep: 1
            },
            {
              text: "Containers might have performance issues",
              correct: false,
              points: 5,
              feedback: "Performance is operational, not a security misconfiguration risk.",
              nextStep: 0
            },
            {
              text: "Container images might be outdated",
              correct: false,
              points: 5,
              feedback: "Image currency is a maintenance issue, not an API exposure problem.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You identify the exposed Docker API. What's the professional assessment approach?",
          choices: [
            {
              text: "Document the exposure and potential impact without exploiting it",
              correct: true,
              points: 25,
              feedback: "Professional assessment! Identify the risk without attempting container compromise.",
              nextStep: 2
            },
            {
              text: "Actually access the API to list running containers",
              correct: false,
              points: -40,
              feedback: "Unauthorized access to infrastructure APIs is unethical and potentially illegal.",
              nextStep: 2
            },
            {
              text: "Only check if the port is open",
              correct: false,
              points: 10,
              feedback: "Port checking is basic - proper assessment includes understanding the service and risks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical security misconfiguration! Exposed Docker API enables complete container environment compromise.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you secure the Docker daemon API?",
          choices: [
            {
              text: "Use TLS with client certificate authentication and network restrictions",
              correct: true,
              points: 20,
              feedback: "Essential! Docker API should require TLS encryption and proper authentication.",
              nextStep: 1
            },
            {
              text: "Change the default port to hide the service",
              correct: false,
              points: -20,
              feedback: "Security through obscurity doesn't work - use proper authentication.",
              nextStep: 1
            },
            {
              text: "Allow network access but require basic authentication",
              correct: false,
              points: -15,
              feedback: "Basic authentication over unencrypted connections is insufficient.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What comprehensive container security should you implement?",
          choices: [
            {
              text: "API security, non-root containers, and regular vulnerability scanning",
              correct: true,
              points: 25,
              feedback: "Enterprise container security! Includes access control, runtime security, and maintenance.",
              nextStep: 2
            },
            {
              text: "Use the same Docker configuration for all environments",
              correct: false,
              points: -25,
              feedback: "Different environments may require different security configurations.",
              nextStep: 2
            },
            {
              text: "Disable the Docker API entirely",
              correct: false,
              points: -20,
              feedback: "The API is needed for management - secure it properly instead.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Docker security established! API now secured with TLS authentication and network controls.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponents355: {
    id: 355,
    title: "Vulnerable Apache Struts Framework",
    difficulty: "Medium",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover a web application using an outdated Apache Struts version with known remote code execution vulnerabilities. What exploitation risk exists?",
          choices: [
            {
              text: "Public exploits can achieve remote code execution on the server",
              correct: true,
              points: 20,
              feedback: "Critical finding! Struts vulnerabilities often allow complete server compromise.",
              nextStep: 1
            },
            {
              text: "The application might have compatibility issues",
              correct: false,
              points: 5,
              feedback: "Compatibility is different from security vulnerability risk.",
              nextStep: 0
            },
            {
              text: "Web pages might render incorrectly",
              correct: false,
              points: 5,
              feedback: "Rendering issues are visual, not security problems.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You identify the vulnerable Struts version. What's the professional reporting approach?",
          choices: [
            {
              text: "Provide detailed version information and CVE references without testing exploits",
              correct: true,
              points: 25,
              feedback: "Professional reporting! Specific vulnerability references enable quick remediation.",
              nextStep: 2
            },
            {
              text: "Test public exploits in a production-like environment",
              correct: false,
              points: -35,
              feedback: "Never test exploits, even in similar environments - this could cause damage.",
              nextStep: 2
            },
            {
              text: "Only report the framework name without version details",
              correct: false,
              points: 10,
              feedback: "Version-specific information is crucial for effective remediation.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical vulnerable component! Outdated Struts framework with known RCE vulnerabilities.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you address the vulnerable Struts framework?",
          choices: [
            {
              text: "Immediately update to a patched version and conduct security testing",
              correct: true,
              points: 20,
              feedback: "Essential! Critical vulnerabilities require immediate patching and validation.",
              nextStep: 1
            },
            {
              text: "Add WAF rules to block exploit attempts",
              correct: false,
              points: 10,
              feedback: "WAFs help but don't fix the root vulnerability in the framework.",
              nextStep: 1
            },
            {
              text: "Wait for the next scheduled maintenance window",
              correct: false,
              points: -30,
              feedback: "Critical RCE vulnerabilities should be patched immediately, not delayed.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What comprehensive framework security should you implement?",
          choices: [
            {
              text: "Regular dependency scanning, patch management process, and security monitoring",
              correct: true,
              points: 25,
              feedback: "Enterprise framework security! Includes detection, process, and monitoring.",
              nextStep: 2
            },
            {
              text: "Freeze framework versions after initial development",
              correct: false,
              points: -35,
              feedback: "Frozen versions accumulate security vulnerabilities over time.",
              nextStep: 2
            },
            {
              text: "Use the same framework version across all applications",
              correct: false,
              points: -25,
              feedback: "Different applications may require different versions based on their needs.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Framework security established! Now using patched version with ongoing vulnerability management.",
          choices: []
        }
      ]
    }
  },

  authFailure356: {
    id: 356,
    title: "JWT Token Without Proper Validation",
    difficulty: "Medium",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover a JWT implementation that doesn't verify token signatures or validate the 'alg' field. What authentication bypass risk exists?",
          choices: [
            {
              text: "Token forgery and algorithm confusion attacks enabling privilege escalation",
              correct: true,
              points: 20,
              feedback: "Critical finding! Missing JWT validation allows token manipulation and authentication bypass.",
              nextStep: 1
            },
            {
              text: "Tokens might be too large for network transmission",
              correct: false,
              points: 5,
              feedback: "Token size is operational, not an authentication vulnerability.",
              nextStep: 0
            },
            {
              text: "Token expiration might not work properly",
              correct: false,
              points: 5,
              feedback: "Expiration issues are different from signature validation problems.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully forge a JWT token. What's the professional testing methodology?",
          choices: [
            {
              text: "Create test tokens in a controlled environment to prove the vulnerability",
              correct: true,
              points: 25,
              feedback: "Professional methodology! Controlled testing proves the flaw without accessing real systems.",
              nextStep: 2
            },
            {
              text: "Use forged tokens to access production user accounts",
              correct: false,
              points: -50,
              feedback: "Never use forged credentials to access real systems or user data.",
              nextStep: 2
            },
            {
              text: "Only analyze the token structure without testing",
              correct: false,
              points: 10,
              feedback: "Analysis is good but should be combined with safe validation testing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Authentication failure found! JWT tokens accepted without proper signature validation.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you properly validate JWT tokens?",
          choices: [
            {
              text: "Verify signatures, validate 'alg' field, and check standard claims",
              correct: true,
              points: 20,
              feedback: "Essential! Comprehensive JWT validation includes cryptographic verification and claim checking.",
              nextStep: 1
            },
            {
              text: "Only check token expiration and basic structure",
              correct: false,
              points: -25,
              feedback: "Missing signature validation enables complete token forgery.",
              nextStep: 1
            },
            {
              text: "Use client-side token validation for performance",
              correct: false,
              points: -20,
              feedback: "Client-side validation can be bypassed - always validate server-side.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What comprehensive JWT security should you implement?",
          choices: [
            {
              text: "Proper validation, key rotation, and token revocation mechanisms",
              correct: true,
              points: 25,
              feedback: "Enterprise JWT security! Includes validation, key management, and lifecycle controls.",
              nextStep: 2
            },
            {
              text: "Use the same signing key for all environments",
              correct: false,
              points: -30,
              feedback: "Key separation prevents test tokens from working in production.",
              nextStep: 2
            },
            {
              text: "Disable token expiration for better user experience",
              correct: false,
              points: -35,
              feedback: "Token expiration is essential for security - balance with user convenience.",
              nextStep: 2
            }
          ]
        },
        {
          text: "JWT security established! All tokens now properly validated with comprehensive security checks.",
          choices: []
        }
      ]
    }
  },

  softwareIntegrity357: {
    id: 357,
    title: "Insecure Deserialization in Java Application",
    difficulty: "Medium",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover a Java application that deserializes user-controlled data without validation. What remote code execution risk exists?",
          choices: [
            {
              text: "Gadget chain attacks can execute arbitrary code during deserialization",
              correct: true,
              points: 20,
              feedback: "Critical finding! Java deserialization vulnerabilities can lead to remote code execution.",
              nextStep: 1
            },
            {
              text: "Data might be corrupted during processing",
              correct: false,
              points: 5,
              feedback: "Data corruption is a reliability issue, not an integrity vulnerability.",
              nextStep: 0
            },
            {
              text: "The application might use excessive memory",
              correct: false,
              points: 5,
              feedback: "Memory usage is performance-related, not an integrity concern.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You identify the insecure deserialization vulnerability. What's the safe assessment approach?",
          choices: [
            {
              text: "Analyze the code and document the risky deserialization patterns",
              correct: true,
              points: 25,
              feedback: "Professional assessment! Code analysis identifies the vulnerability without active exploitation.",
              nextStep: 2
            },
            {
              text: "Create and test deserialization payloads in production",
              correct: false,
              points: -45,
              feedback: "Never test exploitation payloads in production environments.",
              nextStep: 2
            },
            {
              text: "Only check if serialized data is being received",
              correct: false,
              points: 10,
              feedback: "Data reception checking is insufficient - analyze how it's processed.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Critical integrity failure! Insecure deserialization enables remote code execution.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you secure Java deserialization?",
          choices: [
            {
              text: "Use safe deserialization libraries and validate input before processing",
              correct: true,
              points: 20,
              feedback: "Essential! Safe deserialization libraries prevent gadget chain attacks.",
              nextStep: 1
            },
            {
              text: "Base64 encode serialized data before transmission",
              correct: false,
              points: -15,
              feedback: "Encoding doesn't prevent deserialization attacks - it's not encryption.",
              nextStep: 1
            },
            {
              "text": "Use Java's native ObjectInputStream with input filtering",
              correct: false,
              points: -20,
              feedback: "ObjectInputStream is inherently unsafe - use dedicated safe libraries.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What comprehensive deserialization security should you implement?",
          choices: [
            {
              text: "Safe deserialization, input validation, and runtime monitoring",
              correct: true,
              points: 25,
              feedback: "Enterprise deserialization security! Includes safe libraries, validation, and detection.",
              nextStep: 2
            },
            {
              text: "Allow deserialization only from trusted network sources",
              correct: false,
              points: -25,
              feedback: "Network trust doesn't prevent malicious payloads from authorized sources.",
              nextStep: 2
            },
            {
              text: "Use the same deserialization method for all data types",
              correct: false,
              points: -20,
              feedback: "Different data types may require different deserialization approaches.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Deserialization security established! Now using safe libraries with comprehensive validation.",
          choices: []
        }
      ]
    }
  },

  loggingFailures358: {
    id: 358,
    title: "Missing Database Query Logging",
    difficulty: "Medium",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover that database queries, especially data modification operations, aren't being logged. What security investigation gap exists?",
          choices: [
            {
              text: "Data breaches and unauthorized changes can't be traced or investigated",
              correct: true,
              points: 20,
              feedback: "Critical finding! Missing database audit trails prevent forensic investigation of security incidents.",
              nextStep: 1
            },
            {
              text: "Database performance might be unclear",
              correct: false,
              points: 5,
              feedback: "Performance monitoring is different from security auditing.",
              nextStep: 0
            },
            {
              text: "Application errors might not be correlated with database issues",
              correct: false,
              points: 5,
              feedback: "Error correlation is troubleshooting, not security monitoring.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You confirm database operations aren't logged. What's the professional assessment approach?",
          choices: [
            {
              text: "Document the logging gap and its impact on security investigations",
              correct: true,
              points: 25,
              feedback: "Professional assessment! Clearly explain how the gap affects incident response.",
              nextStep: 2
            },
            {
              text: "Perform unauthorized data changes to prove they're not logged",
              correct: false,
              points: -40,
              feedback: "Never make unauthorized changes to prove logging deficiencies.",
              nextStep: 2
            },
            {
              text: "Only check if general database logging is enabled",
              correct: false,
              points: 10,
              feedback: "Specific security-relevant operations need explicit auditing.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Logging failure found! Database operations lack audit trails for security monitoring.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "What database operations should be logged for security?",
          choices: [
            {
              text: "Data modifications, schema changes, and privileged operations",
              correct: true,
              points: 20,
              feedback: "Essential! Security auditing should cover data and structural changes.",
              nextStep: 1
            },
            {
              text: "Only failed authentication attempts",
              correct: false,
              points: -20,
              feedback: "Successful operations also need auditing for complete security monitoring.",
              nextStep: 1
            },
            {
              text: "All database queries regardless of type",
              correct: false,
              points: -15,
              feedback: "Focus on security-relevant operations to avoid performance impact.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What comprehensive database auditing should you implement?",
          choices: [
            {
              text: "Query logging, access monitoring, and alerting for suspicious patterns",
              correct: true,
              points: 25,
              feedback: "Enterprise database auditing! Includes logging, monitoring, and proactive detection.",
              nextStep: 2
            },
            {
              text: "Store audit logs in the same database for convenience",
              correct: false,
              points: -30,
              feedback: "Audit logs should be stored separately for security and integrity.",
              nextStep: 2
            },
            {
              text: "Only enable auditing during investigations",
              correct: false,
              points: -35,
              feedback: "Continuous auditing is essential for detecting incidents.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Database auditing established! Critical operations now logged with security monitoring.",
          choices: []
        }
      ]
    }
  },

  ssrf359: {
    id: 359,
    title: "SSRF in Webhook Testing Feature",
    difficulty: "Medium",
    vulnerability: "A10:2021 - Server-Side Request Forgery",
    attacker: {
      story: [
        {
          text: "You discover a webhook testing feature that makes HTTP requests to user-provided URLs for validation. What internal network access risk exists?",
          choices: [
            {
              text: "Server can be made to probe internal services and cloud metadata endpoints",
              correct: true,
              points: 20,
              feedback: "Critical finding! Webhook testing SSRF can access internal networks and cloud services.",
              nextStep: 1
            },
            {
              text: "Webhook deliveries might be unreliable",
              correct: false,
              points: 5,
              feedback: "Delivery reliability is operational, not an SSRF vulnerability.",
              nextStep: 0
            },
            {
              text: "The testing interface might have usability issues",
              correct: false,
              points: 5,
              feedback: "Usability problems are different from security risks.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You confirm the webhook tester makes unrestricted requests. What's the safe testing approach?",
          choices: [
            {
              text: "Use public services to demonstrate the request capability without internal probing",
              correct: true,
              points: 25,
              feedback: "Professional testing! Prove the vulnerability without accessing internal systems.",
              nextStep: 2
            },
            {
              text: "Attempt to access internal company services",
              correct: false,
              points: -45,
              feedback: "Never attempt to access internal networks without authorization.",
              nextStep: 2
            },
            {
              text: "Only test with localhost URLs",
              correct: false,
              points: -20,
              feedback: "Localhost testing could affect the server itself - use external services.",
              nextStep: 2
            }
          ]
        },
        {
          text: "SSRF vulnerability found! Webhook testing feature enables internal network reconnaissance.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How should you secure the webhook testing feature?",
          choices: [
            {
              text: "Implement URL allowlisting and network egress controls",
              correct: true,
              points: 20,
              feedback: "Essential! Restrict where the server can make test requests.",
              nextStep: 1
            },
            {
              text: "Add rate limiting to prevent excessive testing",
              correct: false,
              points: 10,
              feedback: "Rate limiting helps with abuse but doesn't prevent SSRF.",
              nextStep: 1
            },
            {
              text: "Use DNS filtering without IP validation",
              correct: false,
              points: -25,
              feedback: "DNS-based controls don't prevent IP-based internal access.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What comprehensive webhook security should you implement?",
          choices: [
            {
              text: "URL validation, request signing, and security testing safeguards",
              correct: true,
              points: 25,
              feedback: "Enterprise webhook security! Includes input control, authentication, and safe testing.",
              nextStep: 2
            },
            {
              text: "Allow any URL for maximum integration flexibility",
              correct: false,
              points: -35,
              feedback: "Unrestricted URL access creates massive SSRF risks.",
              nextStep: 2
            },
            {
              text: "Disable webhook testing entirely",
              correct: false,
              points: -20,
              feedback: "Testing is valuable - implement it securely instead of disabling.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Webhook security established! Testing now restricted to approved domains with network controls.",
          choices: []
        }
      ]
    }
  },

  
  accessControl360: {
    id: 360,
    title: "Time-Based Access Control Bypass",
    difficulty: "Hard",
    vulnerability: "A01:2021 - Broken Access Control",
    attacker: {
      story: [
        {
          text: "You discover a premium feature that checks subscription status only during login. What happens if a user's subscription expires while they're still logged in?",
          choices: [
            {
              text: "Users maintain access to premium features until they logout and login again",
              correct: true,
              points: 25,
              feedback: "Tricky finding! Time-based access control flaws allow continued access after privileges should be revoked.",
              nextStep: 1
            },
            {
              text: "The feature automatically logs users out when subscription expires",
              correct: false,
              points: 10,
              feedback: "That would be the secure behavior, but we're looking for the vulnerability.",
              nextStep: 0
            },
            {
              text: "Users get error messages but can still use basic features",
              correct: false,
              points: 5,
              feedback: "The issue is specifically about maintaining premium access after expiration.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You test this by letting a trial account expire while maintaining an active session. What's the clever exploitation approach?",
          choices: [
            {
              text: "Maintain long-lived sessions to extend premium access beyond payment",
              correct: true,
              points: 30,
              feedback: "Clever! Session maintenance becomes a way to bypass time-based access controls.",
              nextStep: 2
            },
            {
              text: "Share active session tokens with other users",
              correct: false,
              points: -20,
              feedback: "Session sharing is a different issue - focus on the time-based bypass.",
              nextStep: 2
            },
            {
              text: "Modify system clock to trick the application",
              correct: false,
              points: 15,
              feedback: "Client-side time manipulation usually doesn't affect server-side subscription checks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Tricky access control bypass! Subscription checks only at login enable indefinite premium access through session maintenance.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How do you fix this time-based access control vulnerability?",
          choices: [
            {
              text: "Implement real-time subscription checks for each premium feature access",
              correct: true,
              points: 25,
              feedback: "Essential! Real-time validation prevents time-based privilege escalation.",
              nextStep: 1
            },
            {
              text: "Shorten session expiration times significantly",
              correct: false,
              points: -15,
              feedback: "This creates poor user experience and doesn't guarantee timely privilege revocation.",
              nextStep: 1
            },
            {
              text: "Add client-side subscription countdown timers",
              correct: false,
              points: -20,
              feedback: "Client-side controls can be bypassed - always verify server-side.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the sophisticated approach to time-based access control?",
          choices: [
            {
              text: "Real-time authorization with session invalidation on privilege changes",
              correct: true,
              points: 30,
              feedback: "Sophisticated solution! Combines continuous validation with proactive session management.",
              nextStep: 2
            },
            {
              text: "Check subscription status only during sensitive operations",
              correct: false,
              points: -25,
              feedback: "All premium feature accesses should be validated, not just sensitive ones.",
              nextStep: 2
            },
            {
              text: "Use the same validation frequency for all user types",
              correct: false,
              points: -20,
              feedback: "Different user risk levels may require different validation frequencies.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Time-based access control fixed! Real-time subscription validation now prevents session-based privilege extension.",
          choices: []
        }
      ]
    }
  },

  cryptoFailures361: {
    id: 361,
    title: "Encryption Oracle Attack Vulnerability",
    difficulty: "Hard",
    vulnerability: "A02:2021 - Cryptographic Failures",
    attacker: {
      story: [
        {
          text: "You discover an API that encrypts user data and returns the ciphertext, but also decrypts certain patterns for 'convenience features'. What cryptographic risk exists?",
          choices: [
            {
              text: "Encryption oracle enables chosen ciphertext attacks to decrypt other data",
              correct: true,
              points: 25,
              feedback: "Tricky finding! Mixed encryption/decryption endpoints can create cryptographic oracles.",
              nextStep: 1
            },
            {
              text: "The encryption might use weak algorithms",
              correct: false,
              points: 10,
              feedback: "Algorithm strength is important, but the oracle vulnerability is more subtle.",
              nextStep: 0
            },
            {
              text: "Data might be encrypted twice by mistake",
              correct: false,
              points: 5,
              feedback: "Double encryption is a different issue from oracle attacks.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You notice the system decrypts certain formatted messages for 'preview features'. How can this be exploited?",
          choices: [
            {
              text: "Use the preview feature to decrypt captured ciphertexts by manipulating inputs",
              correct: true,
              points: 30,
              feedback: "Clever! Preview features become decryption oracles for attacker-controlled ciphertext.",
              nextStep: 2
            },
            {
              text: "Brute force the encryption key using the preview",
              correct: false,
              points: -15,
              feedback: "Brute force is impractical against modern encryption - oracle attacks are more feasible.",
              nextStep: 2
            },
            {
              text: "Use the encryption endpoint to hide malicious data",
              correct: false,
              points: 10,
              feedback: "Data hiding is different from the oracle decryption attack.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cryptographic oracle vulnerability! Mixed encryption/decryption endpoints enable chosen ciphertext attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How do you prevent encryption oracle attacks?",
          choices: [
            {
              text: "Separate encryption and decryption services with strict input validation",
              correct: true,
              points: 25,
              feedback: "Essential! Service separation prevents mixed-mode cryptographic operations.",
              nextStep: 1
            },
            {
              text: "Use different keys for encryption and preview features",
              correct: false,
              points: -20,
              feedback: "Key separation helps but doesn't prevent oracle attacks if decryption is still available.",
              nextStep: 1
            },
            {
              text: "Add rate limiting to encryption endpoints",
              correct: false,
              points: 10,
              feedback: "Rate limiting reduces attack speed but doesn't fix the oracle vulnerability.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive cryptographic architecture?",
          choices: [
            {
              text: "Separate services, authenticated encryption, and strict mode separation",
              correct: true,
              points: 30,
              feedback: "Sophisticated architecture! Prevents oracle attacks through service and mode isolation.",
              nextStep: 2
            },
            {
              text: "Allow decryption only for administrative users",
              correct: false,
              points: -25,
              feedback: "Admin access doesn't prevent oracle attacks if the functionality exists.",
              nextStep: 2
            },
            {
              text: "Use the same cryptographic mode for all operations",
              correct: false,
              points: -30,
              feedback: "Different operations may require different cryptographic modes for security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Cryptographic architecture secured! Encryption oracle vulnerability eliminated through service separation.",
          choices: []
        }
      ]
    }
  },

  injection362: {
    id: 362,
    title: "Second-Order SQL Injection Through User Profiles",
    difficulty: "Hard",
    vulnerability: "A03:2021 - Injection",
    attacker: {
      story: [
        {
          text: "You discover a system that properly escapes user input when saving to database, but uses raw stored data in later queries. What subtle injection risk exists?",
          choices: [
            {
              text: "Second-order injection - stored malicious data executes in different context later",
              correct: true,
              points: 25,
              feedback: "Tricky finding! Proper initial escaping doesn't prevent injection when stored data is reused unsafely.",
              nextStep: 1
            },
            {
              text: "The database might corrupt special characters",
              correct: false,
              points: 5,
              feedback: "Database corruption is a data integrity issue, not injection.",
              nextStep: 0
            },
            {
              text: "User profiles might display incorrectly",
              correct: false,
              points: 5,
              feedback: "Display issues are visual, not security vulnerabilities.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You store a carefully crafted payload in your user profile that's escaped on save. How does it become dangerous later?",
          choices: [
            {
              text: "When admin views user reports, your payload executes in an unprotected query context",
              correct: true,
              points: 30,
              feedback: "Clever! The payload becomes dangerous when used in a different, unprotected query context.",
              nextStep: 2
            },
            {
              text: "The payload automatically executes when you login",
              correct: false,
              points: -20,
              feedback: "Second-order injection requires a different context to trigger, not automatic execution.",
              nextStep: 2
            },
            {
              text: "Other users viewing your profile get infected",
              correct: false,
              points: 10,
              feedback: "This would be XSS, not second-order SQL injection.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Second-order SQL injection vulnerability! Properly escaped stored data becomes dangerous when reused in different query contexts.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How do you prevent second-order SQL injection?",
          choices: [
            {
              text: "Treat all database data as untrusted and validate/escape on use, not just storage",
              correct: true,
              points: 25,
              feedback: "Essential! Data should be considered potentially dangerous whenever used in queries.",
              nextStep: 1
            },
            {
              text: "Use stored procedures for all database access",
              correct: false,
              points: -15,
              feedback: "Stored procedures can still be vulnerable to injection if they use dynamic SQL.",
              nextStep: 1
            },
            {
              text: "Block special characters in user profiles entirely",
              correct: false,
              points: -20,
              feedback: "This breaks legitimate use cases - better to handle data safely.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive data handling strategy?",
          choices: [
            {
              text: "Parameterized queries for all database interactions, regardless of data source",
              correct: true,
              points: 30,
              feedback: "Sophisticated strategy! Consistent parameterization prevents injection regardless of data origin.",
              nextStep: 2
            },
            {
              text: "Only validate user input from external sources",
              correct: false,
              points: -30,
              feedback: "Database data should be treated as potentially dangerous too.",
              nextStep: 2
            },
            {
              text: "Use different validation rules for storage vs. usage",
              correct: false,
              points: -25,
              feedback: "Consistent safety practices are better than context-dependent rules.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Second-order injection protection implemented! All database data now treated as potentially dangerous.",
          choices: []
        }
      ]
    }
  },

  insecureDesign363: {
    id: 363,
    title: "Race Condition in Account Balance System",
    difficulty: "Hard",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You discover a banking system that reads account balance, processes transaction, then updates balance without proper locking. What concurrency flaw exists?",
          choices: [
            {
              text: "Race condition allows double-spending through parallel transaction requests",
              correct: true,
              points: 25,
              feedback: "Tricky finding! Lack of proper locking enables balance manipulation through concurrent operations.",
              nextStep: 1
            },
            {
              text: "Transactions might process in wrong order",
              correct: false,
              points: 10,
              feedback: "Ordering issues are different from race condition vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Balance calculations might be inaccurate",
              correct: false,
              points: 5,
              feedback: "Calculation accuracy is different from concurrency safety.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You quickly send multiple transaction requests for the same amount. How does this exploit the race condition?",
          choices: [
            {
              text: "All requests see the original balance and succeed, allowing over-spending",
              correct: true,
              points: 30,
              feedback: "Clever! Concurrent reads before any writes enable multiple transactions against the same balance.",
              nextStep: 2
            },
            {
              text: "The system crashes from too many requests",
              correct: false,
              points: -15,
              feedback: "System crashes are denial of service, not the race condition exploitation.",
              nextStep: 2
            },
            {
              text: "Transactions get processed with incorrect amounts",
              correct: false,
              points: 10,
              feedback: "Amount corruption is different from intentional double-spending.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Race condition vulnerability! Lack of transaction locking enables financial double-spending attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How do you prevent race conditions in financial transactions?",
          choices: [
            {
              text: "Implement database row locking or optimistic concurrency control",
              correct: true,
              points: 25,
              feedback: "Essential! Proper concurrency control prevents simultaneous balance modifications.",
              nextStep: 1
            },
            {
              text: "Add delays between transaction processing",
              correct: false,
              points: -25,
              feedback: "Delays don't guarantee safety and create poor user experience.",
              nextStep: 1
            },
            {
              text: "Process transactions in batches to avoid conflicts",
              correct: false,
              points: -20,
              feedback: "Batching creates latency and doesn't prevent all race conditions.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the sophisticated concurrency approach?",
          choices: [
            {
              text: "Database transactions with proper isolation levels and row locking",
              correct: true,
              points: 30,
              feedback: "Sophisticated solution! Database-level concurrency control provides robust protection.",
              nextStep: 2
            },
            {
              text: "Use the same locking mechanism for all transaction types",
              correct: false,
              points: -25,
              feedback: "Different transaction types may require different concurrency strategies.",
              nextStep: 2
            },
            {
              text: "Allow only one transaction per user at a time",
              correct: false,
              points: -30,
              feedback: "This creates poor user experience and doesn't prevent all race conditions.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Concurrency safety implemented! Financial transactions now protected with proper database locking.",
          choices: []
        }
      ]
    }
  },

  securityMisconfig364: {
    id: 364,
    title: "CORS Misconfiguration with Wildcard and Credentials",
    difficulty: "Hard",
    vulnerability: "A05:2021 - Security Misconfiguration",
    attacker: {
      story: [
        {
          text: "You discover an API that allows credentials but uses wildcard CORS origin. What subtle cross-origin risk exists?",
          choices: [
            {
              text: "Wildcard origin with credentials allows any site to make authenticated requests",
              correct: true,
              points: 25,
              feedback: "Tricky finding! Wildcard origins with credentials create serious cross-origin security issues.",
              nextStep: 1
            },
            {
              text: "The API might be slower for cross-origin requests",
              correct: false,
              points: 5,
              feedback: "Performance impact is not the security risk here.",
              nextStep: 0
            },
            {
              text: "Browser might block all cross-origin requests",
              correct: false,
              points: 5,
              feedback: "Modern browsers actually allow this dangerous configuration with warnings.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You create a malicious website that makes cross-origin requests to the API. Why does this work despite browser security?",
          choices: [
            {
              text: "Wildcard origin tells browser to send credentials to any requesting domain",
              correct: true,
              points: 30,
              feedback: "Clever! The wildcard origin override tells browsers this is intentionally allowed.",
              nextStep: 2
            },
            {
              text: "The API ignores CORS headers entirely",
              correct: false,
              points: -20,
              feedback: "If CORS was ignored, browsers would block the requests.",
              nextStep: 2
            },
            {
              text: "Browsers have a CORS vulnerability",
              correct: false,
              points: 10,
              feedback: "This is application misconfiguration, not a browser vulnerability.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Dangerous CORS misconfiguration! Wildcard origin with credentials enables cross-site authenticated request attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How do you properly configure CORS with credentials?",
          choices: [
            {
              text: "Use specific allowed origins instead of wildcard when credentials are required",
              correct: true,
              points: 25,
              feedback: "Essential! Specific origins are required when using credentials for security.",
              nextStep: 1
            },
            {
              text: "Keep wildcard but add additional security headers",
              correct: false,
              points: -30,
              feedback: "Additional headers don't fix the fundamental CORS misconfiguration.",
              nextStep: 1
            },
            {
              text: "Use wildcard for development but specific origins for production",
              correct: false,
              points: -25,
              feedback: "Development should also use secure configurations to prevent mistakes.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive CORS security strategy?",
          choices: [
            {
              text: "Dynamic origin validation, proper credential handling, and security testing",
              correct: true,
              points: 30,
              feedback: "Sophisticated strategy! Dynamic validation allows flexibility while maintaining security.",
              nextStep: 2
            },
            {
              text: "Allow all origins but require additional authentication",
              correct: false,
              points: -35,
              feedback: "Additional authentication doesn't prevent cross-origin credential exposure.",
              nextStep: 2
            },
            {
              text: "Use the same CORS policy for all API endpoints",
              correct: false,
              points: -30,
              feedback: "Different endpoints may require different CORS policies based on sensitivity.",
              nextStep: 2
            }
          ]
        },
        {
          text: "CORS security fixed! Now uses specific allowed origins with proper credential handling.",
          choices: []
        }
      ]
    }
  },

  vulnerableComponents365: {
    id: 365,
    title: "Dependency Confusion Attack",
    difficulty: "Hard",
    vulnerability: "A06:2021 - Vulnerable and Outdated Components",
    attacker: {
      story: [
        {
          text: "You discover a company using internal private packages but relying on public package repositories without namespace protection. What supply chain risk exists?",
          choices: [
            {
              text: "Dependency confusion - attackers can publish malicious public packages with same names",
              correct: true,
              points: 25,
              feedback: "Tricky finding! Mixed public/private dependencies enable package namespace hijacking.",
              nextStep: 1
            },
            {
              text: "Internal packages might have version conflicts",
              correct: false,
              points: 10,
              feedback: "Version conflicts are dependency management issues, not supply chain attacks.",
              nextStep: 0
            },
            {
              text: "Build system might download wrong package versions",
              correct: false,
              points: 5,
              feedback: "Version selection issues are different from intentional namespace hijacking.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You notice internal package '@company/utils' isn't published publicly. How can this be exploited?",
          choices: [
            {
              text: "Publish malicious '@company/utils' to public registry with higher version number",
              correct: true,
              points: 30,
              feedback: "Clever! Build systems often prefer higher version numbers, enabling malicious package injection.",
              nextStep: 2
            },
            {
              text: "Report the missing package as a security issue",
              correct: false,
              points: 15,
              feedback: "While this is good practice, we're looking for the exploitation technique.",
              nextStep: 2
            },
            {
              text: "Create a typo-squatting version of the package name",
              correct: false,
              points: 10,
              feedback: "Typo-squatting is different from dependency confusion attacks.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Dependency confusion vulnerability! Unprotected internal package names enable supply chain attacks through public registry poisoning.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How do you prevent dependency confusion attacks?",
          choices: [
            {
              text: "Use scoped packages and configure package managers to prefer private registries",
              correct: true,
              points: 25,
              feedback: "Essential! Scoped packages and registry configuration prevent namespace conflicts.",
              nextStep: 1
            },
            {
              text: "Publish all internal packages to public registry",
              correct: false,
              points: -30,
              feedback: "This exposes internal code and doesn't prevent malicious versions.",
              nextStep: 1
            },
            {
              text: "Use checksum verification for all downloads",
              correct: false,
              points: 10,
              feedback: "Checksums help but don't prevent the initial malicious package download.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive supply chain security approach?",
          choices: [
            {
              text: "Scoped packages, registry mirrors, and software composition analysis",
              correct: true,
              points: 30,
              feedback: "Sophisticated approach! Multiple layers protect against various supply chain attacks.",
              nextStep: 2
            },
            {
              text: "Allow only verified publishers in public registries",
              correct: false,
              points: -25,
              feedback: "This doesn't work for organizations using their own unpublished packages.",
              nextStep: 2
            },
            {
              text: "Use the same package sources for all environments",
              correct: false,
              points: -30,
              feedback: "Different environments may require different package sources for security.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Supply chain security established! Dependency confusion attacks prevented through proper package scoping and registry configuration.",
          choices: []
        }
      ]
    }
  },

  authFailure366: {
    id: 366,
    title: "JWT Algorithm Confusion Attack",
    difficulty: "Hard",
    vulnerability: "A07:2021 - Identification and Authentication Failures",
    attacker: {
      story: [
        {
          text: "You discover a JWT implementation that supports multiple algorithms including 'none'. What cryptographic bypass risk exists?",
          choices: [
            {
              text: "Algorithm confusion allows token forgery by switching to unsigned 'none' algorithm",
              correct: true,
              points: 25,
              feedback: "Tricky finding! Algorithm flexibility enables switching to vulnerable or unsigned algorithms.",
              nextStep: 1
            },
            {
              text: "Tokens might be too large for some systems",
              correct: false,
              points: 5,
              feedback: "Size issues are operational, not authentication vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Different algorithms might have performance impacts",
              correct: false,
              points: 5,
              feedback: "Performance is not the security risk here.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You modify a JWT to use 'alg': 'none' and remove the signature. Why does the server accept this token?",
          choices: [
            {
              text: "Server trusts the alg field and processes unsigned tokens for 'none' algorithm",
              correct: true,
              points: 30,
              feedback: "Clever! The server blindly follows the alg field without validating it matches expected algorithms.",
              nextStep: 2
            },
            {
              text: "The signature verification has a bug",
              correct: false,
              points: -20,
              feedback: "This is intentional algorithm support, not a verification bug.",
              nextStep: 2
            },
            {
              text: "Browsers automatically fix JWT errors",
              correct: false,
              points: 10,
              feedback: "Browsers don't modify JWT tokens - this is server-side misconfiguration.",
              nextStep: 2
            }
          ]
        },
        {
          text: "JWT algorithm confusion vulnerability! Support for 'none' algorithm enables token forgery and authentication bypass.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How do you prevent JWT algorithm confusion attacks?",
          choices: [
            {
              text: "Explicitly specify allowed algorithms and ignore the alg field in tokens",
              correct: true,
              points: 25,
              feedback: "Essential! Server should dictate allowed algorithms, not trust client-provided alg field.",
              nextStep: 1
            },
            {
              text: "Remove support for the 'none' algorithm only",
              correct: false,
              points: -25,
              feedback: "Other algorithm confusion attacks are possible - need comprehensive protection.",
              nextStep: 1
            },
            {
              text: "Add additional signature verification steps",
              correct: false,
              points: -20,
              feedback: "Additional verification doesn't help if the server accepts unsigned tokens.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive JWT validation strategy?",
          choices: [
            {
              text: "Explicit algorithm whitelist, key ID validation, and proper library usage",
              correct: true,
              points: 30,
              feedback: "Sophisticated strategy! Multiple validation layers prevent various JWT attacks.",
              nextStep: 2
            },
            {
              text: "Allow all algorithms for maximum compatibility",
              correct: false,
              points: -35,
              feedback: "This creates the vulnerability - restrict to known secure algorithms.",
              nextStep: 2
            },
            {
              text: "Use the same JWT library for all services",
              correct: false,
              points: -30,
              feedback: "Different services may require different JWT implementations based on needs.",
              nextStep: 2
            }
          ]
        },
        {
          text: "JWT security hardened! Algorithm confusion attacks prevented through explicit algorithm validation.",
          choices: []
        }
      ]
    }
  },

  softwareIntegrity367: {
    id: 367,
    title: "Zip Slip Archive Extraction Vulnerability",
    difficulty: "Hard",
    vulnerability: "A08:2021 - Software and Data Integrity Failures",
    attacker: {
      story: [
        {
          text: "You discover a file upload feature that extracts zip archives without validating file paths. What directory traversal risk exists?",
          choices: [
            {
              text: "Zip slip attack - malicious archives can overwrite system files through path traversal",
              correct: true,
              points: 25,
              feedback: "Tricky finding! Archive extraction without path validation enables file system manipulation.",
              nextStep: 1
            },
            {
              text: "Extracted files might have wrong permissions",
              correct: false,
              points: 5,
              feedback: "Permission issues are different from path traversal vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Archive might contain too many files",
              correct: false,
              points: 5,
              feedback: "File count limits are resource protection, not integrity issues.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You create a zip archive containing a file with path '../../etc/passwd'. How does this exploit the vulnerability?",
          choices: [
            {
              text: "Extraction follows the relative path, writing outside intended directory",
              correct: true,
              points: 30,
              feedback: "Clever! Relative paths in archives can escape extraction directories and overwrite system files.",
              nextStep: 2
            },
            {
              text: "The archive becomes corrupted during upload",
              correct: false,
              points: -15,
              feedback: "Archive corruption is not the exploitation mechanism.",
              nextStep: 2
            },
            {
              text: "System detects malicious path and blocks extraction",
              correct: false,
              points: 10,
              feedback: "That would be the secure behavior, but we're exploiting the lack of this protection.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Zip slip vulnerability! Archive extraction without path validation enables file system traversal and overwrite attacks.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How do you prevent zip slip attacks during archive extraction?",
          choices: [
            {
              text: "Sanitize all file paths and ensure they remain within target directory",
              correct: true,
              points: 25,
              feedback: "Essential! Path sanitization prevents directory traversal during extraction.",
              nextStep: 1
            },
            {
              text: "Only allow archives from trusted sources",
              correct: false,
              points: -25,
              feedback: "Trusted sources can still be compromised - need technical controls.",
              nextStep: 1
            },
            {
              text: "Extract to temporary directory first",
              correct: false,
              points: -20,
              feedback: "Temporary directories don't prevent traversal if paths aren't sanitized.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive archive security approach?",
          choices: [
            {
              text: "Path validation, file type verification, and extraction in isolated environments",
              correct: true,
              points: 30,
              feedback: "Sophisticated approach! Multiple layers protect against various archive-based attacks.",
              nextStep: 2
            },
            {
              text: "Allow only specific file types in archives",
              correct: false,
              points: -30,
              feedback: "File type restrictions don't prevent path traversal attacks.",
              nextStep: 2
            },
            {
              text: "Use the same extraction rules for all archive formats",
              correct: false,
              points: -25,
              feedback: "Different archive formats may require different security handling.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Archive security implemented! Zip slip attacks prevented through comprehensive path validation and sanitization.",
          choices: []
        }
      ]
    }
  },

  loggingFailures368: {
    id: 368,
    title: "Log Injection and Log Forgery",
    difficulty: "Hard",
    vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
    attacker: {
      story: [
        {
          text: "You discover an application that logs user input without sanitization. What log manipulation risk exists beyond typical injection?",
          choices: [
            {
              text: "Log injection enables log forgery and obfuscation of malicious activities",
              correct: true,
              points: 25,
              feedback: "Tricky finding! Unsanitized logs enable attackers to manipulate log contents and hide evidence.",
              nextStep: 1
            },
            {
              text: "Log files might become too large",
              correct: false,
              points: 5,
              feedback: "Size issues are operational, not security vulnerabilities.",
              nextStep: 0
            },
            {
              text: "Log entries might be difficult to read",
              correct: false,
              points: 5,
              feedback: "Readability is a usability issue, not a security risk.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You include carriage returns and fake log entries in your input. How does this affect security monitoring?",
          choices: [
            {
              text: "Fake log entries obfuscate real attack patterns and create false evidence",
              correct: true,
              points: 30,
              feedback: "Clever! Log injection can create misleading entries and hide real attack traces.",
              nextStep: 2
            },
            {
              text: "The logging system crashes from invalid characters",
              correct: false,
              points: -20,
              feedback: "System crashes are denial of service, not the log manipulation attack.",
              nextStep: 2
            },
            {
              text: "Other users see your injected content",
              correct: false,
              points: 10,
              feedback: "Log content is typically not user-facing - this is about monitoring evasion.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Log injection vulnerability! Unsanitized logging enables log forgery and security monitoring evasion.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "How do you prevent log injection attacks?",
          choices: [
            {
              text: "Sanitize all user input before logging and use structured logging formats",
              correct: true,
              points: 25,
              feedback: "Essential! Input sanitization and structured logging prevent log manipulation.",
              nextStep: 1
            },
            {
              text: "Only log specific predefined fields",
              correct: false,
              points: -20,
              feedback: "This limits debugging capability - better to sanitize all logged data.",
              nextStep: 1
            },
            {
              text: "Encode special characters in log displays only",
              correct: false,
              points: -25,
              feedback: "The raw log data still contains the injection - need to sanitize at source.",
              nextStep: 1
            }
          ]
        },
        {
          text: "What's the comprehensive logging security strategy?",
          choices: [
            {
              text: "Input sanitization, structured logging, and log integrity protection",
              correct: true,
              points: 30,
              feedback: "Sophisticated strategy! Multiple layers protect log integrity and prevent manipulation.",
              nextStep: 2
            },
            {
              text: "Allow raw logging for complete debugging information",
              correct: false,
              points: -35,
              feedback: "Raw logging creates security risks - balance debugging needs with security.",
              nextStep: 2
            },
            {
              text: "Use the same log format for all applications",
              correct: false,
              points: -30,
              feedback: "Different applications may require different logging approaches.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Logging security implemented! Log injection prevented through comprehensive input sanitization and structured logging.",
          choices: []
        }
      ]
    }
  },

  ssrf369: {
  id: 369,
  title: "DNS Rebinding SSRF Attack",
  difficulty: "Hard", 
  vulnerability: "A10:2021 - Server-Side Request Forgery",
  attacker: {
    story: [
      {
        text: "You discover an SSRF vulnerability where the server validates URLs using DNS, but makes the actual request later. What advanced SSRF technique applies?",
        choices: [
          {
            text: "DNS rebinding - DNS record changes between validation and request execution",
            correct: true,
            points: 25,
            feedback: "Tricky finding! Time-of-check-time-of-use vulnerability in DNS validation enables rebinding attacks.",
            nextStep: 1
          },
          {
            text: "The URL parser might have parsing inconsistencies",
            correct: false,
            points: 10,
            feedback: "Parser issues are different from DNS rebinding attacks.",
            nextStep: 0
          },
          {
            text: "Server might follow redirects automatically",
            correct: false,
            points: 5,
            feedback: "Redirect following is common but different from DNS rebinding.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How do you exploit this time-based DNS vulnerability?",
        choices: [
          {
            text: "Register domain with short TTL, change IP from allowed to internal after validation",
            correct: true,
            points: 30,
            feedback: "Clever! DNS rebinding exploits the time gap between validation and actual request.",
            nextStep: 2
          },
          {
            text: "Use IPv6 addresses to bypass filters",
            correct: false,
            points: -15,
            feedback: "IPv6 bypass is different from DNS rebinding technique.",
            nextStep: 2
          },
          {
            text: "Send multiple rapid requests to confuse the filter",
            correct: false,
            points: 10,
            feedback: "Rate-based attacks are different from DNS rebinding.",
            nextStep: 2
          }
        ]
      },
      {
        text: "DNS rebinding SSRF! Time-of-check-time-of-use vulnerability enables internal network access despite DNS validation.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent DNS rebinding attacks in SSRF protection?",
        choices: [
          {
            text: "Resolve DNS once and reuse IP for both validation and request",
            correct: true,
            points: 25,
            feedback: "Essential! Consistent DNS resolution prevents time-based attacks.",
            nextStep: 1
          },
          {
            text: "Use longer DNS caching times",
            correct: false,
            points: -20,
            feedback: "Caching doesn't prevent intentional rapid DNS changes by attackers.",
            nextStep: 1
          },
          {
            text: "Block all domains with short TTL values",
            correct: false,
            points: -25,
            feedback: "This blocks legitimate sites and isn't reliable protection.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive SSRF protection strategy?",
        choices: [
          {
            text: "DNS pinning, allowlist validation, and network layer restrictions",
            correct: true,
            points: 30,
            feedback: "Sophisticated strategy! Multiple layers prevent various SSRF techniques.",
            nextStep: 2
          },
          {
            text: "Allow only HTTPS URLs for outgoing requests",
            correct: false,
            points: -30,
            feedback: "Protocol restriction doesn't prevent internal network access.",
            nextStep: 2
          },
          {
            text: "Use the same DNS server for all validations",
            correct: false,
            points: -25,
            feedback: "DNS server consistency doesn't prevent rebinding attacks.",
            nextStep: 2
          }
        ]
      },
      {
        text: "SSRF protection implemented! DNS rebinding prevented through consistent DNS resolution and network restrictions.",
        choices: []
      }
    ]
  }
},

insecureDesign370: {
  id: 370,
  title: "Business Logic Bypass Through Parameter Pollution",
  difficulty: "Medium",
  vulnerability: "A04:2021 - Insecure Design",
  attacker: {
    story: [
      {
        text: "You discover a shopping cart that applies discounts based on coupon codes in URL parameters. What happens if you provide multiple coupon parameters?",
        choices: [
          {
            text: "Last parameter overrides previous ones, allowing discount stacking bypass",
            correct: true,
            points: 20,
            feedback: "Good catch! Parameter pollution can break business logic by overriding values.",
            nextStep: 1
          },
          {
            text: "System applies all coupons simultaneously",
            correct: false,
            points: 10,
            feedback: "Multiple coupon application is different from parameter override.",
            nextStep: 0
          },
          {
            text: "The request fails with an error",
            correct: false,
            points: 5,
            feedback: "Error on multiple parameters would be secure behavior.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can you exploit this to get maximum discount?",
        choices: [
          {
            text: "Send valid coupon last after invalid ones to override validation",
            correct: true,
            points: 25,
            feedback: "Smart! Parameter order manipulation bypasses business logic checks.",
            nextStep: 2
          },
          {
            text: "Use special characters in coupon codes",
            correct: false,
            points: -10,
            feedback: "Special characters relate to injection, not parameter pollution.",
            nextStep: 2
          },
          {
            text: "Send the same coupon code multiple times",
            correct: false,
            points: 5,
            feedback: "Duplicate parameters typically don't bypass business logic.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Business logic bypass! Parameter pollution enables discount manipulation through value overriding.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent parameter pollution vulnerabilities?",
        choices: [
          {
            text: "Validate and use only the first occurrence of each parameter",
            correct: true,
            points: 20,
            feedback: "Essential! Consistent parameter handling prevents override attacks.",
            nextStep: 1
          },
          {
            text: "Block requests with duplicate parameters",
            correct: false,
            points: -15,
            feedback: "This breaks legitimate use cases and frameworks.",
            nextStep: 1
          },
          {
            text: "Use different parameter names for each value",
            correct: false,
            points: -10,
            feedback: "Parameter naming doesn't prevent intentional pollution attacks.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the robust parameter handling approach?",
        choices: [
          {
            text: "First-value consistency, schema validation, and business logic testing",
            correct: true,
            points: 25,
            feedback: "Comprehensive approach! Multiple layers prevent parameter manipulation.",
            nextStep: 2
          },
          {
            text: "Allow only one parameter of each type per request",
            correct: false,
            points: -20,
            feedback: "This is difficult to enforce and breaks standard HTTP.",
            nextStep: 2
          },
          {
            text: "Use the same parameter order for all requests",
            correct: false,
            points: -15,
            feedback: "Parameter order is client-controlled and unreliable.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Parameter handling secured! Business logic now protected against parameter pollution attacks.",
        choices: []
      }
    ]
  }
},

cryptoFailures371: {
  id: 371,
  title: "Weak Random Number Generation in Password Reset",
  difficulty: "Medium", 
  vulnerability: "A02:2021 - Cryptographic Failures",
  attacker: {
    story: [
      {
        text: "You notice password reset tokens are short numeric codes. What cryptographic weakness might exist?",
        choices: [
          {
            text: "Weak entropy and predictable token generation",
            correct: true,
            points: 20,
            feedback: "Good observation! Short numeric tokens have limited randomness.",
            nextStep: 1
          },
          {
            text: "Tokens might expire too quickly",
            correct: false,
            points: 5,
            feedback: "Expiration timing is different from cryptographic strength.",
            nextStep: 0
          },
          {
            text: "Tokens could be reused multiple times",
            correct: false,
            points: 10,
            feedback: "Reuse is a logic flaw, not cryptographic weakness.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can you exploit predictable reset tokens?",
        choices: [
          {
            text: "Brute force attack using the limited numeric space",
            correct: true,
            points: 25,
            feedback: "Correct! Limited token space makes brute force feasible.",
            nextStep: 2
          },
          {
            text: "Reverse engineer the token generation algorithm",
            correct: false,
            points: -15,
            feedback: "Algorithm reversal is harder than simple brute force.",
            nextStep: 2
          },
          {
            text: "Intercept tokens during email transmission",
            correct: false,
            points: 10,
            feedback: "Interception is a different attack vector.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Cryptographic failure! Weak random generation enables password reset token prediction.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you strengthen password reset tokens?",
        choices: [
          {
            text: "Use cryptographically secure random generators with sufficient length",
            correct: true,
            points: 20,
            feedback: "Essential! Proper randomness and length prevent prediction.",
            nextStep: 1
          },
          {
            text: "Implement shorter expiration times",
            correct: false,
            points: -15,
            feedback: "Shorter expiration doesn't fix weak token generation.",
            nextStep: 1
          },
          {
            text: "Add rate limiting to reset attempts",
            correct: false,
            points: 10,
            feedback: "Rate limiting helps but doesn't fix the root cause.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive reset token strategy?",
        choices: [
          {
            text: "Secure generation, adequate length, and one-time use enforcement",
            correct: true,
            points: 25,
            feedback: "Robust strategy! Multiple protections for reset tokens.",
            nextStep: 2
          },
          {
            text: "Use the same token format for all users",
            correct: false,
            points: -20,
            feedback: "Format consistency doesn't guarantee security.",
            nextStep: 2
          },
          {
            text: "Store tokens in encrypted database only",
            correct: false,
            points: -15,
            feedback: "Storage encryption doesn't prevent weak generation.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Reset tokens secured! Now using cryptographically strong random generation.",
        choices: []
      }
    ]
  }
},

injection372: {
  id: 372,
  title: "NoSQL Injection in MongoDB Query",
  difficulty: "Medium",
  vulnerability: "A03:2021 - Injection",
  attacker: {
    story: [
      {
        text: "You discover a login form that uses MongoDB with user input directly in queries. What injection risk exists?",
        choices: [
          {
            text: "NoSQL injection through operator injection in JSON queries",
            correct: true,
            points: 20,
            feedback: "Good finding! NoSQL databases are vulnerable to operator injection.",
            nextStep: 1
          },
          {
            text: "Traditional SQL injection attacks",
            correct: false,
            points: 5,
            feedback: "MongoDB doesn't use SQL - different injection technique.",
            nextStep: 0
          },
          {
            text: "Buffer overflow in query processing",
            correct: false,
            points: 5,
            feedback: "Buffer overflows are memory issues, not injection.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can you bypass authentication using NoSQL injection?",
        choices: [
          {
            text: "Use {'$ne': ''} to make password comparison always true",
            correct: true,
            points: 25,
            feedback: "Clever! MongoDB operators can bypass authentication logic.",
            nextStep: 2
          },
          {
            text: "Inject JavaScript code into the query",
            correct: false,
            points: -10,
            feedback: "Modern MongoDB doesn't execute JavaScript in queries by default.",
            nextStep: 2
          },
          {
            text: "Use SQL comments to truncate the query",
            correct: false,
            points: -15,
            feedback: "SQL syntax doesn't work in MongoDB.",
            nextStep: 2
          }
        ]
      },
      {
        text: "NoSQL injection vulnerability! Operator injection enables authentication bypass in MongoDB.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent NoSQL injection?",
        choices: [
          {
            text: "Use parameterized queries or input validation for all user input",
            correct: true,
            points: 20,
            feedback: "Essential! Input validation and proper query construction prevent injection.",
            nextStep: 1
          },
          {
            text: "Disable JavaScript execution in MongoDB",
            correct: false,
            points: -15,
            feedback: "This doesn't prevent operator injection attacks.",
            nextStep: 1
          },
          {
            text: "Use web application firewall only",
            correct: false,
            points: -20,
            feedback: "WAFs can be bypassed - need application-level protection.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive NoSQL security approach?",
        choices: [
          {
            text: "Input validation, parameterized queries, and least privilege access",
            correct: true,
            points: 25,
            feedback: "Robust approach! Multiple layers prevent NoSQL injection.",
            nextStep: 2
          },
          {
            text: "Allow only simple equality queries",
            correct: false,
            points: -25,
            feedback: "This breaks application functionality.",
            nextStep: 2
          },
          {
            text: "Use the same validation for SQL and NoSQL",
            correct: false,
            points: -20,
            feedback: "Different databases require different validation approaches.",
            nextStep: 2
          }
        ]
      },
      {
        text: "NoSQL injection prevented! Now using proper input validation and parameterized queries.",
        choices: []
      }
    ]
  }
},

accessControl373: {
  id: 373,
  title: "Insecure Direct Object Reference (IDOR)",
  difficulty: "Easy",
  vulnerability: "A01:2021 - Broken Access Control",
  attacker: {
    story: [
      {
        text: "You notice URLs like '/user/profile/123' where 123 is your user ID. What happens if you change this number?",
        choices: [
          {
            text: "IDOR vulnerability - you can access other users' data by changing IDs",
            correct: true,
            points: 15,
            feedback: "Classic finding! Predictable object references enable horizontal privilege escalation.",
            nextStep: 1
          },
          {
            text: "The page returns a 404 error",
            correct: false,
            points: 5,
            feedback: "That would be secure behavior with proper access control.",
            nextStep: 0
          },
          {
            text: "You get logged out automatically",
            correct: false,
            points: 5,
            feedback: "Automatic logout is unusual for IDOR scenarios.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can you systematically find accessible user data?",
        choices: [
          {
            text: "Increment user IDs sequentially to enumerate all user profiles",
            correct: true,
            points: 20,
            feedback: "Correct! Sequential enumeration is common in IDOR attacks.",
            nextStep: 2
          },
          {
            text: "Use SQL injection to extract user data",
            correct: false,
            points: -10,
            feedback: "SQL injection is different from IDOR.",
            nextStep: 2
          },
          {
            text: "Modify your own user ID in database",
            correct: false,
            points: -15,
            feedback: "Database modification requires different access levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "IDOR vulnerability! Predictable object references enable unauthorized data access.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent IDOR vulnerabilities?",
        choices: [
          {
            text: "Implement proper authorization checks for each object access",
            correct: true,
            points: 15,
            feedback: "Essential! Server-side authorization prevents IDOR.",
            nextStep: 1
          },
          {
            text: "Use longer random IDs instead of sequential numbers",
            correct: false,
            points: -10,
            feedback: "Obfuscation doesn't replace proper authorization checks.",
            nextStep: 1
          },
          {
            text: "Hide object IDs from client-side completely",
            correct: false,
            points: -15,
            feedback: "Often impractical for web applications.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the robust access control approach?",
        choices: [
          {
            text: "Server-side authorization with session context validation",
            correct: true,
            points: 20,
            feedback: "Comprehensive approach! Context-aware authorization is key.",
            nextStep: 2
          },
          {
            text: "Allow access based on IP address restrictions",
            correct: false,
            points: -20,
            feedback: "IP-based access doesn't prevent authenticated IDOR.",
            nextStep: 2
          },
          {
            text: "Use the same access rules for all object types",
            correct: false,
            points: -15,
            feedback: "Different objects may require different access rules.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Access control implemented! IDOR prevented through proper server-side authorization.",
        choices: []
      }
    ]
  }
},

securityMisconfig374: {
  id: 374,
  title: "Debug Mode Enabled in Production",
  difficulty: "Easy",
  vulnerability: "A05:2021 - Security Misconfiguration",
  attacker: {
    story: [
      {
        text: "You encounter detailed error messages revealing stack traces and internal paths. What misconfiguration is this?",
        choices: [
          {
            text: "Debug mode enabled in production environment",
            correct: true,
            points: 15,
            feedback: "Common misconfiguration! Debug mode leaks sensitive information.",
            nextStep: 1
          },
          {
            text: "Missing web application firewall",
            correct: false,
            points: 5,
            feedback: "WAF absence is different from debug mode exposure.",
            nextStep: 0
          },
          {
            text: "Insufficient logging configuration",
            correct: false,
            points: 5,
            feedback: "Logging issues don't directly cause information leakage to users.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can detailed error messages help attackers?",
        choices: [
          {
            text: "Reveal internal structure and potential attack vectors",
            correct: true,
            points: 20,
            feedback: "Correct! Stack traces help attackers understand application internals.",
            nextStep: 2
          },
          {
            text: "Allow remote code execution directly",
            correct: false,
            points: -15,
            feedback: "Information leakage doesn't directly enable code execution.",
            nextStep: 2
          },
          {
            text: "Bypass authentication completely",
            correct: false,
            points: -10,
            feedback: "Debug mode doesn't typically bypass authentication.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Security misconfiguration! Debug mode in production exposes sensitive application details.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure application error handling?",
        choices: [
          {
            text: "Disable debug mode in production and use generic error messages",
            correct: true,
            points: 15,
            feedback: "Essential! Production should never show detailed errors.",
            nextStep: 1
          },
          {
            text: "Block IP addresses that trigger errors",
            correct: false,
            points: -15,
            feedback: "This doesn't fix the information leakage issue.",
            nextStep: 1
          },
          {
            text: "Encrypt error messages before displaying",
            correct: false,
            points: -20,
            feedback: "Encrypted errors are useless for legitimate debugging.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the proper error handling strategy?",
        choices: [
          {
            text: "Environment-specific configurations with detailed logging and generic user messages",
            correct: true,
            points: 20,
            feedback: "Comprehensive strategy! Balance debugging needs with security.",
            nextStep: 2
          },
          {
            text: "Disable all error messages completely",
            correct: false,
            points: -25,
            feedback: "Some error feedback is necessary for usability.",
            nextStep: 2
          },
          {
            text: "Use the same error level for all environments",
            correct: false,
            points: -20,
            feedback: "Different environments require different error detail levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Error handling secured! Debug mode disabled in production with proper logging.",
        choices: []
      }
    ]
  }
},

vulnerableComponents375: {
  id: 375,
  title: "Known Vulnerability in jQuery Version",
  difficulty: "Easy",
  vulnerability: "A06:2021 - Vulnerable and Outdated Components",
  attacker: {
    story: [
      {
        text: "You identify an old jQuery version with known XSS vulnerabilities being used. What component risk exists?",
        choices: [
          {
            text: "Known vulnerability in client-side library enabling XSS attacks",
            correct: true,
            points: 15,
            feedback: "Common issue! Outdated libraries have known security flaws.",
            nextStep: 1
          },
          {
            text: "The website might load slower",
            correct: false,
            points: 5,
            feedback: "Performance is not the security risk here.",
            nextStep: 0
          },
          {
            text: "JavaScript features might not work properly",
            correct: false,
            points: 5,
            feedback: "Functionality issues are different from security vulnerabilities.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can you exploit the vulnerable jQuery version?",
        choices: [
          {
            text: "Craft inputs that trigger the known XSS vulnerability in jQuery",
            correct: true,
            points: 20,
            feedback: "Correct! Known vulnerabilities have public exploitation techniques.",
            nextStep: 2
          },
          {
            text: "Modify the jQuery file on the server",
            correct: false,
            points: -15,
            feedback: "File modification requires different access levels.",
            nextStep: 2
          },
          {
            text: "Use jQuery to mine cryptocurrency",
            correct: false,
            points: -20,
            feedback: "Cryptojacking is different from XSS exploitation.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Vulnerable component! Outdated jQuery version with known XSS vulnerabilities.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you manage vulnerable components?",
        choices: [
          {
            text: "Regular dependency scanning and prompt updates",
            correct: true,
            points: 15,
            feedback: "Essential! Proactive maintenance prevents component attacks.",
            nextStep: 1
          },
          {
            text: "Remove all third-party dependencies",
            correct: false,
            points: -25,
            feedback: "Impractical and unnecessary with proper management.",
            nextStep: 1
          },
          {
            text: "Use WAF to block exploitation attempts",
            correct: false,
            points: -15,
            feedback: "WAFs are reactive, not preventive for component vulnerabilities.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive component management strategy?",
        choices: [
          {
            text: "Software composition analysis, vulnerability monitoring, and patch management",
            correct: true,
            points: 20,
            feedback: "Robust strategy! Continuous monitoring and prompt updates.",
            nextStep: 2
          },
          {
            text: "Allow only approved organizations' components",
            correct: false,
            points: -20,
            feedback: "Even trusted organizations have vulnerabilities.",
            nextStep: 2
          },
          {
            text: "Use the same component versions forever",
            correct: false,
            points: -30,
            feedback: "This guarantees vulnerable components over time.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Component management established! Regular scanning and updates prevent known vulnerabilities.",
        choices: []
      }
    ]
  }
},

authFailure376: {
  id: 376,
  title: "Session Fixation Vulnerability",
  difficulty: "Medium",
  vulnerability: "A07:2021 - Identification and Authentication Failures",
  attacker: {
    story: [
      {
        text: "You notice the application assigns session IDs before login and keeps the same ID after authentication. What authentication risk exists?",
        choices: [
          {
            text: "Session fixation - attacker sets session ID then victim authenticates with it",
            correct: true,
            points: 20,
            feedback: "Good finding! Session fixation enables session hijacking.",
            nextStep: 1
          },
          {
            text: "Sessions might expire too quickly",
            correct: false,
            points: 5,
            feedback: "Expiration timing is different from fixation vulnerability.",
            nextStep: 0
          },
          {
            text: "Session IDs might be predictable",
            correct: false,
            points: 10,
            feedback: "Predictability is different from fixation.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How do you exploit session fixation?",
        choices: [
          {
            text: "Get session ID, send to victim, victim logs in, you access their account",
            correct: true,
            points: 25,
            feedback: "Correct! The fixed session becomes authenticated after victim login.",
            nextStep: 2
          },
          {
            text: "Brute force session IDs after login",
            correct: false,
            points: -15,
            feedback: "Brute force is different from fixation attacks.",
            nextStep: 2
          },
          {
            text: "Steal session cookies using XSS",
            correct: false,
            points: 10,
            feedback: "XSS is a different attack vector.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Session fixation vulnerability! Pre-authentication sessions retain same ID after login.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent session fixation?",
        choices: [
          {
            text: "Issue new session ID after successful authentication",
            correct: true,
            points: 20,
            feedback: "Essential! Session regeneration prevents fixation.",
            nextStep: 1
          },
          {
            text: "Use longer session IDs",
            correct: false,
            points: -15,
            feedback: "ID length doesn't prevent fixation attacks.",
            nextStep: 1
          },
          {
            text: "Bind sessions to IP addresses",
            correct: false,
            points: -10,
            feedback: "IP binding breaks legitimate user mobility.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive session management approach?",
        choices: [
          {
            text: "Session regeneration, secure attributes, and proper invalidation",
            correct: true,
            points: 25,
            feedback: "Robust approach! Multiple session security measures.",
            nextStep: 2
          },
          {
            text: "Allow only one session per user",
            correct: false,
            points: -20,
            feedback: "This creates poor user experience.",
            nextStep: 2
          },
          {
            text: "Use the same session timeout for all users",
            correct: false,
            points: -15,
            feedback: "Different user types may require different timeouts.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Session management secured! Session fixation prevented through post-authentication regeneration.",
        choices: []
      }
    ]
  }
},

softwareIntegrity377: {
  id: 377,
  title: "Insecure Deserialization Attack",
  difficulty: "Hard",
  vulnerability: "A08:2021 - Software and Data Integrity Failures",
  attacker: {
    story: [
      {
        text: "You discover the application uses Java serialization for session data. What integrity risk exists?",
        choices: [
          {
            text: "Insecure deserialization enabling remote code execution",
            correct: true,
            points: 25,
            feedback: "Critical finding! Deserialization vulnerabilities can lead to RCE.",
            nextStep: 1
          },
          {
            text: "Session data might become corrupted",
            correct: false,
            points: 5,
            feedback: "Data corruption is different from code execution.",
            nextStep: 0
          },
          {
            text: "Serialization might be inefficient",
            correct: false,
            points: 5,
            feedback: "Performance is not the security risk here.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can malicious serialized data lead to code execution?",
        choices: [
          {
            text: "Gadget chains in classpath execute during deserialization",
            correct: true,
            points: 30,
            feedback: "Advanced technique! Gadget chains enable RCE through deserialization.",
            nextStep: 2
          },
          {
            text: "Serialized data overwrites memory buffers",
            correct: false,
            points: -20,
            feedback: "This describes buffer overflow, not deserialization.",
            nextStep: 2
          },
          {
            text: "Malicious data corrupts the application logic",
            correct: false,
            points: 10,
            feedback: "Logic corruption is different from code execution.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Insecure deserialization vulnerability! Untrusted data deserialization enables remote code execution.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent insecure deserialization?",
        choices: [
          {
            text: "Use safe serialization formats like JSON instead of native serialization",
            correct: true,
            points: 25,
            feedback: "Essential! Safe formats prevent object injection attacks.",
            nextStep: 1
          },
          {
            text: "Validate serialized data structure only",
            correct: false,
            points: -30,
            feedback: "Structure validation doesn't prevent gadget chain exploitation.",
            nextStep: 1
          },
          {
            text: "Encrypt serialized data before transmission",
            correct: false,
            points: -25,
            feedback: "Encryption doesn't prevent malicious content deserialization.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive data serialization strategy?",
        choices: [
          {
            text: "Safe formats, input validation, and deserialization filters",
            correct: true,
            points: 30,
            feedback: "Robust strategy! Multiple layers prevent deserialization attacks.",
            nextStep: 2
          },
          {
            text: "Allow only simple data types in serialization",
            correct: false,
            points: -25,
            feedback: "This breaks complex object serialization needs.",
            nextStep: 2
          },
          {
            text: "Use the same serialization for all data types",
            correct: false,
            points: -30,
            feedback: "Different data may require different serialization approaches.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Deserialization secured! Now using safe serialization formats with proper validation.",
        choices: []
      }
    ]
  }
},

loggingFailures378: {
  id: 378,
  title: "Missing Critical Security Events",
  difficulty: "Medium",
  vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
  attacker: {
    story: [
      {
        text: "You test various attacks and notice no alerts or unusual logging occurs. What monitoring gap exists?",
        choices: [
          {
            text: "Critical security events not being logged or monitored",
            correct: true,
            points: 20,
            feedback: "Significant gap! Missing logs prevent attack detection.",
            nextStep: 1
          },
          {
            text: "Logs might be stored in wrong location",
            correct: false,
            points: 5,
            feedback: "Storage location is operational, not a detection failure.",
            nextStep: 0
          },
          {
            text: "Log rotation might be too frequent",
            correct: false,
            points: 5,
            feedback: "Rotation frequency affects retention, not initial logging.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is missing security event logging dangerous?",
        choices: [
          {
            text: "Attacks can proceed undetected without investigation capability",
            correct: true,
            points: 25,
            feedback: "Critical risk! No logs means no detection or forensics.",
            nextStep: 2
          },
          {
            text: "Application performance might degrade",
            correct: false,
            points: -15,
            feedback: "Performance is not the primary security concern here.",
            nextStep: 2
          },
          {
            text: "User sessions might expire incorrectly",
            correct: false,
            points: -10,
            feedback: "Session management is unrelated to logging gaps.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Security logging failure! Critical security events not monitored enabling undetected attacks.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you implement proper security logging?",
        choices: [
          {
            text: "Log all authentication, access control, and input validation failures",
            correct: true,
            points: 20,
            feedback: "Essential! Critical security events must be logged.",
            nextStep: 1
          },
          {
            text: "Log every user action for complete audit trail",
            correct: false,
            points: -25,
            feedback: "Excessive logging creates noise and storage issues.",
            nextStep: 1
          },
          {
            text: "Use logging only for error conditions",
            correct: false,
            points: -30,
            feedback: "Security events include successful and failed attempts.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive security monitoring strategy?",
        choices: [
          {
            text: "Structured logging, real-time alerting, and regular log review",
            correct: true,
            points: 25,
            feedback: "Robust strategy! Logging plus monitoring and review.",
            nextStep: 2
          },
          {
            text: "Store logs for compliance requirements only",
            correct: false,
            points: -35,
            feedback: "Compliance minimums often miss security needs.",
            nextStep: 2
          },
          {
            text: "Use the same log level for all applications",
            correct: false,
            points: -30,
            feedback: "Different applications have different security logging needs.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Security monitoring established! Critical events now logged with real-time alerting.",
        choices: []
      }
    ]
  }
},

ssrf379: {
  id: 379,
  title: "Cloud Metadata Service SSRF",
  difficulty: "Medium",
  vulnerability: "A10:2021 - Server-Side Request Forgery",
  attacker: {
    story: [
      {
        text: "You find an SSRF vulnerability in a cloud-hosted application. What cloud-specific risk exists?",
        choices: [
          {
            text: "Access to cloud metadata service revealing credentials and secrets",
            correct: true,
            points: 20,
            feedback: "Cloud-specific risk! Metadata services contain sensitive cloud credentials.",
            nextStep: 1
          },
          {
            text: "Higher bandwidth costs for the victim",
            correct: false,
            points: 5,
            feedback: "Cost impact is not the primary security risk.",
            nextStep: 0
          },
          {
            text: "Cloud service might throttle requests",
            correct: false,
            points: 5,
            feedback: "Throttling is operational, not a security vulnerability.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can you exploit SSRF to access cloud metadata?",
        choices: [
          {
            text: "Request http://169.254.169.254/latest/meta-data/",
            correct: true,
            points: 25,
            feedback: "Correct! Cloud metadata services use specific internal IP addresses.",
            nextStep: 2
          },
          {
            text: "Use DNS rebinding to internal services",
            correct: false,
            points: 10,
            feedback: "DNS rebinding is a different SSRF technique.",
            nextStep: 2
          },
          {
            text: "Exploit URL parser inconsistencies",
            correct: false,
            points: 5,
            feedback: "Parser issues are general SSRF, not cloud-specific.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Cloud metadata SSRF! Internal cloud services accessible through SSRF vulnerability.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you protect cloud metadata from SSRF?",
        choices: [
          {
            text: "Use cloud metadata service v2 with required headers",
            correct: true,
            points: 20,
            feedback: "Essential! Metadata v2 requires headers that SSRF can't provide.",
            nextStep: 1
          },
          {
            text: "Block all internal IP addresses in outgoing requests",
            correct: false,
            points: -25,
            feedback: "This breaks legitimate internal service communication.",
            nextStep: 1
          },
          {
            text: "Use network security groups only",
            correct: false,
            points: -20,
            feedback: "Network controls don't prevent application-level SSRF.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive cloud SSRF protection?",
        choices: [
          {
            text: "Metadata service hardening, network policies, and request validation",
            correct: true,
            points: 25,
            feedback: "Robust protection! Multiple layers for cloud environments.",
            nextStep: 2
          },
          {
            text: "Disable metadata service completely",
            correct: false,
            points: -35,
            feedback: "Metadata service is essential for cloud operation.",
            nextStep: 2
          },
          {
            text: "Use the same SSRF protection for all environments",
            correct: false,
            points: -30,
            feedback: "Cloud environments require specific protections.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Cloud SSRF protection implemented! Metadata service secured with proper authentication.",
        choices: []
      }
    ]
  }
},

accessControl380: {
  id: 380,
  title: "Mass Assignment Vulnerability in API",
  difficulty: "Hard",
  vulnerability: "A01:2021 - Broken Access Control",
  attacker: {
    story: [
      {
        text: "You discover a user registration API that accepts JSON objects and automatically maps them to user models. What privilege escalation risk exists?",
        choices: [
          {
            text: "Mass assignment - attackers can set privileged fields like isAdmin or balance",
            correct: true,
            points: 25,
            feedback: "Tricky finding! Automatic object mapping can expose sensitive fields not intended for user input.",
            nextStep: 1
          },
          {
            text: "The API might process requests too slowly",
            correct: false,
            points: 5,
            feedback: "Performance issues are different from mass assignment vulnerabilities.",
            nextStep: 0
          },
          {
            text: "User data might be stored in wrong format",
            correct: false,
            points: 5,
            feedback: "Data format issues are not security vulnerabilities.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can you exploit this to gain admin privileges during registration?",
        choices: [
          {
            text: "Include 'isAdmin': true in registration JSON payload",
            correct: true,
            points: 30,
            feedback: "Clever! Mass assignment allows setting fields that shouldn't be user-controllable.",
            nextStep: 2
          },
          {
            text: "Modify the user ID parameter in the request",
            correct: false,
            points: -20,
            feedback: "ID manipulation is IDOR, not mass assignment.",
            nextStep: 2
          },
          {
            text: "Use SQL injection in the registration form",
            correct: false,
            points: -15,
            feedback: "SQL injection is a different vulnerability category.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Mass assignment vulnerability! Automatic object mapping enables privilege escalation through unexpected field injection.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent mass assignment vulnerabilities?",
        choices: [
          {
            text: "Use allowlists for fields that can be mass-assigned from user input",
            correct: true,
            points: 25,
            feedback: "Essential! Explicit allowlisting prevents unexpected field assignment.",
            nextStep: 1
          },
          {
            text: "Encrypt all sensitive fields in database",
            correct: false,
            points: -20,
            feedback: "Encryption doesn't prevent field assignment during object mapping.",
            nextStep: 1
          },
          {
            text: "Use longer field names for sensitive data",
            correct: false,
            points: -25,
            feedback: "Field name obfuscation is not reliable security.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the robust object mapping strategy?",
        choices: [
          {
            text: "Data transfer objects with explicit mapping and input validation",
            correct: true,
            points: 30,
            feedback: "Sophisticated approach! DTOs provide clear separation between user input and internal models.",
            nextStep: 2
          },
          {
            text: "Allow mass assignment only for non-sensitive fields",
            correct: false,
            points: -30,
            feedback: "This still leaves risk - better to use explicit allowlisting.",
            nextStep: 2
          },
          {
            text: "Use the same mapping rules for all API endpoints",
            correct: false,
            points: -25,
            feedback: "Different endpoints may require different security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Mass assignment protection implemented! Now using explicit DTOs with proper field validation.",
        choices: []
      }
    ]
  }
},

cryptoFailures381: {
  id: 381,
  title: "Timing Attack on String Comparison",
  difficulty: "Hard",
  vulnerability: "A02:2021 - Cryptographic Failures",
  attacker: {
    story: [
      {
        text: "You notice API token validation takes slightly longer for tokens that start with correct characters. What cryptographic side-channel exists?",
        choices: [
          {
            text: "Timing attack - comparison time reveals correct characters sequentially",
            correct: true,
            points: 25,
            feedback: "Advanced finding! Micro-timing differences can leak information about secret values.",
            nextStep: 1
          },
          {
            text: "The tokens might be too short for security",
            correct: false,
            points: 10,
            feedback: "Length issues are different from timing attacks.",
            nextStep: 0
          },
          {
            text: "Tokens could be intercepted in transit",
            correct: false,
            points: 5,
            feedback: "Interception is a different attack vector.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can you systematically discover the secret token using timing differences?",
        choices: [
          {
            text: "Measure response times for different prefix guesses to find correct characters",
            correct: true,
            points: 30,
            feedback: "Sophisticated! Statistical analysis of timing differences reveals the secret character by character.",
            nextStep: 2
          },
          {
            text: "Send extremely long tokens to cause timeouts",
            correct: false,
            points: -20,
            feedback: "Timeouts are denial of service, not timing attacks.",
            nextStep: 2
          },
          {
            text: "Use network sniffing to capture token exchanges",
            correct: false,
            points: 10,
            feedback: "Sniffing is a different attack method.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Timing attack vulnerability! String comparison time leaks information about secret values character by character.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent timing attacks on string comparison?",
        choices: [
          {
            text: "Use constant-time comparison functions that take same time regardless of input",
            correct: true,
            points: 25,
            feedback: "Essential! Constant-time algorithms eliminate timing side-channels.",
            nextStep: 1
          },
          {
            text: "Add random delays to all comparisons",
            correct: false,
            points: -20,
            feedback: "Random delays can be averaged out by attackers with enough samples.",
            nextStep: 1
          },
          {
            text: "Use shorter tokens for faster comparison",
            correct: false,
            points: -25,
            feedback: "Shorter tokens are weaker cryptographically and don't prevent timing attacks.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive side-channel protection?",
        choices: [
          {
            text: "Constant-time algorithms, rate limiting, and security-aware coding practices",
            correct: true,
            points: 30,
            feedback: "Advanced protection! Multiple layers prevent various side-channel attacks.",
            nextStep: 2
          },
          {
            text: "Perform all comparisons on separate isolated servers",
            correct: false,
            points: -30,
            feedback: "Isolation doesn't prevent timing differences in the algorithm itself.",
            nextStep: 2
          },
          {
            text: "Use the same comparison method for all data types",
            correct: false,
            points: -25,
            feedback: "Different data types may require different comparison approaches.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Timing attack protection implemented! Now using constant-time comparison algorithms.",
        choices: []
      }
    ]
  }
},

injection382: {
  id: 382,
  title: "Template Injection with Server-Side JavaScript",
  difficulty: "Hard",
  vulnerability: "A03:2021 - Injection",
  attacker: {
    story: [
      {
        text: "You discover a feature that dynamically renders user content using template engines. What advanced injection risk exists beyond typical XSS?",
        choices: [
          {
            text: "Server-Side Template Injection (SSTI) enabling remote code execution",
            correct: true,
            points: 25,
            feedback: "Critical finding! Template injection can lead to server compromise.",
            nextStep: 1
          },
          {
            text: "The templates might render slowly",
            correct: false,
            points: 5,
            feedback: "Performance is not the security risk.",
            nextStep: 0
          },
          {
            text: "User content might display with wrong styling",
            correct: false,
            points: 5,
            feedback: "Styling issues are visual, not security vulnerabilities.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can template syntax lead to server-side code execution?",
        choices: [
          {
            text: "Inject template expressions that execute JavaScript on the server",
            correct: true,
            points: 30,
            feedback: "Advanced technique! Template engines often allow expression execution with server privileges.",
            nextStep: 2
          },
          {
            text: "Overwrite template files on the filesystem",
            correct: false,
            points: -20,
            feedback: "File overwrite requires different vulnerabilities.",
            nextStep: 2
          },
          {
            text: "Use SQL injection in template parameters",
            correct: false,
            points: -15,
            feedback: "SQL injection is different from template injection.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Server-Side Template Injection! User input in templates enables remote code execution on the server.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent server-side template injection?",
        choices: [
          {
            text: "Use logic-less templates or sandboxed execution environments",
            correct: true,
            points: 25,
            feedback: "Essential! Limiting template capabilities prevents code execution.",
            nextStep: 1
          },
          {
            text: "Validate template syntax before rendering",
            correct: false,
            points: -25,
            feedback: "Malicious templates can use valid syntax for attacks.",
            nextStep: 1
          },
          {
            text: "Encode all user input before template processing",
            correct: false,
            points: -20,
            feedback: "Encoding can break legitimate template functionality.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the robust template security strategy?",
        choices: [
          {
            text: "Sandboxed templates, strict input validation, and security reviews",
            correct: true,
            points: 30,
            feedback: "Comprehensive approach! Multiple layers prevent template injection.",
            nextStep: 2
          },
          {
            text: "Allow only predefined template variables",
            correct: false,
            points: -30,
            feedback: "This severely limits template functionality.",
            nextStep: 2
          },
          {
            text: "Use the same template engine for all applications",
            correct: false,
            points: -25,
            feedback: "Different applications may require different template engines.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Template security implemented! Now using sandboxed templates with proper input validation.",
        choices: []
      }
    ]
  }
},

insecureDesign383: {
  id: 383,
  title: "Cryptographic Design Flaw in Custom Protocol",
  difficulty: "Hard",
  vulnerability: "A04:2021 - Insecure Design",
  attacker: {
    story: [
      {
        text: "You analyze a custom encryption protocol that uses the same key for both encryption and authentication. What fundamental design flaw exists?",
        choices: [
          {
            text: "Key reuse violates cryptographic principles and enables attacks",
            correct: true,
            points: 25,
            feedback: "Advanced finding! Cryptographic key separation is a fundamental security principle.",
            nextStep: 1
          },
          {
            text: "The protocol might be inefficient",
            correct: false,
            points: 5,
            feedback: "Efficiency is not the security concern here.",
            nextStep: 0
          },
          {
            text: "Keys might be too short for security",
            correct: false,
            points: 10,
            feedback: "Key length is important but different from key reuse issues.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can key reuse be exploited to break the cryptographic protection?",
        choices: [
          {
            text: "Replay attacks and cryptographic analysis become feasible",
            correct: true,
            points: 30,
            feedback: "Sophisticated! Key reuse enables various cryptographic attacks that wouldn't work with proper key separation.",
            nextStep: 2
          },
          {
            text: "Brute force attacks become faster",
            correct: false,
            points: -15,
            feedback: "Key reuse doesn't directly affect brute force speed.",
            nextStep: 2
          },
          {
            text: "The encryption can be easily reversed",
            correct: false,
            points: -20,
            feedback: "Key reuse doesn't automatically make encryption reversible.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Cryptographic design flaw! Key reuse for multiple purposes violates fundamental security principles.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you fix cryptographic key management design?",
        choices: [
          {
            text: "Use separate keys for different cryptographic operations with proper key derivation",
            correct: true,
            points: 25,
            feedback: "Essential! Key separation is fundamental to cryptographic security.",
            nextStep: 1
          },
          {
            text: "Use longer keys to compensate for reuse",
            correct: false,
            points: -30,
            feedback: "Key length doesn't fix the fundamental design flaw of key reuse.",
            nextStep: 1
          },
          {
            text: "Rotate keys more frequently",
            correct: false,
            points: -25,
            feedback: "Frequent rotation doesn't prevent attacks enabled by key reuse.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the robust cryptographic design approach?",
        choices: [
          {
            text: "Key separation, proper random generation, and established protocols",
            correct: true,
            points: 30,
            feedback: "Professional approach! Use established cryptographic protocols instead of custom designs.",
            nextStep: 2
          },
          {
            text: "Use the same key derivation for all applications",
            correct: false,
            points: -35,
            feedback: "Different applications may require different key derivation strategies.",
            nextStep: 2
          },
          {
            text: "Allow key reuse only for related operations",
            correct: false,
            points: -30,
            feedback: "Key reuse should generally be avoided entirely.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Cryptographic design secured! Now using proper key separation and established protocols.",
        choices: []
      }
    ]
  }
},

securityMisconfig384: {
  id: 384,
  title: "HTTP Request Smuggling via Header Manipulation",
  difficulty: "Hard",
  vulnerability: "A05:2021 - Security Misconfiguration",
  attacker: {
    story: [
      {
        text: "You discover a frontend server and backend server interpret Content-Length and Transfer-Encoding headers differently. What request processing risk exists?",
        choices: [
          {
            text: "HTTP Request Smuggling - desynchronized parsing enables request manipulation",
            correct: true,
            points: 25,
            feedback: "Advanced finding! Header parsing differences between servers enable request smuggling.",
            nextStep: 1
          },
          {
            text: "Requests might be processed out of order",
            correct: false,
            points: 10,
            feedback: "Ordering issues are different from request smuggling.",
            nextStep: 0
          },
          {
            text: "Headers might be truncated or corrupted",
            correct: false,
            points: 5,
            feedback: "Data corruption is not the specific vulnerability here.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can you exploit header parsing differences to bypass security controls?",
        choices: [
          {
            text: "Craft requests that frontend and backend interpret as different requests",
            correct: true,
            points: 30,
            feedback: "Sophisticated! Desynchronized parsing can hide malicious requests from security controls.",
            nextStep: 2
          },
          {
            text: "Send extremely large headers to cause buffer overflow",
            correct: false,
            points: -20,
            feedback: "Buffer overflow is a different vulnerability.",
            nextStep: 2
          },
          {
            text: "Use special characters to break header parsing",
            correct: false,
            points: -15,
            feedback: "Parser breaking is different from request smuggling.",
            nextStep: 2
          }
        ]
      },
      {
        text: "HTTP Request Smuggling vulnerability! Desynchronized header parsing between frontend and backend servers.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent HTTP Request Smuggling attacks?",
        choices: [
          {
            text: "Normalize HTTP header processing across all servers and use HTTP/2",
            correct: true,
            points: 25,
            feedback: "Essential! Consistent parsing and modern protocols prevent smuggling.",
            nextStep: 1
          },
          {
            text: "Block requests with both Content-Length and Transfer-Encoding",
            correct: false,
            points: -20,
            feedback: "This breaks legitimate HTTP/1.1 compatibility.",
            nextStep: 1
          },
          {
            text: "Use application-level routing instead of reverse proxies",
            correct: false,
            points: -25,
            feedback: "This is often impractical and doesn't guarantee protection.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive HTTP processing security?",
        choices: [
          {
            text: "Header normalization, protocol upgrades, and security testing",
            correct: true,
            points: 30,
            feedback: "Robust approach! Multiple strategies prevent request smuggling.",
            nextStep: 2
          },
          {
            text: "Allow only one HTTP method per connection",
            correct: false,
            points: -30,
            feedback: "This severely impacts performance and functionality.",
            nextStep: 2
          },
          {
            text: "Use the same web server software throughout",
            correct: false,
            points: -25,
            feedback: "Different components may require different server software.",
            nextStep: 2
          }
        ]
      },
      {
        text: "HTTP processing secured! Request smuggling prevented through header normalization and protocol upgrades.",
        choices: []
      }
    ]
  }
},

vulnerableComponents385: {
  id: 385,
  title: "Software Supply Chain Attack via Build Process",
  difficulty: "Hard",
  vulnerability: "A06:2021 - Vulnerable and Outdated Components",
  attacker: {
    story: [
      {
        text: "You discover a company's build process downloads dependencies from public repositories without integrity verification. What supply chain risk exists beyond known vulnerabilities?",
        choices: [
          {
            text: "Build process compromise enabling malicious code injection",
            correct: true,
            points: 25,
            feedback: "Advanced finding! The build process itself can be an attack vector.",
            nextStep: 1
          },
          {
            text: "Dependencies might have licensing issues",
            correct: false,
            points: 5,
            feedback: "Licensing is legal, not security.",
            nextStep: 0
          },
          {
            text: "Builds might take longer than necessary",
            correct: false,
            points: 5,
            feedback: "Performance is not the security risk.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can you compromise the build process to inject backdoors?",
        choices: [
          {
            text: "Compromise a build tool or dependency to modify artifacts during compilation",
            correct: true,
            points: 30,
            feedback: "Sophisticated attack! Build process compromise affects all resulting artifacts.",
            nextStep: 2
          },
          {
            text: "Social engineer developers to use malicious dependencies",
            correct: false,
            points: 15,
            feedback: "Social engineering is different from build process compromise.",
            nextStep: 2
          },
          {
            text: "Intercept network traffic during build",
            correct: false,
            points: 10,
            feedback: "Network interception is a different attack vector.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Build process vulnerability! Unverified dependencies and tools enable software supply chain attacks.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure the software build process?",
        choices: [
          {
            text: "Use dependency pinning, integrity verification, and reproducible builds",
            correct: true,
            points: 25,
            feedback: "Essential! Build integrity prevents supply chain attacks.",
            nextStep: 1
          },
          {
            text: "Build only on isolated air-gapped networks",
            correct: false,
            points: -30,
            feedback: "Often impractical and doesn't prevent all supply chain risks.",
            nextStep: 1
          },
          {
            "text": "Use checksums only for critical dependencies",
            correct: false,
            points: -25,
            feedback: "All dependencies should be verified for integrity.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive build security strategy?",
        choices: [
          {
            text: "Secure supply chain, artifact signing, and environment hardening",
            correct: true,
            points: 30,
            feedback: "Enterprise approach! Multiple layers protect the entire build pipeline.",
            nextStep: 2
          },
          {
            text: "Allow only whitelisted IP addresses for downloads",
            correct: false,
            points: -35,
            feedback: "IP restrictions don't prevent compromised packages from trusted sources.",
            nextStep: 2
          },
          {
            text: "Use the same build environment for all projects",
            correct: false,
            points: -30,
            feedback: "Different projects may require different build environments.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Build process secured! Now using verified dependencies and reproducible builds.",
        choices: []
      }
    ]
  }
},

authFailure386: {
  id: 386,
  title: "OAuth Implementation Flaw - Authorization Code Interception",
  difficulty: "Hard",
  vulnerability: "A07:2021 - Identification and Authentication Failures",
  attacker: {
    story: [
      {
        text: "You discover an OAuth implementation that doesn't validate redirect URIs properly. What authorization bypass risk exists?",
        choices: [
          {
            text: "Authorization code interception through open redirect or URI manipulation",
            correct: true,
            points: 25,
            feedback: "Advanced OAuth finding! Redirect URI validation is critical for OAuth security.",
            nextStep: 1
          },
          {
            text: "Tokens might be too long for some systems",
            correct: false,
            points: 5,
            feedback: "Length issues are operational, not OAuth-specific vulnerabilities.",
            nextStep: 0
          },
          {
            text: "User sessions might expire during OAuth flow",
            correct: false,
            points: 5,
            feedback: "Session timing is a usability issue.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can you steal authorization codes using redirect URI manipulation?",
        choices: [
          {
            text: "Register malicious redirect URI or use open redirect to capture codes",
            correct: true,
            points: 30,
            feedback: "Sophisticated OAuth attack! Improper redirect validation enables code interception.",
            nextStep: 2
          },
          {
            text: "Brute force the authorization codes",
            correct: false,
            points: -20,
            feedback: "Authorization codes are typically long and random.",
            nextStep: 2
          },
          {
            text: "Use XSS to steal tokens from storage",
            correct: false,
            points: 10,
            feedback: "XSS is a different attack vector.",
            nextStep: 2
          }
        ]
      },
      {
        text: "OAuth implementation flaw! Improper redirect URI validation enables authorization code interception.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure OAuth redirect URI handling?",
        choices: [
          {
            text: "Validate redirect URIs against pre-registered exact URIs",
            correct: true,
            points: 25,
            feedback: "Essential! Exact redirect URI matching prevents interception attacks.",
            nextStep: 1
          },
          {
            text: "Use HTTPS for all redirects only",
            correct: false,
            points: -20,
            feedback: "HTTPS doesn't prevent malicious but valid redirect targets.",
            nextStep: 1
          },
          {
            text: "Shorten authorization code expiration time",
            correct: false,
            points: -15,
            feedback: "Shorter expiration helps but doesn't fix the root vulnerability.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive OAuth security approach?",
        choices: [
          {
            text: "PKCE, exact redirect matching, and client authentication",
            correct: true,
            points: 30,
            feedback: "Modern OAuth security! PKCE provides additional protection for public clients.",
            nextStep: 2
          },
          {
            text: "Allow only domain-level redirect URI validation",
            correct: false,
            points: -35,
            feedback: "Domain-level validation is insufficient - exact matching is required.",
            nextStep: 2
          },
          {
            text: "Use the same OAuth flow for all client types",
            correct: false,
            points: -30,
            feedback: "Different client types require different OAuth flows.",
            nextStep: 2
          }
        ]
      },
      {
        text: "OAuth security implemented! Now using PKCE and exact redirect URI validation.",
        choices: []
      }
    ]
  }
},

softwareIntegrity387: {
  id: 387,
  title: "Subresource Integrity (SRI) Bypass",
  difficulty: "Hard",
  vulnerability: "A08:2021 - Software and Data Integrity Failures",
  attacker: {
    story: [
      {
        text: "You discover a CDN serving JavaScript libraries with SRI hashes, but the hashes aren't updated when libraries change. What integrity risk exists?",
        choices: [
          {
            text: "SRI bypass - outdated hashes allow malicious content to be executed",
            correct: true,
            points: 25,
            feedback: "Advanced finding! SRI requires proper hash maintenance to be effective.",
            nextStep: 1
          },
          {
            text: "Libraries might load slower from CDN",
            correct: false,
            points: 5,
            feedback: "Performance is not the security risk.",
            nextStep: 0
          },
          {
            text: "Browser caching might be inefficient",
            correct: false,
            points: 5,
            feedback: "Caching issues are operational, not integrity failures.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can you exploit outdated SRI hashes to inject malicious JavaScript?",
        choices: [
          {
            text: "Compromise the CDN and serve malicious content that matches old hashes",
            correct: true,
            points: 30,
            feedback: "Sophisticated attack! Outdated SRI hashes enable content substitution attacks.",
            nextStep: 2
          },
          {
            text: "Modify the SRI hashes in the HTML page",
            correct: false,
            points: -20,
            feedback: "SRI hash modification would cause integrity failures.",
            nextStep: 2
          },
          {
            text: "Use DNS poisoning to redirect to malicious CDN",
            correct: false,
            points: 15,
            feedback: "DNS poisoning is a different attack vector.",
            nextStep: 2
          }
        ]
      },
      {
        text: "SRI bypass vulnerability! Outdated integrity hashes enable malicious content execution.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you maintain effective Subresource Integrity?",
        choices: [
          {
            text: "Automate hash updates and use version-pinned URLs",
            correct: true,
            points: 25,
            feedback: "Essential! Automated SRI maintenance ensures hashes stay current.",
            nextStep: 1
          },
          {
            text: "Use longer hash algorithms only",
            correct: false,
            points: -20,
            feedback: "Hash length doesn't help if hashes are outdated.",
            nextStep: 1
          },
          {
            text: "Host all resources internally to avoid CDN risks",
            correct: false,
            points: -25,
            feedback: "Internal hosting has its own challenges and costs.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive external resource security?",
        choices: [
          {
            text: "SRI with automation, Content Security Policy, and resource monitoring",
            correct: true,
            points: 30,
            feedback: "Enterprise approach! Multiple layers protect against compromised external resources.",
            nextStep: 2
          },
          {
            text: "Allow only specific CDN providers",
            correct: false,
            points: -30,
            feedback: "Even trusted CDNs can be compromised.",
            nextStep: 2
          },
          {
            text: "Use the same SRI hash for all library versions",
            correct: false,
            points: -35,
            feedback: "This completely defeats the purpose of SRI.",
            nextStep: 2
          }
        ]
      },
      {
        text: "External resource security implemented! Now using automated SRI updates and comprehensive monitoring.",
        choices: []
      }
    ]
  }
},

loggingFailures388: {
  id: 388,
  title: "Log Evasion Through Unicode Normalization",
  difficulty: "Hard",
  vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
  attacker: {
    story: [
      {
        text: "You discover the application logs user input but normalizes Unicode characters before storage. What log evasion technique is possible?",
        choices: [
          {
            text: "Unicode normalization attacks - different encodings normalize to same characters",
            correct: true,
            points: 25,
            feedback: "Advanced finding! Unicode normalization can be exploited to evade detection.",
            nextStep: 1
          },
          {
            text: "Logs might become too large for analysis",
            correct: false,
            points: 5,
            feedback: "Size issues are operational, not evasion techniques.",
            nextStep: 0
          },
          {
            text: "Special characters might not display properly",
            correct: false,
            points: 5,
            feedback: "Display issues are usability problems.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can Unicode normalization help evade security monitoring?",
        choices: [
          {
            text: "Use different Unicode representations that normalize to harmless-looking text",
            correct: true,
            points: 30,
            feedback: "Sophisticated evasion! Attackers can hide malicious intent through Unicode tricks.",
            nextStep: 2
          },
          {
            text: "Crash the logging system with invalid Unicode",
            correct: false,
            points: -20,
            feedback: "System crashing is denial of service, not evasion.",
            nextStep: 2
          },
          {
            text: "Use Unicode to bypass input validation",
            correct: false,
            points: 15,
            feedback: "Input validation bypass is different from log evasion.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Log evasion vulnerability! Unicode normalization enables attackers to hide malicious activity in logs.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent Unicode-based log evasion?",
        choices: [
          {
            text: "Log both raw input and normalized form for comparison",
            correct: true,
            points: 25,
            feedback: "Essential! Logging both forms enables detection of normalization attacks.",
            nextStep: 1
          },
          {
            text: "Block all Unicode characters in user input",
            correct: false,
            points: -30,
            feedback: "This breaks internationalization and legitimate use cases.",
            nextStep: 1
          },
          {
            text: "Use stricter Unicode normalization forms",
            correct: false,
            points: -25,
            feedback: "Different normalization forms have different trade-offs.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive log analysis strategy?",
        choices: [
          {
            text: "Multiple normalization passes, pattern matching, and behavioral analysis",
            correct: true,
            points: 30,
            feedback: "Advanced monitoring! Multiple analysis techniques detect evasion attempts.",
            nextStep: 2
          },
          {
            text: "Allow only ASCII characters in security-sensitive fields",
            correct: false,
            points: -35,
            feedback: "This is impractical for global applications.",
            nextStep: 2
          },
          {
            text: "Use the same normalization for all log types",
            correct: false,
            points: -30,
            feedback: "Different log types may require different handling.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Log analysis enhanced! Now detecting Unicode normalization evasion attempts.",
        choices: []
      }
    ]
  }
},

ssrf389: {
  id: 389,
  title: "SSRF to Internal Server-Side Request Forgery",
  difficulty: "Hard",
  vulnerability: "A10:2021 - Server-Side Request Forgery",
  attacker: {
    story: [
      {
        text: "You discover an SSRF vulnerability that can make requests to internal services. What advanced exploitation technique exists beyond metadata access?",
        choices: [
          {
            text: "Internal Server-Side Request Forgery - chain requests between internal services",
            correct: true,
            points: 25,
            feedback: "Advanced SSRF technique! Internal service chaining enables deeper network penetration.",
            nextStep: 1
          },
          {
            text: "The requests might be rate-limited",
            correct: false,
            points: 5,
            feedback: "Rate limiting is a control, not an exploitation technique.",
            nextStep: 0
          },
          {
            text: "Internal services might use different protocols",
            correct: false,
            points: 10,
            feedback: "Protocol differences are operational details.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can you exploit internal service dependencies through SSRF?",
        choices: [
          {
            text: "Use one internal service to make requests to other internal services",
            correct: true,
            points: 30,
            feedback: "Sophisticated! Service chaining bypasses network segmentation and access controls.",
            nextStep: 2
          },
          {
            text: "Brute force internal IP addresses and ports",
            correct: false,
            points: -20,
            feedback: "Brute forcing is different from service chaining.",
            nextStep: 2
          },
          {
            text: "Use DNS rebinding for each internal service",
            correct: false,
            points: 15,
            feedback: "DNS rebinding is a different SSRF technique.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced SSRF vulnerability! Internal service chaining enables deep network penetration.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent internal service chaining via SSRF?",
        choices: [
          {
            text: "Implement egress filtering and network segmentation for internal services",
            correct: true,
            points: 25,
            feedback: "Essential! Network controls prevent lateral movement through SSRF.",
            nextStep: 1
          },
          {
            text: "Use different authentication for internal services",
            correct: false,
            points: -20,
            feedback: "Authentication doesn't prevent the requests from being made.",
            nextStep: 1
          },
          {
            text: "Block all internal network requests from applications",
            correct: false,
            points: -25,
            feedback: "This often breaks legitimate application functionality.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive internal network security?",
        choices: [
          {
            text: "Microsegmentation, service authentication, and least privilege networking",
            correct: true,
            points: 30,
            feedback: "Enterprise network security! Multiple layers prevent internal exploitation.",
            nextStep: 2
          },
          {
            text: "Allow full internal network access for all services",
            correct: false,
            points: -40,
            feedback: "This creates massive attack surface.",
            nextStep: 2
          },
          {
            text: "Use the same network rules for all environments",
            correct: false,
            points: -35,
            feedback: "Different environments require different network security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Internal network security implemented! Now using microsegmentation to prevent SSRF chaining.",
        choices: []
      }
    ]
  }
},

accessControl390: {
  id: 390,
  title: "JSON Web Token (JWT) Claim Manipulation in Microservices",
  difficulty: "Hard",
  vulnerability: "A01:2021 - Broken Access Control",
  attacker: {
    story: [
      {
        text: "You discover a microservices architecture where services trust JWT claims without verifying them against the authentication service. What advanced access control bypass exists?",
        choices: [
          {
            text: "JWT claim manipulation - services accept modified claims without signature verification",
            correct: true,
            points: 30,
            feedback: "Critical finding! In microservices, JWT claims must be verified by each service to prevent privilege escalation.",
            nextStep: 1
          },
          {
            text: "The JWT tokens might expire too quickly",
            correct: false,
            points: 5,
            feedback: "Expiration timing is operational, not an access control bypass.",
            nextStep: 0
          },
          {
            text: "Services might use different encryption algorithms",
            correct: false,
            points: 10,
            feedback: "Algorithm differences are configuration issues, not access control vulnerabilities.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can you escalate privileges across multiple microservices?",
        choices: [
          {
            text: "Modify JWT claims like roles/permissions and services accept them without revalidation",
            correct: true,
            points: 35,
            feedback: "Sophisticated attack! Distributed trust model failures enable cross-service privilege escalation.",
            nextStep: 2
          },
          {
            text: "Replay the same JWT across different services",
            correct: false,
            points: -25,
            feedback: "Replay attacks are different from claim manipulation.",
            nextStep: 2
          },
          {
            text: "Use token reflection attacks between services",
            correct: false,
            points: 15,
            feedback: "Token reflection is a different vulnerability pattern.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced access control failure! Microservices architecture vulnerable to JWT claim manipulation due to insufficient claim verification.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure JWT verification in microservices architecture?",
        choices: [
          {
            text: "Implement centralized JWT validation service or use API gateway with claim verification",
            correct: true,
            points: 30,
            feedback: "Enterprise solution! Centralized validation ensures consistent security across all services.",
            nextStep: 1
          },
          {
            text: "Use shorter JWT expiration times only",
            correct: false,
            points: -30,
            feedback: "Expiration doesn't prevent claim manipulation during token validity period.",
            nextStep: 1
          },
          {
            text: "Encrypt JWT payload between services",
            correct: false,
            points: -25,
            feedback: "Encryption doesn't prevent manipulation if attackers can generate valid tokens.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the zero-trust microservices security approach?",
        choices: [
          {
            text: "Service mesh with mTLS, centralized authZ, and claims verification at each service",
            correct: true,
            points: 35,
            feedback: "Zero-trust architecture! Every service verifies every request independently.",
            nextStep: 2
          },
          {
            text: "Allow services to trust JWT from any internal source",
            correct: false,
            points: -40,
            feedback: "This creates the vulnerability - never trust, always verify.",
            nextStep: 2
          },
          {
            text: "Use the same JWT secret for all services",
            correct: false,
            points: -35,
            feedback: "Shared secrets increase blast radius if compromised.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Microservices security hardened! Now implementing zero-trust with service-level JWT verification.",
        choices: []
      }
    ]
  }
},

cryptoFailures391: {
  id: 391,
  title: "Cryptographic Agility Failure in Certificate Pinning",
  difficulty: "Hard",
  vulnerability: "A02:2021 - Cryptographic Failures",
  attacker: {
    story: [
      {
        text: "You discover a mobile app with certificate pinning that cannot update pinned certificates without app store release. What cryptographic agility problem exists?",
        choices: [
          {
            text: "Cryptographic agility failure - inability to respond to CA compromises or algorithm deprecation",
            correct: true,
            points: 30,
            feedback: "Advanced finding! Certificate pinning without update mechanism creates operational security risk.",
            nextStep: 1
          },
          {
            text: "The app might use weak encryption algorithms",
            correct: false,
            points: 10,
            feedback: "Algorithm strength is different from agility issues.",
            nextStep: 0
          },
          {
            text: "Certificate validation might be too strict",
            correct: false,
            points: 5,
            feedback: "Strict validation is generally good security practice.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can this agility failure be exploited during CA compromise?",
        choices: [
          {
            text: "App becomes unusable during legitimate CA changes, forcing users to disable security",
            correct: true,
            points: 35,
            feedback: "Sophisticated risk! Security controls that break functionality often get disabled by users.",
            nextStep: 2
          },
          {
            text: "Directly attack the pinned certificate",
            correct: false,
            points: -25,
            feedback: "Certificate pinning is designed to prevent direct attacks.",
            nextStep: 2
          },
          {
            text: "Use quantum computing to break encryption",
            correct: false,
            points: -30,
            feedback: "Quantum attacks are theoretical and different from agility issues.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Cryptographic agility failure! Rigid certificate pinning creates operational security risks during CA incidents.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you implement certificate pinning with cryptographic agility?",
        choices: [
          {
            text: "Use certificate transparency logs and dynamic pinning with fallback mechanisms",
            correct: true,
            points: 30,
            feedback: "Enterprise approach! Dynamic pinning balances security with operational flexibility.",
            nextStep: 1
          },
          {
            text: "Pin to multiple certificates from different CAs",
            correct: false,
            points: -25,
            feedback: "Multiple pins don't solve the update problem during widespread CA issues.",
            nextStep: 1
          },
          {
            text: "Use shorter certificate lifetimes only",
            correct: false,
            points: -30,
            feedback: "Short lifetimes don't address the pinning update mechanism.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the modern certificate security strategy?",
        choices: [
          {
            text: "Certificate transparency monitoring, key rotation automation, and emergency update channels",
            correct: true,
            points: 35,
            feedback: "Comprehensive PKI management! Combines proactive monitoring with emergency response capabilities.",
            nextStep: 2
          },
          {
            text: "Avoid certificate pinning entirely for maximum agility",
            correct: false,
            points: -40,
            feedback: "Pinning provides important security benefits - need balanced approach.",
            nextStep: 2
          },
          {
            text: "Use the same pinning strategy for all applications",
            correct: false,
            points: -35,
            feedback: "Different applications have different security and agility requirements.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Cryptographic agility implemented! Now using dynamic pinning with emergency update capabilities.",
        choices: []
      }
    ]
  }
},

injection392: {
  id: 392,
  title: "Expression Language Injection in Java Frameworks",
  difficulty: "Hard",
  vulnerability: "A03:2021 - Injection",
  attacker: {
    story: [
      {
        text: "You discover a Java application using Expression Language (EL) in JSP pages with user input evaluated directly. What server-side code execution risk exists?",
        choices: [
          {
            text: "Expression Language Injection - direct code execution in application context",
            correct: true,
            points: 30,
            feedback: "Critical finding! EL injection enables full server compromise through expression evaluation.",
            nextStep: 1
          },
          {
            text: "The application might have memory leaks",
            correct: false,
            points: 5,
            feedback: "Memory issues are different from injection vulnerabilities.",
            nextStep: 0
          },
          {
            text: "JSP pages might render slowly",
            correct: false,
            points: 5,
            feedback: "Performance is not the security risk here.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can EL injection lead to remote code execution?",
        choices: [
          {
            text: "Leverage EL expressions to call Java methods and execute system commands",
            correct: true,
            points: 35,
            feedback: "Advanced technique! EL provides direct access to Java runtime environment.",
            nextStep: 2
          },
          {
            text: "Overwrite JSP files on the filesystem",
            correct: false,
            points: -25,
            feedback: "File overwrite requires different vulnerabilities.",
            nextStep: 2
          },
          {
            text: "Use SQL injection through EL expressions",
            correct: false,
            points: -20,
            feedback: "EL injection is server-side code execution, not database access.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Expression Language Injection vulnerability! User input evaluation in EL enables server-side code execution.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent Expression Language Injection?",
        choices: [
          {
            text: "Use JSP EL sanitization libraries and disable direct expression evaluation",
            correct: true,
            points: 30,
            feedback: "Essential! EL sanitization prevents expression injection attacks.",
            nextStep: 1
          },
          {
            text: "Disable all EL evaluation in JSP pages",
            correct: false,
            points: -35,
            feedback: "This breaks legitimate JSP functionality.",
            nextStep: 1
          },
          {
            text: "Use input validation for special characters only",
            correct: false,
            points: -30,
            feedback: "Character blocking is insufficient for complex EL expressions.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive Java web application security?",
        choices: [
          {
            text: "SecurityManager, expression sanitization, and secure coding practices",
            correct: true,
            points: 35,
            feedback: "Enterprise Java security! Multiple layers protect against expression injection.",
            nextStep: 2
          },
          {
            text: "Allow EL only in development environment",
            correct: false,
            points: -40,
            feedback: "Development practices often leak to production.",
            nextStep: 2
          },
          {
            text: "Use the same security configuration for all Java versions",
            correct: false,
            points: -35,
            feedback: "Different Java versions have different security requirements.",
            nextStep: 2
          }
        ]
      },
      {
        text: "EL injection protection implemented! Now using comprehensive expression sanitization and SecurityManager.",
        choices: []
      }
    ]
  }
},

insecureDesign393: {
  id: 393,
  title: "Missing Non-Repudiation in Financial Transactions",
  difficulty: "Hard",
  vulnerability: "A04:2021 - Insecure Design",
  attacker: {
    story: [
      {
        text: "You analyze a banking system where users can approve transactions but the system doesn't cryptographically bind approvals to specific transactions. What design flaw exists?",
        choices: [
          {
            text: "Missing non-repudiation - users can deny authorizing specific transactions",
            correct: true,
            points: 30,
            feedback: "Critical design flaw! Financial systems require cryptographic non-repudiation.",
            nextStep: 1
          },
          {
            text: "Transactions might process out of order",
            correct: false,
            points: 10,
            feedback: "Ordering issues are different from non-repudiation.",
            nextStep: 0
          },
          {
            text: "The system might have audit log gaps",
            correct: false,
            points: 15,
            feedback: "Audit gaps are logging issues, not design flaws.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can missing non-repudiation be exploited in disputes?",
        choices: [
          {
            text: "Users can legitimately deny authorizing transactions they actually approved",
            correct: true,
            points: 35,
            feedback: "Sophisticated risk! Without cryptographic proof, transaction authorization becomes disputable.",
            nextStep: 2
          },
          {
            text: "Directly modify transaction amounts",
            correct: false,
            points: -25,
            feedback: "Amount modification is a different attack vector.",
            nextStep: 2
          },
          {
            text: "Replay transaction approvals",
            correct: false,
            points: 20,
            feedback: "Replay attacks are different from non-repudiation failures.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Insecure design! Missing cryptographic non-repudiation enables transaction repudiation in financial systems.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you implement cryptographic non-repudiation?",
        choices: [
          {
            text: "Use digital signatures binding user identity to specific transaction details",
            correct: true,
            points: 30,
            feedback: "Essential! Digital signatures provide mathematical proof of authorization.",
            nextStep: 1
          },
          {
            text: "Store more detailed audit logs only",
            correct: false,
            points: -30,
            feedback: "Logs can be modified - need cryptographic proof.",
            nextStep: 1
          },
          {
            text: "Use multi-factor authentication for transactions",
            correct: false,
            points: -25,
            feedback: "MFA proves identity but doesn't bind to specific transactions.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive transaction security architecture?",
        choices: [
          {
            text: "Digital signatures, transaction hashing, and secure timestamping",
            correct: true,
            points: 35,
            feedback: "Enterprise financial security! Multiple cryptographic controls ensure non-repudiation.",
            nextStep: 2
          },
          {
            text: "Allow transaction approval without specific binding",
            correct: false,
            points: -40,
            feedback: "This creates the vulnerability - always bind approvals to specifics.",
            nextStep: 2
          },
          {
            text: "Use the same approval method for all transaction types",
            correct: false,
            points: -35,
            feedback: "Different transaction values may require different security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Non-repudiation implemented! Now using digital signatures with transaction-specific binding.",
        choices: []
      }
    ]
  }
},

securityMisconfig394: {
  id: 394,
  title: "Container Orchestration Misconfiguration - Privilege Escalation",
  difficulty: "Hard",
  vulnerability: "A05:2021 - Security Misconfiguration",
  attacker: {
    story: [
      {
        text: "You discover a Kubernetes cluster where containers run as root with privileged security contexts. What container escape risk exists?",
        choices: [
          {
            text: "Container privilege escalation to host node compromise",
            correct: true,
            points: 30,
            feedback: "Critical finding! Privileged containers can escape to host system.",
            nextStep: 1
          },
          {
            text: "Containers might consume excessive resources",
            correct: false,
            points: 5,
            feedback: "Resource consumption is operational, not security.",
            nextStep: 0
          },
          {
            text: "Network policies might be too restrictive",
            correct: false,
            points: 10,
            feedback: "Restrictive policies are generally good security.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can privileged container access lead to cluster compromise?",
        choices: [
          {
            text: "Mount host filesystem and access node credentials or service account tokens",
            correct: true,
            points: 35,
            feedback: "Advanced container escape! Host filesystem access enables full cluster compromise.",
            nextStep: 2
          },
          {
            text: "Overload the container runtime with requests",
            correct: false,
            points: -25,
            feedback: "Overloading is denial of service, not privilege escalation.",
            nextStep: 2
          },
          {
            text: "Use DNS rebinding between containers",
            correct: false,
            points: -20,
            feedback: "DNS rebinding is a different attack vector.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Container security misconfiguration! Privileged containers enable host system compromise and cluster escalation.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure container orchestration environments?",
        choices: [
          {
            text: "Use Pod Security Standards, non-root users, and security contexts",
            correct: true,
            points: 30,
            feedback: "Essential! Kubernetes security contexts prevent privilege escalation.",
            nextStep: 1
          },
          {
            text: "Run all containers as root for consistency",
            correct: false,
            points: -40,
            feedback: "This dramatically increases attack surface.",
            nextStep: 1
          },
          {
            text: "Use network segmentation only",
            correct: false,
            points: -35,
            feedback: "Network controls don't prevent container escape attacks.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the zero-trust container security strategy?",
        choices: [
          {
            text: "Pod Security Admission, service mesh, and runtime security monitoring",
            correct: true,
            points: 35,
            feedback: "Enterprise container security! Multiple layers protect against container escape.",
            nextStep: 2
          },
          {
            text: "Allow privileged containers for operational convenience",
            correct: false,
            points: -45,
            feedback: "Privileged containers should be exceptional, not normal.",
            nextStep: 2
          },
          {
            text: "Use the same security context for all containers",
            correct: false,
            points: -40,
            feedback: "Different workloads have different security requirements.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Container security hardened! Now using Pod Security Standards and non-root execution.",
        choices: []
      }
    ]
  }
},

vulnerableComponents395: {
  id: 395,
  title: "Software Bill of Materials (SBOM) Integrity Failure",
  difficulty: "Hard",
  vulnerability: "A06:2021 - Vulnerable and Outdated Components",
  attacker: {
    story: [
      {
        text: "You discover an organization generates SBOMs but doesn't verify them during builds or deployments. What supply chain integrity risk exists?",
        choices: [
          {
            text: "SBOM integrity failure - builds can use different components than documented",
            correct: true,
            points: 30,
            feedback: "Advanced finding! SBOMs without verification provide false security assurance.",
            nextStep: 1
          },
          {
            text: "SBOMs might be incomplete or inaccurate",
            correct: false,
            points: 15,
            feedback: "Completeness issues are different from integrity failures.",
            nextStep: 0
          },
          {
            text: "The SBOM format might be outdated",
            correct: false,
            points: 5,
            feedback: "Format issues are operational, not security risks.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can SBOM integrity failure enable supply chain attacks?",
        choices: [
          {
            text: "Attackers can substitute malicious components while SBOM shows clean bill",
            correct: true,
            points: 35,
            feedback: "Sophisticated attack! Integrity failures enable component substitution without detection.",
            nextStep: 2
          },
          {
            text: "Directly modify the SBOM document",
            correct: false,
            points: -25,
            feedback: "SBOM modification is different from build integrity failure.",
            nextStep: 2
          },
          {
            text: "Use dependency confusion in SBOM generation",
            correct: false,
            points: 20,
            feedback: "Dependency confusion is a different attack vector.",
            nextStep: 2
          }
        ]
      },
      {
        text: "SBOM integrity failure! Unverified software bill of materials enables undetected supply chain attacks.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you ensure SBOM integrity throughout CI/CD?",
        choices: [
          {
            text: "Generate SBOM during build and verify against deployed artifacts",
            correct: true,
            points: 30,
            feedback: "Essential! Build-time SBOM generation with deployment verification ensures integrity.",
            nextStep: 1
          },
          {
            text: "Use SBOMs from development environment only",
            correct: false,
            points: -35,
            feedback: "Development and production environments often differ.",
            nextStep: 1
          },
          {
            text: "Verify SBOMs manually before releases",
            correct: false,
            points: -30,
            feedback: "Manual verification doesn't scale and is error-prone.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive software supply chain security?",
        choices: [
          {
            text: "SBOM integrity, artifact signing, and provenance verification",
            correct: true,
            points: 35,
            feedback: "Enterprise supply chain security! Multiple integrity checks prevent component substitution.",
            nextStep: 2
          },
          {
            text: "Allow SBOM generation from any build environment",
            correct: false,
            points: -40,
            feedback: "SBOMs must come from trusted build processes.",
            nextStep: 2
          },
          {
            text: "Use the same SBOM format for all projects",
            correct: false,
            points: -35,
            feedback: "Different projects may use different appropriate SBOM formats.",
            nextStep: 2
          }
        ]
      },
      {
        text: "SBOM integrity implemented! Now verifying build artifacts against generated software bill of materials.",
        choices: []
      }
    ]
  }
},

authFailure396: {
  id: 396,
  title: "Distributed Session Management Race Condition",
  difficulty: "Hard",
  vulnerability: "A07:2021 - Identification and Authentication Failures",
  attacker: {
    story: [
      {
        text: "You discover a distributed application using eventual consistency for session storage across multiple data centers. What authentication race condition exists?",
        choices: [
          {
            text: "Session replication race condition - stale sessions can be accepted during replication delays",
            correct: true,
            points: 30,
            feedback: "Advanced finding! Distributed session management creates race conditions during replication.",
            nextStep: 1
          },
          {
            text: "Sessions might expire at different times across regions",
            correct: false,
            points: 15,
            feedback: "Timing differences are operational, not race conditions.",
            nextStep: 0
          },
          {
            text: "User data might be inconsistent across regions",
            correct: false,
            points: 10,
            feedback: "Data consistency is different from session validation.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can replication delays be exploited for authentication bypass?",
        choices: [
          {
            text: "Use revoked sessions in regions where revocation hasn't replicated yet",
            correct: true,
            points: 35,
            feedback: "Sophisticated attack! Eventual consistency enables use of invalidated sessions.",
            nextStep: 2
          },
          {
            text: "Replay the same session across different regions",
            correct: false,
            points: -25,
            feedback: "Session replay is different from replication race conditions.",
            nextStep: 2
          },
          {
            "text": "Brute force session IDs during replication",
            correct: false,
            points: -30,
            feedback: "Brute force is impractical against properly generated session IDs.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Distributed session race condition! Eventual consistency enables use of revoked sessions during replication delays.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure distributed session management?",
        choices: [
          {
            text: "Use strong consistency or session affinity with immediate revocation propagation",
            correct: true,
            points: 30,
            feedback: "Essential! Strong consistency eliminates replication race conditions.",
            nextStep: 1
          },
          {
            text: "Use shorter session timeouts globally",
            correct: false,
            points: -30,
            feedback: "Shorter timeouts don't prevent use of immediately revoked sessions.",
            nextStep: 1
          },
          {
            text: "Replicate sessions asynchronously for performance",
            correct: false,
            points: -35,
            feedback: "Asynchronous replication creates the vulnerability.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the global session management architecture?",
        choices: [
          {
            text: "Global session store with strong consistency and immediate invalidation",
            correct: true,
            points: 35,
            feedback: "Enterprise distributed systems! Global session management prevents replication issues.",
            nextStep: 2
          },
          {
            text: "Allow regional session autonomy for performance",
            correct: false,
            points: -40,
            feedback: "Regional autonomy creates security gaps during revocations.",
            nextStep: 2
          },
          {
            text: "Use the same session timeout for all regions",
            correct: false,
            points: -35,
            feedback: "Timeout consistency doesn't solve replication delays.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Distributed sessions secured! Now using global session store with strong consistency.",
        choices: []
      }
    ]
  }
},

softwareIntegrity397: {
  id: 397,
  title: "CI/CD Pipeline Compromise Through Build Argument Injection",
  difficulty: "Hard",
  vulnerability: "A08:2021 - Software and Data Integrity Failures",
  attacker: {
    story: [
      {
        text: "You discover a CI/CD system where build arguments from pull requests are executed during pipeline runs. What integrity compromise risk exists?",
        choices: [
          {
            text: "Build argument injection - malicious PRs can execute arbitrary pipeline commands",
            correct: true,
            points: 30,
            feedback: "Critical finding! Untrusted build arguments enable pipeline compromise.",
            nextStep: 1
          },
          {
            text: "Builds might take longer with complex arguments",
            correct: false,
            points: 5,
            feedback: "Performance is not the security risk.",
            nextStep: 0
          },
          {
            text: "Artifacts might be built with wrong configurations",
            correct: false,
            points: 10,
            feedback: "Configuration errors are different from intentional compromise.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can build argument injection lead to supply chain compromise?",
        choices: [
          {
            text: "Inject malicious build commands that modify artifacts or leak secrets",
            correct: true,
            points: 35,
            feedback: "Sophisticated attack! Pipeline compromise affects all downstream artifacts and deployments.",
            nextStep: 2
          },
          {
            text: "Overwrite source code in the repository",
            correct: false,
            points: -25,
            feedback: "Source overwrite requires different access levels.",
            nextStep: 2
          },
          {
            text: "Use dependency confusion in build arguments",
            correct: false,
            points: 20,
            feedback: "Dependency confusion is a different attack vector.",
            nextStep: 2
          }
        ]
      },
      {
        text: "CI/CD pipeline vulnerability! Build argument injection enables supply chain compromise through malicious pull requests.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure CI/CD pipeline parameters?",
        choices: [
          {
            text: "Use environment-specific secrets and sanitize all build arguments",
            correct: true,
            points: 30,
            feedback: "Essential! Pipeline security requires strict input validation and secret management.",
            nextStep: 1
          },
          {
            text: "Allow build arguments only from trusted contributors",
            correct: false,
            points: -35,
            feedback: "Trusted contributors can be compromised or make mistakes.",
            nextStep: 1
          },
          {
            text: "Use code signing after build completion",
            correct: false,
            points: -30,
            feedback: "Signing doesn't prevent the build from being compromised.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the zero-trust CI/CD security model?",
        choices: [
          {
            text: "Pipeline-as-code review, build isolation, and artifact provenance",
            correct: true,
            points: 35,
            feedback: "Enterprise CI/CD security! Treat all inputs as untrusted and verify all outputs.",
            nextStep: 2
          },
          {
            text: "Allow dynamic build arguments for flexibility",
            correct: false,
            points: -40,
            feedback: "Flexibility often compromises security in CI/CD systems.",
            nextStep: 2
          },
          {
            text: "Use the same build environment for all pipelines",
            correct: false,
            points: -35,
            feedback: "Different pipelines may require different security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "CI/CD security implemented! Now using pipeline-as-code with strict input validation.",
        choices: []
      }
    ]
  }
},

loggingFailures398: {
  id: 398,
  title: "Log Storage Compression Side-Channel",
  difficulty: "Hard",
  vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
  attacker: {
    story: [
      {
        text: "You discover a logging system that uses compression before storage. What information leakage risk exists through compression side-channels?",
        choices: [
          {
            text: "Compression side-channel - compressed size reveals information about log content",
            correct: true,
            points: 30,
            feedback: "Advanced finding! Compression ratios can leak information about secret values.",
            nextStep: 1
          },
          {
            text: "Logs might be difficult to search when compressed",
            correct: false,
            points: 5,
            feedback: "Searchability is operational, not a security risk.",
            nextStep: 0
          },
          {
            text: "Compression might reduce log retention period",
            correct: false,
            points: 5,
            feedback: "Retention is management, not security.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can compression ratios reveal sensitive information?",
        choices: [
          {
            text: "Compare compressed sizes to infer presence of known patterns or secrets",
            correct: true,
            points: 35,
            feedback: "Sophisticated technique! Compression efficiency reveals information about data patterns.",
            nextStep: 2
          },
          {
            text: "Directly extract data from compressed logs",
            correct: false,
            points: -30,
            feedback: "Direct extraction requires access to compressed files.",
            nextStep: 2
          },
          {
            text: "Use compression bombs to crash the logging system",
            correct: false,
            points: -25,
            feedback: "Compression bombs are denial of service, not information leakage.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Log compression side-channel! Compression ratios leak information about sensitive log content.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent compression side-channels in logging?",
        choices: [
          {
            text: "Use fixed-size logging fields or add random padding before compression",
            correct: true,
            points: 30,
            feedback: "Essential! Fixed sizes or padding eliminate compression side-channels.",
            nextStep: 1
          },
          {
            text: "Disable log compression entirely",
            correct: false,
            points: -35,
            feedback: "Compression provides important storage benefits.",
            nextStep: 1
          },
          {
            text: "Use weaker compression algorithms",
            correct: false,
            points: -30,
            feedback: "Weaker compression doesn't eliminate side-channels.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive log protection strategy?",
        choices: [
          {
            text: "Structured logging, fixed fields, encryption, and access controls",
            correct: true,
            points: 35,
            feedback: "Enterprise log security! Multiple protections prevent various information leakage vectors.",
            nextStep: 2
          },
          {
            text: "Allow log compression only for non-sensitive data",
            correct: false,
            points: -40,
            feedback: "Data classification errors can expose sensitive information.",
            nextStep: 2
          },
          {
            text: "Use the same compression for all log types",
            correct: false,
            points: -35,
            feedback: "Different log types may require different security handling.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Log protection enhanced! Now using fixed-size fields and encryption to prevent side-channels.",
        choices: []
      }
    ]
  }
},

ssrf399: {
  id: 399,
  title: "DNS Rebinding to Bypass Cloud Security Groups",
  difficulty: "Hard",
  vulnerability: "A10:2021 - Server-Side Request Forgery",
  attacker: {
    story: [
      {
        text: "You discover an SSRF vulnerability in a cloud environment with security groups blocking internal traffic. What advanced bypass technique exists?",
        choices: [
          {
            text: "DNS rebinding to bypass security groups through external domain resolution",
            correct: true,
            points: 30,
            feedback: "Advanced cloud SSRF! DNS rebinding can circumvent network security controls.",
            nextStep: 1
          },
          {
            text: "The security groups might be misconfigured",
            correct: false,
            points: 15,
            feedback: "Misconfiguration is different from intentional bypass techniques.",
            nextStep: 0
          },
          {
            text: "Internal services might use weak authentication",
            correct: false,
            points: 10,
            feedback: "Authentication strength is different from network bypass.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can DNS rebinding circumvent cloud security groups?",
        choices: [
          {
            text: "Domain resolves to external IP during validation but internal IP during request",
            correct: true,
            points: 35,
            feedback: "Sophisticated cloud attack! Security groups often allow outbound DNS but block internal traffic.",
            nextStep: 2
          },
          {
            text: "Use IP address spoofing to bypass filters",
            correct: false,
            points: -30,
            feedback: "IP spoofing is typically blocked in cloud environments.",
            nextStep: 2
          },
          {
            text: "Exploit security group rule precedence",
            correct: false,
            points: -25,
            feedback: "Rule precedence is different from DNS-based bypass.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced SSRF technique! DNS rebinding bypasses cloud security groups to access internal services.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent DNS rebinding in cloud environments?",
        choices: [
          {
            text: "Implement egress filtering and validate resolved IPs against internal ranges",
            correct: true,
            points: 30,
            feedback: "Essential! Egress controls and IP validation prevent DNS rebinding attacks.",
            nextStep: 1
          },
          {
            text: "Block all outbound DNS queries",
            correct: false,
            points: -40,
            feedback: "This breaks legitimate application functionality.",
            nextStep: 1
          },
          {
            text: "Use longer DNS TTL values only",
            correct: false,
            points: -35,
            feedback: "TTL values don't prevent intentional rapid DNS changes.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive cloud network security?",
        choices: [
          {
            text: "Network policies, DNS filtering, and zero-trust architecture",
            correct: true,
            points: 35,
            feedback: "Enterprise cloud security! Multiple layers prevent network-based attacks.",
            nextStep: 2
          },
          {
            text: "Allow full internal network access for simplicity",
            correct: false,
            points: -45,
            feedback: "This dramatically increases attack surface.",
            nextStep: 2
          },
          {
            text: "Use the same security groups for all environments",
            correct: false,
            points: -40,
            feedback: "Different environments require different security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Cloud network security hardened! Now implementing egress filtering and DNS protection.",
        choices: []
      }
    ]
  }
},

accessControl400: {
  id: 400,
  title: "URL Parameter Manipulation for Page Access",
  difficulty: "Easy",
  vulnerability: "A01:2021 - Broken Access Control",
  attacker: {
    story: [
      {
        text: "You notice a website has URLs like '/user.php?page=profile' and '/admin.php?page=dashboard'. What happens if you try to access admin pages while logged in as a regular user?",
        choices: [
          {
            text: "You can access admin pages by directly visiting admin URLs",
            correct: true,
            points: 15,
            feedback: "Good catch! Direct URL access without proper checks is a common access control issue.",
            nextStep: 1
          },
          {
            text: "You get redirected to login page",
            correct: false,
            points: 5,
            feedback: "That would be the secure behavior, but we're looking for the vulnerability.",
            nextStep: 0
          },
          {
            text: "The pages load but show empty content",
            correct: false,
            points: 5,
            feedback: "Empty content might still mean the page is accessible.",
            nextStep: 0
          }
        ]
      },
      {
        text: "What's the simplest way to test if admin features are accessible?",
        choices: [
          {
            text: "Change the URL from 'user.php' to 'admin.php' in the address bar",
            correct: true,
            points: 20,
            feedback: "Correct! Simple URL manipulation is the easiest way to test access controls.",
            nextStep: 2
          },
          {
            text: "Use a proxy tool to modify requests",
            correct: false,
            points: -10,
            feedback: "While possible, this is more complex than needed for basic testing.",
            nextStep: 2
          },
          {
            text: "Create a new admin account",
            correct: false,
            points: -15,
            feedback: "Creating accounts is different from accessing existing admin features.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Access control bypass! Admin pages accessible through direct URL access without proper authorization checks.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent direct URL access to admin pages?",
        choices: [
          {
            text: "Implement role-based checks on every page load",
            correct: true,
            points: 15,
            feedback: "Essential! Every page should verify user permissions, not just at login.",
            nextStep: 1
          },
          {
            text: "Hide admin URLs from regular users",
            correct: false,
            points: -10,
            feedback: "Security through obscurity doesn't work - URLs can be guessed.",
            nextStep: 1
          },
          {
            text: "Use complicated URLs that are hard to guess",
            correct: false,
            points: -15,
            feedback: "Complex URLs don't prevent determined attackers.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the proper way to structure page access?",
        choices: [
          {
            text: "Check user role and permissions before rendering any restricted content",
            correct: true,
            points: 20,
            feedback: "Good practice! Always verify permissions server-side for each request.",
            nextStep: 2
          },
          {
            text: "Use JavaScript to hide admin links from users",
            correct: false,
            points: -20,
            feedback: "Client-side controls can be bypassed - always check server-side.",
            nextStep: 2
          },
          {
            text: "Redirect users after they access forbidden pages",
            correct: false,
            points: -15,
            feedback: "The page still loaded - better to prevent access entirely.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Access control fixed! Now properly checking user roles on every page request.",
        choices: []
      }
    ]
  }
},

cryptoFailures401: {
  id: 401,
  title: "Passwords Stored in Plain Text",
  difficulty: "Easy",
  vulnerability: "A02:2021 - Cryptographic Failures",
  attacker: {
    story: [
      {
        text: "You notice when you reset your password, the website emails you your old password. What cryptographic issue does this indicate?",
        choices: [
          {
            text: "Passwords are stored in plain text instead of being hashed",
            correct: true,
            points: 15,
            feedback: "Exactly! If they can email your password, they're storing it in readable form.",
            nextStep: 1
          },
          {
            text: "The passwords are too short",
            correct: false,
            points: 5,
            feedback: "Length is important, but the bigger issue is storage method.",
            nextStep: 0
          },
          {
            text: "Emails are not encrypted",
            correct: false,
            points: 5,
            feedback: "Email encryption is separate from password storage security.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is plain text password storage dangerous?",
        choices: [
          {
            text: "If database is hacked, all passwords are immediately exposed",
            correct: true,
            points: 20,
            feedback: "Correct! Plain text passwords mean instant compromise if the database is breached.",
            nextStep: 2
          },
          {
            text: "Passwords take up more storage space",
            correct: false,
            points: -10,
            feedback: "Storage space is not the security concern here.",
            nextStep: 2
          },
          {
            text: "Users might forget their passwords",
            correct: false,
            points: -15,
            feedback: "Password memory is a usability issue, not a security vulnerability.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Cryptographic failure! Passwords stored in plain text instead of secure hashes.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should passwords be stored securely?",
        choices: [
          {
            text: "Use strong hashing algorithms like bcrypt with salt",
            correct: true,
            points: 15,
            feedback: "Essential! Proper hashing makes passwords unreadable even if database is compromised.",
            nextStep: 1
          },
          {
            text: "Encrypt passwords with a secret key",
            correct: false,
            points: -15,
            feedback: "Encryption can be reversed - hashing is one-way and more secure.",
            nextStep: 1
          },
          {
            text: "Store passwords in a separate database",
            correct: false,
            points: -10,
            feedback: "Location doesn't matter if they're still stored in plain text.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the proper password reset process?",
        choices: [
          {
            text: "Generate a temporary reset link, never reveal old passwords",
            correct: true,
            points: 20,
            feedback: "Correct! Reset links ensure passwords remain secret throughout the process.",
            nextStep: 2
          },
          {
            text: "Email the password in an encrypted attachment",
            correct: false,
            points: -20,
            feedback: "The system still knows the plain text password - this is insecure.",
            nextStep: 2
          },
          {
            text: "Call users on the phone with their password",
            correct: false,
            points: -15,
            feedback: "The fundamental issue is plain text storage, not delivery method.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Password storage secured! Now using proper bcrypt hashing with salt.",
        choices: []
      }
    ]
  }
},

injection402: {
  id: 402,
  title: "Search Box SQL Injection",
  difficulty: "Easy",
  vulnerability: "A03:2021 - Injection",
  attacker: {
    story: [
      {
        text: "You're testing a search feature on a website. What happens if you type a single quote (') in the search box?",
        choices: [
          {
            text: "You might see a database error message revealing SQL structure",
            correct: true,
            points: 15,
            feedback: "Good thinking! Error messages can reveal if user input goes directly into SQL queries.",
            nextStep: 1
          },
          {
            text: "The search returns all results",
            correct: false,
            points: 5,
            feedback: "That would be unusual behavior for a single quote.",
            nextStep: 0
          },
          {
            text: "The website crashes completely",
            correct: false,
            points: 5,
            feedback: "Complete crashes are rare from simple character inputs.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Seeing a SQL error, what's the next simple test?",
        choices: [
          {
            text: "Try ' OR '1'='1 to see if you can return all records",
            correct: true,
            points: 20,
            feedback: "Classic SQL injection test! This can bypass search filters.",
            nextStep: 2
          },
          {
            text: "Immediately try to delete the database",
            correct: false,
            points: -20,
            feedback: "Never attempt destructive actions during security testing.",
            nextStep: 2
          },
          {
            text: "Search for common passwords",
            correct: false,
            points: -10,
            feedback: "Password searching is different from injection testing.",
            nextStep: 2
          }
        ]
      },
      {
        text: "SQL injection vulnerability! User input directly used in database queries without sanitization.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent SQL injection in search features?",
        choices: [
          {
            text: "Use parameterized queries or prepared statements",
            correct: true,
            points: 15,
            feedback: "Essential! Parameterized queries separate data from commands.",
            nextStep: 1
          },
          {
            text: "Block single quotes and other special characters",
            correct: false,
            points: -15,
            feedback: "This breaks legitimate searches and can be bypassed.",
            nextStep: 1
          },
          {
            text: "Use a web application firewall only",
            correct: false,
            points: -10,
            feedback: "WAFs can be bypassed - fix the code itself.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the best practice for handling user input?",
        choices: [
          {
            text: "Treat all user input as untrusted and validate/sanitize properly",
            correct: true,
            points: 20,
            feedback: "Correct! Never trust user input - always validate and sanitize.",
            nextStep: 2
          },
          {
            text: "Only allow input from registered users",
            correct: false,
            points: -20,
            feedback: "Registered users can also be attackers.",
            nextStep: 2
          },
          {
            text: "Use client-side validation as the main protection",
            correct: false,
            points: -15,
            feedback: "Client-side controls can be easily bypassed.",
            nextStep: 2
          }
        ]
      },
      {
        text: "SQL injection protection implemented! Now using parameterized queries for all database access.",
        choices: []
      }
    ]
  }
},

insecureDesign403: {
  id: 403,
  title: "Password Complexity Rules That Help Attackers",
  difficulty: "Easy",
  vulnerability: "A04:2021 - Insecure Design",
  attacker: {
    story: [
      {
        text: "A website requires passwords to be exactly 8 characters with one capital letter and one number. How does this help attackers?",
        choices: [
          {
            text: "It reduces the possible password combinations for brute force attacks",
            correct: true,
            points: 15,
            feedback: "Exactly! Strict rules make passwords more predictable and easier to guess.",
            nextStep: 1
          },
          {
            text: "It makes passwords harder to remember",
            correct: false,
            points: 5,
            feedback: "While true, this doesn't directly help attackers.",
            nextStep: 0
          },
          {
            text: "Users will write passwords down more often",
            correct: false,
            points: 5,
            feedback: "This is a user behavior issue, not a direct help to attackers.",
            nextStep: 0
          }
        ]
      },
      {
        text: "What pattern do users commonly follow with these rules?",
        choices: [
          {
            text: "Capital first letter, 6 lowercase, number at the end (e.g., Password1)",
            correct: true,
            points: 20,
            feedback: "Common pattern! Predictable patterns make brute forcing much easier.",
            nextStep: 2
          },
          {
            text: "They use completely random characters",
            correct: false,
            points: -10,
            feedback: "Most users don't create truly random passwords.",
            nextStep: 2
          },
          {
            text: "They use the same password everywhere",
            correct: false,
            points: 10,
            feedback: "While common, this is a different security issue.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Insecure design! Password complexity rules that actually make guessing easier.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "What's better password policy design?",
        choices: [
          {
            text: "Minimum length (12+ characters) without complex character requirements",
            correct: true,
            points: 15,
            feedback: "Correct! Length is more important than complexity for security.",
            nextStep: 1
          },
          {
            text: "Require all character types: upper, lower, number, symbol",
            correct: false,
            points: -15,
            feedback: "This leads to predictable patterns like 'Password1!'",
            nextStep: 1
          },
          {
            text: "Force password changes every 30 days",
            correct: false,
            points: -10,
            feedback: "Frequent changes lead to weak, incremental passwords.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the modern approach to password security?",
        choices: [
          {
            text: "Long passphrases with checking against breach databases",
            correct: true,
            points: 20,
            feedback: "Modern best practice! Passphrases are easier to remember and harder to crack.",
            nextStep: 2
          },
          {
            text: "Very short passwords that are changed frequently",
            correct: false,
            points: -20,
            feedback: "Short passwords are weak regardless of change frequency.",
            nextStep: 2
          },
          {
            text: "Let users choose any password they want",
            correct: false,
            points: -15,
            feedback: "Some guidance is still needed to prevent very weak passwords.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Password policy improved! Now focusing on length and breach monitoring instead of complexity rules.",
        choices: []
      }
    ]
  }
},

securityMisconfig404: {
  id: 404,
  title: "Default Admin Passwords Not Changed",
  difficulty: "Easy",
  vulnerability: "A05:2021 - Security Misconfiguration",
  attacker: {
    story: [
      {
        text: "You discover a company using popular software that comes with default admin credentials. What common security mistake might they have made?",
        choices: [
          {
            text: "Not changing the default admin username and password",
            correct: true,
            points: 15,
            feedback: "Very common issue! Default credentials are the first thing attackers try.",
            nextStep: 1
          },
          {
            text: "Using the latest version of the software",
            correct: false,
            points: 5,
            feedback: "Using latest versions is generally good practice.",
            nextStep: 0
          },
          {
            text: "Installing too many features",
            correct: false,
            points: 5,
            feedback: "Feature bloat is different from credential management.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can attackers easily find these default credentials?",
        choices: [
          {
            text: "Search online for the software's default passwords",
            correct: true,
            points: 20,
            feedback: "Exactly! Default passwords are often documented in manuals and online.",
            nextStep: 2
          },
          {
            text: "Brute force random password combinations",
            correct: false,
            points: -10,
            feedback: "Why brute force when defaults are publicly known?",
            nextStep: 2
          },
          {
            text: "Intercept network traffic during installation",
            correct: false,
            points: -15,
            feedback: "This is much harder than simply looking up defaults.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Security misconfiguration! Default admin credentials left unchanged, providing easy access to attackers.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "What's the first step after installing new software?",
        choices: [
          {
            text: "Immediately change all default passwords",
            correct: true,
            points: 15,
            feedback: "Critical! Changing defaults should be the very first configuration step.",
            nextStep: 1
          },
          {
            text: "Test all the features to make sure they work",
            correct: false,
            points: -10,
            feedback: "Security should come before functionality testing.",
            nextStep: 1
          },
          {
            text: "Make backup of the default configuration",
            correct: false,
            points: -5,
            feedback: "Backups are good, but password changes are more urgent.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the proper credential management process?",
        choices: [
          {
            text: "Use unique, strong passwords and enable multi-factor authentication",
            correct: true,
            points: 20,
            feedback: "Best practice! Strong unique passwords plus MFA provides layered security.",
            nextStep: 2
          },
          {
            text: "Write down passwords in a secure notebook",
            correct: false,
            points: -15,
            feedback: "Physical security has its own risks - use password managers.",
            nextStep: 2
          },
          {
            text: "Use the same strong password for all admin accounts",
            correct: false,
            points: -20,
            feedback: "Password reuse creates risk if one system is compromised.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Default credentials secured! All default passwords changed and MFA enabled.",
        choices: []
      }
    ]
  }
},

vulnerableComponents405: {
  id: 405,
  title: "Outdated WordPress Plugins with Known Vulnerabilities",
  difficulty: "Easy",
  vulnerability: "A06:2021 - Vulnerable and Outdated Components",
  attacker: {
    story: [
      {
        text: "You notice a website is using WordPress with plugins that haven't been updated in years. What security risk does this create?",
        choices: [
          {
            text: "Known vulnerabilities in old versions can be easily exploited",
            correct: true,
            points: 15,
            feedback: "Exactly! Old plugins often have publicly known security holes.",
            nextStep: 1
          },
          {
            text: "The website might load slower",
            correct: false,
            points: 5,
            feedback: "Performance is not the primary security concern.",
            nextStep: 0
          },
          {
            text: "Newer browsers might not display it properly",
            correct: false,
            points: 5,
            feedback: "Browser compatibility is different from security vulnerabilities.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can attackers find vulnerable plugins?",
        choices: [
          {
            text: "Use automated scanners that check for known plugin vulnerabilities",
            correct: true,
            points: 20,
            feedback: "Correct! Many tools automatically scan for outdated components with known issues.",
            nextStep: 2
          },
          {
            text: "Guess the admin password repeatedly",
            correct: false,
            points: -10,
            feedback: "Password guessing is less efficient than exploiting known vulnerabilities.",
            nextStep: 2
          },
          {
            text: "Send phishing emails to the site owner",
            correct: false,
            points: -15,
            feedback: "Social engineering is a different attack approach.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Vulnerable components! Outdated plugins with publicly known security vulnerabilities.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you keep components secure?",
        choices: [
          {
            text: "Regularly update all plugins and themes",
            correct: true,
            points: 15,
            feedback: "Essential! Regular updates patch known security vulnerabilities.",
            nextStep: 1
          },
          {
            text: "Use as few plugins as possible",
            correct: false,
            points: -10,
            feedback: "While reducing plugins helps, updates are still crucial for ones you use.",
            nextStep: 1
          },
          {
            text: "Hide plugin version numbers",
            correct: false,
            points: -15,
            feedback: "Security through obscurity - scanners can still detect vulnerable versions.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the proper update process?",
        choices: [
          {
            text: "Monitor for updates, test them, then apply promptly",
            correct: true,
            points: 20,
            feedback: "Good practice! Balance security with stability through proper testing.",
            nextStep: 2
          },
          {
            text: "Automatically update everything immediately",
            correct: false,
            points: -15,
            feedback: "Automatic updates can sometimes break functionality.",
            nextStep: 2
          },
          {
            text: "Only update when new features are needed",
            correct: false,
            points: -20,
            feedback: "Security updates should not wait for feature needs.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Component management improved! Now regularly updating all plugins and monitoring for vulnerabilities.",
        choices: []
      }
    ]
  }
},

authFailure406: {
  id: 406,
  title: "No Login Attempt Limits",
  difficulty: "Easy",
  vulnerability: "A07:2021 - Identification and Authentication Failures",
  attacker: {
    story: [
      {
        text: "You notice a login page doesn't lock after multiple wrong password attempts. What authentication vulnerability exists?",
        choices: [
          {
            text: "Brute force attacks can try unlimited password guesses",
            correct: true,
            points: 15,
            feedback: "Exactly! Without limits, attackers can try thousands of password combinations.",
            nextStep: 1
          },
          {
            text: "Users might forget their passwords more often",
            correct: false,
            points: 5,
            feedback: "This is a usability issue, not a security vulnerability.",
            nextStep: 0
          },
          {
            text: "The login page might be slower",
            correct: false,
            points: 5,
            feedback: "Performance is not the security risk here.",
            nextStep: 0
          }
        ]
      },
      {
        text: "What's the easiest way to exploit this?",
        choices: [
          {
            text: "Use automated tools to try common passwords rapidly",
            correct: true,
            points: 20,
            feedback: "Correct! Automation makes brute force attacks practical without limits.",
            nextStep: 2
          },
          {
            text: "Guess one password per day manually",
            correct: false,
            points: -15,
            feedback: "This would take years - automation is the real threat.",
            nextStep: 2
          },
          {
            text: "Ask users for their passwords directly",
            correct: false,
            points: -10,
            feedback: "Social engineering is a different attack method.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Authentication failure! No login attempt limits enabling brute force attacks.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent brute force attacks?",
        choices: [
          {
            text: "Implement account lockout or rate limiting after failed attempts",
            correct: true,
            points: 15,
            feedback: "Essential! Limits make brute force attacks impractical.",
            nextStep: 1
          },
          {
            text: "Use longer password requirements only",
            correct: false,
            points: -15,
            feedback: "Long passwords help, but unlimited attempts still create risk.",
            nextStep: 1
          },
          {
            text: "Hide the login page from public view",
            correct: false,
            points: -10,
            feedback: "Security through obscurity doesn't work - attackers can find login pages.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the balanced approach to login security?",
        choices: [
          {
            text: "Temporary lockouts with gradual increase in lockout time",
            correct: true,
            points: 20,
            feedback: "Smart approach! Prevents attacks while minimizing user disruption.",
            nextStep: 2
          },
          {
            text: "Permanent account lock after 3 wrong attempts",
            correct: false,
            points: -20,
            feedback: "Too strict - creates denial of service and support burden.",
            nextStep: 2
          },
          {
            text: "No limits but use very complex passwords",
            correct: false,
            points: -15,
            feedback: "Complex passwords alone aren't enough against unlimited attempts.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Brute force protection implemented! Now using progressive lockouts after failed login attempts.",
        choices: []
      }
    ]
  }
},

softwareIntegrity407: {
  id: 407,
  title: "File Upload Without Type Checking",
  difficulty: "Easy",
  vulnerability: "A08:2021 - Software and Data Integrity Failures",
  attacker: {
    story: [
      {
        text: "A website lets users upload profile pictures. What happens if you try to upload a PHP file instead of an image?",
        choices: [
          {
            text: "The website might accept it and allow execution if accessed directly",
            correct: true,
            points: 15,
            feedback: "Good thinking! File upload without proper validation can lead to code execution.",
            nextStep: 1
          },
          {
            text: "The upload will always fail automatically",
            correct: false,
            points: 5,
            feedback: "That would be secure behavior, but we're testing for vulnerabilities.",
            nextStep: 0
          },
          {
            text: "The file gets corrupted during upload",
            correct: false,
            points: 5,
            feedback: "Corruption is a reliability issue, not intentional security.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is accepting executable files dangerous?",
        choices: [
          {
            text: "Attackers can upload web shells and take control of the server",
            correct: true,
            points: 20,
            feedback: "Critical risk! Malicious files can give attackers full server access.",
            nextStep: 2
          },
          {
            text: "Executable files take up more storage space",
            correct: false,
            points: -10,
            feedback: "Storage space is not the security concern.",
            nextStep: 2
          },
          {
            text: "Other users might download malicious files",
            correct: false,
            points: 10,
            feedback: "While possible, server compromise is the bigger risk.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Software integrity failure! File upload accepts executable files without proper validation.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure file uploads?",
        choices: [
          {
            text: "Check file types server-side and restrict to allowed extensions",
            correct: true,
            points: 15,
            feedback: "Essential! Server-side validation is crucial - client-side can be bypassed.",
            nextStep: 1
          },
          {
            text: "Rely on browser file type restrictions only",
            correct: false,
            points: -15,
            feedback: "Browser controls can be easily bypassed by attackers.",
            nextStep: 1
          },
          {
            text: "Scan uploaded files with antivirus software",
            correct: false,
            points: -10,
            feedback: "Antivirus helps but shouldn't be the only protection.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive upload security?",
        choices: [
          {
            text: "Type checking, size limits, and storing files outside web root",
            correct: true,
            points: 20,
            feedback: "Layered security! Multiple controls prevent various attack vectors.",
            nextStep: 2
          },
          {
            text: "Allow all files but change permissions to read-only",
            correct: false,
            points: -20,
            feedback: "Executable files in web directories are dangerous regardless of permissions.",
            nextStep: 2
          },
          {
            text: "Use the same validation for all file types",
            correct: false,
            points: -15,
            feedback: "Different file types may require different security handling.",
            nextStep: 2
          }
        ]
      },
      {
        text: "File upload security implemented! Now using server-side type checking and secure storage.",
        choices: []
      }
    ]
  }
},

loggingFailures408: {
  id: 408,
  title: "Not Logging Failed Login Attempts",
  difficulty: "Easy",
  vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
  attacker: {
    story: [
      {
        text: "You try multiple wrong passwords on a login page but don't see any error messages or delays. What logging issue might exist?",
        choices: [
          {
            text: "Failed login attempts might not be logged at all",
            correct: true,
            points: 15,
            feedback: "Good observation! Lack of feedback might indicate missing security logging.",
            nextStep: 1
          },
          {
            text: "The login is very fast and efficient",
            correct: false,
            points: 5,
            feedback: "Efficiency is good, but security logging is still needed.",
            nextStep: 0
          },
          {
            text: "The system has strong brute force protection",
            correct: false,
            points: 5,
            feedback: "Strong protection usually includes logging for monitoring.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is logging failed logins important for security?",
        choices: [
          {
            text: "It helps detect brute force attacks and suspicious activity",
            correct: true,
            points: 20,
            feedback: "Exactly! Logs provide evidence of attack attempts and patterns.",
            nextStep: 2
          },
          {
            text: "It makes the system run faster",
            correct: false,
            points: -10,
            feedback: "Logging doesn't typically improve performance.",
            nextStep: 2
          },
          {
            text: "It helps users remember their passwords",
            correct: false,
            points: -15,
            feedback: "Logging is for security monitoring, not user assistance.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Logging failure! Failed authentication attempts not being recorded for security monitoring.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "What authentication events should always be logged?",
        choices: [
          {
            text: "Both successful and failed login attempts with timestamps and IPs",
            correct: true,
            points: 15,
            feedback: "Essential! Complete authentication logging helps detect attacks and track incidents.",
            nextStep: 1
          },
          {
            text: "Only successful logins to reduce log size",
            correct: false,
            points: -15,
            feedback: "Failed attempts are crucial for detecting attacks.",
            nextStep: 1
          },
          {
            text: "Only logins from unusual locations",
            correct: false,
            points: -10,
            feedback: "You need all attempts to establish what's 'usual'.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the proper security monitoring approach?",
        choices: [
          {
            text: "Log key events and set up alerts for suspicious patterns",
            correct: true,
            points: 20,
            feedback: "Proactive security! Logging plus monitoring enables quick response to threats.",
            nextStep: 2
          },
          {
            text: "Store logs but only review during incidents",
            correct: false,
            points: -20,
            feedback: "Reactive approach misses ongoing attacks.",
            nextStep: 2
          },
          {
            text: "Log everything and figure it out later",
            correct: false,
            points: -15,
            feedback: "Too much data can hide important signals - be strategic.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Security logging implemented! Now monitoring authentication events and alerting on suspicious activity.",
        choices: []
      }
    ]
  }
},

ssrf409: {
  id: 409,
  title: "Image URL Upload SSRF",
  difficulty: "Easy",
  vulnerability: "A10:2021 - Server-Side Request Forgery",
  attacker: {
    story: [
      {
        text: "A website lets users set profile pictures by providing image URLs. What happens if you use a URL pointing to an internal server address?",
        choices: [
          {
            text: "The server might fetch the image from internal networks",
            correct: true,
            points: 15,
            feedback: "Good catch! URL fetching can be used to probe internal networks.",
            nextStep: 1
          },
          {
            text: "The URL will be rejected automatically",
            correct: false,
            points: 5,
            feedback: "That would be secure behavior, but we're testing for vulnerabilities.",
            nextStep: 0
          },
          {
            text: "Only public internet URLs will work",
            correct: false,
            points: 5,
            feedback: "Internal URLs might work if no protections are in place.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can this be used to discover internal systems?",
        choices: [
          {
            text: "Try different internal IPs and see which ones respond or timeout",
            correct: true,
            points: 20,
            feedback: "Correct! Response differences reveal internal network structure.",
            nextStep: 2
          },
          {
            text: "Use the feature to upload malicious files",
            correct: false,
            points: -10,
            feedback: "This is about network discovery, not file upload.",
            nextStep: 2
          },
          {
            text: "Brute force the admin password through the image URL",
            correct: false,
            points: -15,
            feedback: "Password brute forcing is a different attack.",
            nextStep: 2
          }
        ]
      },
      {
        text: "SSRF vulnerability! Image URL fetching can be abused to scan internal networks.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent SSRF in URL fetching features?",
        choices: [
          {
            text: "Validate URLs against allowlists and block internal IP ranges",
            correct: true,
            points: 15,
            feedback: "Essential! Restrict URL fetching to trusted external sources only.",
            nextStep: 1
          },
          {
            text: "Use a proxy for all outgoing requests",
            correct: false,
            points: -15,
            feedback: "Proxies don't necessarily prevent internal network access.",
            nextStep: 1
          },
          {
            text: "Only allow URLs from major image hosting sites",
            correct: false,
            points: -10,
            feedback: "Allowlisting specific domains is better than general categories.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive URL validation?",
        choices: [
          {
            text: "Domain allowlisting, IP validation, and content type checking",
            correct: true,
            points: 20,
            feedback: "Layered protection! Multiple checks prevent various SSRF techniques.",
            nextStep: 2
          },
          {
            text: "Allow any URL but scan the content for malware",
            correct: false,
            points: -20,
            feedback: "Content scanning doesn't prevent internal network scanning.",
            nextStep: 2
          },
          {
            text: "Use the same validation for all URL types",
            correct: false,
            points: -15,
            feedback: "Different URL types may require different security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "SSRF protection implemented! Now validating URLs and blocking internal network access.",
        choices: []
      }
    ]
  }
},

accessControl410: {
  id: 410,
  title: "User Role Change Through Hidden Form Fields",
  difficulty: "Easy",
  vulnerability: "A01:2021 - Broken Access Control",
  attacker: {
    story: [
      {
        text: "You find a user registration form that has a hidden field called 'role' with value 'user'. What happens if you change this to 'admin' before submitting?",
        choices: [
          {
            text: "You might register as an admin instead of a regular user",
            correct: true,
            points: 15,
            feedback: "Exactly! Hidden form fields can be manipulated to escalate privileges.",
            nextStep: 1
          },
          {
            text: "The form submission will fail with an error",
            correct: false,
            points: 5,
            feedback: "That would be secure behavior, but we're testing for vulnerabilities.",
            nextStep: 0
          },
          {
            text: "The hidden field is just for display and doesn't affect registration",
            correct: false,
            points: 5,
            feedback: "Hidden fields in forms are submitted with the data and can be processed.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is trusting hidden form fields dangerous?",
        choices: [
          {
            text: "Client-side values can be easily modified by attackers",
            correct: true,
            points: 20,
            feedback: "Correct! Never trust client-side data - always verify server-side.",
            nextStep: 2
          },
          {
            text: "Hidden fields make the page load slower",
            correct: false,
            points: -10,
            feedback: "Performance is not the security concern here.",
            nextStep: 2
          },
          {
            text: "Users might not see important information",
            correct: false,
            points: -15,
            feedback: "This is a usability issue, not a security vulnerability.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Access control bypass! Hidden form fields used for role assignment without server-side validation.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should user roles be assigned securely?",
        choices: [
          {
            text: "Assign roles server-side based on authenticated user context",
            correct: true,
            points: 15,
            feedback: "Essential! Roles should be determined server-side, not from client input.",
            nextStep: 1
          },
          {
            text: "Use JavaScript to hide the role field better",
            correct: false,
            points: -15,
            feedback: "Client-side hiding doesn't prevent manipulation - always verify server-side.",
            nextStep: 1
          },
          {
            text: "Encrypt the hidden field value",
            correct: false,
            points: -10,
            feedback: "Encryption can be reverse-engineered - better to not send sensitive data to client.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the principle for handling sensitive data?",
        choices: [
          {
            text: "Never trust client-side data for security decisions",
            correct: true,
            points: 20,
            feedback: "Fundamental security principle! Always validate and authorize server-side.",
            nextStep: 2
          },
          {
            text: "Use complex encoding for all form fields",
            correct: false,
            points: -20,
            feedback: "Encoding doesn't replace proper server-side validation.",
            nextStep: 2
          },
          {
            text: "Allow role changes only through admin interface",
            correct: false,
            points: -15,
            feedback: "The issue is initial assignment, not subsequent changes.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Role assignment secured! Now determining user roles server-side only.",
        choices: []
      }
    ]
  }
},

cryptoFailures411: {
  id: 411,
  title: "Credit Card Numbers Visible in Browser Cache",
  difficulty: "Easy",
  vulnerability: "A02:2021 - Cryptographic Failures",
  attacker: {
    story: [
      {
        text: "You notice a payment page displays your full credit card number after purchase. What privacy risk exists if you check browser history?",
        choices: [
          {
            text: "Credit card numbers might be stored in browser cache and history",
            correct: true,
            points: 15,
            feedback: "Good observation! Sensitive data should never be displayed after entry.",
            nextStep: 1
          },
          {
            text: "The payment might be processed twice",
            correct: false,
            points: 5,
            feedback: "Duplicate processing is a different issue.",
            nextStep: 0
          },
          {
            text: "The page might load slower next time",
            correct: false,
            points: 5,
            feedback: "Performance is not the security concern here.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How could someone access these cached credit card numbers?",
        choices: [
          {
            text: "Check browser history or cache on a shared computer",
            correct: true,
            points: 20,
            feedback: "Exactly! Browser caching can expose sensitive data to other users.",
            nextStep: 2
          },
          {
            text: "Intercept the network traffic during payment",
            correct: false,
            points: 10,
            feedback: "While possible, cached data is easier to access on shared devices.",
            nextStep: 2
          },
          {
            text: "Guess the credit card number randomly",
            correct: false,
            points: -15,
            feedback: "Random guessing is impractical compared to accessing cached data.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Cryptographic failure! Sensitive data displayed and cached in browser without protection.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should credit card numbers be handled after entry?",
        choices: [
          {
            text: "Only show last 4 digits and never store full numbers unnecessarily",
            correct: true,
            points: 15,
            feedback: "Best practice! Mask sensitive data and minimize storage.",
            nextStep: 1
          },
          {
            text: "Encrypt the numbers before displaying them",
            correct: false,
            points: -15,
            feedback: "If you need to display them, you shouldn't have stored them at all.",
            nextStep: 1
          },
          {
            text: "Use a popup window that doesn't get cached",
            correct: false,
            points: -10,
            feedback: "Popups can still be cached - better to not display sensitive data.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the proper sensitive data handling?",
        choices: [
          {
            text: "Use tokenization and never display full sensitive data after entry",
            correct: true,
            points: 20,
            feedback: "Secure approach! Tokenization replaces sensitive data with tokens.",
            nextStep: 2
          },
          {
            text: "Clear browser cache after each session",
            correct: false,
            points: -20,
            feedback: "You can't control users' browser settings - design securely.",
            nextStep: 2
          },
          {
            text: "Ask users to manually clear their history",
            correct: false,
            points: -15,
            feedback: "Relying on user behavior is not reliable security.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Data protection implemented! Now masking sensitive data and using tokenization.",
        choices: []
      }
    ]
  }
},

injection412: {
  id: 412,
  title: "XSS Through Image Alt Text",
  difficulty: "Easy",
  vulnerability: "A03:2021 - Injection",
  attacker: {
    story: [
      {
        text: "A blog lets users upload images with custom alt text. What happens if you put JavaScript code in the alt text field?",
        choices: [
          {
            text: "The JavaScript might execute when the image alt text is displayed",
            correct: true,
            points: 15,
            feedback: "Good thinking! Any user input displayed on pages can be an XSS vector.",
            nextStep: 1
          },
          {
            text: "The image won't upload properly",
            correct: false,
            points: 5,
            feedback: "That would be secure behavior, but we're testing for vulnerabilities.",
            nextStep: 0
          },
          {
            text: "The alt text will be ignored completely",
            correct: false,
            points: 5,
            feedback: "Alt text is important for accessibility and is typically displayed.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is this type of XSS dangerous?",
        choices: [
          {
            text: "It can steal cookies or redirect users to malicious sites",
            correct: true,
            points: 20,
            feedback: "Correct! XSS can compromise user sessions and security.",
            nextStep: 2
          },
          {
            text: "It makes the website load slower",
            correct: false,
            points: -10,
            feedback: "Performance impact is not the primary risk.",
            nextStep: 2
          },
          {
            text: "The images might not display correctly",
            correct: false,
            points: -15,
            feedback: "Display issues are minor compared to security risks.",
            nextStep: 2
          }
        ]
      },
      {
        text: "XSS vulnerability! User input in alt text executed as JavaScript without sanitization.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent XSS in user-generated content?",
        choices: [
          {
            text: "Properly escape all user input before displaying it",
            correct: true,
            points: 15,
            feedback: "Essential! Output encoding prevents browsers from executing scripts.",
            nextStep: 1
          },
          {
            text: "Block all special characters in user input",
            correct: false,
            points: -15,
            feedback: "This breaks legitimate use cases - better to escape properly.",
            nextStep: 1
          },
          {
            text: "Use JavaScript validation only",
            correct: false,
            points: -10,
            feedback: "Client-side validation can be bypassed - always validate server-side.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive XSS protection?",
        choices: [
          {
            text: "Input validation, output encoding, and Content Security Policy",
            correct: true,
            points: 20,
            feedback: "Layered defense! Multiple protections prevent various XSS attacks.",
            nextStep: 2
          },
          {
            text: "Allow HTML only from trusted users",
            correct: false,
            points: -20,
            feedback: "Trusted users can make mistakes or be compromised.",
            nextStep: 2
          },
          {
            text: "Use the same validation for all input fields",
            correct: false,
            points: -15,
            feedback: "Different fields may require different validation rules.",
            nextStep: 2
          }
        ]
      },
      {
        text: "XSS protection implemented! Now properly escaping all user-generated content.",
        choices: []
      }
    ]
  }
},

insecureDesign413: {
  id: 413,
  title: "Security Questions with Easily Researchable Answers",
  difficulty: "Easy",
  vulnerability: "A04:2021 - Insecure Design",
  attacker: {
    story: [
      {
        text: "A website uses security questions like 'What's your mother's maiden name?' for password reset. What design flaw makes this insecure?",
        choices: [
          {
            text: "Answers can often be found through social media or public records",
            correct: true,
            points: 15,
            feedback: "Exactly! Personal information is often publicly available online.",
            nextStep: 1
          },
          {
            text: "Users might forget their answers",
            correct: false,
            points: 5,
            feedback: "This is a usability issue, not a security design flaw.",
            nextStep: 0
          },
          {
            text: "The questions are too long to remember",
            correct: false,
            points: 5,
            feedback: "Length is not the security concern.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can attackers easily find these answers?",
        choices: [
          {
            text: "Search social media profiles and public databases",
            correct: true,
            points: 20,
            feedback: "Correct! Much personal information is publicly accessible online.",
            nextStep: 2
          },
          {
            text: "Guess randomly until they get it right",
            correct: false,
            points: -10,
            feedback: "Random guessing is inefficient compared to research.",
            nextStep: 2
          },
          {
            text: "Use keyloggers on the user's computer",
            correct: false,
            points: -15,
            feedback: "Keyloggers are a different attack method.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Insecure design! Security questions based on publicly available personal information.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "What's a better alternative to traditional security questions?",
        choices: [
          {
            text: "Use multi-factor authentication or randomly generated questions",
            correct: true,
            points: 15,
            feedback: "Better approach! MFA is more secure than knowledge-based authentication.",
            nextStep: 1
          },
          {
            text: "Use more personal questions about childhood",
            correct: false,
            points: -15,
            feedback: "More personal questions are still often discoverable.",
            nextStep: 1
          },
          {
            text: "Allow users to write their own questions",
            correct: false,
            points: -10,
            feedback: "Users often choose equally guessable questions.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the modern authentication design?",
        choices: [
          {
            text: "Passwordless authentication or MFA with backup codes",
            correct: true,
            points: 20,
            feedback: "Modern security! Moving away from knowledge-based authentication.",
            nextStep: 2
          },
          {
            text: "More complex security questions with longer answers",
            correct: false,
            points: -20,
            feedback: "Complexity doesn't solve the fundamental researchability issue.",
            nextStep: 2
          },
          {
            text: "Use the same questions for all users",
            correct: false,
            points: -15,
            feedback: "Common questions make automated attacks easier.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Authentication design improved! Now using MFA instead of insecure security questions.",
        choices: []
      }
    ]
  }
},

securityMisconfig414: {
  id: 414,
  title: "Directory Listing Enabled on Web Server",
  difficulty: "Easy",
  vulnerability: "A05:2021 - Security Misconfiguration",
  attacker: {
    story: [
      {
        text: "You visit a website URL and instead of a page, you see a list of files and folders. What common misconfiguration is this?",
        choices: [
          {
            text: "Directory listing is enabled, exposing file structure",
            correct: true,
            points: 15,
            feedback: "Exactly! Directory listings can reveal sensitive files and structure.",
            nextStep: 1
          },
          {
            text: "The website is under maintenance",
            correct: false,
            points: 5,
            feedback: "Maintenance pages usually say so - this shows actual file listings.",
            nextStep: 0
          },
          {
            text: "The page failed to load properly",
            correct: false,
            points: 5,
            feedback: "Load failures show errors, not organized file listings.",
            nextStep: 0
          }
        ]
      },
      {
        text: "What sensitive information might be exposed through directory listings?",
        choices: [
          {
            text: "Configuration files, backups, or unpublished pages",
            correct: true,
            points: 20,
            feedback: "Correct! File listings can expose files not meant for public view.",
            nextStep: 2
          },
          {
            text: "User passwords in plain text",
            correct: false,
            points: -10,
            feedback: "Passwords shouldn't be in web-accessible directories anyway.",
            nextStep: 2
          },
          {
            text: "The website source code",
            correct: false,
            points: 10,
            feedback: "While possible, most servers don't serve source files directly.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Security misconfiguration! Directory listing enabled, exposing server file structure.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you disable directory listings?",
        choices: [
          {
            text: "Configure web server to disable directory browsing",
            correct: true,
            points: 15,
            feedback: "Essential! Server configuration should prevent automatic directory listings.",
            nextStep: 1
          },
          {
            text: "Put an index.html file in every directory",
            correct: false,
            points: -15,
            feedback: "This works but doesn't address the configuration issue.",
            nextStep: 1
          },
          {
            text: "Use complex folder names that are hard to guess",
            correct: false,
            points: -10,
            feedback: "Security through obscurity doesn't work.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the proper web server hardening?",
        choices: [
          {
            text: "Disable directory listing, remove default files, and configure proper permissions",
            correct: true,
            points: 20,
            feedback: "Comprehensive hardening! Multiple measures to secure web servers.",
            nextStep: 2
          },
          {
            text: "Allow listing only for specific folders",
            correct: false,
            points: -20,
            feedback: "Better to disable completely - you might forget some folders.",
            nextStep: 2
          },
          {
            text: "Use the same configuration for all servers",
            correct: false,
            points: -15,
            feedback: "Different servers may have different requirements.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Server configuration secured! Directory listing disabled and default files removed.",
        choices: []
      }
    ]
  }
},

vulnerableComponents415: {
  id: 415,
  title: "Using Abandoned Open Source Libraries",
  difficulty: "Easy",
  vulnerability: "A06:2021 - Vulnerable and Outdated Components",
  attacker: {
    story: [
      {
        text: "You discover a website using a JavaScript library that hasn't been updated in 5 years. What security risk exists even if no vulnerabilities are currently known?",
        choices: [
          {
            text: "The library is abandoned and won't get security patches for new vulnerabilities",
            correct: true,
            points: 15,
            feedback: "Good point! Abandoned libraries become vulnerable over time as new threats emerge.",
            nextStep: 1
          },
          {
            text: "The library might be slower than newer versions",
            correct: false,
            points: 5,
            feedback: "Performance is not the primary security concern.",
            nextStep: 0
          },
          {
            text: "Newer browsers might not support it",
            correct: false,
            points: 5,
            feedback: "Browser compatibility is a different issue.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why are abandoned libraries particularly dangerous?",
        choices: [
          {
            text: "New vulnerabilities won't be fixed, making the application permanently vulnerable",
            correct: true,
            points: 20,
            feedback: "Exactly! Without maintenance, vulnerabilities remain open forever.",
            nextStep: 2
          },
          {
            text: "They take up more disk space",
            correct: false,
            points: -10,
            feedback: "Storage space is not a security risk.",
            nextStep: 2
          },
          {
            text: "They might conflict with other libraries",
            correct: false,
            points: -15,
            feedback: "Compatibility issues are different from security vulnerabilities.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Vulnerable components risk! Using abandoned libraries without security updates.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should you choose third-party libraries?",
        choices: [
          {
            text: "Select actively maintained libraries with regular security updates",
            correct: true,
            points: 15,
            feedback: "Essential! Active maintenance ensures ongoing security.",
            nextStep: 1
          },
          {
            text: "Use the most popular library regardless of maintenance",
            correct: false,
            points: -15,
            feedback: "Popularity doesn't guarantee security or maintenance.",
            nextStep: 1
          },
          {
            text: "Stick with older, proven stable versions",
            correct: false,
            points: -10,
            feedback: "Older versions lack protection against new threats.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the proper component management strategy?",
        choices: [
          {
            text: "Regularly review and update dependencies, replacing abandoned ones",
            correct: true,
            points: 20,
            feedback: "Proactive management! Continuously evaluate and update components.",
            nextStep: 2
          },
          {
            text: "Use the same versions forever once tested",
            correct: false,
            points: -20,
            feedback: "This guarantees vulnerabilities over time.",
            nextStep: 2
          },
          {
            text: "Only update when adding new features",
            correct: false,
            points: -15,
            feedback: "Security updates should happen independently of feature development.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Component management improved! Now using actively maintained libraries with regular updates.",
        choices: []
      }
    ]
  }
},

authFailure416: {
  id: 416,
  title: "Password Reset Links That Don't Expire",
  difficulty: "Easy",
  vulnerability: "A07:2021 - Identification and Authentication Failures",
  attacker: {
    story: [
      {
        text: "You request a password reset and receive a link. What happens if you use the same link to reset your password again a week later?",
        choices: [
          {
            text: "The link might still work, allowing repeated password changes",
            correct: true,
            points: 15,
            feedback: "Exactly! Reset links should expire after use or time limit.",
            nextStep: 1
          },
          {
            text: "The link will definitely be expired and not work",
            correct: false,
            points: 5,
            feedback: "That would be secure behavior, but we're testing for vulnerabilities.",
            nextStep: 0
          },
          {
            text: "You need to request a new link each time",
            correct: false,
            points: 5,
            feedback: "This is how it should work, but we're checking if it does.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why are non-expiring reset links dangerous?",
        choices: [
          {
            text: "Anyone with the link can reset the password anytime in the future",
            correct: true,
            points: 20,
            feedback: "Correct! Permanent reset links are like permanent master keys.",
            nextStep: 2
          },
          {
            text: "They make the email inbox full",
            correct: false,
            points: -10,
            feedback: "Storage space is not the security concern.",
            nextStep: 2
          },
          {
            text: "Users might forget they requested a reset",
            correct: false,
            points: -15,
            feedback: "This is a usability issue, not a security vulnerability.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Authentication failure! Password reset links without expiration enabling account takeover.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should password reset links be designed?",
        choices: [
          {
            text: "Make them single-use and expire after short time (e.g., 1 hour)",
            correct: true,
            points: 15,
            feedback: "Essential! Time-limited, single-use tokens are secure.",
            nextStep: 1
          },
          {
            text: "Use longer links that are harder to guess",
            correct: false,
            points: -15,
            feedback: "Length doesn't matter if links don't expire.",
            nextStep: 1
          },
          {
            text: "Send reset codes via SMS instead of links",
            correct: false,
            points: -10,
            feedback: "Delivery method doesn't solve the expiration issue.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the secure reset process?",
        choices: [
          {
            text: "Time-limited, single-use tokens with immediate invalidation after use",
            correct: true,
            points: 20,
            feedback: "Secure design! Multiple protections prevent reuse and delay attacks.",
            nextStep: 2
          },
          {
            text: "Allow users to disable old links manually",
            correct: false,
            points: -20,
            feedback: "Relying on user action is not reliable security.",
            nextStep: 2
          },
          {
            text: "Use the same expiration for all users",
            correct: false,
            points: -15,
            feedback: "Different user types might need different security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Password reset secured! Now using time-limited, single-use tokens.",
        choices: []
      }
    ]
  }
},

softwareIntegrity417: {
  id: 417,
  title: "Client-Side Price Validation in E-commerce",
  difficulty: "Easy",
  vulnerability: "A08:2021 - Software and Data Integrity Failures",
  attacker: {
    story: [
      {
        text: "An online store shows item prices in HTML and uses JavaScript to calculate totals. What happens if you modify the price in browser developer tools?",
        choices: [
          {
            text: "You might be able to purchase items at manipulated prices",
            correct: true,
            points: 15,
            feedback: "Exactly! Client-side validation can be bypassed.",
            nextStep: 1
          },
          {
            text: "The JavaScript will detect the change and block the purchase",
            correct: false,
            points: 5,
            feedback: "That would require the JavaScript to validate itself - unlikely.",
            nextStep: 0
          },
          {
            text: "The page will crash when you try to checkout",
            correct: false,
            points: 5,
            feedback: "Crashes are errors, not intentional security measures.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is client-side price validation insufficient?",
        choices: [
          {
            text: "Users can modify any client-side data before sending to server",
            correct: true,
            points: 20,
            feedback: "Correct! Never trust client-side data for critical business logic.",
            nextStep: 2
          },
          {
            text: "JavaScript might be disabled in some browsers",
            correct: false,
            points: -10,
            feedback: "While true, this is not the primary security concern.",
            nextStep: 2
          },
          {
            text: "Client-side calculations are slower",
            correct: false,
            points: -15,
            feedback: "Performance is not the security issue.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Data integrity failure! Client-side price validation enabling price manipulation.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should e-commerce prices be validated?",
        choices: [
          {
            text: "Verify all prices server-side before processing payment",
            correct: true,
            points: 15,
            feedback: "Essential! Always validate business logic server-side.",
            nextStep: 1
          },
          {
            text: "Use stronger JavaScript obfuscation",
            correct: false,
            points: -15,
            feedback: "Obfuscation can be reverse-engineered - not a security solution.",
            nextStep: 1
          },
          {
            text: "Hide prices until checkout page",
            correct: false,
            points: -10,
            feedback: "Prices still need to be sent to client eventually.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the proper e-commerce security?",
        choices: [
          {
            text: "Server-side validation for all business logic and cryptographic signing of transactions",
            correct: true,
            points: 20,
            feedback: "Comprehensive approach! Multiple server-side validations prevent manipulation.",
            nextStep: 2
          },
          {
            text: "Allow price changes only for logged-in users",
            correct: false,
            points: -20,
            feedback: "Logged-in users can still be attackers.",
            nextStep: 2
          },
          {
            text: "Use the same validation for all products",
            correct: false,
            points: -15,
            feedback: "Different products may require different validation rules.",
            nextStep: 2
          }
        ]
      },
      {
        text: "E-commerce security implemented! Now validating all prices server-side.",
        choices: []
      }
    ]
  }
},

loggingFailures418: {
  id: 418,
  title: "Not Logging User Logouts",
  difficulty: "Easy",
  vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
  attacker: {
    story: [
      {
        text: "You notice a system logs user logins but not logouts. During an investigation, how does this limit security monitoring?",
        choices: [
          {
            text: "You can't tell if a user session ended normally or was hijacked",
            correct: true,
            points: 15,
            feedback: "Exactly! Logout events help distinguish normal activity from attacks.",
            nextStep: 1
          },
          {
            text: "The logs will be too large to read",
            correct: false,
            points: 5,
            feedback: "Logout events are small and infrequent.",
            nextStep: 0
          },
          {
            text: "Users might forget to logout",
            correct: false,
            points: 5,
            feedback: "User behavior is different from logging capability.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why are logout events important for security investigations?",
        choices: [
          {
            text: "They help establish session timelines and detect session hijacking",
            correct: true,
            points: 20,
            feedback: "Correct! Session timelines are crucial for incident investigation.",
            nextStep: 2
          },
          {
            text: "They reduce the number of active sessions on the server",
            correct: false,
            points: -10,
            feedback: "Session management is separate from logging.",
            nextStep: 2
          },
          {
            text: "They help users remember their login history",
            correct: false,
            points: -15,
            feedback: "User convenience is not the primary security reason.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Logging failure! Missing logout events limiting security monitoring and investigation.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "What authentication events should be logged?",
        choices: [
          {
            text: "Both login and logout events with timestamps and IP addresses",
            correct: true,
            points: 15,
            feedback: "Essential! Complete session tracking enables proper security monitoring.",
            nextStep: 1
          },
          {
            text: "Only failed login attempts to save space",
            correct: false,
            points: -15,
            feedback: "Successful events are also important for establishing patterns.",
            nextStep: 1
          },
          {
            text: "Logouts only for administrative users",
            correct: false,
            points: -10,
            feedback: "All user sessions should be tracked for security.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive authentication logging?",
        choices: [
          {
            text: "Log all authentication events: success, failure, logout, and password changes",
            correct: true,
            points: 20,
            feedback: "Complete monitoring! All critical authentication activities should be logged.",
            nextStep: 2
          },
          {
            text: "Log only events that trigger security alerts",
            correct: false,
            points: -20,
            feedback: "You need baseline data to know what's abnormal.",
            nextStep: 2
          },
          {
            text: "Use the same log format for all applications",
            correct: false,
            points: -15,
            feedback: "Different applications may have different logging needs.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Authentication logging complete! Now tracking all login and logout events.",
        choices: []
      }
    ]
  }
},

ssrf419: {
  id: 419,
  title: "Webhook URL SSRF in Notification Settings",
  difficulty: "Easy",
  vulnerability: "A10:2021 - Server-Side Request Forgery",
  attacker: {
    story: [
      {
        text: "A service lets users set webhook URLs to receive notifications. What happens if you set a webhook to an internal server address like http://localhost?",
        choices: [
          {
            text: "The service might try to send notifications to internal servers",
            correct: true,
            points: 15,
            feedback: "Good thinking! Webhook features can be abused for SSRF.",
            nextStep: 1
          },
          {
            text: "The webhook will be rejected automatically",
            correct: false,
            points: 5,
            feedback: "That would be secure behavior, but we're testing for vulnerabilities.",
            nextStep: 0
          },
          {
            text: "Only HTTPS URLs are allowed",
            correct: false,
            points: 5,
            feedback: "HTTP might still be accepted, and localhost is internal regardless of protocol.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can this help map internal networks?",
        choices: [
          {
            text: "Try different internal addresses and see which ones accept connections",
            correct: true,
            points: 20,
            feedback: "Correct! Response patterns reveal internal network structure.",
            nextStep: 2
          },
          {
            text: "Use the webhook to upload files to internal servers",
            correct: false,
            points: -10,
            feedback: "Webhooks typically send data, not receive files.",
            nextStep: 2
          },
          {
            text: "Brute force internal server passwords",
            correct: false,
            points: -15,
            feedback: "Webhooks don't typically involve authentication to internal services.",
            nextStep: 2
          }
        ]
      },
      {
        text: "SSRF vulnerability! Webhook feature allows requests to internal network addresses.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure webhook URL configuration?",
        choices: [
          {
            text: "Validate URLs and block internal IP addresses and domains",
            correct: true,
            points: 15,
            feedback: "Essential! Restrict webhooks to external addresses only.",
            nextStep: 1
          },
          {
            text: "Use a proxy for all webhook requests",
            correct: false,
            points: -15,
            feedback: "Proxies might still allow internal network access.",
            nextStep: 1
          },
          {
            text: "Only allow webhooks from verified domains",
            correct: false,
            points: -10,
            feedback: "Verification doesn't prevent internal address usage.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive webhook security?",
        choices: [
          {
            text: "URL validation, allowlisting, and network segmentation",
            correct: true,
            points: 20,
            feedback: "Layered protection! Multiple controls prevent SSRF through webhooks.",
            nextStep: 2
          },
          {
            text: "Allow any URL but timeout quickly",
            correct: false,
            points: -20,
            feedback: "Timeouts don't prevent the initial connection attempt.",
            nextStep: 2
          },
          {
            text: "Use the same validation for all webhook types",
            correct: false,
            points: -15,
            feedback: "Different webhook purposes may require different security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Webhook security implemented! Now validating URLs and blocking internal addresses.",
        choices: []
      }
    ]
  }
},

accessControl420: {
  id: 420,
  title: "GraphQL Field-Level Authorization Bypass",
  difficulty: "Hard",
  vulnerability: "A01:2021 - Broken Access Control",
  attacker: {
    story: [
      {
        text: "You discover a GraphQL API where object-level authorization exists but field-level authorization is missing. Users can query their own data but what happens with nested sensitive fields?",
        choices: [
          {
            text: "Users can access sensitive fields of their objects that should be restricted",
            correct: true,
            points: 30,
            feedback: "Critical finding! GraphQL field-level authorization is essential for fine-grained access control.",
            nextStep: 1
          },
          {
            text: "The query fails with authentication errors",
            correct: false,
            points: 5,
            feedback: "That would indicate proper field-level authorization.",
            nextStep: 0
          },
          {
            text: "Only admin users can query nested fields",
            correct: false,
            points: 10,
            feedback: "The issue is field-level within accessible objects, not overall query access.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can you exploit missing field-level authorization in GraphQL?",
        choices: [
          {
            text: "Query sensitive fields within accessible objects using GraphQL's flexible query structure",
            correct: true,
            points: 35,
            feedback: "Sophisticated attack! GraphQL's flexibility becomes a risk without proper field-level controls.",
            nextStep: 2
          },
          {
            text: "Modify the GraphQL schema directly",
            correct: false,
            points: -25,
            feedback: "Schema modification requires different access levels.",
            nextStep: 2
          },
          {
            text: "Use SQL injection in GraphQL arguments",
            correct: false,
            points: -20,
            feedback: "This would be a different vulnerability category.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced access control failure! Missing GraphQL field-level authorization enables data exposure within otherwise accessible objects.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you implement proper GraphQL field-level authorization?",
        choices: [
          {
            text: "Use GraphQL middleware or directives to enforce field-level permissions",
            correct: true,
            points: 30,
            feedback: "Enterprise solution! GraphQL directives provide declarative field-level security.",
            nextStep: 1
          },
          {
            text: "Restrict entire object types instead of individual fields",
            correct: false,
            points: -30,
            feedback: "This breaks legitimate use cases - need granular field control.",
            nextStep: 1
          },
          {
            text: "Use query depth limiting as the primary protection",
            correct: false,
            points: -25,
            feedback: "Depth limiting doesn't prevent accessing sensitive fields at allowed depths.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the zero-trust GraphQL security architecture?",
        choices: [
          {
            text: "Field-level directives, query cost analysis, and persistent query validation",
            correct: true,
            points: 35,
            feedback: "Comprehensive GraphQL security! Multiple layers protect against various attack vectors.",
            nextStep: 2
          },
          {
            text: "Allow all fields but filter responses client-side",
            correct: false,
            points: -40,
            feedback: "Client-side filtering exposes data in transit - filter at source.",
            nextStep: 2
          },
          {
            text: "Use the same field permissions for all user roles",
            correct: false,
            points: -35,
            feedback: "Different roles require different field-level access.",
            nextStep: 2
          }
        ]
      },
      {
        text: "GraphQL security hardened! Now implementing field-level authorization with declarative directives.",
        choices: []
      }
    ]
  }
},

cryptoFailures421: {
  id: 421,
  title: "Homomorphic Encryption Implementation Flaws",
  difficulty: "Hard",
  vulnerability: "A02:2021 - Cryptographic Failures",
  attacker: {
    story: [
      {
        text: "A system uses homomorphic encryption to process data while encrypted. What novel cryptographic risk exists if the implementation has mathematical errors?",
        choices: [
          {
            text: "Computations on ciphertext may leak information about plaintext through side channels",
            correct: true,
            points: 30,
            feedback: "Advanced finding! Homomorphic encryption introduces new attack surfaces through computation leakage.",
            nextStep: 1
          },
          {
            text: "The encrypted data might become corrupted",
            correct: false,
            points: 10,
            feedback: "Data corruption is a reliability issue, not a cryptographic vulnerability.",
            nextStep: 0
          },
          {
            text: "Key rotation becomes more difficult",
            correct: false,
            points: 5,
            feedback: "Operational complexity is different from cryptographic weaknesses.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can mathematical imperfections in homomorphic encryption be exploited?",
        choices: [
          {
            text: "Analyze computation patterns to derive information about encrypted data",
            correct: true,
            points: 35,
            feedback: "Sophisticated cryptanalysis! Homomorphic operations can reveal data patterns despite encryption.",
            nextStep: 2
          },
          {
            text: "Brute force the encryption key faster",
            correct: false,
            points: -30,
            feedback: "Homomorphic encryption doesn't typically weaken key strength directly.",
            nextStep: 2
          },
          {
            text: "Modify the encrypted data during computation",
            correct: false,
            points: -25,
            feedback: "Data modification is a different attack vector.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced cryptographic failure! Homomorphic encryption implementation flaws enable plaintext recovery through computation analysis.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure homomorphic encryption implementations?",
        choices: [
          {
            text: "Use formally verified libraries and limit computation complexity",
            correct: true,
            points: 30,
            feedback: "Essential! Formal verification ensures mathematical correctness in homomorphic operations.",
            nextStep: 1
          },
          {
            text: "Use larger key sizes to compensate for implementation flaws",
            correct: false,
            points: -35,
            feedback: "Key size doesn't fix mathematical implementation errors.",
            nextStep: 1
          },
          {
            text: "Perform all computations on isolated networks",
            correct: false,
            points: -30,
            feedback: "Network isolation doesn't prevent cryptographic analysis of computation patterns.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the enterprise homomorphic encryption strategy?",
        choices: [
          {
            text: "Formal verification, noise management, and computation auditing",
            correct: true,
            points: 35,
            feedback: "Comprehensive approach! Multiple controls ensure homomorphic encryption security.",
            nextStep: 2
          },
          {
            text: "Use homomorphic encryption for all data processing",
            correct: false,
            points: -40,
            feedback: "Homomorphic encryption has performance costs and specific use cases.",
            nextStep: 2
          },
          {
            text: "Implement custom homomorphic algorithms for better security",
            correct: false,
            points: -45,
            feedback: "Custom cryptography is dangerous - use well-vetted standard implementations.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Homomorphic encryption secured! Now using formally verified implementations with proper noise management.",
        choices: []
      }
    ]
  }
},

injection422: {
  id: 422,
  title: "NoSQL Operator Injection in Graph Queries",
  difficulty: "Hard",
  vulnerability: "A03:2021 - Injection",
  attacker: {
    story: [
      {
        text: "A graph database application constructs Cypher queries by concatenating user input. What injection risk exists beyond traditional SQL injection?",
        choices: [
          {
            text: "Graph query injection enabling data relationship manipulation and traversal",
            correct: true,
            points: 30,
            feedback: "Advanced finding! Graph query injection can expose relationship patterns and connected data.",
            nextStep: 1
          },
          {
            text: "The graph database might crash from malformed queries",
            correct: false,
            points: 10,
            feedback: "System crashes are reliability issues, not the primary injection risk.",
            nextStep: 0
          },
          {
            text: "Query performance might degrade",
            correct: false,
            points: 5,
            feedback: "Performance impact is not the security vulnerability.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can graph query injection reveal hidden data relationships?",
        choices: [
          {
            text: "Inject graph traversal patterns to explore connected nodes and relationships",
            correct: true,
            points: 35,
            feedback: "Sophisticated technique! Graph injection can map entire data networks and hidden connections.",
            nextStep: 2
          },
          {
            text: "Overwrite graph node properties directly",
            correct: false,
            points: -30,
            feedback: "Property modification requires different vulnerability types.",
            nextStep: 2
          },
          {
            text: "Use traditional SQL injection techniques",
            correct: false,
            points: -25,
            feedback: "Graph databases use different query languages than SQL.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced injection vulnerability! Graph query injection enables exploration of data relationships and network patterns.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent graph database injection?",
        choices: [
          {
            text: "Use parameterized graph queries with bound parameters",
            correct: true,
            points: 30,
            feedback: "Essential! Parameterized queries separate data from graph traversal logic.",
            nextStep: 1
          },
          {
            text: "Validate user input against a list of allowed graph patterns",
            correct: false,
            points: -35,
            feedback: "Pattern validation is complex and error-prone in graph contexts.",
            nextStep: 1
          },
          {
            text: "Use query timeouts as primary protection",
            correct: false,
            points: -30,
            feedback: "Timeouts don't prevent data exposure, just slow down attacks.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive graph database security?",
        choices: [
          {
            text: "Parameterized queries, query planning limits, and relationship-level authorization",
            correct: true,
            points: 35,
            feedback: "Enterprise graph security! Multiple layers protect graph data and relationships.",
            nextStep: 2
          },
          {
            text: "Allow only pre-defined graph query templates",
            correct: false,
            points: -40,
            feedback: "This severely limits graph database flexibility and utility.",
            nextStep: 2
          },
          {
            text: "Use the same query validation for all graph databases",
            correct: false,
            points: -35,
            feedback: "Different graph databases have different query languages and security needs.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Graph database security implemented! Now using parameterized queries with traversal limits.",
        choices: []
      }
    ]
  }
},

insecureDesign423: {
  id: 423,
  title: "Event Sourcing without Command Validation",
  difficulty: "Hard",
  vulnerability: "A04:2021 - Insecure Design",
  attacker: {
    story: [
      {
        text: "A system uses event sourcing architecture where events are immutable once stored. What design flaw exists if commands aren't properly validated before generating events?",
        choices: [
          {
            text: "Invalid state changes become permanent in the event store",
            correct: true,
            points: 30,
            feedback: "Critical design flaw! Event sourcing requires rigorous command validation since events are immutable.",
            nextStep: 1
          },
          {
            text: "The event store might grow too large",
            correct: false,
            points: 10,
            feedback: "Storage size is an operational concern, not a security design flaw.",
            nextStep: 0
          },
          {
            text: "Event replay might take longer",
            correct: false,
            points: 5,
            feedback: "Performance is not the security issue.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can weak command validation compromise event-sourced systems?",
        choices: [
          {
            text: "Malicious events become part of permanent history, corrupting all future state",
            correct: true,
            points: 35,
            feedback: "Sophisticated risk! Event sourcing immutability makes validation errors permanent and systemic.",
            nextStep: 2
          },
          {
            text: "Events might be processed out of order",
            correct: false,
            points: -30,
            feedback: "Ordering issues are different from validation failures.",
            nextStep: 2
          },
          {
            text: "The event bus might become overloaded",
            correct: false,
            points: -25,
            feedback: "Performance degradation is not the security impact.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Insecure design! Event sourcing without proper command validation enables permanent system corruption through malicious events.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure event sourcing architecture?",
        choices: [
          {
            text: "Implement strong command validation and event schema evolution controls",
            correct: true,
            points: 30,
            feedback: "Essential! Command validation is the primary defense in event-sourced systems.",
            nextStep: 1
          },
          {
            text: "Use cryptographic signing for all events",
            correct: false,
            points: -35,
            feedback: "Signing doesn't prevent logically invalid commands from being accepted.",
            nextStep: 1
          },
          {
            text: "Allow event modification for administrative fixes",
            correct: false,
            points: -40,
            feedback: "Event modification breaks event sourcing principles and creates audit issues.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the robust event sourcing security pattern?",
        choices: [
          {
            text: "Command validation, event versioning, and compensation event strategies",
            correct: true,
            points: 35,
            feedback: "Enterprise event sourcing! Comprehensive approach handles validation and error recovery.",
            nextStep: 2
          },
          {
            text: "Validate events during replay instead of at command time",
            correct: false,
            points: -45,
            feedback: "By replay time, invalid events are already permanently stored.",
            nextStep: 2
          },
          {
            text: "Use the same validation rules for all event types",
            correct: false,
            points: -40,
            feedback: "Different event types have different validation requirements.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Event sourcing secured! Now implementing comprehensive command validation with compensation strategies.",
        choices: []
      }
    ]
  }
},

securityMisconfig424: {
  id: 424,
  title: "Service Mesh mTLS Configuration Bypass",
  difficulty: "Hard",
  vulnerability: "A05:2021 - Security Misconfiguration",
  attacker: {
    story: [
      {
        text: "A Kubernetes cluster uses service mesh with mTLS, but some services are configured in permissive mode for migration. What advanced bypass risk exists?",
        choices: [
          {
            text: "Attackers can bypass mTLS by targeting services in permissive mode",
            correct: true,
            points: 30,
            feedback: "Critical finding! Mixed mTLS modes create bypass opportunities through the weakest configured service.",
            nextStep: 1
          },
          {
            text: "The service mesh might use more CPU resources",
            correct: false,
            points: 5,
            feedback: "Resource usage is operational, not a security bypass risk.",
            nextStep: 0
          },
          {
            "text": "Logging might be inconsistent across services",
            correct: false,
            points: 10,
            feedback: "Logging inconsistencies are observability issues.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can permissive mTLS mode be exploited for lateral movement?",
        choices: [
          {
            text: "Compromise a service in permissive mode and use it to communicate with strict mode services",
            correct: true,
            points: 35,
            feedback: "Advanced container escape! Mixed mTLS modes enable pivoting from weak to strong security zones.",
            nextStep: 2
          },
          {
            text: "Directly attack the service mesh control plane",
            correct: false,
            points: -30,
            feedback: "Control plane attacks are different from mTLS bypass.",
            nextStep: 2
          },
          {
            text: "Use DNS spoofing between services",
            correct: false,
            points: -25,
            feedback: "DNS attacks are mitigated by proper service mesh security.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced security misconfiguration! Mixed mTLS modes in service mesh enable authentication bypass and lateral movement.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you properly configure service mesh mTLS?",
        choices: [
          {
            text: "Use strict mTLS mode universally with explicit exception policies",
            correct: true,
            points: 30,
            feedback: "Essential! Universal strict mTLS with documented exceptions prevents bypass attacks.",
            nextStep: 1
          },
          {
            text: "Gradually enable mTLS without monitoring mixed mode risks",
            correct: false,
            points: -40,
            feedback: "Unmonitored migration creates security gaps.",
            nextStep: 1
          },
          {
            text: "Use permissive mode permanently for legacy services",
            correct: false,
            points: -35,
            feedback: "Permanent exceptions become permanent vulnerabilities.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the zero-trust service mesh architecture?",
        choices: [
          {
            text: "Universal mTLS, network policies, and continuous security validation",
            correct: true,
            points: 35,
            feedback: "Enterprise service mesh! Comprehensive zero-trust implementation for microservices.",
            nextStep: 2
          },
          {
            text: "Allow permissive mode for all development environments",
            correct: false,
            points: -45,
            feedback: "Development environments should mirror production security.",
            nextStep: 2
          },
          {
            text: "Use the same mTLS settings for all namespaces",
            correct: false,
            points: -40,
            feedback: "Different namespaces may have different security requirements.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Service mesh security hardened! Now using universal strict mTLS with proper exception management.",
        choices: []
      }
    ]
  }
},

vulnerableComponents425: {
  id: 425,
  title: "Blockchain Smart Contract Reentrancy Attacks",
  difficulty: "Hard",
  vulnerability: "A06:2021 - Vulnerable and Outdated Components",
  attacker: {
    story: [
      {
        text: "A DeFi application uses a smart contract with external calls before updating internal state. What advanced component vulnerability exists?",
        choices: [
          {
            text: "Reentrancy attack - recursive calls can drain contract funds",
            correct: true,
            points: 30,
            feedback: "Critical blockchain finding! Reentrancy is a classic smart contract vulnerability with devastating consequences.",
            nextStep: 1
          },
          {
            text: "The contract might use too much gas",
            correct: false,
            points: 10,
            feedback: "Gas costs are economic, not security vulnerabilities.",
            nextStep: 0
          },
          {
            text: "Transaction fees might be too high",
            correct: false,
            points: 5,
            feedback: "Fee structure is different from contract security.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How does reentrancy enable fund drainage in smart contracts?",
        choices: [
          {
            text: "Malicious contract recursively calls withdrawal function before balance updates",
            correct: true,
            points: 35,
            feedback: "Sophisticated attack! Reentrancy exploits the gap between external calls and state updates.",
            nextStep: 2
          },
          {
            text: "Directly modify the contract bytecode",
            correct: false,
            points: -35,
            feedback: "Bytecode modification is prevented by blockchain immutability.",
            nextStep: 2
          },
          {
            text: "Use quantum computing to break cryptography",
            correct: false,
            points: -30,
            feedback: "Quantum attacks are theoretical and different from reentrancy.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced component vulnerability! Smart contract reentrancy enables recursive fund drainage through state update race conditions.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent smart contract reentrancy attacks?",
        choices: [
          {
            text: "Use checks-effects-interactions pattern and reentrancy guards",
            correct: true,
            points: 30,
            feedback: "Essential! CEI pattern and guards prevent state manipulation during external calls.",
            nextStep: 1
          },
          {
            text: "Limit contract functionality to avoid external calls",
            correct: false,
            points: -40,
            feedback: "This severely limits smart contract utility.",
            nextStep: 1
          },
          {
            text: "Use larger gas limits to prevent recursive calls",
            correct: false,
            points: -35,
            feedback: "Gas limits don't prevent reentrancy, just limit recursion depth.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive smart contract security?",
        choices: [
          {
            text: "Formal verification, security patterns, and bug bounty programs",
            correct: true,
            points: 35,
            feedback: "Enterprise blockchain security! Multiple approaches ensure contract safety.",
            nextStep: 2
          },
          {
            text: "Use the same security patterns for all contract types",
            correct: false,
            points: -45,
            feedback: "Different contract types have different security requirements.",
            nextStep: 2
          },
          {
            text: "Allow contract upgrades to fix vulnerabilities later",
            correct: false,
            points: -40,
            feedback: "Upgradeability introduces its own security risks.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Smart contract security implemented! Now using CEI pattern with reentrancy guards and formal verification.",
        choices: []
      }
    ]
  }
},

authFailure426: {
  id: 426,
  title: "OAuth 2.0 Device Authorization Grant Misconfiguration",
  difficulty: "Hard",
  vulnerability: "A07:2021 - Identification and Authentication Failures",
  attacker: {
    story: [
      {
        text: "An IoT device uses OAuth 2.0 Device Authorization Grant but doesn't properly validate the binding between device code and user session. What advanced authentication risk exists?",
        choices: [
          {
            text: "Session swapping - attacker can associate their account with victim's device code",
            correct: true,
            points: 30,
            feedback: "Advanced OAuth finding! Device flow requires strict binding between device codes and user sessions.",
            nextStep: 1
          },
          {
            text: "The device might use too much battery",
            correct: false,
            points: 5,
            feedback: "Power consumption is not an authentication vulnerability.",
            nextStep: 0
          },
          {
            text: "User codes might be too long to type",
            correct: false,
            points: 5,
            feedback: "Usability is different from security.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can device authorization flow be exploited for account takeover?",
        choices: [
          {
            text: "Intercept device code and complete authorization with attacker's account",
            correct: true,
            points: 35,
            feedback: "Sophisticated attack! Weak device-user binding enables account association attacks.",
            nextStep: 2
          },
          {
            text: "Brute force the device code directly",
            correct: false,
            points: -30,
            feedback: "Device codes are typically long and random.",
            nextStep: 2
          },
          {
            text: "Modify the device hardware to bypass authentication",
            correct: false,
            points: -25,
            feedback: "Hardware attacks are different from protocol vulnerabilities.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced authentication failure! OAuth device flow misconfiguration enables session swapping and account takeover.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure OAuth 2.0 Device Authorization Grant?",
        choices: [
          {
            text: "Implement strict device code-user session binding with short expiration",
            correct: true,
            points: 30,
            feedback: "Essential! Strong binding and short lifetimes prevent session swapping.",
            nextStep: 1
          },
          {
            text: "Use longer device codes for better security",
            correct: false,
            points: -35,
            feedback: "Code length doesn't prevent session binding issues.",
            nextStep: 1
          },
          {
            text: "Require biometric authentication on all devices",
            correct: false,
            points: -30,
            feedback: "Not all devices support biometrics, and this doesn't fix protocol issues.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive device authentication strategy?",
        choices: [
          {
            text: "Device attestation, binding validation, and continuous authentication",
            correct: true,
            points: 35,
            feedback: "Enterprise IoT security! Multiple layers protect device authentication flows.",
            nextStep: 2
          },
          {
            text: "Allow device codes to be used multiple times",
            correct: false,
            points: -45,
            feedback: "Reusable codes dramatically increase security risk.",
            nextStep: 2
          },
          {
            text: "Use the same OAuth flow for all device types",
            correct: false,
            points: -40,
            feedback: "Different devices may require different authentication strategies.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Device authentication secured! Now implementing strict session binding with device attestation.",
        choices: []
      }
    ]
  }
},

softwareIntegrity427: {
  id: 427,
  title: "CI/CD Pipeline Dependency Confusion Through Build Args",
  difficulty: "Hard",
  vulnerability: "A08:2021 - Software and Data Integrity Failures",
  attacker: {
    story: [
      {
        text: "A CI/CD pipeline uses build arguments to specify dependency versions, but doesn't verify artifact provenance. What advanced supply chain risk exists?",
        choices: [
          {
            text: "Dependency confusion through build argument manipulation",
            correct: true,
            points: 30,
            feedback: "Critical finding! Build-time dependency specification without verification enables supply chain attacks.",
            nextStep: 1
          },
          {
            text: "Builds might take longer to complete",
            correct: false,
            points: 5,
            feedback: "Performance is not the integrity risk.",
            nextStep: 0
          },
          {
            text: "Artifact sizes might be larger than expected",
            correct: false,
            points: 5,
            feedback: "Size variations are operational issues.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can build argument manipulation compromise software integrity?",
        choices: [
          {
            text: "Inject malicious dependency versions that get built into production artifacts",
            correct: true,
            points: 35,
            feedback: "Sophisticated supply chain attack! Build argument control enables dependency poisoning.",
            nextStep: 2
          },
          {
            text: "Directly modify the source code in repository",
            correct: false,
            points: -35,
            feedback: "Source modification requires different access levels.",
            nextStep: 2
          },
          {
            text: "Use social engineering to change dependency versions",
            correct: false,
            points: -30,
            feedback: "Social engineering is a different attack vector.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced integrity failure! CI/CD build argument manipulation enables dependency confusion and supply chain compromise.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure CI/CD dependency management?",
        choices: [
          {
            text: "Use lock files and verify artifact provenance through signing",
            correct: true,
            points: 30,
            feedback: "Essential! Lock files and provenance verification prevent dependency manipulation.",
            nextStep: 1
          },
          {
            text: "Allow flexible dependency versions for latest features",
            correct: false,
            points: -40,
            feedback: "Flexibility creates security risk - pin versions precisely.",
            nextStep: 1
          },
          {
            text: "Use checksums without cryptographic signing",
            correct: false,
            points: -35,
            feedback: "Checksums don't provide provenance - need cryptographic signatures.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive software supply chain security?",
        choices: [
          {
            text: "SBOM generation, provenance verification, and policy enforcement",
            correct: true,
            points: 35,
            feedback: "Enterprise supply chain security! Multiple controls ensure software integrity.",
            nextStep: 2
          },
          {
            text: "Allow dependency updates without security review",
            correct: false,
            points: -45,
            feedback: "All dependency changes should be reviewed for security impact.",
            nextStep: 2
          },
          {
            text: "Use the same dependency policies for all projects",
            correct: false,
            points: -40,
            feedback: "Different projects may have different security requirements.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Supply chain security implemented! Now using lock files, SBOMs, and provenance verification.",
        choices: []
      }
    ]
  }
},

loggingFailures428: {
  id: 428,
  title: "Distributed Tracing Context Injection Attacks",
  difficulty: "Hard",
  vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
  attacker: {
    story: [
      {
        text: "A microservices application uses distributed tracing but doesn't validate trace context headers. What advanced log corruption risk exists?",
        choices: [
          {
            text: "Trace context injection - attackers can manipulate tracing data and corrupt observability",
            correct: true,
            points: 30,
            feedback: "Advanced finding! Distributed tracing without validation enables observability manipulation.",
            nextStep: 1
          },
          {
            text: "Tracing might use too much storage",
            correct: false,
            points: 5,
            feedback: "Storage costs are operational, not security vulnerabilities.",
            nextStep: 0
          },
          {
            text: "Trace data might be incomplete",
            correct: false,
            points: 10,
            feedback: "Data completeness is an observability issue.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can trace context manipulation affect security monitoring?",
        choices: [
          {
            text: "Inject false trace data to hide real attack patterns and create false incidents",
            correct: true,
            points: 35,
            feedback: "Sophisticated attack! Trace manipulation can deceive security monitoring and incident response.",
            nextStep: 2
          },
          {
            text: "Directly modify stored trace data in databases",
            correct: false,
            points: -35,
            feedback: "Database modification requires different access levels.",
            nextStep: 2
          },
          {
            text: "Use tracing to perform timing attacks",
            correct: false,
            points: -30,
            feedback: "Timing attacks are different from trace manipulation.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced logging failure! Distributed tracing context injection enables observability manipulation and security monitoring bypass.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure distributed tracing?",
        choices: [
          {
            text: "Validate and sanitize trace context headers with cryptographic signatures",
            correct: true,
            points: 30,
            feedback: "Essential! Trace context validation prevents observability manipulation.",
            nextStep: 1
          },
          {
            text: "Disable tracing for security-sensitive services",
            correct: false,
            points: -40,
            feedback: "This reduces visibility into critical services.",
            nextStep: 1
          },
          {
            text: "Use tracing only in development environments",
            correct: false,
            points: -35,
            feedback: "Production needs tracing for operational and security visibility.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive observability security?",
        choices: [
          {
            text: "Trace validation, log integrity, and monitoring anomaly detection",
            correct: true,
            points: 35,
            feedback: "Enterprise observability security! Multiple layers protect monitoring integrity.",
            nextStep: 2
          },
          {
            text: "Allow untrusted trace context for maximum visibility",
            correct: false,
            points: -45,
            feedback: "Untrusted tracing data is worse than no tracing data.",
            nextStep: 2
          },
          {
            text: "Use the same tracing configuration for all services",
            correct: false,
            points: -40,
            feedback: "Different services may have different tracing requirements.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Observability security implemented! Now validating trace contexts and ensuring log integrity.",
        choices: []
      }
    ]
  }
},

ssrf429: {
  id: 429,
  title: "DNS Rebinding to Bypass Cloud-Native Security Controls",
  difficulty: "Hard",
  vulnerability: "A10:2021 - Server-Side Request Forgery",
  attacker: {
    story: [
      {
        text: "A cloud-native application uses service mesh but has SSRF vulnerabilities in legacy components. What advanced bypass technique combines SSRF with cloud networking?",
        choices: [
          {
            text: "DNS rebinding to bypass service mesh policies and access restricted services",
            correct: true,
            points: 30,
            feedback: "Advanced cloud SSRF! DNS rebinding can circumvent service mesh security controls.",
            nextStep: 1
          },
          {
            text: "The service mesh might add latency to requests",
            correct: false,
            points: 5,
            feedback: "Performance impact is not a security bypass.",
            nextStep: 0
          },
          {
            text: "Network policies might be too complex to manage",
            correct: false,
            points: 10,
            feedback: "Management complexity is operational, not a vulnerability.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can DNS rebinding exploit mixed security models in cloud-native environments?",
        choices: [
          {
            text: "Use DNS to resolve to external IP during validation but internal IP during mesh routing",
            correct: true,
            points: 35,
            feedback: "Sophisticated cloud attack! DNS rebinding exploits timing differences in security enforcement.",
            nextStep: 2
          },
          {
            text: "Directly modify service mesh configuration",
            correct: false,
            points: -35,
            feedback: "Mesh configuration requires elevated privileges.",
            nextStep: 2
          },
          {
            text: "Use IP spoofing to bypass network policies",
            correct: false,
            points: -30,
            feedback: "IP spoofing is typically blocked in cloud environments.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced SSRF technique! DNS rebinding bypasses cloud-native security controls through protocol-level exploitation.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent DNS rebinding in cloud-native architectures?",
        choices: [
          {
            text: "Implement DNS filtering and egress controls with consistent validation",
            correct: true,
            points: 30,
            feedback: "Essential! Comprehensive DNS security prevents rebinding attacks.",
            nextStep: 1
          },
          {
            text: "Use service mesh as the only SSRF protection",
            correct: false,
            points: -40,
            feedback: "Defense in depth required - mesh alone isn't sufficient.",
            nextStep: 1
          },
          {
            text: "Block all external DNS resolution",
            correct: false,
            points: -35,
            feedback: "This breaks legitimate application functionality.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the zero-trust network security for cloud-native?",
        choices: [
          {
            text: "Microsegmentation, DNS security, and consistent policy enforcement",
            correct: true,
            points: 35,
            feedback: "Enterprise cloud security! Multiple layers prevent network-based attacks.",
            nextStep: 2
          },
          {
            text: "Allow full network access within service mesh",
            correct: false,
            points: -45,
            feedback: "This creates massive attack surface.",
            nextStep: 2
          },
          {
            text: "Use the same network policies for all environments",
            correct: false,
            points: -40,
            feedback: "Different environments require different security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Cloud-native security hardened! Now implementing DNS filtering with microsegmentation.",
        choices: []
      }
    ]
  }
},

accessControl430: {
  id: 430,
  title: "Attribute-Based Access Control (ABAC) Policy Injection",
  difficulty: "Hard",
  vulnerability: "A01:2021 - Broken Access Control",
  attacker: {
    story: [
      {
        text: "An ABAC system evaluates policies based on user attributes, but policies can be modified through API calls. What advanced access control risk exists when policy conditions use user-provided data?",
        choices: [
          {
            text: "Policy injection - manipulating attribute values to bypass ABAC conditions",
            correct: true,
            points: 30,
            feedback: "Critical finding! ABAC systems are vulnerable to policy injection when user attributes influence policy evaluation.",
            nextStep: 1
          },
          {
            text: "The policy engine might process requests slower",
            correct: false,
            points: 5,
            feedback: "Performance impact is not the security vulnerability.",
            nextStep: 0
          },
          {
            text: "User attributes might become inconsistent across systems",
            correct: false,
            points: 10,
            feedback: "Data consistency is operational, not an access control bypass.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can ABAC policy injection lead to privilege escalation?",
        choices: [
          {
            text: "Modify user attributes to satisfy policy conditions for restricted operations",
            correct: true,
            points: 35,
            feedback: "Sophisticated attack! ABAC policy injection exploits the gap between attribute modification and policy evaluation.",
            nextStep: 2
          },
          {
            text: "Directly modify the policy decision point logic",
            correct: false,
            points: -30,
            feedback: "PDP modification requires different access levels.",
            nextStep: 2
          },
          {
            text: "Replay authorized requests from other users",
            correct: false,
            points: -25,
            feedback: "Request replay is a different attack vector.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced access control failure! ABAC policy injection enables privilege escalation through attribute manipulation.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure ABAC implementations against policy injection?",
        choices: [
          {
            text: "Implement attribute validation and separation between user-modifiable and system attributes",
            correct: true,
            points: 30,
            feedback: "Essential! Attribute classification and validation prevent policy injection attacks.",
            nextStep: 1
          },
          {
            text: "Use longer attribute names to make manipulation harder",
            correct: false,
            points: -35,
            feedback: "Attribute naming doesn't prevent value manipulation.",
            nextStep: 1
          },
          {
            text: "Cache policy decisions indefinitely for performance",
            correct: false,
            points: -30,
            feedback: "Caching can bypass real-time attribute validation.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the enterprise ABAC security architecture?",
        choices: [
          {
            text: "Attribute validation, policy signing, and decision logging with real-time monitoring",
            correct: true,
            points: 35,
            feedback: "Comprehensive ABAC security! Multiple controls ensure policy integrity and prevent injection.",
            nextStep: 2
          },
          {
            text: "Allow users to modify all their attributes for flexibility",
            correct: false,
            points: -40,
            feedback: "Critical attributes should be system-controlled only.",
            nextStep: 2
          },
          {
            text: "Use the same policy language for all applications",
            correct: false,
            points: -35,
            feedback: "Different applications may require different policy approaches.",
            nextStep: 2
          }
        ]
      },
      {
        text: "ABAC security implemented! Now using attribute validation and policy signing with comprehensive monitoring.",
        choices: []
      }
    ]
  }
},

cryptoFailures431: {
  id: 431,
  title: "Post-Quantum Cryptography Migration Risks",
  difficulty: "Hard",
  vulnerability: "A02:2021 - Cryptographic Failures",
  attacker: {
    story: [
      {
        text: "An organization is migrating to post-quantum cryptography but maintains hybrid classical-PQC systems during transition. What cryptographic risk exists during this migration period?",
        choices: [
          {
            text: "Cryptographic downgrade attacks forcing fallback to vulnerable classical algorithms",
            correct: true,
            points: 30,
            feedback: "Advanced finding! Cryptographic migration creates downgrade attack surfaces.",
            nextStep: 1
          },
          {
            text: "The new algorithms might use more computational resources",
            correct: false,
            points: 10,
            feedback: "Performance impact is operational, not a security vulnerability.",
            nextStep: 0
          },
          {
            text: "Key sizes might be larger requiring more storage",
            correct: false,
            points: 5,
            feedback: "Storage requirements are not security risks.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can attackers exploit hybrid cryptographic systems?",
        choices: [
          {
            text: "Force protocol downgrade to classical cryptography and exploit known vulnerabilities",
            correct: true,
            points: 35,
            feedback: "Sophisticated attack! Hybrid systems enable downgrade to weaker cryptography.",
            nextStep: 2
          },
          {
            text: "Use quantum computers to break PQC algorithms directly",
            correct: false,
            points: -35,
            feedback: "Quantum computers capable of breaking PQC are not yet practical.",
            nextStep: 2
          },
          {
            text: "Steal larger PQC keys through traditional means",
            correct: false,
            points: -30,
            feedback: "Key theft is a different attack vector.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced cryptographic failure! Hybrid PQC migration enables cryptographic downgrade attacks.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you securely migrate to post-quantum cryptography?",
        choices: [
          {
            text: "Implement strict cryptographic policies preventing downgrade and using PQC-first approach",
            correct: true,
            points: 30,
            feedback: "Essential! Cryptographic agility with downgrade prevention ensures secure migration.",
            nextStep: 1
          },
          {
            text: "Allow flexible algorithm negotiation for maximum compatibility",
            correct: false,
            points: -40,
            feedback: "Flexibility creates downgrade vulnerabilities.",
            nextStep: 1
          },
          {
            text: "Use only PQC algorithms without fallback options",
            correct: false,
            points: -35,
            feedback: "Complete removal of fallbacks can break interoperability.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive PQC migration strategy?",
        choices: [
          {
            text: "Cryptographic inventory, risk assessment, and phased migration with monitoring",
            correct: true,
            points: 35,
            feedback: "Enterprise PQC migration! Structured approach ensures security throughout transition.",
            nextStep: 2
          },
          {
            text: "Migrate all systems simultaneously for consistency",
            correct: false,
            points: -45,
            feedback: "Big-bang migration creates operational risks.",
            nextStep: 2
          },
          {
            text: "Use the same PQC algorithm for all use cases",
            correct: false,
            points: -40,
            feedback: "Different use cases may require different PQC approaches.",
            nextStep: 2
          }
        ]
      },
      {
        text: "PQC migration secured! Now using downgrade-resistant protocols with comprehensive monitoring.",
        choices: []
      }
    ]
  }
},

injection432: {
  id: 432,
  title: "Prototype Pollution in JavaScript Runtime",
  difficulty: "Hard",
  vulnerability: "A03:2021 - Injection",
  attacker: {
    story: [
      {
        text: "A Node.js application merges user input with existing objects using vulnerable functions like Object.assign(). What advanced injection risk affects the JavaScript runtime itself?",
        choices: [
          {
            text: "Prototype pollution - modifying Object prototype to affect all objects",
            correct: true,
            points: 30,
            feedback: "Critical finding! Prototype pollution enables runtime manipulation affecting entire application.",
            nextStep: 1
          },
          {
            text: "The application might have memory leaks",
            correct: false,
            points: 5,
            feedback: "Memory issues are different from prototype pollution.",
            nextStep: 0
          },
          {
            text: "JavaScript execution might become slower",
            correct: false,
            points: 5,
            feedback: "Performance impact is not the security vulnerability.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can prototype pollution lead to remote code execution?",
        choices: [
          {
            text: "Pollute prototype with malicious properties that get evaluated during operations",
            correct: true,
            points: 35,
            feedback: "Sophisticated technique! Prototype pollution can lead to RCE through property injection.",
            nextStep: 2
          },
          {
            text: "Directly modify the Node.js binary in memory",
            correct: false,
            points: -35,
            feedback: "Binary modification requires different vulnerabilities.",
            nextStep: 2
          },
          {
            text: "Use traditional SQL injection in database calls",
            correct: false,
            points: -30,
            feedback: "SQL injection is a different vulnerability category.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced injection vulnerability! Prototype pollution enables JavaScript runtime manipulation and potential RCE.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent prototype pollution in JavaScript applications?",
        choices: [
          {
            text: "Use Object.create(null) for safe objects and validate input with prototype-free merging",
            correct: true,
            points: 30,
            feedback: "Essential! Safe object creation and input validation prevent prototype pollution.",
            nextStep: 1
          },
          {
            text: "Disable the Object prototype entirely",
            correct: false,
            points: -40,
            feedback: "This breaks fundamental JavaScript functionality.",
            nextStep: 1
          },
          {
            text: "Use only primitive data types throughout application",
            correct: false,
            points: -35,
            feedback: "This is impractical for complex applications.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive JavaScript runtime security?",
        choices: [
          {
            text: "Prototype pollution prevention, code sandboxing, and security-focused linting",
            correct: true,
            points: 35,
            feedback: "Enterprise JavaScript security! Multiple layers protect the runtime environment.",
            nextStep: 2
          },
          {
            text: "Allow prototype modification only in development",
            correct: false,
            points: -45,
            feedback: "Development practices often leak to production.",
            nextStep: 2
          },
          {
            text: "Use the same object patterns for all applications",
            correct: false,
            points: -40,
            feedback: "Different applications may require different object handling.",
            nextStep: 2
          }
        ]
      },
      {
        text: "JavaScript runtime secured! Now using safe object patterns with comprehensive input validation.",
        choices: []
      }
    ]
  }
},

insecureDesign433: {
  id: 433,
  title: "Zero-Knowledge Proof Implementation Flaws",
  difficulty: "Hard",
  vulnerability: "A04:2021 - Insecure Design",
  attacker: {
    story: [
      {
        text: "A privacy-preserving system uses zero-knowledge proofs but the implementation has subtle mathematical errors in proof generation. What fundamental design risk exists?",
        choices: [
          {
            text: "Proof soundness failure - accepting invalid proofs that leak information",
            correct: true,
            points: 30,
            feedback: "Critical design flaw! ZKP soundness failures compromise the fundamental privacy guarantee.",
            nextStep: 1
          },
          {
            text: "Proof generation might be computationally expensive",
            correct: false,
            points: 10,
            feedback: "Performance costs are operational, not design flaws.",
            nextStep: 0
          },
          {
            text: "Proof sizes might be larger than necessary",
            correct: false,
            points: 5,
            feedback: "Size optimization is different from security design.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can ZKP soundness failures compromise privacy?",
        choices: [
          {
            text: "Accept proofs that reveal partial information about the secret witness",
            correct: true,
            points: 35,
            feedback: "Sophisticated risk! Soundness failures can gradually leak secret information through multiple proofs.",
            nextStep: 2
          },
          {
            text: "Directly extract the secret from the proof",
            correct: false,
            points: -35,
            feedback: "Proper ZKPs should not allow direct secret extraction.",
            nextStep: 2
          },
          {
            text: "Modify the proof verification algorithm",
            correct: false,
            points: -30,
            feedback: "Algorithm modification requires different access levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Insecure design! Zero-knowledge proof implementation flaws compromise privacy through soundness failures.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you ensure zero-knowledge proof security?",
        choices: [
          {
            text: "Use formally verified ZKP libraries and implement comprehensive test vectors",
            correct: true,
            points: 30,
            feedback: "Essential! Formal verification and testing ensure ZKP cryptographic correctness.",
            nextStep: 1
          },
          {
            text: "Implement custom ZKP schemes for specific use cases",
            correct: false,
            points: -45,
            feedback: "Custom cryptography is extremely risky - use well-vetted implementations.",
            nextStep: 1
          },
          {
            text: "Use larger security parameters to compensate for implementation flaws",
            correct: false,
            points: -40,
            feedback: "Parameter size doesn't fix mathematical implementation errors.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the enterprise ZKP security framework?",
        choices: [
          {
            text: "Formal verification, security proofs, and independent cryptographic review",
            correct: true,
            points: 35,
            feedback: "Comprehensive ZKP security! Multiple validation layers ensure mathematical correctness.",
            nextStep: 2
          },
          {
            text: "Allow ZKP parameter tuning for performance optimization",
            correct: false,
            points: -50,
            feedback: "Parameter tuning can inadvertently weaken security.",
            nextStep: 2
          },
          {
            text: "Use the same ZKP system for all privacy requirements",
            correct: false,
            points: -45,
            feedback: "Different privacy needs may require different ZKP approaches.",
            nextStep: 2
          }
        ]
      },
      {
        text: "ZKP security implemented! Now using formally verified libraries with comprehensive testing.",
        choices: []
      }
    ]
  }
},

securityMisconfig434: {
  id: 434,
  title: "eBPF Program Verification Bypass in Container Security",
  difficulty: "Hard",
  vulnerability: "A05:2021 - Security Misconfiguration",
  attacker: {
    story: [
      {
        text: "A container security tool uses eBPF for runtime protection but has misconfigured program verification. What advanced kernel-level risk exists?",
        choices: [
          {
            text: "eBPF verification bypass enabling kernel memory access and container escape",
            correct: true,
            points: 30,
            feedback: "Critical finding! eBPF verification misconfigurations can lead to kernel-level compromises.",
            nextStep: 1
          },
          {
            text: "The eBPF programs might use more CPU resources",
            correct: false,
            points: 5,
            feedback: "Resource usage is operational, not a security bypass.",
            nextStep: 0
          },
          {
            text: "Container startup might be slower with eBPF enabled",
            correct: false,
            points: 5,
            feedback: "Performance impact is not the security risk.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can eBPF verification bypass lead to container escape?",
        choices: [
          {
            text: "Load malicious eBPF programs that access kernel memory and elevate privileges",
            correct: true,
            points: 35,
            feedback: "Sophisticated kernel attack! eBPF bypass enables direct kernel memory manipulation.",
            nextStep: 2
          },
          {
            text: "Directly modify container runtime configuration",
            correct: false,
            points: -35,
            feedback: "Runtime modification requires different access levels.",
            nextStep: 2
          },
          {
            text: "Use traditional container breakout techniques",
            correct: false,
            points: -30,
            feedback: "eBPF bypass is a more advanced attack vector.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced security misconfiguration! eBPF verification bypass enables kernel memory access and container escape.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure eBPF-based container security tools?",
        choices: [
          {
            text: "Implement strict eBPF program verification and use signed eBPF programs only",
            correct: true,
            points: 30,
            feedback: "Essential! eBPF verification and signing prevent malicious program loading.",
            nextStep: 1
          },
          {
            text: "Disable eBPF verification for better performance",
            correct: false,
            points: -45,
            feedback: "Disabling verification creates massive security risks.",
            nextStep: 1
          },
          {
            text: "Use eBPF only for monitoring without enforcement",
            correct: false,
            points: -40,
            feedback: "This reduces security effectiveness.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive container runtime security?",
        choices: [
          {
            text: "eBPF security, seccomp profiles, and kernel hardening with monitoring",
            correct: true,
            points: 35,
            feedback: "Enterprise container security! Multiple kernel-level protections prevent escapes.",
            nextStep: 2
          },
          {
            text: "Allow unrestricted eBPF for maximum visibility",
            correct: false,
            points: -50,
            feedback: "Unrestricted eBPF creates unacceptable kernel risks.",
            nextStep: 2
          },
          {
            text: "Use the same eBPF policies for all containers",
            correct: false,
            points: -45,
            feedback: "Different containers may require different security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Container security hardened! Now using verified eBPF programs with kernel protection.",
        choices: []
      }
    ]
  }
},

vulnerableComponents435: {
  id: 435,
  title: "AI/ML Model Poisoning Through Training Data",
  difficulty: "Hard",
  vulnerability: "A06:2021 - Vulnerable and Outdated Components",
  attacker: {
    story: [
      {
        text: "A machine learning system retrains models with new user data without proper validation. What advanced supply chain risk affects the AI model itself?",
        choices: [
          {
            text: "Model poisoning - injecting malicious data to manipulate model behavior",
            correct: true,
            points: 30,
            feedback: "Critical finding! AI model poisoning creates backdoors and manipulation through training data.",
            nextStep: 1
          },
          {
            text: "The model might become less accurate over time",
            correct: false,
            points: 10,
            feedback: "Accuracy degradation is operational, not a security vulnerability.",
            nextStep: 0
          },
          {
            text: "Model inference might use more computational resources",
            correct: false,
            points: 5,
            feedback: "Resource usage is not the security risk.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can model poisoning create hidden backdoors?",
        choices: [
          {
            text: "Inject training data with specific triggers that cause desired malicious behavior",
            correct: true,
            points: 35,
            feedback: "Sophisticated AI attack! Model poisoning embeds triggers that activate under specific conditions.",
            nextStep: 2
          },
          {
            text: "Directly modify the trained model weights",
            correct: false,
            points: -35,
            feedback: "Weight modification requires model file access.",
            nextStep: 2
          },
          {
            text: "Use adversarial attacks during inference only",
            correct: false,
            points: -30,
            feedback: "Adversarial attacks are different from training data poisoning.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced component vulnerability! AI model poisoning enables hidden backdoors through malicious training data.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure machine learning training pipelines?",
        choices: [
          {
            text: "Implement data provenance, anomaly detection, and model validation",
            correct: true,
            points: 30,
            feedback: "Essential! ML pipeline security requires data and model validation.",
            nextStep: 1
          },
          {
            text: "Use larger training datasets to dilute poisoned data",
            correct: false,
            points: -40,
            feedback: "Dataset size doesn't prevent targeted poisoning attacks.",
            nextStep: 1
          },
          {
            text: "Train models once and never update them",
            correct: false,
            points: -35,
            feedback: "Static models become outdated and ineffective.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive AI security framework?",
        choices: [
          {
            text: "Secure data pipelines, model testing, and runtime protection with monitoring",
            correct: true,
            points: 35,
            feedback: "Enterprise AI security! Multiple layers protect throughout ML lifecycle.",
            nextStep: 2
          },
          {
            text: "Allow unrestricted data sources for maximum training data",
            correct: false,
            points: -45,
            feedback: "Unrestricted data creates poisoning vulnerabilities.",
            nextStep: 2
          },
          {
            text: "Use the same model architecture for all AI applications",
            correct: false,
            points: -40,
            feedback: "Different applications require different AI approaches.",
            nextStep: 2
          }
        ]
      },
      {
        text: "AI security implemented! Now using secure data pipelines with comprehensive model validation.",
        choices: []
      }
    ]
  }
},

authFailure436: {
  id: 436,
  title: "WebAuthn Implementation Flaws in FIDO2 Authentication",
  difficulty: "Hard",
  vulnerability: "A07:2021 - Identification and Authentication Failures",
  attacker: {
    story: [
      {
        text: "A WebAuthn implementation doesn't properly validate authenticator attestation and allows registration without verification. What advanced authentication risk exists?",
        choices: [
          {
            text: "Authenticator impersonation - registering malicious authenticators as legitimate",
            correct: true,
            points: 30,
            feedback: "Critical finding! WebAuthn without proper attestation enables authenticator spoofing.",
            nextStep: 1
          },
          {
            text: "The authentication might take longer to complete",
            correct: false,
            points: 5,
            feedback: "Performance impact is not the security vulnerability.",
            nextStep: 0
          },
          {
            text: "Users might need additional hardware",
            correct: false,
            points: 5,
            feedback: "Hardware requirements are operational, not security risks.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can WebAuthn attestation flaws lead to authentication bypass?",
        choices: [
          {
            text: "Register software authenticators as hardware authenticators bypassing security requirements",
            correct: true,
            points: 35,
            feedback: "Sophisticated FIDO2 attack! Attestation flaws enable authenticator type spoofing.",
            nextStep: 2
          },
          {
            text: "Directly steal the private key from hardware authenticators",
            correct: false,
            points: -35,
            feedback: "Hardware key extraction is extremely difficult.",
            nextStep: 2
          },
          {
            text: "Use phishing to capture WebAuthn challenges",
            correct: false,
            points: -30,
            feedback: "Phishing is a different attack vector.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced authentication failure! WebAuthn implementation flaws enable authenticator impersonation and security bypass.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you properly implement WebAuthn with FIDO2?",
        choices: [
          {
            text: "Enforce authenticator attestation verification and maintain trusted authenticator lists",
            correct: true,
            points: 30,
            feedback: "Essential! Attestation verification ensures authenticator legitimacy.",
            nextStep: 1
          },
          {
            text: "Allow any authenticator for maximum user convenience",
            correct: false,
            points: -40,
            feedback: "Convenience creates security risks with unverified authenticators.",
            nextStep: 1
          },
          {
            text: "Use WebAuthn without user verification for simpler UX",
            correct: false,
            points: -35,
            feedback: "User verification is a critical security component.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive FIDO2 security architecture?",
        choices: [
          {
            text: "Attestation verification, policy enforcement, and continuous authenticator assessment",
            correct: true,
            points: 35,
            feedback: "Enterprise FIDO2 security! Multiple controls ensure authenticator trust.",
            nextStep: 2
          },
          {
            text: "Use the same attestation policy for all user types",
            correct: false,
            points: -45,
            feedback: "Different user risk levels may require different attestation requirements.",
            nextStep: 2
          },
          {
            text: "Allow self-attestation for all authenticators",
            correct: false,
            points: -40,
            feedback: "Self-attestation provides no security guarantees.",
            nextStep: 2
          }
        ]
      },
      {
        text: "WebAuthn security implemented! Now enforcing authenticator attestation with comprehensive verification.",
        choices: []
      }
    ]
  }
},

softwareIntegrity437: {
  id: 437,
  title: "Trusted Execution Environment (TEE) Side-Channel Attacks",
  difficulty: "Hard",
  vulnerability: "A08:2021 - Software and Data Integrity Failures",
  attacker: {
    story: [
      {
        text: "A confidential computing application uses TEEs but doesn't protect against microarchitectural attacks. What advanced integrity risk exists at the hardware level?",
        choices: [
          {
            text: "TEE side-channel attacks extracting secrets through timing, cache, or power analysis",
            correct: true,
            points: 30,
            feedback: "Critical finding! TEEs are vulnerable to sophisticated microarchitectural attacks.",
            nextStep: 1
          },
          {
            text: "The TEE might have limited memory capacity",
            correct: false,
            points: 5,
            feedback: "Resource limitations are operational, not integrity failures.",
            nextStep: 0
          },
          {
            text: "TEE initialization might be slower than regular execution",
            correct: false,
            points: 5,
            feedback: "Performance impact is not the security vulnerability.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can side-channel attacks compromise TEE security guarantees?",
        choices: [
          {
            text: "Extract encryption keys and sensitive data through microarchitectural leakage",
            correct: true,
            points: 35,
            feedback: "Sophisticated hardware attack! Side-channels bypass TEE logical isolation.",
            nextStep: 2
          },
          {
            text: "Directly modify TEE memory contents",
            correct: false,
            points: -35,
            feedback: "Direct memory modification is prevented by hardware isolation.",
            nextStep: 2
          },
          {
            text: "Use software bugs in the TEE implementation",
            correct: false,
            points: -30,
            feedback: "Software bugs are different from hardware side-channels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced integrity failure! TEE side-channel attacks enable secret extraction despite hardware isolation.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you protect TEEs against side-channel attacks?",
        choices: [
          {
            text: "Implement constant-time algorithms and cache attack mitigations within TEE code",
            correct: true,
            points: 30,
            feedback: "Essential! TEE applications must be side-channel resistant through secure coding.",
            nextStep: 1
          },
          {
            text: "Use larger key sizes to compensate for side-channel leakage",
            correct: false,
            points: -40,
            feedback: "Key size doesn't prevent side-channel information leakage.",
            nextStep: 1
          },
          {
            text: "Disable CPU optimizations entirely for TEE execution",
            correct: false,
            points: -35,
            feedback: "This is often impractical and reduces performance significantly.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive confidential computing security?",
        choices: [
          {
            text: "Side-channel resistant code, hardware updates, and runtime attestation",
            correct: true,
            points: 35,
            feedback: "Enterprise confidential computing! Multiple layers protect against hardware attacks.",
            nextStep: 2
          },
          {
            text: "Assume TEEs are completely secure without additional protections",
            correct: false,
            points: -45,
            feedback: "TEEs require application-level security measures.",
            nextStep: 2
          },
          {
            text: "Use the same TEE configuration for all applications",
            correct: false,
            points: -40,
            feedback: "Different applications have different security requirements.",
            nextStep: 2
          }
        ]
      },
      {
        text: "TEE security enhanced! Now using side-channel resistant algorithms with comprehensive protection.",
        choices: []
      }
    ]
  }
},

loggingFailures438: {
  id: 438,
  title: "Differential Privacy Implementation Flaws",
  difficulty: "Hard",
  vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
  attacker: {
    story: [
      {
        text: "A analytics system uses differential privacy but the epsilon parameter is too large or noise generation is predictable. What advanced privacy logging risk exists?",
        choices: [
          {
            text: "Differential privacy failure enabling individual record reconstruction",
            correct: true,
            points: 30,
            feedback: "Critical finding! Differential privacy implementations can fail through parameter misuse.",
            nextStep: 1
          },
          {
            text: "The analytics might be less accurate with privacy protection",
            correct: false,
            points: 10,
            feedback: "Accuracy trade-offs are operational, not security failures.",
            nextStep: 0
          },
          {
            text: "Query performance might be slower with privacy mechanisms",
            correct: false,
            points: 5,
            feedback: "Performance impact is not the security vulnerability.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can differential privacy failures compromise individual privacy?",
        choices: [
          {
            text: "Reconstruct individual records through multiple queries and noise analysis",
            correct: true,
            points: 35,
            feedback: "Sophisticated privacy attack! Differential privacy failures enable statistical reconstruction.",
            nextStep: 2
          },
          {
            text: "Directly access the raw underlying data",
            correct: false,
            points: -35,
            feedback: "Direct access is prevented by the privacy layer.",
            nextStep: 2
          },
          {
            text: "Use timing attacks to infer query results",
            correct: false,
            points: -30,
            feedback: "Timing attacks are different from statistical reconstruction.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced logging failure! Differential privacy implementation flaws enable individual record reconstruction through statistical analysis.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you properly implement differential privacy?",
        choices: [
          {
            text: "Use appropriate epsilon values, secure noise generation, and query budgeting",
            correct: true,
            points: 30,
            feedback: "Essential! Proper parameter selection and implementation ensure differential privacy.",
            nextStep: 1
          },
          {
            text: "Use very small epsilon values for maximum privacy",
            correct: false,
            points: -40,
            feedback: "Extremely small epsilon makes data useless - balance is key.",
            nextStep: 1
          },
          {
            text: "Implement custom noise algorithms for specific use cases",
            correct: false,
            points: -35,
            feedback: "Custom algorithms risk mathematical errors - use proven implementations.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive privacy-preserving analytics framework?",
        choices: [
          {
            text: "Differential privacy, query auditing, and privacy budget enforcement",
            correct: true,
            points: 35,
            feedback: "Enterprise privacy analytics! Multiple controls ensure statistical privacy.",
            nextStep: 2
          },
          {
            text: "Allow unlimited queries with fixed epsilon values",
            correct: false,
            points: -45,
            feedback: "Unlimited queries enable privacy reconstruction attacks.",
            nextStep: 2
          },
          {
            text: "Use the same privacy parameters for all datasets",
            correct: false,
            points: -40,
            feedback: "Different datasets have different privacy sensitivities.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Differential privacy implemented! Now using proper epsilon values with query budgeting.",
        choices: []
      }
    ]
  }
},

ssrf439: {
  id: 439,
  title: "Serverless Function SSRF with IAM Role Assumption",
  difficulty: "Hard",
  vulnerability: "A10:2021 - Server-Side Request Forgery",
  attacker: {
    story: [
      {
        text: "A serverless function has SSRF vulnerability and executes with IAM roles that can assume other roles. What advanced cloud privilege escalation risk exists?",
        choices: [
          {
            text: "IAM role chaining through SSRF to escalate cloud permissions",
            correct: true,
            points: 30,
            feedback: "Critical finding! Serverless SSRF with IAM roles enables cloud privilege escalation.",
            nextStep: 1
          },
          {
            text: "The function might have cold start latency",
            correct: false,
            points: 5,
            feedback: "Performance characteristics are operational, not security vulnerabilities.",
            nextStep: 0
          },
          {
            text: "Function memory might be limited",
            correct: false,
            points: 5,
            feedback: "Resource limits are not security risks.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can serverless SSRF lead to cloud account compromise?",
        choices: [
          {
            text: "Use SSRF to access metadata service and assume higher-privileged IAM roles",
            correct: true,
            points: 35,
            feedback: "Sophisticated cloud attack! Serverless SSRF enables IAM role assumption chain attacks.",
            nextStep: 2
          },
          {
            text: "Directly modify the serverless function code",
            correct: false,
            points: -35,
            feedback: "Code modification requires different access levels.",
            nextStep: 2
          },
          {
            text: "Use traditional network scanning techniques",
            correct: false,
            points: -30,
            feedback: "Network scanning is different from IAM role exploitation.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced SSRF technique! Serverless function SSRF enables IAM role chaining and cloud privilege escalation.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure serverless functions against SSRF?",
        choices: [
          {
            text: "Implement strict egress controls and use minimal IAM roles with no assumption permissions",
            correct: true,
            points: 30,
            feedback: "Essential! Serverless security requires network and IAM hardening.",
            nextStep: 1
          },
          {
            text: "Allow full internet access for serverless functions",
            correct: false,
            points: -40,
            feedback: "Unrestricted access creates SSRF attack surface.",
            nextStep: 1
          },
          {
            text: "Use administrative IAM roles for all functions",
            correct: false,
            points: -45,
            feedback: "Over-privileged roles increase blast radius.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive serverless security architecture?",
        choices: [
          {
            text: "Network policies, minimal IAM roles, and runtime protection with monitoring",
            correct: true,
            points: 35,
            feedback: "Enterprise serverless security! Multiple layers protect cloud functions.",
            nextStep: 2
          },
          {
            text: "Allow role assumption for operational flexibility",
            correct: false,
            points: -50,
            feedback: "Role assumption creates privilege escalation risks.",
            nextStep: 2
          },
          {
            text: "Use the same IAM roles for all serverless functions",
            correct: false,
            points: -45,
            feedback: "Different functions require different permission levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Serverless security hardened! Now using minimal IAM roles with network controls.",
        choices: []
      }
    ]
  }
},

accessControl440: {
  id: 440,
  title: "API Endpoint Missing User Context Validation",
  difficulty: "Medium",
  vulnerability: "A01:2021 - Broken Access Control",
  attacker: {
    story: [
      {
        text: "You discover a REST API endpoint '/api/users/{userId}/orders' that returns user orders. What happens if you change the userId parameter to another user's ID?",
        choices: [
          {
            text: "You can access other users' order history without authorization",
            correct: true,
            points: 20,
            feedback: "Exactly! Missing user context validation allows horizontal privilege escalation.",
            nextStep: 1
          },
          {
            text: "The API returns an authentication error",
            correct: false,
            points: 5,
            feedback: "That would be secure behavior, but we're testing for vulnerabilities.",
            nextStep: 0
          },
          {
            text: "Only your own user ID works in the URL",
            correct: false,
            points: 5,
            feedback: "This would indicate proper access control is in place.",
            nextStep: 0
          }
        ]
      },
      {
        text: "What's the impact of being able to view other users' orders?",
        choices: [
          {
            text: "Privacy breach exposing personal information and purchase history",
            correct: true,
            points: 25,
            feedback: "Correct! This violates user privacy and can lead to further attacks.",
            nextStep: 2
          },
          {
            text: "You can modify other users' orders",
            correct: false,
            points: -15,
            feedback: "This vulnerability allows viewing, not necessarily modifying data.",
            nextStep: 2
          },
          {
            text: "The website performance will degrade",
            correct: false,
            points: -10,
            feedback: "Performance impact is not the primary security concern.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Access control failure! API endpoints missing user context validation enable unauthorized data access.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure user-specific API endpoints?",
        choices: [
          {
            text: "Validate that the authenticated user matches the requested user ID",
            correct: true,
            points: 20,
            feedback: "Essential! Always verify the user context matches the authenticated identity.",
            nextStep: 1
          },
          {
            text: "Use random user IDs that are hard to guess",
            correct: false,
            points: -15,
            feedback: "Obfuscation doesn't replace proper authorization checks.",
            nextStep: 1
          },
          {
            text: "Hide user IDs from URL parameters entirely",
            correct: false,
            points: -10,
            feedback: "This is often impractical for RESTful API design.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the proper authorization pattern for user resources?",
        choices: [
          {
            text: "Check user ownership for each resource access, not just endpoint access",
            correct: true,
            points: 25,
            feedback: "Good practice! Resource-level authorization ensures users only access their own data.",
            nextStep: 2
          },
          {
            text: "Use API keys instead of user authentication",
            correct: false,
            points: -20,
            feedback: "API keys don't solve user context validation problems.",
            nextStep: 2
          },
          {
            text: "Rate limit API calls to prevent mass data access",
            correct: false,
            points: -15,
            feedback: "Rate limiting helps but doesn't fix the authorization flaw.",
            nextStep: 2
          }
        ]
      },
      {
        text: "API authorization implemented! Now validating user context for all user-specific endpoints.",
        choices: []
      }
    ]
  }
},

cryptoFailures441: {
  id: 441,
  title: "Insecure SSL/TLS Configuration Supporting Weak Ciphers",
  difficulty: "Medium",
  vulnerability: "A02:2021 - Cryptographic Failures",
  attacker: {
    story: [
      {
        text: "You scan a website's SSL/TLS configuration and discover it supports outdated encryption protocols like SSLv3 and weak ciphers. What security risk does this create?",
        choices: [
          {
            text: "Downgrade attacks forcing weak encryption that can be broken",
            correct: true,
            points: 20,
            feedback: "Exactly! Supporting weak protocols enables cryptographic downgrade attacks.",
            nextStep: 1
          },
          {
            text: "The website might load slower with weak ciphers",
            correct: false,
            points: 5,
            feedback: "Performance impact is not the security risk.",
            nextStep: 0
          },
          {
            text: "Browser compatibility issues with older devices",
            correct: false,
            points: 5,
            feedback: "Compatibility is operational, not a security vulnerability.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can attackers exploit weak SSL/TLS configurations?",
        choices: [
          {
            text: "Force connections to use breakable encryption and decrypt traffic",
            correct: true,
            points: 25,
            feedback: "Correct! Weak ciphers can be broken to read encrypted communications.",
            nextStep: 2
          },
          {
            text: "Directly steal the SSL certificate private key",
            correct: false,
            points: -15,
            feedback: "Key theft requires different attack vectors.",
            nextStep: 2
          },
          {
            text: "Use the weak configuration to crash the server",
            correct: false,
            points: -10,
            feedback: "Server crashes are denial of service, not the cryptographic risk.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Cryptographic failure! Weak SSL/TLS configuration enables encryption downgrade and traffic decryption.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you properly configure SSL/TLS security?",
        choices: [
          {
            text: "Disable old protocols and weak ciphers, enable modern TLS with strong encryption",
            correct: true,
            points: 20,
            feedback: "Essential! Modern TLS configuration with strong ciphers only.",
            nextStep: 1
          },
          {
            text: "Support all protocols for maximum compatibility",
            correct: false,
            points: -20,
            feedback: "Compatibility should not compromise security.",
            nextStep: 1
          },
          {
            text: "Use longer SSL certificate key sizes only",
            correct: false,
            points: -15,
            feedback: "Key size doesn't help if weak protocols are enabled.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive TLS security approach?",
        choices: [
          {
            text: "TLS 1.2+ only, strong cipher suites, and regular security scanning",
            correct: true,
            points: 25,
            feedback: "Best practice! Regular scanning ensures configuration remains secure.",
            nextStep: 2
          },
          {
            text: "Allow SSLv3 for legacy application support",
            correct: false,
            points: -25,
            feedback: "SSLv3 is completely broken and should never be used.",
            nextStep: 2
          },
          {
            text: "Use the same TLS configuration for all servers",
            correct: false,
            points: -20,
            feedback: "Different servers may have different security requirements.",
            nextStep: 2
          }
        ]
      },
      {
        text: "TLS security hardened! Now using modern protocols with strong cipher suites only.",
        choices: []
      }
    ]
  }
},

injection442: {
  id: 442,
  title: "Command Injection Through File Upload Features",
  difficulty: "Medium",
  vulnerability: "A03:2021 - Injection",
  attacker: {
    story: [
      {
        text: "A website allows file uploads and processes them with system commands. What happens if you upload a file with a malicious name containing command injection characters?",
        choices: [
          {
            text: "The system might execute arbitrary commands during file processing",
            correct: true,
            points: 20,
            feedback: "Good thinking! File names used in system commands can lead to command injection.",
            nextStep: 1
          },
          {
            text: "The file upload will be rejected automatically",
            correct: false,
            points: 5,
            feedback: "That would be secure behavior, but we're testing for vulnerabilities.",
            nextStep: 0
          },
          {
            text: "The file will be saved with a different name",
            correct: false,
            points: 5,
            feedback: "Renaming would prevent the attack, but we're checking if it happens.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can command injection through file names be exploited?",
        choices: [
          {
            text: "Use semicolons or backticks in filenames to inject system commands",
            correct: true,
            points: 25,
            feedback: "Correct! Command separators in filenames can execute arbitrary commands.",
            nextStep: 2
          },
          {
            text: "Upload executable files directly",
            correct: false,
            points: -15,
            feedback: "Executable file upload is different from command injection.",
            nextStep: 2
          },
          {
            text: "Use SQL injection in the filename field",
            correct: false,
            points: -10,
            feedback: "SQL injection is a different vulnerability type.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Command injection vulnerability! File upload features executing system commands without proper input sanitization.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent command injection in file processing?",
        choices: [
          {
            text: "Sanitize file names and use parameterized system calls",
            correct: true,
            points: 20,
            feedback: "Essential! Input validation and safe API usage prevent command injection.",
            nextStep: 1
          },
          {
            text: "Block all special characters in file names",
            correct: false,
            points: -15,
            feedback: "This breaks legitimate file names - better to sanitize properly.",
            nextStep: 1
          },
          {
            text: "Use client-side validation only",
            correct: false,
            points: -20,
            feedback: "Client-side controls can be bypassed - always validate server-side.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the secure file handling approach?",
        choices: [
          {
            text: "Validate inputs, use safe APIs, and run with minimal privileges",
            correct: true,
            points: 25,
            feedback: "Comprehensive security! Multiple layers prevent file processing attacks.",
            nextStep: 2
          },
          {
            text: "Allow all file types but scan with antivirus",
            correct: false,
            points: -25,
            feedback: "Antivirus doesn't prevent command injection attacks.",
            nextStep: 2
          },
          {
            text: "Use the same validation for all file upload features",
            correct: false,
            points: -20,
            feedback: "Different upload features may require different security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "File upload security implemented! Now using input sanitization and safe system APIs.",
        choices: []
      }
    ]
  }
},

insecureDesign443: {
  id: 443,
  title: "Predictable Password Reset Tokens",
  difficulty: "Medium",
  vulnerability: "A04:2021 - Insecure Design",
  attacker: {
    story: [
      {
        text: "You notice password reset tokens are sequential numbers or based on predictable patterns like timestamps. What design flaw makes this insecure?",
        choices: [
          {
            text: "Predictable tokens can be guessed or brute forced easily",
            correct: true,
            points: 20,
            feedback: "Exactly! Predictable reset tokens enable account takeover attacks.",
            nextStep: 1
          },
          {
            text: "Users might receive multiple reset emails",
            correct: false,
            points: 5,
            feedback: "Email frequency is a usability issue, not a design flaw.",
            nextStep: 0
          },
          {
            text: "The tokens might be too short to remember",
            correct: false,
            points: 5,
            feedback: "Token memorability is not a security concern.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can predictable reset tokens lead to account compromise?",
        choices: [
          {
            text: "Attackers can guess valid tokens and reset passwords for any account",
            correct: true,
            points: 25,
            feedback: "Correct! Predictable tokens make account takeover trivial.",
            nextStep: 2
          },
          {
            text: "Tokens can be reused multiple times",
            correct: false,
            points: -15,
            feedback: "Reuse is a different issue from predictability.",
            nextStep: 2
          },
          {
            text: "Users might share their tokens accidentally",
            correct: false,
            points: -10,
            feedback: "User behavior is different from design flaws.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Insecure design! Predictable password reset tokens enable easy account takeover.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should password reset tokens be designed?",
        choices: [
          {
            text: "Use cryptographically secure random generators with sufficient length",
            correct: true,
            points: 20,
            feedback: "Essential! Secure random tokens prevent prediction and guessing.",
            nextStep: 1
          },
          {
            text: "Use shorter tokens for user convenience",
            correct: false,
            points: -20,
            feedback: "Short tokens are easier to guess - security over convenience.",
            nextStep: 1
          },
          {
            text: "Base tokens on user information for easy remembering",
            correct: false,
            points: -15,
            feedback: "User-based tokens are predictable - use random generation.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive password reset security?",
        choices: [
          {
            text: "Secure random tokens, short expiration, and one-time use only",
            correct: true,
            points: 25,
            feedback: "Best practice! Multiple security measures for reset tokens.",
            nextStep: 2
          },
          {
            text: "Allow token reuse for user convenience",
            correct: false,
            points: -25,
            feedback: "Token reuse creates security risks.",
            nextStep: 2
          },
          {
            text: "Use the same token format for all users",
            correct: false,
            points: -20,
            feedback: "Format consistency doesn't guarantee security.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Password reset design improved! Now using secure random tokens with proper expiration.",
        choices: []
      }
    ]
  }
},

securityMisconfig445: {
  id: 445,
  title: "Exposed Version Control Files in Web Root",
  difficulty: "Medium",
  vulnerability: "A05:2021 - Security Misconfiguration",
  attacker: {
    story: [
      {
        text: "You discover that a website's .git or .svn directories are accessible through the web server. What sensitive information might be exposed?",
        choices: [
          {
            text: "Source code, configuration files, and commit history",
            correct: true,
            points: 20,
            feedback: "Exactly! Version control files can expose the entire codebase and development history.",
            nextStep: 1
          },
          {
            text: "User session cookies and passwords",
            correct: false,
            points: 10,
            feedback: "Session data is typically not stored in version control.",
            nextStep: 0
          },
          {
            text: "Database connection strings only",
            correct: false,
            points: 5,
            feedback: "While possible, much more than just database info is exposed.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can exposed version control files help attackers?",
        choices: [
          {
            text: "Download the entire source code to find vulnerabilities and hardcoded secrets",
            correct: true,
            points: 25,
            feedback: "Correct! Source code access makes finding vulnerabilities much easier.",
            nextStep: 2
          },
          {
            text: "Directly modify the website content",
            correct: false,
            points: -15,
            feedback: "Version control access doesn't directly enable content modification.",
            nextStep: 2
          },
          {
            text: "Take over the version control server",
            correct: false,
            points: -10,
            feedback: "Web access to files doesn't provide server control.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Security misconfiguration! Exposed version control files revealing source code and sensitive information.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent version control file exposure?",
        choices: [
          {
            text: "Configure web server to block access to version control directories",
            correct: true,
            points: 20,
            feedback: "Essential! Web servers should block access to sensitive directories.",
            nextStep: 1
          },
          {
            text: "Use obscure directory names for version control",
            correct: false,
            points: -15,
            feedback: "Security through obscurity doesn't work - use proper configuration.",
            nextStep: 1
          },
          {
            text: "Delete version control files after deployment",
            correct: false,
            points: -10,
            feedback: "This breaks deployment processes - better to block access.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the proper web server security configuration?",
        choices: [
          {
            text: "Block sensitive directories, disable directory listing, and remove default files",
            correct: true,
            points: 25,
            feedback: "Comprehensive hardening! Multiple measures to secure web servers.",
            nextStep: 2
          },
          {
            text: "Allow directory listing for development convenience",
            correct: false,
            points: -25,
            feedback: "Directory listing should be disabled in production.",
            nextStep: 2
          },
          {
            text: "Use the same configuration for all environments",
            correct: false,
            points: -20,
            feedback: "Different environments may require different security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Web server secured! Now blocking access to version control and sensitive directories.",
        choices: []
      }
    ]
  }
},

vulnerableComponents446: {
  id: 446,
  title: "Known Vulnerabilities in Docker Base Images",
  difficulty: "Medium",
  vulnerability: "A06:2021 - Vulnerable and Outdated Components",
  attacker: {
    story: [
      {
        text: "You discover a Docker container using an outdated base image with known CVEs. What container-specific risk exists beyond the vulnerabilities themselves?",
        choices: [
          {
            text: "The entire container ecosystem inherits the base image vulnerabilities",
            correct: true,
            points: 20,
            feedback: "Exactly! Container base images propagate vulnerabilities to all derived images.",
            nextStep: 1
          },
          {
            text: "The container might use more disk space",
            correct: false,
            points: 5,
            feedback: "Storage usage is operational, not a security risk.",
            nextStep: 0
          },
          {
            text: "Container startup might be slower",
            correct: false,
            points: 5,
            feedback: "Performance impact is not the security vulnerability.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can vulnerable base images be exploited in container environments?",
        choices: [
          {
            text: "Escape the container to host system using base image vulnerabilities",
            correct: true,
            points: 25,
            feedback: "Correct! Container escape vulnerabilities often originate in base images.",
            nextStep: 2
          },
          {
            text: "Modify the container image during download",
            correct: false,
            points: -15,
            feedback: "Image modification during download is a different attack vector.",
            nextStep: 2
          },
          {
            text: "Use the vulnerabilities to mine cryptocurrency",
            correct: false,
            points: -10,
            feedback: "While possible, container escape is the more critical risk.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Vulnerable components! Outdated Docker base images with known vulnerabilities affecting container security.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you manage Docker image security?",
        choices: [
          {
            text: "Use minimal base images and regularly scan for vulnerabilities",
            correct: true,
            points: 20,
            feedback: "Essential! Minimal images and regular scanning reduce attack surface.",
            nextStep: 1
          },
          {
            text: "Use the latest base images without testing",
            correct: false,
            points: -20,
            feedback: "Latest images might have compatibility issues - test before updating.",
            nextStep: 1
          },
          {
            text: "Build custom base images from scratch",
            correct: false,
            points: -15,
            feedback: "This is complex and may introduce new vulnerabilities.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive container security strategy?",
        choices: [
          {
            text: "Image scanning, minimal base images, and runtime protection",
            correct: true,
            points: 25,
            feedback: "Best practice! Multiple layers for container security.",
            nextStep: 2
          },
          {
            text: "Allow all base images for development flexibility",
            correct: false,
            points: -25,
            feedback: "Flexibility should not compromise security.",
            nextStep: 2
          },
          {
            text: "Use the same base image for all containers",
            correct: false,
            points: -20,
            feedback: "Different containers may require different base images.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Container security improved! Now using minimal base images with regular vulnerability scanning.",
        choices: []
      }
    ]
  }
},

authFailure447: {
  id: 447,
  title: "Session Timeout Missing or Too Long",
  difficulty: "Medium",
  vulnerability: "A07:2021 - Identification and Authentication Failures",
  attacker: {
    story: [
      {
        text: "You notice a web application never logs you out automatically, even after days of inactivity. What authentication risk does this create?",
        choices: [
          {
            text: "Session hijacking risk if device is lost or shared",
            correct: true,
            points: 20,
            feedback: "Exactly! Unlimited sessions enable attacks if devices are compromised.",
            nextStep: 1
          },
          {
            text: "Users might forget their passwords",
            correct: false,
            points: 5,
            feedback: "Password memory is a usability issue.",
            nextStep: 0
          },
          {
            text: "The application uses more server memory",
            correct: false,
            points: 5,
            feedback: "Resource usage is operational, not a security risk.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can unlimited session duration be exploited?",
        choices: [
          {
            text: "Access accounts from lost/stolen devices or through session fixation",
            correct: true,
            points: 25,
            feedback: "Correct! Unlimited sessions remain vulnerable long after legitimate access.",
            nextStep: 2
          },
          {
            text: "Brute force the session ID directly",
            correct: false,
            points: -15,
            feedback: "Session IDs are typically long and random.",
            nextStep: 2
          },
          {
            text: "Use the session to overload the server",
            correct: false,
            points: -10,
            feedback: "Server overload is denial of service, not session exploitation.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Authentication failure! Missing session timeout enabling session hijacking and unauthorized access.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should session timeouts be configured?",
        choices: [
          {
            text: "Set reasonable timeouts (e.g., 30 minutes) for inactivity and absolute maximum",
            correct: true,
            points: 20,
            feedback: "Essential! Both inactivity and absolute timeouts protect sessions.",
            nextStep: 1
          },
          {
            text: "Use very short timeouts for maximum security",
            correct: false,
            points: -15,
            feedback: "Too short timeouts create poor user experience.",
            nextStep: 1
          },
          {
            text: "Let users choose their own timeout preferences",
            correct: false,
            points: -20,
            feedback: "Users often choose convenience over security.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the balanced session management approach?",
        choices: [
          {
            text: "Reasonable timeouts with remember-me options for low-risk applications",
            correct: true,
            points: 25,
            feedback: "Balanced approach! Security with usability considerations.",
            nextStep: 2
          },
          {
            text: "No timeouts for better user experience",
            correct: false,
            points: -25,
            feedback: "Convenience should not compromise security.",
            nextStep: 2
          },
          {
            text: "Use the same timeout for all user types",
            correct: false,
            points: -20,
            feedback: "Different user risk levels may require different timeouts.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Session management improved! Now implementing reasonable timeouts with security controls.",
        choices: []
      }
    ]
  }
},

softwareIntegrity448: {
  id: 448,
  title: "Client-Side Input Validation Bypass",
  difficulty: "Medium",
  vulnerability: "A08:2021 - Software and Data Integrity Failures",
  attacker: {
    story: [
      {
        text: "A web form uses JavaScript for input validation but doesn't validate server-side. What happens if you disable JavaScript or modify the form data before submission?",
        choices: [
          {
            text: "You can bypass validation and submit malicious data to the server",
            correct: true,
            points: 20,
            feedback: "Exactly! Client-side validation alone provides no security protection.",
            nextStep: 1
          },
          {
            text: "The form submission will fail completely",
            correct: false,
            points: 5,
            feedback: "That would require server-side validation to be working.",
            nextStep: 0
          },
          {
            text: "Only basic HTML validation will apply",
            correct: false,
            points: 5,
            feedback: "HTML validation is also client-side and can be bypassed.",
            nextStep: 0
          }
        ]
      },
      {
        text: "What types of attacks can bypass client-side validation?",
        choices: [
          {
            text: "SQL injection, XSS, and business logic bypass attacks",
            correct: true,
            points: 25,
            feedback: "Correct! All client-side controls can be bypassed for various attacks.",
            nextStep: 2
          },
          {
            text: "Only simple data format violations",
            correct: false,
            points: -15,
            feedback: "Much more serious attacks can bypass client-side validation.",
            nextStep: 2
          },
          {
            text: "Network interception and modification",
            correct: false,
            points: -10,
            feedback: "Network attacks are different from client-side bypass.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Software integrity failure! Relying on client-side validation enabling data manipulation attacks.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should input validation be implemented?",
        choices: [
          {
            text: "Validate all inputs server-side, use client-side only for user experience",
            correct: true,
            points: 20,
            feedback: "Essential! Server-side validation is mandatory for security.",
            nextStep: 1
          },
          {
            text: "Use complex JavaScript obfuscation to prevent bypass",
            correct: false,
            points: -20,
            feedback: "Obfuscation can be reverse-engineered - not a security solution.",
            nextStep: 1
          },
          {
            text: "Disable form submission if JavaScript is turned off",
            correct: false,
            points: -15,
            feedback: "This breaks accessibility and doesn't prevent other bypass methods.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive input validation strategy?",
        choices: [
          {
            text: "Server-side validation with client-side enhancement and input sanitization",
            correct: true,
            points: 25,
            feedback: "Best practice! Multiple layers with server-side as the primary protection.",
            nextStep: 2
          },
          {
            text: "Allow raw input and sanitize only during output",
            correct: false,
            points: -25,
            feedback: "Input validation should happen as early as possible.",
            nextStep: 2
          },
          {
            text: "Use the same validation rules for all applications",
            correct: false,
            points: -20,
            feedback: "Different applications have different validation requirements.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Input validation secured! Now implementing comprehensive server-side validation.",
        choices: []
      }
    ]
  }
},

loggingFailures449: {
  id: 449,
  title: "Insufficient Log Detail for Security Investigations",
  difficulty: "Medium",
  vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
  attacker: {
    story: [
      {
        text: "During a security incident, you discover logs only show 'login failed' without usernames, IP addresses, or timestamps. How does this impact incident response?",
        choices: [
          {
            text: "Unable to identify attack patterns, sources, or affected users",
            correct: true,
            points: 20,
            feedback: "Exactly! Insufficient log detail makes incident investigation impossible.",
            nextStep: 1
          },
          {
            text: "The logs take up too much storage space",
            correct: false,
            points: 5,
            feedback: "Storage concerns are operational, not security impacts.",
            nextStep: 0
          },
          {
            text: "Log analysis tools might not work properly",
            correct: false,
            points: 5,
            feedback: "Tool compatibility is different from log content adequacy.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why are detailed logs crucial for security monitoring?",
        choices: [
          {
            text: "They provide evidence for investigations and help identify attack patterns",
            correct: true,
            points: 25,
            feedback: "Correct! Detailed logs are essential for understanding and responding to attacks.",
            nextStep: 2
          },
          {
            text: "They make the system run faster",
            correct: false,
            points: -15,
            feedback: "Logging typically has minor performance impact.",
            nextStep: 2
          },
          {
            text: "They help users debug their own issues",
            correct: false,
            points: -10,
            feedback: "While useful, this is not the primary security purpose.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Logging failure! Insufficient log detail preventing effective security monitoring and incident response.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "What information should security logs include?",
        choices: [
          {
            text: "Timestamps, user identities, IP addresses, actions, and outcomes",
            correct: true,
            points: 20,
            feedback: "Essential! Comprehensive logging enables effective security monitoring.",
            nextStep: 1
          },
          {
            text: "Only successful actions to reduce log size",
            correct: false,
            points: -20,
            feedback: "Failed attempts are crucial for detecting attacks.",
            nextStep: 1
          },
          {
            text: "Minimal information to protect user privacy",
            correct: false,
            points: -15,
            feedback: "Balance privacy with security needs - both are important.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the balanced logging strategy?",
        choices: [
          {
            text: "Log security events with sufficient detail while respecting privacy",
            correct: true,
            points: 25,
            feedback: "Balanced approach! Security monitoring with privacy considerations.",
            nextStep: 2
          },
          {
            text: "Log everything for complete visibility",
            correct: false,
            points: -25,
            feedback: "Excessive logging can hide important signals and create privacy issues.",
            nextStep: 2
          },
          {
            text: "Use the same log level for all applications",
            correct: false,
            points: -20,
            feedback: "Different applications have different logging requirements.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Logging improved! Now capturing sufficient detail for security monitoring and investigations.",
        choices: []
      }
    ]
  }
},

accessControl450: {
  id: 450,
  title: "View Other Users' Shopping Carts",
  difficulty: "Easy",
  vulnerability: "A01:2021 - Broken Access Control",
  attacker: {
    story: [
      {
        text: "You notice a website shows your shopping cart at '/cart/user123'. What happens if you change 'user123' to a different username in the URL?",
        choices: [
          {
            text: "You can see other users' shopping carts and their items",
            correct: true,
            points: 15,
            feedback: "Exactly! This is a common access control issue where users can view each other's data.",
            nextStep: 1
          },
          {
            text: "You get an error message saying 'Access Denied'",
            correct: false,
            points: 5,
            feedback: "That would be the secure behavior, but we're looking for the vulnerability.",
            nextStep: 0
          },
          {
            text: "The page shows your own cart with a different username",
            correct: false,
            points: 5,
            feedback: "This would indicate the system ignores the URL parameter.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is being able to view other users' carts a problem?",
        choices: [
          {
            text: "It violates user privacy and reveals personal shopping habits",
            correct: true,
            points: 20,
            feedback: "Correct! Privacy is important, and users shouldn't see each other's shopping data.",
            nextStep: 2
          },
          {
            text: "You can add items to other users' carts",
            correct: false,
            points: -10,
            feedback: "This vulnerability is about viewing, not modifying data.",
            nextStep: 2
          },
          {
            text: "The website might charge you for their items",
            correct: false,
            points: -15,
            feedback: "Viewing doesn't typically lead to unauthorized purchases.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Access control failure! Users can view each other's shopping carts by changing usernames in URLs.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent users from viewing each other's shopping carts?",
        choices: [
          {
            text: "Check that the logged-in user matches the cart owner before showing data",
            correct: true,
            points: 15,
            feedback: "Essential! Always verify the user owns the resource they're trying to access.",
            nextStep: 1
          },
          {
            text: "Use random numbers instead of usernames in URLs",
            correct: false,
            points: -10,
            feedback: "Obfuscation doesn't work - always check permissions.",
            nextStep: 1
          },
          {
            text: "Hide the cart page URL from users",
            correct: false,
            points: -15,
            feedback: "Users can still guess or find URLs - better to implement proper checks.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple rule for user-specific pages?",
        choices: [
          {
            text: "Only show data that belongs to the currently logged-in user",
            correct: true,
            points: 20,
            feedback: "Good practice! This simple rule prevents many access control issues.",
            nextStep: 2
          },
          {
            text: "Allow users to see basic info about other users",
            correct: false,
            points: -20,
            feedback: "Only show other users' data if specifically required by the application.",
            nextStep: 2
          },
          {
            text: "Use the same access rules for all pages",
            correct: false,
            points: -15,
            feedback: "Different pages may need different access rules.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Access control fixed! Now users can only see their own shopping carts.",
        choices: []
      }
    ]
  }
},

cryptoFailures451: {
  id: 451,
  title: "Website Not Using HTTPS",
  difficulty: "Easy",
  vulnerability: "A02:2021 - Cryptographic Failures",
  attacker: {
    story: [
      {
        text: "You notice a website uses 'http://' instead of 'https://' in the address bar. What security risk does this create?",
        choices: [
          {
            text: "Data sent between browser and website is not encrypted",
            correct: true,
            points: 15,
            feedback: "Exactly! HTTP without SSL/TLS means data travels in plain text.",
            nextStep: 1
          },
          {
            text: "The website might load slower",
            correct: false,
            points: 5,
            feedback: "Performance is not the security risk here.",
            nextStep: 0
          },
          {
            text: "Some browser features might not work",
            correct: false,
            points: 5,
            feedback: "Browser compatibility is different from security.",
            nextStep: 0
          }
        ]
      },
      {
        text: "What can attackers see when a website uses HTTP instead of HTTPS?",
        choices: [
          {
            text: "Passwords, personal information, and everything you type",
            correct: true,
            points: 20,
            feedback: "Correct! Without encryption, attackers can read all data you send to the website.",
            nextStep: 2
          },
          {
            text: "Only the website content but not your inputs",
            correct: false,
            points: -10,
            feedback: "Without HTTPS, both content and user inputs are visible.",
            nextStep: 2
          },
          {
            text: "Just your username but not password",
            correct: false,
            points: -15,
            feedback: "All data is exposed without encryption.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Cryptographic failure! Website using HTTP instead of HTTPS, exposing all data in transit.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you fix a website that's not using HTTPS?",
        choices: [
          {
            text: "Install an SSL certificate and force all traffic to use HTTPS",
            correct: true,
            points: 15,
            feedback: "Essential! SSL certificates enable encryption for website communications.",
            nextStep: 1
          },
          {
            text: "Use JavaScript to encrypt data before sending",
            correct: false,
            points: -15,
            feedback: "Client-side encryption doesn't replace HTTPS - use proper SSL/TLS.",
            nextStep: 1
          },
          {
            text: "Ask users to use VPN when visiting the site",
            correct: false,
            points: -10,
            feedback: "VPNs help but don't replace website-level encryption.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple HTTPS rule for websites?",
        choices: [
          {
            text: "Always use HTTPS for all pages, especially login and forms",
            correct: true,
            points: 20,
            feedback: "Best practice! Every page should use HTTPS to protect user data.",
            nextStep: 2
          },
          {
            text: "Use HTTPS only for payment pages",
            correct: false,
            points: -20,
            feedback: "All pages need HTTPS to protect user privacy and security.",
            nextStep: 2
          },
          {
            text: "Let users choose between HTTP and HTTPS",
            correct: false,
            points: -15,
            feedback: "Always force HTTPS - don't give users insecure options.",
            nextStep: 2
          }
        ]
      },
      {
        text: "HTTPS implemented! Now all website traffic is encrypted and secure.",
        choices: []
      }
    ]
  }
},

injection452: {
  id: 452,
  title: "Search Box Cross-Site Scripting (XSS)",
  difficulty: "Easy",
  vulnerability: "A03:2021 - Injection",
  attacker: {
    story: [
      {
        text: "You type '<script>alert('XSS')</script>' in a website search box and press enter. What happens if you see a popup message?",
        choices: [
          {
            text: "The website has XSS vulnerability - it executed your JavaScript code",
            correct: true,
            points: 15,
            feedback: "Exactly! If you see the popup, the website executed your JavaScript code.",
            nextStep: 1
          },
          {
            text: "The search found results about JavaScript",
            correct: false,
            points: 5,
            feedback: "Search results would show web pages, not execute code.",
            nextStep: 0
          },
          {
            text: "Your browser blocked a malicious script",
            correct: false,
            points: 5,
            feedback: "If browser blocked it, you wouldn't see the popup.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is XSS in a search box dangerous?",
        choices: [
          {
            text: "Attackers can steal cookies or show fake login pages to users",
            correct: true,
            points: 20,
            feedback: "Correct! XSS can steal user sessions or trick users into revealing passwords.",
            nextStep: 2
          },
          {
            text: "The search results will be inaccurate",
            correct: false,
            points: -10,
            feedback: "Result accuracy is not the security concern.",
            nextStep: 2
          },
          {
            text: "The website database might get corrupted",
            correct: false,
            points: -15,
            feedback: "XSS affects users' browsers, not typically the database.",
            nextStep: 2
          }
        ]
      },
      {
        text: "XSS vulnerability! Website executing JavaScript from search box input without sanitization.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent XSS in search boxes?",
        choices: [
          {
            text: "Escape special characters before displaying user input",
            correct: true,
            points: 15,
            feedback: "Essential! Escaping prevents browsers from treating input as code.",
            nextStep: 1
          },
          {
            text: "Block the word 'script' in all searches",
            correct: false,
            points: -15,
            feedback: "Attackers can use many other methods - proper escaping is needed.",
            nextStep: 1
          },
          {
            text: "Use CAPTCHA on search pages",
            correct: false,
            points: -10,
            feedback: "CAPTCHA prevents automation but doesn't stop XSS.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple XSS protection rule?",
        choices: [
          {
            text: "Never trust user input - always escape before showing on web pages",
            correct: true,
            points: 20,
            feedback: "Fundamental security rule! Treat all user input as potentially dangerous.",
            nextStep: 2
          },
          {
            text: "Allow HTML only from trusted users",
            correct: false,
            points: -20,
            feedback: "Even trusted users can make mistakes - escape all input.",
            nextStep: 2
          },
          {
            text: "Use the same escaping for all input fields",
            correct: false,
            points: -15,
            feedback: "Different contexts may require different escaping methods.",
            nextStep: 2
          }
        ]
      },
      {
        text: "XSS protection implemented! Now properly escaping all user input displayed on web pages.",
        choices: []
      }
    ]
  }
},

insecureDesign453: {
  id: 453,
  title: "Password Requirements Too Simple",
  difficulty: "Easy",
  vulnerability: "A04:2021 - Insecure Design",
  attacker: {
    story: [
      {
        text: "A website only requires passwords to be 4 characters long with no other rules. Why is this insecure design?",
        choices: [
          {
            text: "Short passwords are easy to guess with brute force attacks",
            correct: true,
            points: 15,
            feedback: "Exactly! Short passwords can be quickly guessed by automated tools.",
            nextStep: 1
          },
          {
            text: "Users might forget simple passwords more easily",
            correct: false,
            points: 5,
            feedback: "Password memory is a usability issue, not a design flaw.",
            nextStep: 0
          },
          {
            text: "The website might store passwords incorrectly",
            correct: false,
            points: 5,
            feedback: "Storage method is separate from password requirement design.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How quickly can a 4-character password be guessed?",
        choices: [
          {
            text: "Seconds or minutes with automated tools",
            correct: true,
            points: 20,
            feedback: "Correct! Computers can try millions of password combinations per second.",
            nextStep: 2
          },
          {
            text: "Several hours of manual guessing",
            correct: false,
            points: -10,
            feedback: "Automated tools work much faster than manual guessing.",
            nextStep: 2
          },
          {
            text: "Days or weeks even with computers",
            correct: false,
            points: -15,
            feedback: "Modern computers crack short passwords almost instantly.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Insecure design! Weak password requirements making accounts easy to compromise.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "What are better password requirements?",
        choices: [
          {
            text: "Minimum 12 characters with no complexity requirements",
            correct: true,
            points: 15,
            feedback: "Good practice! Length is more important than complexity for password security.",
            nextStep: 1
          },
          {
            text: "Exactly 8 characters with one capital letter and number",
            correct: false,
            points: -15,
            feedback: "Fixed length and complexity rules lead to predictable patterns.",
            nextStep: 1
          },
          {
            text: "Let users choose any password they want",
            correct: false,
            points: -10,
            feedback: "Some users will choose very weak passwords without guidance.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the modern approach to passwords?",
        choices: [
          {
            text: "Long passwords or passphrases that are easy to remember but hard to guess",
            correct: true,
            points: 20,
            feedback: "Modern best practice! Passphrases balance security and usability.",
            nextStep: 2
          },
          {
            text: "Require frequent password changes",
            correct: false,
            points: -20,
            feedback: "Frequent changes lead to weak, incremental passwords.",
            nextStep: 2
          },
          {
            text: "Use the same password rules for all applications",
            correct: false,
            points: -15,
            feedback: "Different applications may have different security needs.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Password design improved! Now requiring longer passwords for better security.",
        choices: []
      }
    ]
  }
},

securityMisconfig454: {
  id: 454,
  title: "Error Messages Revealing Server Information",
  difficulty: "Easy",
  vulnerability: "A05:2021 - Security Misconfiguration",
  attacker: {
    story: [
      {
        text: "You see a detailed error message showing database table names, server version, and file paths when something goes wrong. Why is this information dangerous to show users?",
        choices: [
          {
            text: "It helps attackers understand the system and plan attacks",
            correct: true,
            points: 15,
            feedback: "Exactly! Detailed errors give attackers valuable information about your system.",
            nextStep: 1
          },
          {
            text: "Users might get confused by technical details",
            correct: false,
            points: 5,
            feedback: "User confusion is a usability issue, not a security risk.",
            nextStep: 0
          },
          {
            text: "The error messages take up too much screen space",
            correct: false,
            points: 5,
            feedback: "Display size is not the security concern.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can detailed error messages help attackers?",
        choices: [
          {
            text: "They reveal system structure and potential attack targets",
            correct: true,
            points: 20,
            feedback: "Correct! Error messages can reveal database structure, software versions, and system architecture.",
            nextStep: 2
          },
          {
            text: "They allow attackers to fix the errors themselves",
            correct: false,
            points: -10,
            feedback: "Attackers can't fix errors through error messages.",
            nextStep: 2
          },
          {
            text: "They help attackers contact the website administrators",
            correct: false,
            points: -15,
            feedback: "Attackers don't need error messages to find contact information.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Security misconfiguration! Detailed error messages revealing system information to users.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should error messages be handled in production?",
        choices: [
          {
            text: "Show generic error messages to users, log details for administrators",
            correct: true,
            points: 15,
            feedback: "Essential! Users get friendly messages, while admins get technical details in logs.",
            nextStep: 1
          },
          {
            text: "Hide all error messages completely",
            correct: false,
            points: -15,
            feedback: "Users need some feedback - use generic but helpful messages.",
            nextStep: 1
          },
          {
            text: "Show detailed errors only to logged-in users",
            correct: false,
            points: -10,
            feedback: "Logged-in users might still be attackers - use generic messages for all.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple error handling rule?",
        choices: [
          {
            text: "Be helpful to users without revealing system details",
            correct: true,
            points: 20,
            feedback: "Good practice! Balance user assistance with security protection.",
            nextStep: 2
          },
          {
            text: "Show different error details based on user type",
            correct: false,
            points: -20,
            feedback: "All external users should see generic errors regardless of role.",
            nextStep: 2
          },
          {
            text: "Use the same error messages for all applications",
            correct: false,
            points: -15,
            feedback: "Different applications may need different error handling.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Error handling secured! Now showing generic messages to users while logging details for admins.",
        choices: []
      }
    ]
  }
},

vulnerableComponents455: {
  id: 455,
  title: "Using Old WordPress Version",
  difficulty: "Easy",
  vulnerability: "A06:2021 - Vulnerable and Outdated Components",
  attacker: {
    story: [
      {
        text: "You notice a WordPress website is using version 4.0 from several years ago. Current version is 6.0+. What security risk does this create?",
        choices: [
          {
            text: "Known security vulnerabilities that have been fixed in newer versions",
            correct: true,
            points: 15,
            feedback: "Exactly! Old versions have known security holes that attackers can exploit.",
            nextStep: 1
          },
          {
            text: "The website might not work on mobile devices",
            correct: false,
            points: 5,
            feedback: "Mobile compatibility is different from security vulnerabilities.",
            nextStep: 0
          },
          {
            text: "Some plugins might not be available",
            correct: false,
            points: 5,
            feedback: "Plugin availability is a feature issue, not a security risk.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can attackers find out if a website uses old WordPress?",
        choices: [
          {
            text: "Check the page source or use automated scanning tools",
            correct: true,
            points: 20,
            feedback: "Correct! Attackers use tools that automatically detect software versions.",
            nextStep: 2
          },
          {
            text: "Guess the version number randomly",
            correct: false,
            points: -10,
            feedback: "Attackers use systematic methods, not random guessing.",
            nextStep: 2
          },
          {
            text: "Ask the website owner directly",
            correct: false,
            points: -15,
            feedback: "Attackers don't reveal themselves by asking questions.",
            nextStep: 2
          }
        ]
      },
      {
        "text": "Vulnerable components! Using outdated WordPress version with known security issues.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you keep WordPress secure?",
        choices: [
          {
            text: "Regularly update to the latest version and security patches",
            correct: true,
            points: 15,
            feedback: "Essential! Regular updates fix known security vulnerabilities.",
            nextStep: 1
          },
          {
            text: "Hide the WordPress version from showing",
            correct: false,
            points: -15,
            feedback: "Hiding versions doesn't fix vulnerabilities - update instead.",
            nextStep: 1
          },
          {
            text: "Use only the most stable old version",
            correct: false,
            points: -10,
            feedback: "Old versions become vulnerable over time - always update.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple update rule for websites?",
        choices: [
          {
            text: "Apply security updates promptly when they become available",
            correct: true,
            points: 20,
            feedback: "Best practice! Don't delay security updates - they protect against known threats.",
            nextStep: 2
          },
          {
            text: "Wait until many users report problems before updating",
            correct: false,
            points: -20,
            feedback: "By the time users report problems, attackers may have already exploited vulnerabilities.",
            nextStep: 2
          },
          {
            text: "Use the same version forever if it works",
            correct: false,
            points: -15,
            feedback: "Software becomes less secure over time as new vulnerabilities are discovered.",
            nextStep: 2
          }
        ]
      },
      {
        text: "WordPress updated! Now using the latest secure version with regular updates enabled.",
        choices: []
      }
    ]
  }
},

authFailure456: {
  id: 456,
  title: "Username Enumeration in Login Error Messages",
  difficulty: "Easy",
  vulnerability: "A07:2021 - Identification and Authentication Failures",
  attacker: {
    story: [
      {
        text: "A login page shows 'User not found' when you enter a wrong username, but 'Invalid password' when the username exists but password is wrong. Why is this a problem?",
        choices: [
          {
            text: "It reveals which usernames are valid on the system",
            correct: true,
            points: 15,
            feedback: "Exactly! Different error messages let attackers discover valid usernames.",
            nextStep: 1
          },
          {
            text: "The error messages are not helpful enough",
            correct: false,
            points: 5,
            feedback: "The problem is too much information, not too little.",
            nextStep: 0
          },
          {
            text: "Users might get confused by the different messages",
            correct: false,
            points: 5,
            feedback: "User confusion is not the security issue here.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can username enumeration help attackers?",
        choices: [
          {
            text: "They can focus password attacks on valid usernames only",
            correct: true,
            points: 20,
            feedback: "Correct! Knowing valid usernames makes password guessing much more efficient.",
            nextStep: 2
          },
          {
            text: "They can create new accounts with those usernames",
            correct: false,
            points: -10,
            feedback: "Username enumeration reveals existing accounts, not account creation.",
            nextStep: 2
          },
          {
            text: "They can delete the user accounts",
            correct: false,
            points: -15,
            feedback: "Enumeration doesn't provide account deletion capabilities.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Authentication failure! Login error messages revealing valid usernames to attackers.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should login error messages be handled?",
        choices: [
          {
            text: "Use the same generic message for both invalid username and wrong password",
            correct: true,
            points: 15,
            feedback: "Essential! Generic messages prevent attackers from learning which usernames exist.",
            nextStep: 1
          },
          {
            text: "Show different messages to help users understand the problem",
            correct: false,
            points: -15,
            feedback: "User convenience should not compromise security.",
            nextStep: 1
          },
          {
            text: "Only show errors after multiple failed attempts",
            correct: false,
            points: -10,
            feedback: "Delayed errors still reveal information eventually.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the secure login error approach?",
        choices: [
          {
            text: "'Invalid username or password' for all login failures",
            correct: true,
            points: 20,
            feedback: "Best practice! This simple message protects against username enumeration.",
            nextStep: 2
          },
          {
            text: "No error messages at all for login failures",
            correct: false,
            points: -20,
            feedback: "Users need feedback - use generic but secure messages.",
            nextStep: 2
          },
          {
            text: "Use the same error handling for all authentication methods",
            correct: false,
            points: -15,
            feedback: "Different authentication methods may need different error handling.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Login errors secured! Now using generic messages that don't reveal valid usernames.",
        choices: []
      }
    ]
  }
},

softwareIntegrity457: {
  id: 457,
  title: "File Upload Accepting Dangerous File Types",
  difficulty: "Easy",
  vulnerability: "A08:2021 - Software and Data Integrity Failures",
  attacker: {
    story: [
      {
        text: "A website lets users upload files but doesn't check what type of files they are. What happens if you upload an .exe or .php file instead of an image?",
        choices: [
          {
            text: "The website might store and potentially execute dangerous files",
            correct: true,
            points: 15,
            feedback: "Exactly! Uploading executable files can lead to malware or server compromise.",
            nextStep: 1
          },
          {
            text: "The upload will fail because exe files are too large",
            correct: false,
            points: 5,
            feedback: "File size limits don't necessarily block dangerous file types.",
            nextStep: 0
          },
          {
            text: "The file will be automatically converted to an image",
            correct: false,
            points: 5,
            feedback: "Automatic conversion is not typical behavior.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is accepting executable files dangerous for a website?",
        choices: [
          {
            text: "Attackers can upload malware or web shells to take control",
            correct: true,
            points: 20,
            feedback: "Correct! Malicious files can give attackers access to your server.",
            nextStep: 2
          },
          {
            text: "Executable files take up more server storage",
            correct: false,
            points: -10,
            feedback: "Storage space is not the security concern.",
            nextStep: 2
          },
          {
            text: "Users might accidentally run harmful programs",
            correct: false,
            points: -15,
            feedback: "While possible, server compromise is the bigger risk.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Software integrity failure! File upload accepting dangerous file types without validation.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure file upload features?",
        choices: [
          {
            text: "Check file types and only allow safe extensions like .jpg, .png, .pdf",
            correct: true,
            points: 15,
            feedback: "Essential! Whitelist safe file types instead of blocking dangerous ones.",
            nextStep: 1
          },
          {
            text: "Rely on browser file type detection only",
            correct: false,
            points: -15,
            feedback: "Browser detection can be bypassed - always validate server-side.",
            nextStep: 1
          },
          {
            text: "Allow all files but scan with antivirus",
            correct: false,
            points: -10,
            feedback: "Antivirus can miss new threats - better to block dangerous types entirely.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple file upload security rule?",
        choices: [
          {
            text: "Only allow files you specifically need, block everything else",
            correct: true,
            points: 20,
            feedback: "Best practice! Be strict about what you accept.",
            nextStep: 2
          },
          {
            text: "Allow common file types for user convenience",
            correct: false,
            points: -20,
            feedback: "Convenience should not compromise security.",
            nextStep: 2
          },
          {
            text: "Use the same file restrictions for all upload features",
            correct: false,
            points: -15,
            feedback: "Different upload features may need different security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "File upload secured! Now validating file types and only allowing safe extensions.",
        choices: []
      }
    ]
  }
},

loggingFailures458: {
  id: 458,
  title: "Not Logging Important User Actions",
  difficulty: "Easy",
  vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
  attacker: {
    story: [
      {
        text: "You notice a website doesn't keep records of when users log in, change passwords, or update email addresses. Why is this a problem for security?",
        choices: [
          {
            text: "You can't investigate security incidents or track suspicious activity",
            correct: true,
            points: 15,
            feedback: "Exactly! Without logs, you have no evidence to investigate problems.",
            nextStep: 1
          },
          {
            text: "Users might forget what they did on the website",
            correct: false,
            points: 5,
            feedback: "User memory is not the security concern.",
            nextStep: 0
          },
          {
            text: "The website might run slower without logging",
            correct: false,
            points: 5,
            feedback: "Logging has minimal performance impact.",
            nextStep: 0
          }
        ]
      },
      {
        text: "What could happen if there's no record of password changes?",
        choices: [
          {
            text: "You can't tell if an attacker changed someone's password",
            correct: true,
            points: 20,
            feedback: "Correct! Logs provide evidence of unauthorized account changes.",
            nextStep: 2
          },
          {
            text: "Users will change passwords more frequently",
            correct: false,
            points: -10,
            feedback: "Logging doesn't affect password change frequency.",
            nextStep: 2
          },
          {
            text: "The password reset feature might stop working",
            correct: false,
            points: -15,
            feedback: "Logging is separate from functionality.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Logging failure! Not recording important security events for monitoring and investigation.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "What user actions should always be logged?",
        choices: [
          {
            text: "Logins, password changes, and important profile updates",
            correct: true,
            points: 15,
            feedback: "Essential! These are critical security events that need tracking.",
            nextStep: 1
          },
          {
            text: "Only failed login attempts to save space",
            correct: false,
            points: -15,
            feedback: "Successful actions are also important for establishing patterns.",
            nextStep: 1
          },
          {
            text: "Only actions that cause errors",
            correct: false,
            points: -10,
            feedback: "Many security incidents don't cause immediate errors.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple logging rule for security?",
        choices: [
          {
            text: "Log who did what and when for important security actions",
            correct: true,
            points: 20,
            feedback: "Good practice! Basic logging provides essential security visibility.",
            nextStep: 2
          },
          {
            text: "Log everything users do for complete visibility",
            correct: false,
            points: -20,
            feedback: "Too much logging can hide important events - focus on security actions.",
            nextStep: 2
          },
          {
            text: "Use the same logging for all user types",
            correct: false,
            points: -15,
            feedback: "Different user roles may require different logging levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Security logging implemented! Now tracking important user actions for security monitoring.",
        choices: []
      }
    ]
  }
},

ssrf459: {
  id: 459,
  title: "URL Preview Feature Accessing Internal Addresses",
  difficulty: "Easy",
  vulnerability: "A10:2021 - Server-Side Request Forgery",
  attacker: {
    story: [
      {
        text: "A social media site has a feature that shows previews of linked URLs. What happens if you post a link to 'http://localhost' or 'http://192.168.1.1'?",
        choices: [
          {
            text: "The server might try to access internal network addresses",
            correct: true,
            points: 15,
            feedback: "Exactly! URL preview features can be abused to scan internal networks.",
            nextStep: 1
          },
          {
            text: "The link will be blocked as invalid",
            correct: false,
            points: 5,
            feedback: "That would be secure behavior, but we're testing for vulnerabilities.",
            nextStep: 0
          },
          {
            text: "Only public internet URLs will work in previews",
            correct: false,
            points: 5,
            feedback: "Internal URLs might work if no protections are in place.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is accessing internal addresses dangerous?",
        choices: [
          {
            text: "It can reveal information about internal network systems",
            correct: true,
            points: 20,
            feedback: "Correct! SSRF can help attackers map internal networks and find vulnerable systems.",
            nextStep: 2
          },
          {
            text: "It will overload the internal network with traffic",
            correct: false,
            points: -10,
            feedback: "Traffic volume is not the primary security concern.",
            nextStep: 2
          },
          {
            text: "Internal systems might get confused by external requests",
            correct: false,
            points: -15,
            feedback: "System confusion is not the security risk.",
            nextStep: 2
          }
        ]
      },
      {
        text: "SSRF vulnerability! URL preview feature allowing access to internal network addresses.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure URL preview features?",
        choices: [
          {
            text: "Validate URLs and block internal IP addresses and domains",
            correct: true,
            points: 15,
            feedback: "Essential! Restrict URL access to external addresses only.",
            nextStep: 1
          },
          {
            text: "Use a proxy for all URL preview requests",
            correct: false,
            points: -15,
            feedback: "Proxies might still allow internal network access.",
            nextStep: 1
          },
          {
            text: "Only preview URLs from major websites",
            correct: false,
            points: -10,
            feedback: "Whitelisting specific domains is better than general categories.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple SSRF protection rule?",
        choices: [
          {
            text: "Never let your server make requests to internal network addresses",
            correct: true,
            points: 20,
            feedback: "Fundamental rule! External applications shouldn't access internal resources.",
            nextStep: 2
          },
          {
            text: "Allow internal requests only from authenticated users",
            correct: false,
            points: -20,
            feedback: "Even authenticated users shouldn't access internal networks through your app.",
            nextStep: 2
          },
          {
            text: "Use the same URL validation for all features",
            correct: false,
            points: -15,
            feedback: "Different features may require different security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "SSRF protection implemented! Now blocking internal addresses in URL preview features.",
        choices: []
      }
    ]
  }
},

accessControl460: {
  id: 460,
  title: "Editing Other Users' Forum Posts",
  difficulty: "Easy",
  vulnerability: "A01:2021 - Broken Access Control",
  attacker: {
    story: [
      {
        text: "You notice a forum where each post has an 'Edit' button. What happens if you try to edit someone else's post while logged into your own account?",
        choices: [
          {
            text: "You can modify other users' posts without permission",
            correct: true,
            points: 15,
            feedback: "Exactly! Missing authorization checks allow users to edit each other's content.",
            nextStep: 1
          },
          {
            text: "You get an error saying 'Permission Denied'",
            correct: false,
            points: 5,
            feedback: "That would be secure behavior, but we're looking for the vulnerability.",
            nextStep: 0
          },
          {
            text: "Only the post author can see the Edit button",
            correct: false,
            points: 5,
            feedback: "This would indicate proper access control is working.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is being able to edit others' posts a serious problem?",
        choices: [
          {
            text: "It allows content manipulation and misinformation",
            correct: true,
            points: 20,
            feedback: "Correct! Unauthorized editing can spread false information or damage reputations.",
            nextStep: 2
          },
          {
            text: "The forum database might get corrupted",
            correct: false,
            points: -10,
            feedback: "Database corruption is unlikely from authorized edits.",
            nextStep: 2
          },
          {
            text: "Users will post more frequently",
            correct: false,
            points: -15,
            feedback: "Editing access doesn't affect posting frequency.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Access control failure! Users can edit each other's forum posts without proper authorization checks.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent unauthorized post editing?",
        choices: [
          {
            text: "Check if the current user owns the post before showing edit options",
            correct: true,
            points: 15,
            feedback: "Essential! Always verify ownership before allowing modifications.",
            nextStep: 1
          },
          {
            text: "Hide the Edit button using CSS",
            correct: false,
            points: -15,
            feedback: "CSS hiding can be bypassed - implement proper server checks.",
            nextStep: 1
          },
          {
            text: "Only allow editing for the first 5 minutes after posting",
            correct: false,
            points: -10,
            feedback: "Time limits don't prevent unauthorized users from editing.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple rule for user-generated content?",
        choices: [
          {
            text: "Users can only modify content they created themselves",
            correct: true,
            points: 20,
            feedback: "Good practice! This clear rule prevents many access control issues.",
            nextStep: 2
          },
          {
            text: "Allow moderators to edit all posts without restrictions",
            correct: false,
            points: -20,
            feedback: "Even moderators should have audit trails for their changes.",
            nextStep: 2
          },
          {
            text: "Use the same editing rules for all content types",
            correct: false,
            points: -15,
            feedback: "Different content may need different editing permissions.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Editing permissions fixed! Now users can only edit their own posts with proper authorization checks.",
        choices: []
      }
    ]
  }
},

cryptoFailures461: {
  id: 461,
  title: "Sensitive Data in URL Parameters",
  difficulty: "Easy",
  vulnerability: "A02:2021 - Cryptographic Failures",
  attacker: {
    story: [
      {
        text: "You notice a website puts user IDs, session tokens, or other sensitive data in the URL like '?userid=123&token=abc'. Why is this insecure?",
        choices: [
          {
            text: "URLs are saved in browser history and can be shared accidentally",
            correct: true,
            points: 15,
            feedback: "Exactly! URLs with sensitive data can be leaked through history, logs, or sharing.",
            nextStep: 1
          },
          {
            text: "URLs with parameters load slower",
            correct: false,
            points: 5,
            feedback: "Performance is not the security concern.",
            nextStep: 0
          },
          {
            text: "Some browsers block long URLs",
            correct: false,
            points: 5,
            feedback: "Browser limitations are different from security risks.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Where can URLs with sensitive data be exposed?",
        choices: [
          {
            text: "Browser history, server logs, and referral headers",
            correct: true,
            points: 20,
            feedback: "Correct! URLs appear in many places where attackers might see them.",
            nextStep: 2
          },
          {
            text: "Only in the current browser tab",
            correct: false,
            points: -10,
            feedback: "URLs are visible in many locations beyond the current tab.",
            nextStep: 2
          },
          {
            text: "Just in the website's database",
            correct: false,
            points: -15,
            feedback: "URLs travel through many systems before reaching the database.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Cryptographic failure! Sensitive data exposed in URL parameters where it can be easily leaked.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "Where should sensitive data like session tokens be stored?",
        choices: [
          {
            text: "In HTTP cookies with secure flags",
            correct: true,
            points: 15,
            feedback: "Essential! Cookies are designed for secure session management.",
            nextStep: 1
          },
          {
            text: "In hidden form fields",
            correct: false,
            points: -15,
            feedback: "Hidden fields can still be accessed - use proper session storage.",
            nextStep: 1
          },
          {
            text: "In JavaScript variables only",
            correct: false,
            points: -10,
            feedback: "JavaScript variables are cleared on page refresh - use cookies.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple rule for URL parameters?",
        choices: [
          {
            text: "Use URLs for navigation, not for sensitive data",
            correct: true,
            points: 20,
            feedback: "Best practice! URLs should describe the resource, not contain secrets.",
            nextStep: 2
          },
          {
            text: "Encrypt sensitive data before putting in URLs",
            correct: false,
            points: -20,
            feedback: "Even encrypted data in URLs can be replayed - avoid entirely.",
            nextStep: 2
          },
          {
            text: "Use the same parameter handling for all pages",
            correct: false,
            points: -15,
            feedback: "Different pages may have different security requirements.",
            nextStep: 2
          }
        ]
      },
      {
        text: "URL security improved! Now using cookies for sensitive data instead of URL parameters.",
        choices: []
      }
    ]
  }
},

injection462: {
  id: 462,
  title: "HTML Injection in Comment Fields",
  difficulty: "Easy",
  vulnerability: "A03:2021 - Injection",
  attacker: {
    story: [
      {
        text: "A blog lets users post comments. What happens if you type '<h1>Hello</h1>' in the comment box and it appears as a large heading?",
        choices: [
          {
            text: "The website is executing HTML code from user input",
            correct: true,
            points: 15,
            feedback: "Exactly! HTML injection allows users to change how content displays.",
            nextStep: 1
          },
          {
            text: "The blog converts plain text to HTML automatically",
            correct: false,
            points: 5,
            feedback: "Automatic conversion would show the symbols, not execute them as HTML.",
            nextStep: 0
          },
          {
            text: "It's a special feature for formatting comments",
            correct: false,
            points: 5,
            feedback: "HTML execution is a vulnerability, not a feature.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is HTML injection dangerous even without JavaScript?",
        choices: [
          {
            text: "Attackers can deface pages or create fake content",
            correct: true,
            points: 20,
            feedback: "Correct! HTML injection can change page appearance and mislead users.",
            nextStep: 2
          },
          {
            text: "It makes the website load slower",
            correct: false,
            points: -10,
            feedback: "Performance impact is not the security concern.",
            nextStep: 2
          },
          {
            text: "The HTML might not display properly on mobile",
            correct: false,
            points: -15,
            feedback: "Display issues are not the security risk.",
            nextStep: 2
          }
        ]
      },
      {
        text: "HTML injection vulnerability! Comment fields executing HTML code without proper sanitization.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent HTML injection in user comments?",
        choices: [
          {
            text: "Escape special characters like < and > before displaying",
            correct: true,
            points: 15,
            feedback: "Essential! Escaping prevents browsers from treating input as HTML.",
            nextStep: 1
          },
          {
            text: "Block all symbols and special characters",
            correct: false,
            points: -15,
            feedback: "This breaks legitimate comments - escape instead of blocking.",
            nextStep: 1
          },
          {
            text: "Use JavaScript to remove HTML before submission",
            correct: false,
            points: -10,
            feedback: "Client-side controls can be bypassed - escape server-side.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple input handling rule?",
        choices: [
          {
            text: "Treat all user input as text, not code",
            correct: true,
            points: 20,
            feedback: "Fundamental security principle! User input should never be executed as code.",
            nextStep: 2
          },
          {
            text: "Allow limited HTML for user formatting",
            correct: false,
            points: -20,
            feedback: "Limited HTML is hard to secure - use markdown or other safe formats.",
            nextStep: 2
          },
          {
            text: "Use the same escaping for all text fields",
            correct: false,
            points: -15,
            feedback: "Different contexts may require different escaping methods.",
            nextStep: 2
          }
        ]
      },
      {
        text: "HTML injection protection implemented! Now properly escaping all user-generated content.",
        choices: []
      }
    ]
  }
},

insecureDesign463: {
  id: 463,
  title: "Security Questions with Limited Answer Options",
  difficulty: "Easy",
  vulnerability: "A04:2021 - Insecure Design",
  attacker: {
    story: [
      {
        text: "A website uses security questions with dropdown menus like 'What's your favorite color?' with only 10 color options. Why is this insecure design?",
        choices: [
          {
            text: "Limited options make answers easy to guess",
            correct: true,
            points: 15,
            feedback: "Exactly! Limited choices make security questions trivial to bypass.",
            nextStep: 1
          },
          {
            text: "Users might not like the available colors",
            correct: false,
            points: 5,
            feedback: "User preference is a usability issue, not a security flaw.",
            nextStep: 0
          },
          {
            text: "The dropdown menu might not work on mobile",
            correct: false,
            points: 5,
            feedback: "Mobile compatibility is different from security design.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can limited-answer security questions be exploited?",
        choices: [
          {
            text: "Try all possible answers systematically",
            correct: true,
            points: 20,
            feedback: "Correct! With only 10 options, attackers can try them all quickly.",
            nextStep: 2
          },
          {
            text: "Guess the most popular color choice",
            correct: false,
            points: -10,
            feedback: "Systematic trying is more reliable than guessing popular choices.",
            nextStep: 2
          },
          {
            text: "Use color psychology to predict answers",
            correct: false,
            points: -15,
            feedback: "Direct testing is more effective than prediction.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Insecure design! Security questions with limited answer options making them easy to guess.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "What's a better approach to security questions?",
        choices: [
          {
            text: "Use open-ended questions with unlimited possible answers",
            correct: true,
            points: 15,
            feedback: "Essential! Open-ended questions have too many possibilities to guess.",
            nextStep: 1
          },
          {
            text: "Use more dropdown options (50+ choices)",
            correct: false,
            points: -15,
            feedback: "Even many options can be systematically tried - use open-ended questions.",
            nextStep: 1
          },
          {
            text: "Let users create their own questions",
            correct: false,
            points: -10,
            feedback: "Custom questions can still have predictable answers.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the modern security question design?",
        choices: [
          {
            text: "Avoid security questions entirely, use multi-factor authentication instead",
            correct: true,
            points: 20,
            feedback: "Modern best practice! MFA is more secure than knowledge-based authentication.",
            nextStep: 2
          },
          {
            text: "Use the same security questions for all users",
            correct: false,
            points: -20,
            feedback: "Common questions make research easier for attackers.",
            nextStep: 2
          },
          {
            text: "Ask very personal questions for better security",
            correct: false,
            points: -15,
            feedback: "Personal questions can often be researched online.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Security design improved! Now using open-ended questions or replacing with multi-factor authentication.",
        choices: []
      }
    ]
  }
},

securityMisconfig464: {
  id: 464,
  title: "Backup Files Left on Web Server",
  difficulty: "Easy",
  vulnerability: "A05:2021 - Security Misconfiguration",
  attacker: {
    story: [
      {
        text: "You discover files like 'database.sql.bak', 'config.php.old', or 'backup.zip' in a website's directory. Why are these files dangerous to leave accessible?",
        choices: [
          {
            text: "They can contain sensitive information like passwords and data",
            correct: true,
            points: 15,
            feedback: "Exactly! Backup files often contain database dumps, configuration, and other secrets.",
            nextStep: 1
          },
          {
            text: "They take up unnecessary server storage",
            correct: false,
            points: 5,
            feedback: "Storage space is operational, not a security risk.",
            nextStep: 0
          },
          {
            text: "They might cause version conflicts",
            correct: false,
            points: 5,
            feedback: "Version issues are development problems, not security vulnerabilities.",
            nextStep: 0
          }
        ]
      },
      {
        text: "What sensitive information might be in backup files?",
        choices: [
          {
            text: "Database contents, API keys, and configuration secrets",
            correct: true,
            points: 20,
            feedback: "Correct! Backup files can reveal the entire application structure and data.",
            nextStep: 2
          },
          {
            text: "Only old versions of website content",
            correct: false,
            points: -10,
            feedback: "Backups often contain much more than just content.",
            nextStep: 2
          },
          {
            text: "Just user-uploaded images and files",
            correct: false,
            points: -15,
            feedback: "Backups typically include databases and configuration too.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Security misconfiguration! Backup files left accessible on web server revealing sensitive information.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should backup files be handled on production servers?",
        choices: [
          {
            text: "Keep backups in secure locations outside web directories",
            correct: true,
            points: 15,
            feedback: "Essential! Backups should never be accessible through the web server.",
            nextStep: 1
          },
          {
            text: "Use obscure file names for backups",
            correct: false,
            points: -15,
            feedback: "Obscure names can still be found - move files entirely.",
            nextStep: 1
          },
          {
            text: "Password-protect backup zip files",
            correct: false,
            points: -10,
            feedback: "Passwords can be cracked - better to remove from web access.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple backup security rule?",
        choices: [
          {
            text: "Web servers should only serve the files needed for the website to run",
            correct: true,
            points: 20,
            feedback: "Good practice! Remove any files not required for normal operation.",
            nextStep: 2
          },
          {
            text: "Allow backups for quick recovery during emergencies",
            correct: false,
            points: -20,
            feedback: "Keep backups available but not web-accessible.",
            nextStep: 2
          },
          {
            text: "Use the same backup strategy for all environments",
            correct: false,
            points: -15,
            feedback: "Different environments may have different backup needs.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Backup security improved! Now storing backups securely outside web directories.",
        choices: []
      }
    ]
  }
},

vulnerableComponents465: {
  id: 465,
  title: "Outdated jQuery Library with Known Vulnerabilities",
  difficulty: "Easy",
  vulnerability: "A06:2021 - Vulnerable and Outdated Components",
  attacker: {
    story: [
      {
        text: "You check a website's page source and see it's using jQuery 1.8 from many years ago. Current version is 3.6+. What risk does this create?",
        choices: [
          {
            text: "Known security vulnerabilities that attackers can exploit",
            correct: true,
            points: 15,
            feedback: "Exactly! Old jQuery versions have publicly known security issues.",
            nextStep: 1
          },
          {
            text: "The website might not work in modern browsers",
            correct: false,
            points: 5,
            feedback: "Browser compatibility is different from security vulnerabilities.",
            nextStep: 0
          },
          {
            text: "JavaScript features might be missing",
            correct: false,
            points: 5,
            feedback: "Feature availability is not the security risk.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can attackers find out which jQuery version a website uses?",
        choices: [
          {
            text: "View page source or use browser developer tools",
            correct: true,
            points: 20,
            feedback: "Correct! jQuery version is often visible in script tags or JavaScript variables.",
            nextStep: 2
          },
          {
            text: "Guess based on the website's design",
            correct: false,
            points: -10,
            feedback: "Attackers use technical methods, not visual guessing.",
            nextStep: 2
          },
          {
            text: "Ask the website owner directly",
            correct: false,
            points: -15,
            feedback: "Attackers don't reveal themselves by asking questions.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Vulnerable components! Using outdated jQuery library with known security vulnerabilities.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you keep client-side libraries secure?",
        choices: [
          {
            text: "Regularly update to the latest stable versions",
            correct: true,
            points: 15,
            feedback: "Essential! Regular updates patch known security issues.",
            nextStep: 1
          },
          {
            text: "Hide library versions from showing in source code",
            correct: false,
            points: -15,
            feedback: "Hiding versions doesn't fix vulnerabilities - update instead.",
            nextStep: 1
          },
          {
            text: "Use multiple library versions for different features",
            correct: false,
            points: -10,
            feedback: "Multiple versions create complexity and security gaps.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple update rule for web libraries?",
        choices: [
          {
            text: "Check for updates monthly and test before applying",
            correct: true,
            points: 20,
            feedback: "Good practice! Regular updates with testing balance security and stability.",
            nextStep: 2
          },
          {
            text: "Only update when adding new features",
            correct: false,
            points: -20,
            feedback: "Security updates should happen independently of feature development.",
            nextStep: 2
          },
          {
            text: "Use the same library versions forever once tested",
            correct: false,
            points: -15,
            feedback: "Software becomes less secure over time as new vulnerabilities are found.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Library management improved! Now regularly updating jQuery and other client-side libraries.",
        choices: []
      }
    ]
  }
},

authFailure466: {
  id: 466,
  title: "Password Show/Hide Feature Exposing Passwords",
  difficulty: "Easy",
  vulnerability: "A07:2021 - Identification and Authentication Failures",
  attacker: {
    story: [
      {
        text: "A login form has an 'eye' icon that shows your password in plain text when clicked. Why could this be a security risk in public places?",
        choices: [
          {
            text: "Shoulder surfing - people can see your password over your shoulder",
            correct: true,
            points: 15,
            feedback: "Exactly! Visible passwords can be seen by people nearby.",
            nextStep: 1
          },
          {
            text: "The password might be stored in browser memory",
            correct: false,
            points: 5,
            feedback: "Browser memory management is different from visual exposure.",
            nextStep: 0
          },
          {
            text: "Screen readers might read the password aloud",
            correct: false,
            points: 5,
            feedback: "Accessibility tools typically handle password fields properly.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Where is the show/hide feature most dangerous?",
        choices: [
          {
            text: "Public computers, coffee shops, and crowded spaces",
            correct: true,
            points: 20,
            feedback: "Correct! Public locations increase the risk of someone seeing your password.",
            nextStep: 2
          },
          {
            text: "Only on shared family computers",
            correct: false,
            points: -10,
            feedback: "Any public or semi-public setting carries risk.",
            nextStep: 2
          },
          {
            text: "Just in offices with security cameras",
            correct: false,
            points: -15,
            feedback: "Many public spaces pose shoulder surfing risks.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Authentication failure! Password show/hide feature exposing passwords to shoulder surfers in public places.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should password visibility be handled securely?",
        choices: [
          {
            text: "Keep passwords hidden by default, show temporarily only when needed",
            correct: true,
            points: 15,
            feedback: "Good practice! Hidden by default reduces accidental exposure.",
            nextStep: 1
          },
          {
            text: "Remove the show/hide feature entirely",
            correct: false,
            points: -15,
            feedback: "The feature helps with typing accuracy - implement it securely.",
            nextStep: 1
          },
          {
            text: "Show passwords only for weak password warnings",
            correct: false,
            points: -10,
            feedback: "Password strength doesn't affect visibility security.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the balanced approach to password visibility?",
        choices: [
          {
            text: "Hidden by default with optional temporary visibility",
            correct: true,
            points: 20,
            feedback: "Balanced approach! Security with usability for typing verification.",
            nextStep: 2
          },
          {
            text: "Always show passwords for better user experience",
            correct: false,
            points: -20,
            feedback: "Convenience should not compromise security.",
            nextStep: 2
          },
          {
            text: "Use the same visibility setting for all users",
            correct: false,
            points: -15,
            feedback: "Different user environments may have different security needs.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Password visibility secured! Now hidden by default with careful temporary showing.",
        choices: []
      }
    ]
  }
},

softwareIntegrity467: {
  id: 467,
  title: "Client-Side Quantity Limits in Shopping Cart",
  difficulty: "Easy",
  vulnerability: "A08:2021 - Software and Data Integrity Failures",
  attacker: {
    story: [
      {
        text: "An online store uses JavaScript to limit product quantities to 10 per customer. What happens if you modify the HTML to allow higher quantities?",
        choices: [
          {
            text: "You might be able to order more than the allowed limit",
            correct: true,
            points: 15,
            feedback: "Exactly! Client-side limits can be bypassed by modifying the page.",
            nextStep: 1
          },
          {
            text: "The website will detect the modification and block you",
            correct: false,
            points: 5,
            feedback: "That would require server-side validation to be working.",
            nextStep: 0
          },
          {
            text: "Only the display will change but the limit still applies",
            correct: false,
            points: 5,
            feedback: "If only client-side limits exist, the change might work.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is bypassing quantity limits a problem for the store?",
        choices: [
          {
            text: "It can enable inventory manipulation or abuse promotions",
            correct: true,
            points: 20,
            feedback: "Correct! Quantity limits protect inventory and prevent abuse of discounts.",
            nextStep: 2
          },
          {
            text: "The shopping cart might calculate prices wrong",
            correct: false,
            points: -10,
            feedback: "Price calculation is separate from quantity enforcement.",
            nextStep: 2
          },
          {
            text: "Other customers might see the changed quantities",
            correct: false,
            points: -15,
            feedback: "Client-side changes only affect your own view.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Software integrity failure! Client-side quantity limits enabling inventory manipulation.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should quantity limits be enforced?",
        choices: [
          {
            text: "Validate limits server-side before processing orders",
            correct: true,
            points: 15,
            feedback: "Essential! Server-side validation cannot be bypassed by users.",
            nextStep: 1
          },
          {
            text: "Use complex JavaScript to make bypassing harder",
            correct: false,
            points: -15,
            feedback: "Complex client-side code can still be bypassed - validate server-side.",
            nextStep: 1
          },
          {
            text: "Hide quantity fields until limits are checked",
            correct: false,
            points: -10,
            feedback: "Fields can still be modified when shown - validate server-side.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple rule for business rules?",
        choices: [
          {
            text: "All business rules must be enforced server-side",
            correct: true,
            points: 20,
            feedback: "Fundamental rule! Client-side can be for user experience, server-side for enforcement.",
            nextStep: 2
          },
          {
            text: "Use the same validation for all products",
            correct: false,
            points: -20,
            feedback: "Different products may have different business rules.",
            nextStep: 2
          },
          {
            text: "Allow some flexibility in business rules for customers",
            correct: false,
            points: -15,
            feedback: "Business rules should be consistently enforced.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Quantity limits secured! Now enforcing all business rules server-side.",
        choices: []
      }
    ]
  }
},

loggingFailures468: {
  id: 468,
  title: "Not Logging Password Change Events",
  difficulty: "Easy",
  vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
  attacker: {
    story: [
      {
        text: "A website lets users change passwords but doesn't keep any record of when password changes happen. Why is this a problem for security?",
        choices: [
          {
            text: "You can't detect if an attacker changed someone's password",
            correct: true,
            points: 15,
            feedback: "Exactly! Without logs, there's no evidence of unauthorized password changes.",
            nextStep: 1
          },
          {
            text: "Users might forget their new passwords",
            correct: false,
            points: 5,
            feedback: "Password memory is a user issue, not a logging failure.",
            nextStep: 0
          },
          {
            text: "The password change feature might stop working",
            correct: false,
            points: 5,
            feedback: "Functionality is separate from logging.",
            nextStep: 0
          }
        ]
      },
      {
        text: "What information should password change logs include?",
        choices: [
          {
            text: "Who changed the password, when, and from where",
            correct: true,
            points: 20,
            feedback: "Correct! These details are essential for investigating security incidents.",
            nextStep: 2
          },
          {
            text: "Only the time the password was changed",
            correct: false,
            points: -10,
            feedback: "Time alone isn't enough - need user and location context.",
            nextStep: 2
          },
          {
            text: "Just whether the change was successful",
            correct: false,
            points: -15,
            feedback: "Success status doesn't provide enough investigation details.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Logging failure! Not recording password change events for security monitoring.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "What security events should always be logged?",
        choices: [
          {
            text: "Password changes, logins, and important account modifications",
            correct: true,
            points: 15,
            feedback: "Essential! These are critical security events that need tracking.",
            nextStep: 1
          },
          {
            text: "Only failed login attempts",
            correct: false,
            points: -15,
            feedback: "Successful security events are also important to log.",
            nextStep: 1
          },
          {
            text: "Just actions that trigger security alerts",
            correct: false,
            points: -10,
            feedback: "You need baseline logs to establish what's normal.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple logging rule for account security?",
        choices: [
          {
            text: "Log all actions that affect account access or security",
            correct: true,
            points: 20,
            feedback: "Good practice! This ensures you can investigate security issues.",
            nextStep: 2
          },
          {
            text: "Log only suspicious activities",
            correct: false,
            points: -20,
            feedback: "You need all security events to detect what's suspicious.",
            nextStep: 2
          },
          {
            text: "Use the same logging for all user types",
            correct: false,
            points: -15,
            feedback: "Different user roles may require different logging levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Security logging implemented! Now tracking password changes and other critical security events.",
        choices: []
      }
    ]
  }
},

ssrf469: {
  id: 469,
  title: "Profile Picture URL Fetching Internal Images",
  difficulty: "Easy",
  vulnerability: "A10:2021 - Server-Side Request Forgery",
  attacker: {
    story: [
      {
        text: "A website lets users set profile pictures by providing image URLs. What happens if you use a URL like 'http://localhost/admin' or 'http://192.168.1.1'?",
        choices: [
          {
            text: "The server might try to fetch images from internal networks",
            correct: true,
            points: 15,
            feedback: "Exactly! URL fetching features can be abused to access internal systems.",
            nextStep: 1
          },
          {
            text: "The URL will be rejected as invalid",
            correct: false,
            points: 5,
            feedback: "That would be secure behavior, but we're testing for vulnerabilities.",
            nextStep: 0
          },
          {
            text: "Only image URLs from major sites will work",
            correct: false,
            points: 5,
            feedback: "Internal URLs might work if no protections are in place.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is accessing internal addresses through profile pictures dangerous?",
        choices: [
          {
            text: "It can reveal internal network information and system details",
            correct: true,
            points: 20,
            feedback: "Correct! SSRF helps attackers discover internal systems and services.",
            nextStep: 2
          },
          {
            text: "It will use up the website's bandwidth",
            correct: false,
            points: -10,
            feedback: "Bandwidth usage is not the security concern.",
            nextStep: 2
          },
          {
            text: "Internal systems might block the requests",
            correct: false,
            points: -15,
            feedback: "Even blocked requests can reveal information through error messages.",
            nextStep: 2
          }
        ]
      },
      {
        text: "SSRF vulnerability! Profile picture URL fetching allowing access to internal network addresses.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure URL fetching for profile pictures?",
        choices: [
          {
            text: "Validate URLs and block internal IP addresses and domains",
            correct: true,
            points: 15,
            feedback: "Essential! Restrict URL access to external addresses only.",
            nextStep: 1
          },
          {
            text: "Use a proxy for all image requests",
            correct: false,
            points: -15,
            feedback: "Proxies might still allow internal network access.",
            nextStep: 1
          },
          {
            text: "Only allow URLs from specific image hosting sites",
            correct: false,
            points: -10,
            feedback: "Whitelisting specific domains is better than general filtering.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple SSRF protection rule?",
        choices: [
          {
            text: "Never allow your server to make requests to internal networks",
            correct: true,
            points: 20,
            feedback: "Fundamental rule! Web applications should only access external resources.",
            nextStep: 2
          },
          {
            text: "Allow internal requests only during development",
            correct: false,
            points: -20,
            feedback: "Development practices should match production security.",
            nextStep: 2
          },
          {
            text: "Use the same URL validation for all features",
            correct: false,
            points: -15,
            feedback: "Different features may require different security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "SSRF protection implemented! Now blocking internal addresses in URL fetching features.",
        choices: []
      }
    ]
  }
},

accessControl470: {
  id: 470,
  title: "Viewing Other Users' Order Confirmations",
  difficulty: "Easy",
  vulnerability: "A01:2021 - Broken Access Control",
  attacker: {
    story: [
      {
        text: "After making a purchase, you see your order confirmation at '/orders/123'. What happens if you change the number to '/orders/124'?",
        choices: [
          {
            text: "You can see another customer's order details",
            correct: true,
            points: 15,
            feedback: "Exactly! Sequential order numbers make it easy to view others' purchases.",
            nextStep: 1
          },
          {
            text: "You get an 'order not found' error",
            correct: false,
            points: 5,
            feedback: "That would happen if order numbers weren't sequential or had gaps.",
            nextStep: 0
          },
          {
            text: "It shows your own order again",
            correct: false,
            points: 5,
            feedback: "This would indicate the system ignores the URL parameter.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is seeing others' order confirmations a privacy issue?",
        choices: [
          {
            text: "It reveals personal information and purchase history",
            correct: true,
            points: 20,
            feedback: "Correct! Order details often include names, addresses, and what people bought.",
            nextStep: 2
          },
          {
            text: "You can cancel their orders",
            correct: false,
            points: -10,
            feedback: "Viewing doesn't typically allow modification.",
            nextStep: 2
          },
          {
            text: "It might charge you for their purchases",
            correct: false,
            points: -15,
            feedback: "Viewing orders doesn't cause unauthorized charges.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Access control failure! Sequential order numbers allow customers to view each other's purchases.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should order access be controlled?",
        choices: [
          {
            text: "Check if the logged-in user owns the order before showing it",
            correct: true,
            points: 15,
            feedback: "Essential! Always verify ownership before displaying sensitive information.",
            nextStep: 1
          },
          {
            text: "Use random order numbers instead of sequential ones",
            correct: false,
            points: -10,
            feedback: "Random numbers help but don't replace proper access checks.",
            nextStep: 1
          },
          {
            text: "Hide order numbers from the URL",
            correct: false,
            points: -15,
            feedback: "Order numbers might still be needed - better to implement proper checks.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple rule for customer data?",
        choices: [
          {
            text: "Customers should only see their own orders and information",
            correct: true,
            points: 20,
            feedback: "Good practice! This clear rule protects customer privacy.",
            nextStep: 2
          },
          {
            text: "Allow customers to see recent orders from all users",
            correct: false,
            points: -20,
            feedback: "This would violate privacy - only show own data.",
            nextStep: 2
          },
          {
            text: "Use the same access rules for all order types",
            correct: false,
            points: -15,
            feedback: "Different order types might need different access rules.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Order access secured! Now verifying customer ownership before showing order details.",
        choices: []
      }
    ]
  }
},

cryptoFailures471: {
  id: 471,
  title: "Website Not Forcing HTTPS Redirect",
  difficulty: "Easy",
  vulnerability: "A02:2021 - Cryptographic Failures",
  attacker: {
    story: [
      {
        text: "A website has HTTPS available but doesn't automatically redirect from HTTP. What happens if users type 'http://' instead of 'https://'?",
        choices: [
          {
            text: "They browse without encryption, exposing their data",
            correct: true,
            points: 15,
            feedback: "Exactly! Without automatic redirect, users might accidentally use unencrypted HTTP.",
            nextStep: 1
          },
          {
            text: "The website loads slower without HTTPS",
            correct: false,
            points: 5,
            feedback: "Performance difference is minimal - security is the main concern.",
            nextStep: 0
          },
          {
            text: "Some browser features won't work",
            correct: false,
            points: 5,
            feedback: "Most features work on HTTP, but without security.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is it important to force HTTPS?",
        choices: [
          {
            text: "To ensure all traffic is encrypted and secure",
            correct: true,
            points: 20,
            feedback: "Correct! Forcing HTTPS protects users even if they forget to type it.",
            nextStep: 2
          },
          {
            text: "HTTPS websites rank higher in search engines",
            correct: false,
            points: 10,
            feedback: "While true, this is not the security reason.",
            nextStep: 2
          },
          {
            text: "HTTP websites are blocked by most browsers",
            correct: false,
            points: -15,
            feedback: "Browsers don't block HTTP, they just show warnings.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Cryptographic failure! Website not forcing HTTPS redirect, allowing unencrypted connections.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you ensure all traffic uses HTTPS?",
        choices: [
          {
            text: "Set up automatic redirect from HTTP to HTTPS",
            correct: true,
            points: 15,
            feedback: "Essential! Automatic redirects ensure users always get encrypted connections.",
            nextStep: 1
          },
          {
            text: "Tell users to always type https://",
            correct: false,
            points: -15,
            feedback: "Users often forget - automate security when possible.",
            nextStep: 1
          },
          {
            text: "Block HTTP connections completely",
            correct: false,
            points: -10,
            feedback: "Redirect is better than blocking - it guides users to security.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple HTTPS rule?",
        choices: [
          {
            text: "Always redirect HTTP to HTTPS for all pages",
            correct: true,
            points: 20,
            feedback: "Best practice! Every page should be served over HTTPS.",
            nextStep: 2
          },
          {
            text: "Use HTTPS only for login and payment pages",
            correct: false,
            points: -20,
            feedback: "All pages need HTTPS to protect user privacy.",
            nextStep: 2
          },
          {
            text: "Let users choose between HTTP and HTTPS",
            correct: false,
            points: -15,
            feedback: "Always force HTTPS - don't give insecure options.",
            nextStep: 2
          }
        ]
      },
      {
        text: "HTTPS redirect implemented! Now automatically redirecting all HTTP traffic to secure HTTPS.",
        choices: []
      }
    ]
  }
},

injection472: {
  id: 472,
  title: "Contact Form Email Header Injection",
  difficulty: "Easy",
  vulnerability: "A03:2021 - Injection",
  attacker: {
    story: [
      {
        text: "A contact form sends emails to the website owner. What happens if you put 'test@test.com\\r\\nBcc: victim@victim.com' in the email field?",
        choices: [
          {
            text: "The email might be sent to additional hidden recipients",
            correct: true,
            points: 15,
            feedback: "Exactly! Email header injection can add unauthorized recipients.",
            nextStep: 1
          },
          {
            text: "The form will reject the special characters",
            correct: false,
            points: 5,
            feedback: "That would be secure behavior, but we're testing for vulnerabilities.",
            nextStep: 0
          },
          {
            text: "The email will fail to send",
            correct: false,
            points: 5,
            feedback: "If vulnerable, the email might send successfully to extra addresses.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is email header injection dangerous?",
        choices: [
          {
            text: "It can send spam or phishing emails from your website",
            correct: true,
            points: 20,
            feedback: "Correct! Attackers can abuse your contact form to send malicious emails.",
            nextStep: 2
          },
          {
            text: "It will overload the email server",
            correct: false,
            points: -10,
            feedback: "Server load is not the primary security concern.",
            nextStep: 2
          },
          {
            text: "The email formatting will look wrong",
            correct: false,
            points: -15,
            feedback: "Formatting issues are minor compared to security risks.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Injection vulnerability! Contact form allowing email header injection to send unauthorized emails.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent email header injection?",
        choices: [
          {
            text: "Validate and sanitize all form inputs before using in email headers",
            correct: true,
            points: 15,
            feedback: "Essential! Remove or escape special characters that could modify email headers.",
            nextStep: 1
          },
          {
            text: "Block all special characters in email fields",
            correct: false,
            points: -15,
            feedback: "This breaks legitimate email addresses - sanitize instead.",
            nextStep: 1
          },
          {
            text: "Use JavaScript to check email format only",
            correct: false,
            points: -10,
            feedback: "Client-side checks can be bypassed - validate server-side.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple email security rule?",
        choices: [
          {
            text: "Never put user input directly into email headers",
            correct: true,
            points: 20,
            feedback: "Fundamental rule! User input should only go in email body, not headers.",
            nextStep: 2
          },
          {
            text: "Allow only common email providers like Gmail",
            correct: false,
            points: -20,
            feedback: "This doesn't prevent header injection - validate inputs properly.",
            nextStep: 2
          },
          {
            text: "Use the same validation for all form fields",
            correct: false,
            points: -15,
            feedback: "Different fields may require different validation rules.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Email security implemented! Now sanitizing all inputs used in email headers.",
        choices: []
      }
    ]
  }
},

insecureDesign473: {
  id: 473,
  title: "Password Reset Sending Current Password",
  difficulty: "Easy",
  vulnerability: "A04:2021 - Insecure Design",
  attacker: {
    story: [
      {
        text: "When you click 'Forgot Password', the website emails you your current password. Why is this design insecure?",
        choices: [
          {
            text: "It means passwords are stored in plain text, not securely hashed",
            correct: true,
            points: 15,
            feedback: "Exactly! If they can email your password, they're storing it in readable form.",
            nextStep: 1
          },
          {
            text: "Users might not check their email",
            correct: false,
            points: 5,
            feedback: "Email checking is a user behavior issue.",
            nextStep: 0
          },
          {
            text: "The email might go to spam folder",
            correct: false,
            points: 5,
            feedback: "Email delivery is operational, not a design flaw.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is plain text password storage dangerous?",
        choices: [
          {
            text: "If the database is hacked, all passwords are immediately exposed",
            correct: true,
            points: 20,
            feedback: "Correct! Plain text passwords mean instant account compromise if breached.",
            nextStep: 2
          },
          {
            text: "Plain text takes up more storage space",
            correct: false,
            points: -10,
            feedback: "Storage space is not the security concern.",
            nextStep: 2
          },
          {
            text: "Users might forget plain text passwords faster",
            correct: false,
            points: -15,
            feedback: "Password memory is not the security issue.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Insecure design! Password reset revealing that passwords are stored in plain text.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should password reset work securely?",
        choices: [
          {
            text: "Send a time-limited reset link, never reveal current passwords",
            correct: true,
            points: 15,
            feedback: "Essential! Reset links ensure passwords remain secret and secure.",
            nextStep: 1
          },
          {
            text: "Email the password in an encrypted attachment",
            correct: false,
            points: -15,
            feedback: "The system still knows the plain text password - this is insecure.",
            nextStep: 1
          },
          {
            text: "Call users with their password for security",
            correct: false,
            points: -10,
            feedback: "The fundamental issue is plain text storage, not delivery method.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the modern password security approach?",
        choices: [
          {
            text: "Store only password hashes, use secure reset links",
            correct: true,
            points: 20,
            feedback: "Best practice! Hashing makes passwords unreadable even if database is compromised.",
            nextStep: 2
          },
          {
            text: "Encrypt passwords instead of hashing them",
            correct: false,
            points: -20,
            feedback: "Encryption can be reversed - hashing is one-way and more secure.",
            nextStep: 2
          },
          {
            text: "Use the same password for all user accounts",
            correct: false,
            points: -15,
            feedback: "Each user should have a unique, securely stored password.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Password security improved! Now storing hashed passwords and using secure reset links.",
        choices: []
      }
    ]
  }
},

securityMisconfig474: {
  id: 474,
  title: "Default 'Admin' Account Still Active",
  difficulty: "Easy",
  vulnerability: "A05:2021 - Security Misconfiguration",
  attacker: {
    story: [
      {
        text: "You discover a website has a default 'admin' user account that hasn't been disabled or renamed. Why is this dangerous?",
        choices: [
          {
            text: "Attackers know this username exists and can target it",
            correct: true,
            points: 15,
            feedback: "Exactly! Default admin accounts are the first thing attackers try.",
            nextStep: 1
          },
          {
            text: "The admin account might have weak permissions",
            correct: false,
            points: 5,
            feedback: "Admin accounts typically have strong permissions - that's the problem.",
            nextStep: 0
          },
          {
            text: "Multiple people might use the same admin account",
            correct: false,
            points: 5,
            feedback: "While bad practice, this is different from the default account risk.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How do attackers exploit default admin accounts?",
        choices: [
          {
            text: "They try common passwords since they know the username",
            correct: true,
            points: 20,
            feedback: "Correct! Knowing the username makes password guessing much easier.",
            nextStep: 2
          },
          {
            text: "They can delete the admin account",
            correct: false,
            points: -10,
            feedback: "Attackers typically want to use admin accounts, not delete them.",
            nextStep: 2
          },
          {
            text: "The website will automatically grant them access",
            correct: false,
            points: -15,
            feedback: "Access still requires password guessing, but it's easier with known usernames.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Security misconfiguration! Default admin account left active, making it an easy target for attackers.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should admin accounts be configured?",
        choices: [
          {
            text: "Disable default accounts and create custom-named admin accounts",
            correct: true,
            points: 15,
            feedback: "Essential! Custom account names are harder for attackers to guess.",
            nextStep: 1
          },
          {
            text: "Keep the admin account but use a very strong password",
            correct: false,
            points: -15,
            feedback: "Even with strong passwords, known usernames are still targets.",
            nextStep: 1
          },
          {
            text: "Hide the admin login page from public view",
            correct: false,
            points: -10,
            feedback: "Security through obscurity doesn't work - fix the configuration.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple admin account rule?",
        choices: [
          {
            text: "Never use default account names, especially for administrative access",
            correct: true,
            points: 20,
            feedback: "Good practice! Custom account names provide basic protection.",
            nextStep: 2
          },
          {
            text: "Allow only one admin account for simplicity",
            correct: false,
            points: -20,
            feedback: "Multiple admin accounts with different names are more secure.",
            nextStep: 2
          },
          {
            text: "Use the same admin account for all systems",
            correct: false,
            points: -15,
            feedback: "Different systems should have different admin accounts.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Admin accounts secured! Now using custom-named accounts with default accounts disabled.",
        choices: []
      }
    ]
  }
},

vulnerableComponents475: {
  id: 475,
  title: "Outdated PHP Version with Known Vulnerabilities",
  difficulty: "Easy",
  vulnerability: "A06:2021 - Vulnerable and Outdated Components",
  attacker: {
    story: [
      {
        text: "You check a website's server information and see it's running PHP 5.6, which reached end-of-life years ago. What risk does this create?",
        choices: [
          {
            text: "Known security vulnerabilities that won't be fixed",
            correct: true,
            points: 15,
            feedback: "Exactly! End-of-life software doesn't receive security updates.",
            nextStep: 1
          },
          {
            text: "The website might not work with modern browsers",
            correct: false,
            points: 5,
            feedback: "PHP version doesn't directly affect browser compatibility.",
            nextStep: 0
          },
          {
            text: "Some PHP features might be missing",
            correct: false,
            points: 5,
            feedback: "Missing features are development issues, not security risks.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why are end-of-life software versions dangerous?",
        choices: [
          {
            text: "New vulnerabilities discovered won't get security patches",
            correct: true,
            points: 20,
            feedback: "Correct! Without security updates, vulnerabilities remain open forever.",
            nextStep: 2
          },
          {
            text: "They use more server resources",
            correct: false,
            points: -10,
            feedback: "Resource usage is operational, not a security concern.",
            nextStep: 2
          },
          {
            text: "They might conflict with other software",
            correct: false,
            points: -15,
            feedback: "Compatibility issues are different from security vulnerabilities.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Vulnerable components! Using end-of-life PHP version without security updates.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should software versions be managed?",
        choices: [
          {
            text: "Use supported versions and apply security updates regularly",
            correct: true,
            points: 15,
            feedback: "Essential! Stay on supported versions to receive security fixes.",
            nextStep: 1
          },
          {
            text: "Keep using old versions if they work correctly",
            correct: false,
            points: -15,
            feedback: "Working doesn't mean secure - update to supported versions.",
            nextStep: 1
          },
          {
            text: "Hide version information from showing publicly",
            correct: false,
            points: -10,
            feedback: "Hiding versions doesn't fix vulnerabilities - update instead.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple software maintenance rule?",
        choices: [
          {
            text: "Regularly update to supported versions with security patches",
            correct: true,
            points: 20,
            feedback: "Best practice! Regular updates protect against known vulnerabilities.",
            nextStep: 2
          },
          {
            text: "Only update when adding new features",
            correct: false,
            points: -20,
            feedback: "Security updates should happen independently of feature development.",
            nextStep: 2
          },
          {
            text: "Use the same software versions forever once stable",
            correct: false,
            points: -15,
            feedback: "Software becomes less secure over time as new vulnerabilities are found.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Software updated! Now using supported PHP version with regular security updates.",
        choices: []
      }
    ]
  }
},

authFailure476: {
  id: 476,
  title: "Remember Me Feature with Long Expiration",
  difficulty: "Easy",
  vulnerability: "A07:2021 - Identification and Authentication Failures",
  attacker: {
    story: [
      {
        text: "A website's 'Remember Me' login feature keeps users logged in for 30 days. Why could this be a security risk?",
        choices: [
          {
            text: "If device is lost or shared, others can access the account",
            correct: true,
            points: 15,
            feedback: "Exactly! Long-lasting sessions remain vulnerable if devices are compromised.",
            nextStep: 1
          },
          {
            text: "Users might forget their passwords",
            correct: false,
            points: 5,
            feedback: "Password memory is a user issue, not an authentication failure.",
            nextStep: 0
          },
          {
            text: "It uses more browser storage space",
            correct: false,
            points: 5,
            feedback: "Storage usage is not the security concern.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Where is the 'Remember Me' feature most risky?",
        choices: [
          {
            text: "Public computers, shared devices, and lost phones",
            correct: true,
            points: 20,
            feedback: "Correct! Any situation where others might access the device creates risk.",
            nextStep: 2
          },
          {
            text: "Only on office computers",
            correct: false,
            points: -10,
            feedback: "Any shared or potentially accessible device carries risk.",
            nextStep: 2
          },
          {
            text: "Just on mobile devices",
            correct: false,
            points: -15,
            feedback: "All device types can be lost or shared.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Authentication failure! 'Remember Me' feature with excessively long session duration.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should 'Remember Me' features be implemented securely?",
        choices: [
          {
            text: "Use reasonable expiration (e.g., 7 days) instead of very long periods",
            correct: true,
            points: 15,
            feedback: "Good practice! Balance convenience with security by using moderate durations.",
            nextStep: 1
          },
          {
            text: "Remove the 'Remember Me' feature entirely",
            correct: false,
            points: -15,
            feedback: "The feature is useful - implement it securely instead of removing.",
            nextStep: 1
          },
          {
            text: "Use very short remember periods (1 day)",
            correct: false,
            points: -10,
            feedback: "Too short defeats the purpose - find a reasonable balance.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the balanced approach to persistent logins?",
        choices: [
          {
            text: "Offer convenience with moderate security, clear expiration warnings",
            correct: true,
            points: 20,
            feedback: "Balanced approach! Security with usability and clear user information.",
            nextStep: 2
          },
          {
            text: "Never allow persistent logins for maximum security",
            correct: false,
            points: -20,
            feedback: "Convenience features are acceptable with proper security measures.",
            nextStep: 2
          },
          {
            text: "Use the same expiration for all users",
            correct: false,
            points: -15,
            feedback: "Different user types may have different security needs.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Remember Me feature secured! Now using reasonable expiration with clear security warnings.",
        choices: []
      }
    ]
  }
},

softwareIntegrity477: {
  id: 477,
  title: "Client-Side Discount Code Validation",
  difficulty: "Easy",
  vulnerability: "A08:2021 - Software and Data Integrity Failures",
  attacker: {
    story: [
      {
        text: "A shopping cart uses JavaScript to validate discount codes but doesn't check them again on the server. What happens if you bypass the JavaScript check?",
        choices: [
          {
            text: "You might be able to use invalid or expired discount codes",
            correct: true,
            points: 15,
            feedback: "Exactly! Client-side validation can be bypassed to use unauthorized discounts.",
            nextStep: 1
          },
          {
            text: "The order will fail during payment processing",
            correct: false,
            points: 5,
            feedback: "That would require server-side validation to be working.",
            nextStep: 0
          },
          {
            text: "Only the display price will change but not the actual charge",
            correct: false,
            points: 5,
            feedback: "If only client-side validation exists, the discount might apply.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is bypassing discount validation a problem for the business?",
        choices: [
          {
            text: "It can cause revenue loss through unauthorized discounts",
            correct: true,
            points: 20,
            feedback: "Correct! Invalid discounts directly impact business revenue.",
            nextStep: 2
          },
          {
            text: "The shopping cart might calculate taxes wrong",
            correct: false,
            points: -10,
            feedback: "Tax calculation is separate from discount validation.",
            nextStep: 2
          },
          {
            text: "Other customers might see the fake discounts",
            correct: false,
            points: -15,
            feedback: "Client-side changes only affect your own view.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Software integrity failure! Client-side discount validation enabling unauthorized discount usage.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should discount codes be validated?",
        choices: [
          {
            text: "Validate all discount codes server-side before applying them",
            correct: true,
            points: 15,
            feedback: "Essential! Server-side validation cannot be bypassed by users.",
            nextStep: 1
          },
          {
            text: "Use complex JavaScript to make bypassing harder",
            correct: false,
            points: -15,
            feedback: "Complex client-side code can still be bypassed - validate server-side.",
            nextStep: 1
          },
          {
            text: "Hide discount fields until validation passes",
            correct: false,
            points: -10,
            feedback: "Fields can still be modified when shown - validate server-side.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple rule for business logic?",
        choices: [
          {
            text: "All business rules must be enforced server-side",
            correct: true,
            points: 20,
            feedback: "Fundamental rule! Client-side can improve user experience, server-side enforces rules.",
            nextStep: 2
          },
          {
            text: "Use the same validation for all discount types",
            correct: false,
            points: -20,
            feedback: "Different discount types may have different validation rules.",
            nextStep: 2
          },
          {
            text: "Allow some discount flexibility for customer satisfaction",
            correct: false,
            points: -15,
            feedback: "Business rules should be consistently enforced.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Discount validation secured! Now enforcing all business rules server-side.",
        choices: []
      }
    ]
  }
},

loggingFailures478: {
  id: 478,
  title: "Not Logging Failed Login Attempts",
  difficulty: "Easy",
  vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
  attacker: {
    story: [
      {
        text: "You try multiple wrong passwords on a login page but don't see any error messages or delays. What logging issue might this indicate?",
        choices: [
          {
            text: "Failed login attempts might not be logged at all",
            correct: true,
            points: 15,
            feedback: "Exactly! Lack of feedback might indicate missing security logging.",
            nextStep: 1
          },
          {
            text: "The login system is very efficient",
            correct: false,
            points: 5,
            feedback: "Efficiency is good, but security logging is still needed.",
            nextStep: 0
          },
          {
            text: "The system has strong brute force protection",
            correct: false,
            points: 5,
            feedback: "Strong protection usually includes logging for monitoring.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why are failed login logs important for security?",
        choices: [
          {
            text: "They help detect brute force attacks and suspicious activity",
            correct: true,
            points: 20,
            feedback: "Correct! Failed login patterns can reveal attack attempts.",
            nextStep: 2
          },
          {
            text: "They make the login process faster",
            correct: false,
            points: -10,
            feedback: "Logging doesn't typically improve performance.",
            nextStep: 2
          },
          {
            text: "They help users remember their passwords",
            correct: false,
            points: -15,
            feedback: "Logging is for security monitoring, not user assistance.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Logging failure! Missing failed login attempt logging preventing attack detection.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "What authentication events should be logged?",
        choices: [
          {
            text: "Both successful and failed login attempts",
            correct: true,
            points: 15,
            feedback: "Essential! Both types of events provide important security information.",
            nextStep: 1
          },
          {
            text: "Only successful logins to reduce log size",
            correct: false,
            points: -15,
            feedback: "Failed attempts are crucial for detecting attacks.",
            nextStep: 1
          },
          {
            text: "Only logins from unusual locations",
            correct: false,
            points: -10,
            feedback: "You need all attempts to establish what's 'usual'.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple security logging rule?",
        choices: [
          {
            text: "Log all authentication events for security monitoring",
            correct: true,
            points: 20,
            feedback: "Good practice! Complete authentication logging enables security monitoring.",
            nextStep: 2
          },
          {
            text: "Log only events that seem suspicious",
            correct: false,
            points: -20,
            feedback: "You need baseline data to know what's suspicious.",
            nextStep: 2
          },
          {
            text: "Use the same logging for all applications",
            correct: false,
            points: -15,
            feedback: "Different applications may have different logging needs.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Authentication logging implemented! Now tracking both successful and failed login attempts.",
        choices: []
      }
    ]
  }
},

ssrf479: {
  id: 479,
  title: "Image URL Import from User Input",
  difficulty: "Easy",
  vulnerability: "A10:2021 - Server-Side Request Forgery",
  attacker: {
    story: [
      {
        text: "A blog lets users import images by providing URLs. What happens if you use a URL like 'http://localhost/admin' or an internal network address?",
        choices: [
          {
            text: "The server might try to fetch images from internal systems",
            correct: true,
            points: 15,
            feedback: "Exactly! Image import features can be abused to scan internal networks.",
            nextStep: 1
          },
          {
            text: "The URL will be rejected as not an image",
            correct: false,
            points: 5,
            feedback: "That would be secure behavior, but we're testing for vulnerabilities.",
            nextStep: 0
          },
          {
            text: "Only image URLs from major sites will work",
            correct: false,
            points: 5,
            feedback: "Internal URLs might work if no protections are in place.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is accessing internal addresses through image import dangerous?",
        choices: [
          {
            text: "It can reveal internal network structure and system information",
            correct: true,
            points: 20,
            feedback: "Correct! SSRF helps attackers discover internal systems and services.",
            nextStep: 2
          },
          {
            text: "It will use up the website's bandwidth",
            correct: false,
            points: -10,
            feedback: "Bandwidth usage is not the security concern.",
            nextStep: 2
          },
          {
            text: "Internal systems might get confused by the requests",
            correct: false,
            points: -15,
            feedback: "System confusion is not the security risk.",
            nextStep: 2
          }
        ]
      },
      {
        text: "SSRF vulnerability! Image import feature allowing access to internal network addresses.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure image import features?",
        choices: [
          {
            text: "Validate URLs and block internal IP addresses and domains",
            correct: true,
            points: 15,
            feedback: "Essential! Restrict URL access to external addresses only.",
            nextStep: 1
          },
          {
            text: "Use a proxy for all image requests",
            correct: false,
            points: -15,
            feedback: "Proxies might still allow internal network access.",
            nextStep: 1
          },
          {
            text: "Only allow image URLs from specific domains",
            correct: false,
            points: -10,
            feedback: "Whitelisting specific domains is better than general filtering.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple SSRF protection rule?",
        choices: [
          {
            text: "Never allow server requests to internal network addresses",
            correct: true,
            points: 20,
            feedback: "Fundamental rule! Web applications should only access external resources.",
            nextStep: 2
          },
          {
            text: "Allow internal requests only for authenticated users",
            correct: false,
            points: -20,
            feedback: "Even authenticated users shouldn't access internal networks through your app.",
            nextStep: 2
          },
          {
            text: "Use the same URL validation for all import features",
            correct: false,
            points: -15,
            feedback: "Different features may require different security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "SSRF protection implemented! Now blocking internal addresses in image import features.",
        choices: []
      }
    ]
  }
},

accessControl480: {
  id: 480,
  title: "GraphQL Query Depth Attack - Nested Resource Exhaustion",
  difficulty: "Hard",
  vulnerability: "A01:2021 - Broken Access Control",
  attacker: {
    story: [
      {
        text: "You discover a GraphQL API with no query depth limiting. The schema has deeply nested relationships (user->posts->comments->authors->...). How can this be exploited?",
        choices: [
          {
            text: "Craft deeply nested queries to cause resource exhaustion and denial of service",
            correct: true,
            points: 30,
            feedback: "Critical finding! GraphQL depth attacks can overwhelm servers with complex nested queries.",
            nextStep: 1
          },
          {
            text: "Extract all database data through a single query",
            correct: false,
            points: 15,
            feedback: "While GraphQL can access much data, depth attacks focus on query complexity, not data extraction.",
            nextStep: 0
          },
          {
            text: "Bypass field-level authorization through nesting",
            correct: false,
            points: 10,
            feedback: "Depth attacks exploit computational complexity, not authorization bypass.",
            nextStep: 0
          }
        ]
      },
      {
        text: "What makes nested GraphQL queries particularly dangerous for servers?",
        choices: [
          {
            text: "Exponential growth in database joins and object creation with each nesting level",
            correct: true,
            points: 35,
            feedback: "Sophisticated attack! Each nesting level multiplies the computational load exponentially.",
            nextStep: 2
          },
          {
            text: "They can bypass API rate limiting mechanisms",
            correct: false,
            points: -25,
            feedback: "Rate limiting typically counts queries, not complexity - depth is different.",
            nextStep: 2
          },
          {
            text: "Nested queries automatically get administrative privileges",
            correct: false,
            points: -30,
            feedback: "Depth doesn't affect authorization - it's about computational complexity.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced access control failure! GraphQL query depth attacks enabling server resource exhaustion through nested query exploitation.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent GraphQL query depth attacks?",
        choices: [
          {
            text: "Implement query depth limiting and query cost analysis",
            correct: true,
            points: 30,
            feedback: "Essential! Depth limiting and cost analysis prevent complex query attacks.",
            nextStep: 1
          },
          {
            text: "Disable nested queries entirely in the schema",
            correct: false,
            points: -35,
            feedback: "This breaks legitimate GraphQL functionality - use limits instead.",
            nextStep: 1
          },
          {
            text: "Use query whitelisting for all operations",
            correct: false,
            points: -30,
            feedback: "Whitelisting is too restrictive for dynamic GraphQL use cases.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive GraphQL API security strategy?",
        choices: [
          {
            text: "Depth limiting, query cost analysis, and persistent query validation",
            correct: true,
            points: 35,
            feedback: "Enterprise GraphQL security! Multiple layers protect against various query-based attacks.",
            nextStep: 2
          },
          {
            text: "Allow unlimited query depth but add more server resources",
            correct: false,
            points: -40,
            feedback: "This doesn't solve the fundamental vulnerability - attackers can always create deeper queries.",
            nextStep: 2
          },
          {
            text: "Use the same depth limits for all GraphQL operations",
            correct: false,
            points: -35,
            feedback: "Different operations may have different legitimate depth requirements.",
            nextStep: 2
          }
        ]
      },
      {
        text: "GraphQL security hardened! Now implementing depth limiting with comprehensive query analysis.",
        choices: []
      }
    ]
  }
},

cryptoFailures481: {
  id: 481,
  title: "Cryptographic Side-Channels in Multi-Tenant Systems",
  difficulty: "Hard",
  vulnerability: "A02:2021 - Cryptographic Failures",
  attacker: {
    story: [
      {
        text: "A multi-tenant SaaS application uses shared cryptographic keys across tenants but different IVs for each. What advanced cryptographic risk exists?",
        choices: [
          {
            text: "IV reuse across tenants can lead to cryptographic pattern analysis",
            correct: true,
            points: 30,
            feedback: "Advanced finding! Shared keys with IV management issues enable cross-tenant cryptographic attacks.",
            nextStep: 1
          },
          {
            text: "The encryption might be slower with shared keys",
            correct: false,
            points: 5,
            feedback: "Performance impact is not the cryptographic vulnerability.",
            nextStep: 0
          },
          {
            text: "Tenants might accidentally see each other's data",
            correct: false,
            points: 10,
            feedback: "Direct data leakage is different from cryptographic side-channels.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can IV reuse in multi-tenant systems be exploited?",
        choices: [
          {
            text: "Analyze encryption patterns to derive information about other tenants' data",
            correct: true,
            points: 35,
            feedback: "Sophisticated cryptanalysis! IV reuse enables statistical analysis across tenant boundaries.",
            nextStep: 2
          },
          {
            text: "Directly decrypt other tenants' data with the shared key",
            correct: false,
            points: -30,
            feedback: "Proper encryption should prevent direct decryption even with shared keys.",
            nextStep: 2
          },
          {
            text: "Cause encryption failures for all tenants",
            correct: false,
            points: -25,
            feedback: "IV reuse doesn't typically cause immediate failures.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced cryptographic failure! Multi-tenant IV reuse enabling cross-tenant cryptographic side-channel attacks.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure cryptographic operations in multi-tenant systems?",
        choices: [
          {
            text: "Use tenant-specific keys and proper IV management with random generation",
            correct: true,
            points: 30,
            feedback: "Essential! Tenant isolation should extend to cryptographic materials.",
            nextStep: 1
          },
          {
            text: "Use larger key sizes to compensate for shared usage",
            correct: false,
            points: -35,
            feedback: "Key size doesn't prevent IV reuse vulnerabilities.",
            nextStep: 1
          },
          {
            text: "Encrypt all tenant data with the same IV for consistency",
            correct: false,
            points: -40,
            feedback: "This dramatically increases cryptographic vulnerability.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the zero-trust cryptographic architecture for SaaS?",
        choices: [
          {
            text: "Tenant-specific keys, hardware security modules, and cryptographic isolation",
            correct: true,
            points: 35,
            feedback: "Enterprise SaaS security! Complete cryptographic separation between tenants.",
            nextStep: 2
          },
          {
            text: "Allow key sharing for operational efficiency",
            correct: false,
            points: -45,
            feedback: "Key sharing creates unacceptable cryptographic risks in multi-tenant systems.",
            nextStep: 2
          },
          {
            text: "Use the same cryptographic setup for all tenants",
            correct: false,
            points: -40,
            feedback: "Different tenants may have different security requirements.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Multi-tenant cryptography secured! Now using tenant-specific keys with proper IV management.",
        choices: []
      }
    ]
  }
},

injection482: {
  id: 482,
  title: "NoSQL Injection in MongoDB Aggregation Pipelines",
  difficulty: "Hard",
  vulnerability: "A03:2021 - Injection",
  attacker: {
    story: [
      {
        text: "A MongoDB application builds aggregation pipelines by merging user input directly into $match and $project stages. What advanced injection risk exists?",
        choices: [
          {
            text: "Aggregation pipeline injection enabling data aggregation bypass and manipulation",
            correct: true,
            points: 30,
            feedback: "Critical finding! Aggregation pipeline injection can bypass data aggregation controls.",
            nextStep: 1
          },
          {
            text: "The database might return incomplete results",
            correct: false,
            points: 10,
            feedback: "Result completeness is operational, not the injection risk.",
            nextStep: 0
          },
          {
            text: "Query performance might degrade significantly",
            correct: false,
            points: 5,
            feedback: "Performance impact is not the security vulnerability.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can aggregation pipeline injection expose sensitive data?",
        choices: [
          {
            text: "Inject $project stages to include excluded fields or manipulate aggregation results",
            correct: true,
            points: 35,
            feedback: "Sophisticated technique! Pipeline injection can override field exclusion and data transformation.",
            nextStep: 2
          },
          {
            text: "Directly modify the database schema",
            correct: false,
            points: -35,
            feedback: "Aggregation pipelines don't typically allow schema modification.",
            nextStep: 2
          },
          {
            text: "Use traditional SQL injection techniques",
            correct: false,
            points: -30,
            feedback: "MongoDB uses different query language than SQL.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced injection vulnerability! MongoDB aggregation pipeline injection enabling data aggregation bypass and field manipulation.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent aggregation pipeline injection?",
        choices: [
          {
            text: "Use parameterized aggregation with $expr and input validation",
            correct: true,
            points: 30,
            feedback: "Essential! Parameterized aggregation prevents pipeline manipulation.",
            nextStep: 1
          },
          {
            text: "Disable aggregation pipelines for user queries",
            correct: false,
            points: -40,
            feedback: "This severely limits application functionality.",
            nextStep: 1
          },
          {
            text: "Use query timeouts as primary protection",
            correct: false,
            points: -35,
            feedback: "Timeouts don't prevent data exposure, just slow down attacks.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive MongoDB security approach?",
        choices: [
          {
            text: "Input validation, parameterized queries, and aggregation pipeline sanitization",
            correct: true,
            points: 35,
            feedback: "Enterprise MongoDB security! Multiple layers protect against various injection vectors.",
            nextStep: 2
          },
          {
            text: "Allow only simple find queries without aggregation",
            correct: false,
            points: -45,
            feedback: "This breaks modern application requirements.",
            nextStep: 2
          },
          {
            text: "Use the same validation for all database operations",
            correct: false,
            points: -40,
            feedback: "Different operations may require different security handling.",
            nextStep: 2
          }
        ]
      },
      {
        text: "MongoDB security implemented! Now using parameterized aggregation with comprehensive input validation.",
        choices: []
      }
    ]
  }
},

insecureDesign483: {
  id: 483,
  title: "Eventual Consistency Race Conditions in Distributed Systems",
  difficulty: "Hard",
  vulnerability: "A04:2021 - Insecure Design",
  attacker: {
    story: [
      {
        text: "A distributed system uses eventual consistency for user balance updates across multiple regions. What fundamental design flaw enables financial attacks?",
        choices: [
          {
            text: "Balance update race conditions allowing double-spending during replication delays",
            correct: true,
            points: 30,
            feedback: "Critical design flaw! Eventual consistency creates windows for financial exploitation.",
            nextStep: 1
          },
          {
            text: "The system might have data consistency issues",
            correct: false,
            points: 10,
            feedback: "Consistency issues are operational, not the security design flaw.",
            nextStep: 0
          },
          {
            text: "User sessions might expire at different times",
            correct: false,
            points: 5,
            feedback: "Session timing is different from financial consistency.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can eventual consistency be exploited for financial gain?",
        choices: [
          {
            text: "Make simultaneous transactions in different regions before balance updates propagate",
            correct: true,
            points: 35,
            feedback: "Sophisticated attack! Geographic consistency delays enable double-spending.",
            nextStep: 2
          },
          {
            text: "Directly modify the balance in each region separately",
            correct: false,
            points: -35,
            feedback: "Balance modification requires different vulnerabilities.",
            nextStep: 2
          },
          {
            text: "Use network delays to replay transactions",
            correct: false,
            points: -30,
            feedback: "Replay attacks are different from consistency exploits.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Insecure design! Eventual consistency in financial systems enabling double-spending through replication race conditions.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure financial operations in distributed systems?",
        choices: [
          {
            text: "Use strong consistency or distributed transactions for financial operations",
            correct: true,
            points: 30,
            feedback: "Essential! Financial systems require strong consistency guarantees.",
            nextStep: 1
          },
          {
            text: "Add artificial delays to hide consistency issues",
            correct: false,
            points: -40,
            feedback: "Delays don't solve the fundamental consistency problem.",
            nextStep: 1
          },
          {
            text: "Use eventual consistency but with faster replication",
            correct: false,
            points: -35,
            feedback: "Faster replication doesn't eliminate the race condition window.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the robust distributed systems architecture for finance?",
        choices: [
          {
            text: "Strong consistency, distributed locking, and compensation transactions",
            correct: true,
            points: 35,
            feedback: "Enterprise financial architecture! Multiple mechanisms ensure financial integrity.",
            nextStep: 2
          },
          {
            text: "Allow eventual consistency for all operations for scalability",
            correct: false,
            points: -45,
            feedback: "Financial operations cannot tolerate eventual consistency.",
            nextStep: 2
          },
          {
            text: "Use the same consistency model for all data types",
            correct: false,
            points: -40,
            feedback: "Different data types have different consistency requirements.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Distributed system design secured! Now using strong consistency for financial operations.",
        choices: []
      }
    ]
  }
},

securityMisconfig484: {
  id: 484,
  title: "Kubernetes Pod Security Policy Bypass",
  difficulty: "Medium",
  vulnerability: "A05:2021 - Security Misconfiguration",
  attacker: {
    story: [
      {
        text: "A Kubernetes cluster has Pod Security Policies enabled but some namespaces are exempted for 'legacy applications'. What container escape risk exists?",
        choices: [
          {
            text: "Attackers can deploy privileged pods in exempted namespaces to escape containers",
            correct: true,
            points: 25,
            feedback: "Critical finding! PSP exemptions create security bypass opportunities.",
            nextStep: 1
          },
          {
            text: "The cluster might have resource allocation issues",
            correct: false,
            points: 5,
            feedback: "Resource management is operational, not a security bypass.",
            nextStep: 0
          },
          {
            text: "Logging might be inconsistent across namespaces",
            correct: false,
            points: 10,
            feedback: "Logging inconsistencies are observability issues.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can PSP exemptions lead to cluster compromise?",
        choices: [
          {
            text: "Deploy privileged containers in exempt namespaces to gain host access",
            correct: true,
            points: 30,
            feedback: "Advanced container escape! PSP bypass enables host system compromise.",
            nextStep: 2
          },
          {
            text: "Directly modify the Kubernetes API server",
            correct: false,
            points: -30,
            feedback: "API server modification requires different access levels.",
            nextStep: 2
          },
          {
            text: "Use DNS spoofing between pods",
            correct: false,
            points: -25,
            feedback: "DNS attacks are mitigated by proper network policies.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Security misconfiguration! Kubernetes Pod Security Policy exemptions enabling container escape and cluster compromise.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you properly secure Kubernetes clusters?",
        choices: [
          {
            text: "Use Pod Security Standards universally with minimal exceptions",
            correct: true,
            points: 25,
            feedback: "Essential! Universal security policies prevent bypass attacks.",
            nextStep: 1
          },
          {
            text: "Allow PSP exemptions for development namespaces",
            correct: false,
            points: -35,
            feedback: "Development should mirror production security.",
            nextStep: 1
          },
          {
            text: "Use network policies instead of pod security",
            correct: false,
            points: -30,
            feedback: "Network and pod security are complementary, not interchangeable.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the zero-trust Kubernetes security model?",
        choices: [
          {
            text: "Pod Security Admission, network policies, and runtime security monitoring",
            correct: true,
            points: 30,
            feedback: "Enterprise Kubernetes security! Multiple layers protect against container escape.",
            nextStep: 2
          },
          {
            text: "Allow privileged pods for operational convenience",
            correct: false,
            points: -40,
            feedback: "Privileged pods dramatically increase attack surface.",
            nextStep: 2
          },
          {
            text: "Use the same security policies for all clusters",
            correct: false,
            points: -35,
            feedback: "Different clusters may have different security requirements.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Kubernetes security hardened! Now using universal Pod Security Standards with minimal exceptions.",
        choices: []
      }
    ]
  }
},

vulnerableComponents485: {
  id: 485,
  title: "Blockchain Oracle Manipulation in DeFi Protocols",
  difficulty: "Hard",
  vulnerability: "A06:2021 - Vulnerable and Outdated Components",
  attacker: {
    story: [
      {
        text: "A DeFi protocol uses a single price feed oracle without manipulation protection. What advanced component risk affects the entire protocol's economics?",
        choices: [
          {
            text: "Oracle manipulation enabling artificial price inflation for liquidation attacks",
            correct: true,
            points: 30,
            feedback: "Critical finding! Oracle manipulation can destabilize entire DeFi protocols.",
            nextStep: 1
          },
          {
            text: "The oracle might provide outdated price information",
            correct: false,
            points: 10,
            feedback: "Data freshness is operational, not the manipulation risk.",
            nextStep: 0
          },
          {
            text: "Transaction fees might increase during high volatility",
            correct: false,
            points: 5,
            feedback: "Fee volatility is economic, not a component vulnerability.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can oracle manipulation lead to protocol exploitation?",
        choices: [
          {
            text: "Artificially inflate asset prices to trigger unfair liquidations",
            correct: true,
            points: 35,
            feedback: "Sophisticated DeFi attack! Oracle manipulation enables systematic protocol exploitation.",
            nextStep: 2
          },
          {
            text: "Directly modify the smart contract code",
            correct: false,
            points: -35,
            feedback: "Smart contract immutability prevents direct code modification.",
            nextStep: 2
          },
          {
            text: "Use quantum computing to break blockchain cryptography",
            correct: false,
            points: -30,
            feedback: "Quantum attacks are theoretical and different from oracle manipulation.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced component vulnerability! Blockchain oracle manipulation enabling DeFi protocol economic attacks.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure DeFi oracle systems?",
        choices: [
          {
            text: "Use multiple oracle sources with manipulation detection and time-weighted averages",
            correct: true,
            points: 30,
            feedback: "Essential! Multiple oracles with manipulation protection prevent single-point failures.",
            nextStep: 1
          },
          {
            text: "Use larger price update intervals to reduce manipulation frequency",
            correct: false,
            points: -40,
            feedback: "Longer intervals create larger manipulation opportunities.",
            nextStep: 1
          },
          {
            text: "Allow only trusted entities to run oracles",
            correct: false,
            points: -35,
            feedback: "Trusted entities can still be compromised or make mistakes.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the robust DeFi oracle architecture?",
        choices: [
          {
            text: "Decentralized oracles, manipulation resistance, and circuit breakers",
            correct: true,
            points: 35,
            feedback: "Enterprise DeFi security! Multiple mechanisms protect against oracle attacks.",
            nextStep: 2
          },
          {
            text: "Use the same oracle for all asset types",
            correct: false,
            points: -45,
            feedback: "Different assets may require different oracle strategies.",
            nextStep: 2
          },
          {
            text: "Allow oracle upgrades without governance approval",
            correct: false,
            points: -40,
            feedback: "Oracle changes should follow proper governance procedures.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Oracle security implemented! Now using multiple decentralized oracles with manipulation protection.",
        choices: []
      }
    ]
  }
},

authFailure486: {
  id: 486,
  title: "OAuth 2.0 Token Mixup Attack",
  difficulty: "Medium",
  vulnerability: "A07:2021 - Identification and Authentication Failures",
  attacker: {
    story: [
      {
        text: "An OAuth 2.0 implementation doesn't validate the audience claim in tokens across multiple clients. What advanced authentication risk exists?",
        choices: [
          {
            text: "Token mixup attack - using one client's token to access another client's resources",
            correct: true,
            points: 25,
            feedback: "Critical finding! Token mixup enables cross-client authorization bypass.",
            nextStep: 1
          },
          {
            text: "Tokens might expire at inconsistent times",
            correct: false,
            points: 5,
            feedback: "Expiration timing is operational, not a mixup vulnerability.",
            nextStep: 0
          },
          {
            text: "User sessions might be shorter than expected",
            correct: false,
            points: 5,
            feedback: "Session duration is different from token validation.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can token mixup lead to account compromise?",
        choices: [
          {
            text: "Use a token from a low-security client to access high-security client resources",
            correct: true,
            points: 30,
            feedback: "Sophisticated OAuth attack! Token mixup bypasses client-specific authorization.",
            nextStep: 2
          },
          {
            text: "Directly steal tokens from the authorization server",
            correct: false,
            points: -30,
            feedback: "Token theft requires different vulnerabilities.",
            nextStep: 2
          },
          {
            text: "Use replay attacks with expired tokens",
            correct: false,
            points: -25,
            feedback: "Replay attacks are different from token mixup.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced authentication failure! OAuth 2.0 token mixup enabling cross-client authorization bypass.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent OAuth token mixup attacks?",
        choices: [
          {
            text: "Validate audience claims and use client-specific token endpoints",
            correct: true,
            points: 25,
            feedback: "Essential! Audience validation ensures tokens are used by intended clients.",
            nextStep: 1
          },
          {
            text: "Use shorter token expiration times",
            correct: false,
            points: -35,
            feedback: "Shorter expiration doesn't prevent mixup during token validity.",
            nextStep: 1
          },
          {
            text: "Require additional authentication for sensitive clients",
            correct: false,
            points: -30,
            feedback: "Additional authentication doesn't fix the token validation flaw.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive OAuth 2.0 security strategy?",
        choices: [
          {
            text: "Audience validation, client authentication, and token binding",
            correct: true,
            points: 30,
            feedback: "Enterprise OAuth security! Multiple layers prevent various token-based attacks.",
            nextStep: 2
          },
          {
            text: "Allow token sharing between related clients",
            correct: false,
            points: -40,
            feedback: "Token sharing creates mixup vulnerabilities.",
            nextStep: 2
          },
          {
            text: "Use the same token format for all clients",
            correct: false,
            points: -35,
            feedback: "Different clients may require different token security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "OAuth security implemented! Now validating audience claims with client-specific token handling.",
        choices: []
      }
    ]
  }
},

softwareIntegrity487: {
  id: 487,
  title: "CI/CD Pipeline Token Leakage to Build Environment",
  difficulty: "Medium",
  vulnerability: "A08:2021 - Software and Data Integrity Failures",
  attacker: {
    story: [
      {
        text: "A CI/CD pipeline passes cloud credentials to build containers for deployment. What integrity risk exists if build logs are publicly accessible?",
        choices: [
          {
            text: "Build logs can expose cloud credentials enabling infrastructure compromise",
            correct: true,
            points: 25,
            feedback: "Critical finding! Build log exposure can leak sensitive deployment credentials.",
            nextStep: 1
          },
          {
            text: "The builds might take longer to complete",
            correct: false,
            points: 5,
            feedback: "Build time is operational, not an integrity risk.",
            nextStep: 0
          },
          {
            text: "Artifact sizes might be larger than expected",
            correct: false,
            points: 5,
            feedback: "Artifact size is not the security concern.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can leaked build credentials impact production?",
        choices: [
          {
            text: "Attackers can access and modify production infrastructure using leaked credentials",
            correct: true,
            points: 30,
            feedback: "Sophisticated supply chain attack! Build credential leakage enables production compromise.",
            nextStep: 2
          },
          {
            text: "Directly modify the source code in repository",
            correct: false,
            points: -30,
            feedback: "Source modification requires different access levels.",
            nextStep: 2
          },
          {
            text: "Use the credentials to mine cryptocurrency",
            correct: false,
            points: -25,
            feedback: "While possible, infrastructure compromise is the critical risk.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Software integrity failure! CI/CD pipeline credential leakage enabling production infrastructure compromise.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure CI/CD pipeline credentials?",
        choices: [
          {
            text: "Use secret management systems and ensure build logs don't expose secrets",
            correct: true,
            points: 25,
            feedback: "Essential! Proper secret management prevents credential leakage.",
            nextStep: 1
          },
          {
            text: "Store credentials in environment variables only",
            correct: false,
            points: -35,
            feedback: "Environment variables can still leak to logs - use proper secret management.",
            nextStep: 1
          },
          {
            text: "Disable build logging entirely",
            correct: false,
            points: -30,
            feedback: "Build logs are essential for debugging - secure them instead of disabling.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive CI/CD security approach?",
        choices: [
          {
            text: "Secret management, build integrity, and deployment verification",
            correct: true,
            points: 30,
            feedback: "Enterprise CI/CD security! Multiple controls ensure pipeline integrity.",
            nextStep: 2
          },
          {
            text: "Allow credential passing for development flexibility",
            correct: false,
            points: -40,
            feedback: "Credential passing creates security risks - use secure alternatives.",
            nextStep: 2
          },
          {
            text: "Use the same credentials for all deployment environments",
            correct: false,
            points: -35,
            feedback: "Different environments should have different credentials.",
            nextStep: 2
          }
        ]
      },
      {
        text: "CI/CD security implemented! Now using secret management with secure build practices.",
        choices: []
      }
    ]
  }
},

loggingFailures488: {
  id: 488,
  title: "Distributed Tracing Sampling Bypass for Attack Obfuscation",
  difficulty: "Medium",
  vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
  attacker: {
    story: [
      {
        text: "A microservices application uses 1% sampling rate for distributed tracing to reduce overhead. What monitoring evasion risk exists?",
        choices: [
          {
            text: "Attackers can bypass monitoring by staying below the sampling threshold",
            correct: true,
            points: 25,
            feedback: "Critical finding! Low sampling rates enable attack obfuscation.",
            nextStep: 1
          },
          {
            text: "Tracing data might be incomplete for debugging",
            correct: false,
            points: 10,
            feedback: "Debugging completeness is operational, not a security evasion risk.",
            nextStep: 0
          },
          {
            text: "Trace storage might use excessive disk space",
            correct: false,
            points: 5,
            feedback: "Storage usage is not the security concern.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can low tracing sampling help attackers evade detection?",
        choices: [
          {
            text: "Perform attacks slowly to avoid triggering trace sampling",
            correct: true,
            points: 30,
            feedback: "Sophisticated evasion! Low sampling enables stealthy, slow attacks.",
            nextStep: 2
          },
          {
            text: "Directly modify stored trace data",
            correct: false,
            points: -30,
            feedback: "Trace data modification requires different access levels.",
            nextStep: 2
          },
          {
            text: "Use timing attacks to corrupt tracing",
            correct: false,
            points: -25,
            feedback: "Timing attacks are different from sampling evasion.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Logging failure! Low distributed tracing sampling rate enabling attack evasion and monitoring bypass.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should distributed tracing be configured for security?",
        choices: [
          {
            text: "Use adaptive sampling that increases for anomalous or security-relevant operations",
            correct: true,
            points: 25,
            feedback: "Essential! Adaptive sampling ensures security visibility while managing overhead.",
            nextStep: 1
          },
          {
            text: "Disable tracing entirely to eliminate sampling issues",
            correct: false,
            points: -35,
            feedback: "Tracing provides essential visibility - configure it properly instead.",
            nextStep: 1
          },
          {
            text: "Use very high sampling rates for all operations",
            correct: false,
            points: -30,
            feedback: "High sampling creates performance overhead - use adaptive approach.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive observability security strategy?",
        choices: [
          {
            text: "Adaptive sampling, security event tracing, and anomaly detection",
            correct: true,
            points: 30,
            feedback: "Enterprise observability security! Multiple approaches ensure security visibility.",
            nextStep: 2
          },
          {
            text: "Allow configurable sampling for each service independently",
            correct: false,
            points: -40,
            feedback: "Inconsistent sampling creates security gaps.",
            nextStep: 2
          },
          {
            text: "Use the same sampling rate for all request types",
            correct: false,
            points: -35,
            feedback: "Different request types may have different security importance.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Observability security enhanced! Now using adaptive tracing sampling with security focus.",
        choices: []
      }
    ]
  }
},

ssrf489: {
  id: 489,
  title: "Cloud Metadata Service SSRF with IMDSv1 Fallback",
  difficulty: "Easy",
  vulnerability: "A10:2021 - Server-Side Request Forgery",
  attacker: {
    story: [
      {
        text: "A cloud application has SSRF vulnerability and the cloud instance allows both IMDSv1 and IMDSv2 for metadata service. What access risk exists?",
        choices: [
          {
            text: "IMDSv1 can be exploited through SSRF to access instance metadata and credentials",
            correct: true,
            points: 15,
            feedback: "Exactly! IMDSv1 is vulnerable to SSRF attacks for credential theft.",
            nextStep: 1
          },
          {
            text: "The instance might have network configuration issues",
            correct: false,
            points: 5,
            feedback: "Network configuration is operational, not the SSRF risk.",
            nextStep: 0
          },
          {
            text: "Metadata service might respond slower with both versions",
            correct: false,
            points: 5,
            feedback: "Performance impact is not the security vulnerability.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is IMDSv1 particularly dangerous with SSRF?",
        choices: [
          {
            text: "IMDSv1 doesn't require authentication headers, making it easy to exploit via SSRF",
            correct: true,
            points: 20,
            feedback: "Correct! IMDSv1's simplicity makes it vulnerable to SSRF attacks.",
            nextStep: 2
          },
          {
            text: "IMDSv1 returns more sensitive data than IMDSv2",
            correct: false,
            points: -10,
            feedback: "Both versions can return sensitive data - the issue is access method.",
            nextStep: 2
          },
          {
            text: "IMDSv1 is enabled by default on all cloud instances",
            correct: false,
            points: -15,
            feedback: "IMDSv1 can be disabled - the risk is when it's enabled with SSRF.",
            nextStep: 2
          }
        ]
      },
      {
        text: "SSRF vulnerability! Cloud metadata service exploitation through IMDSv1 fallback enabling credential theft.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure cloud metadata services?",
        choices: [
          {
            text: "Disable IMDSv1 and use only IMDSv2 with required authentication headers",
            correct: true,
            points: 15,
            feedback: "Essential! IMDSv2's header requirement prevents simple SSRF exploitation.",
            nextStep: 1
          },
          {
            text: "Use network policies to block metadata service access",
            correct: false,
            points: -15,
            feedback: "Applications often need metadata access - use secure versions instead.",
            nextStep: 1
          },
          {
            text: "Rotate credentials frequently to reduce exposure",
            correct: false,
            points: -10,
            feedback: "Rotation helps but doesn't prevent initial credential theft.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple cloud metadata security rule?",
        choices: [
          {
            text: "Always disable IMDSv1 and use IMDSv2 exclusively",
            correct: true,
            points: 20,
            feedback: "Best practice! IMDSv2 provides essential SSRF protection.",
            nextStep: 2
          },
          {
            text: "Allow both versions for maximum compatibility",
            correct: false,
            points: -20,
            feedback: "Compatibility should not compromise security.",
            nextStep: 2
          },
          {
            text: "Use the same metadata configuration for all instances",
            correct: false,
            points: -15,
            feedback: "Different instances may have different security requirements.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Cloud metadata secured! Now using IMDSv2 exclusively with IMDSv1 disabled.",
        choices: []
      }
    ]
  }
},

accessControl490: {
  id: 490,
  title: "Viewing Other Users' Private Messages",
  difficulty: "Easy",
  vulnerability: "A01:2021 - Broken Access Control",
  attacker: {
    story: [
      {
        text: "You notice a messaging app shows your conversations at '/messages/123'. What happens if you change the number to view someone else's conversation ID?",
        choices: [
          {
            text: "You can read other users' private messages",
            correct: true,
            points: 15,
            feedback: "Exactly! Missing authorization checks allow users to view each other's private conversations.",
            nextStep: 1
          },
          {
            text: "You get an 'access denied' error",
            correct: false,
            points: 5,
            feedback: "That would be secure behavior, but we're looking for the vulnerability.",
            nextStep: 0
          },
          {
            text: "It shows your own messages with a different ID",
            correct: false,
            points: 5,
            feedback: "This would indicate the system ignores the conversation ID parameter.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is viewing others' private messages a serious privacy violation?",
        choices: [
          {
            text: "It exposes confidential communications and personal information",
            correct: true,
            points: 20,
            feedback: "Correct! Private messages often contain sensitive personal and business information.",
            nextStep: 2
          },
          {
            text: "You can send messages as other users",
            correct: false,
            points: -10,
            feedback: "This vulnerability is about viewing, not sending messages.",
            nextStep: 2
          },
          {
            text: "The messaging system might stop working",
            correct: false,
            points: -15,
            feedback: "Viewing doesn't typically break system functionality.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Access control failure! Users can view each other's private messages by changing conversation IDs.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure private messaging access?",
        choices: [
          {
            text: "Verify the user is a participant in the conversation before showing messages",
            correct: true,
            points: 15,
            feedback: "Essential! Always check conversation membership before displaying messages.",
            nextStep: 1
          },
          {
            text: "Use random conversation IDs instead of sequential numbers",
            correct: false,
            points: -10,
            feedback: "Random IDs help but don't replace proper authorization checks.",
            nextStep: 1
          },
          {
            text: "Hide conversation IDs from the URL",
            correct: false,
            points: -15,
            feedback: "IDs might still be accessible - better to implement proper checks.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple rule for private data?",
        choices: [
          {
            text: "Users should only see data they're authorized to access",
            correct: true,
            points: 20,
            feedback: "Good practice! This fundamental rule protects user privacy.",
            nextStep: 2
          },
          {
            text: "Allow users to see all data but hide sensitive fields",
            correct: false,
            points: -20,
            feedback: "Partial hiding still violates privacy - restrict access entirely.",
            nextStep: 2
          },
          {
            text: "Use the same access rules for all message types",
            correct: false,
            points: -15,
            feedback: "Different message types may need different access rules.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Messaging security fixed! Now verifying conversation participation before showing messages.",
        choices: []
      }
    ]
  }
},

cryptoFailures491: {
  id: 491,
  title: "Website Not Using HSTS Headers",
  difficulty: "Medium",
  vulnerability: "A02:2021 - Cryptographic Failures",
  attacker: {
    story: [
      {
        text: "A website uses HTTPS but doesn't implement HSTS (HTTP Strict Transport Security) headers. What man-in-the-middle risk exists?",
        choices: [
          {
            text: "Attackers can downgrade connections to HTTP during the first visit",
            correct: true,
            points: 20,
            feedback: "Exactly! Without HSTS, the first connection can be intercepted and downgraded.",
            nextStep: 1
          },
          {
            text: "The website might load slower without HSTS",
            correct: false,
            points: 5,
            feedback: "HSTS has minimal performance impact - security is the concern.",
            nextStep: 0
          },
          {
            text: "Some browsers might show security warnings",
            correct: false,
            points: 5,
            feedback: "Browsers don't typically warn about missing HSTS.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can missing HSTS lead to credential theft?",
        choices: [
          {
            text: "Attackers can intercept the first HTTP request and steal login credentials",
            correct: true,
            points: 25,
            feedback: "Correct! The first visit without HSTS is vulnerable to SSL stripping attacks.",
            nextStep: 2
          },
          {
            text: "HSTS prevents SQL injection attacks",
            correct: false,
            points: -15,
            feedback: "HSTS is for transport security, not application-level attacks.",
            nextStep: 2
          },
          {
            text: "Without HSTS, passwords are stored in plain text",
            correct: false,
            points: -20,
            feedback: "HSTS affects transmission, not storage of passwords.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Cryptographic failure! Missing HSTS headers enabling SSL stripping and connection downgrade attacks.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you implement HSTS properly?",
        choices: [
          {
            text: "Add HSTS header with max-age and includeSubDomains directive",
            correct: true,
            points: 20,
            feedback: "Essential! HSTS headers tell browsers to always use HTTPS.",
            nextStep: 1
          },
          {
            text: "Use HTTPS redirects instead of HSTS",
            correct: false,
            points: -20,
            feedback: "Redirects can be intercepted - HSTS provides stronger protection.",
            nextStep: 1
          },
          {
            text: "Tell users to always bookmark the HTTPS version",
            correct: false,
            points: -15,
            feedback: "User behavior is unreliable - implement technical controls.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive web security approach?",
        choices: [
          {
            text: "HTTPS everywhere, HSTS headers, and secure cookie flags",
            correct: true,
            points: 25,
            feedback: "Best practice! Multiple layers ensure complete transport security.",
            nextStep: 2
          },
          {
            text: "Use HSTS only for login pages",
            correct: false,
            points: -25,
            feedback: "All pages need HSTS protection.",
            nextStep: 2
          },
          {
            text: "Let browsers decide when to use HTTPS",
            correct: false,
            points: -20,
            feedback: "Always force HTTPS through technical controls.",
            nextStep: 2
          }
        ]
      },
      {
        text: "HSTS implemented! Now browsers will always use HTTPS for this website.",
        choices: []
      }
    ]
  }
},

injection492: {
  id: 492,
  title: "LDAP Injection in Employee Search",
  difficulty: "Tricky",
  vulnerability: "A03:2021 - Injection",
  attacker: {
    story: [
      {
        text: "A company directory search builds LDAP queries by concatenating user input. What happens if you search for ')(objectClass=*'?",
        choices: [
          {
            text: "It might return all directory entries instead of filtered results",
            correct: true,
            points: 25,
            feedback: "Exactly! LDAP injection can modify query filters to return unauthorized data.",
            nextStep: 1
          },
          {
            text: "The search will return an error message",
            correct: false,
            points: 10,
            feedback: "That might happen with proper validation, but we're testing for vulnerabilities.",
            nextStep: 0
          },
          {
            text: "Only your own employee record will show",
            correct: false,
            points: 5,
            feedback: "LDAP injection typically affects filter logic, not personalization.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is LDAP injection particularly dangerous for corporate directories?",
        choices: [
          {
            text: "It can expose sensitive employee information and organizational structure",
            correct: true,
            points: 30,
            feedback: "Correct! Corporate directories often contain confidential employee and organizational data.",
            nextStep: 2
          },
          {
            text: "It will corrupt the LDAP database",
            correct: false,
            points: -20,
            feedback: "LDAP injection typically doesn't modify data, just queries it.",
            nextStep: 2
          },
          {
            text: "The directory server might crash",
            correct: false,
            points: -15,
            feedback: "While possible, data exposure is the primary risk.",
            nextStep: 2
          }
        ]
      },
      {
        text: "LDAP injection vulnerability! Employee search allowing directory query manipulation through filter injection.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent LDAP injection?",
        choices: [
          {
            text: "Use parameterized LDAP queries or proper input escaping",
            correct: true,
            points: 25,
            feedback: "Essential! Parameterized queries separate data from LDAP filter logic.",
            nextStep: 1
          },
          {
            text: "Block parentheses and asterisks in search inputs",
            correct: false,
            points: -25,
            feedback: "This breaks legitimate searches - use proper escaping instead.",
            nextStep: 1
          },
          {
            text: "Use client-side validation for search inputs",
            correct: false,
            points: -20,
            feedback: "Client-side controls can be bypassed - validate server-side.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive directory security approach?",
        choices: [
          {
            text: "Input validation, query parameterization, and directory access controls",
            correct: true,
            points: 30,
            feedback: "Enterprise directory security! Multiple layers protect directory data.",
            nextStep: 2
          },
          {
            text: "Allow only simple searches without special characters",
            correct: false,
            points: -30,
            feedback: "This severely limits directory functionality.",
            nextStep: 2
          },
          {
            text: "Use the same validation for all directory attributes",
            correct: false,
            points: -25,
            feedback: "Different attributes may require different validation rules.",
            nextStep: 2
          }
        ]
      },
      {
        text: "LDAP security implemented! Now using parameterized queries with proper input validation.",
        choices: []
      }
    ]
  }
},

insecureDesign493: {
  id: 493,
  title: "Password Strength Meter Giving False Confidence",
  difficulty: "Easy",
  vulnerability: "A04:2021 - Insecure Design",
  attacker: {
    story: [
      {
        text: "A password strength meter shows 'Strong' for passwords that meet complexity rules but are common patterns like 'Password123!'. Why is this misleading?",
        choices: [
          {
            text: "It encourages weak but technically complex passwords that are easy to guess",
            correct: true,
            points: 15,
            feedback: "Exactly! Complexity rules don't prevent predictable patterns.",
            nextStep: 1
          },
          {
            text: "The meter might not work on mobile devices",
            correct: false,
            points: 5,
            feedback: "Device compatibility is different from design flaws.",
            nextStep: 0
          },
          {
            text: "Users might ignore the meter completely",
            correct: false,
            points: 5,
            feedback: "User behavior is separate from meter accuracy.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can misleading strength meters help attackers?",
        choices: [
          {
            text: "Users create passwords that meet complexity but are easily guessable",
            correct: true,
            points: 20,
            feedback: "Correct! Attackers know common patterns that satisfy complexity rules.",
            nextStep: 2
          },
          {
            text: "The meter reveals the password requirements to attackers",
            correct: false,
            points: -10,
            feedback: "While true, this is not the primary issue.",
            nextStep: 2
          },
          {
            text: "Weak meters cause the system to accept any password",
            correct: false,
            points: -15,
            feedback: "The meter is typically advisory, not enforcement.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Insecure design! Password strength meter giving false confidence in weak but complex passwords.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "What's a better approach to password guidance?",
        choices: [
          {
            text: "Emphasize password length and check against common password lists",
            correct: true,
            points: 15,
            feedback: "Good practice! Length and uniqueness are more important than complexity.",
            nextStep: 1
          },
          {
            text: "Require more special characters for stronger passwords",
            correct: false,
            points: -15,
            feedback: "This leads to predictable patterns like 'Password123!'",
            nextStep: 1
          },
          {
            text: "Remove the strength meter entirely",
            correct: false,
            points: -10,
            feedback: "Guidance is helpful when implemented correctly.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the modern password security design?",
        choices: [
          {
            text: "Long passphrases with breach database checking",
            correct: true,
            points: 20,
            feedback: "Modern best practice! Passphrases are easier to remember and harder to crack.",
            nextStep: 2
          },
          {
            text: "Very complex passwords that change frequently",
            correct: false,
            points: -20,
            feedback: "Complex frequent changes lead to weak, incremental passwords.",
            nextStep: 2
          },
          {
            text: "Use the same password rules for all applications",
            correct: false,
            points: -15,
            feedback: "Different applications may have different security needs.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Password guidance improved! Now emphasizing length and checking against common passwords.",
        choices: []
      }
    ]
  }
},

securityMisconfig494: {
  id: 494,
  title: "Exposed Developer Comments in Production",
  difficulty: "Easy",
  vulnerability: "A05:2021 - Security Misconfiguration",
  attacker: {
    story: [
      {
        text: "You view a website's page source and see HTML comments with developer notes like 'TODO: fix admin password' or 'DEBUG: database credentials'. Why is this dangerous?",
        choices: [
          {
            text: "It reveals internal information and potential vulnerabilities",
            correct: true,
            points: 15,
            feedback: "Exactly! Developer comments can expose sensitive information and system details.",
            nextStep: 1
          },
          {
            text: "The comments make the page load slower",
            correct: false,
            points: 5,
            feedback: "Comments have minimal performance impact.",
            nextStep: 0
          },
          {
            text: "Screen readers might read the comments aloud",
            correct: false,
            points: 5,
            feedback: "Accessibility tools typically ignore HTML comments.",
            nextStep: 0
          }
        ]
      },
      {
        text: "What sensitive information might be in developer comments?",
        choices: [
          {
            text: "Credentials, system architecture, and known issues",
            correct: true,
            points: 20,
            feedback: "Correct! Comments often contain internal information not meant for public view.",
            nextStep: 2
          },
          {
            text: "Only styling and layout notes",
            correct: false,
            points: -10,
            feedback: "Comments often contain much more than just styling information.",
            nextStep: 2
          },
          {
            text: "Just old code that's no longer used",
            correct: false,
            points: -15,
            feedback: "Even old code comments can reveal system information.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Security misconfiguration! Developer comments left in production code revealing internal information.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should code be prepared for production?",
        choices: [
          {
            text: "Remove all developer comments and debug information before deployment",
            correct: true,
            points: 15,
            feedback: "Essential! Production code should be clean and minimal.",
            nextStep: 1
          },
          {
            text: "Use obscure commenting styles to hide information",
            correct: false,
            points: -15,
            feedback: "Obscurity is not security - remove comments entirely.",
            nextStep: 1
          },
          {
            text: "Keep comments for future maintenance needs",
            correct: false,
            points: -10,
            feedback: "Use version control for documentation, not production comments.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the simple production deployment rule?",
        choices: [
          {
            text: "Production code should contain only what's needed for the application to run",
            correct: true,
            points: 20,
            feedback: "Good practice! Clean production code reduces information leakage.",
            nextStep: 2
          },
          {
            text: "Allow comments for documentation purposes",
            correct: false,
            points: -20,
            feedback: "Documentation should be separate from production code.",
            nextStep: 2
          },
          {
            text: "Use the same code for development and production",
            correct: false,
            points: -15,
            feedback: "Development and production should have different configurations.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Production code cleaned! Now deploying without developer comments and debug information.",
        choices: []
      }
    ]
  }
},

vulnerableComponents495: {
  id: 495,
  title: "Outdated SSL Library with Heartbleed Vulnerability",
  difficulty: "Medium",
  vulnerability: "A06:2021 - Vulnerable and Outdated Components",
  attacker: {
    story: [
      {
        text: "A server is using OpenSSL 1.0.1, which has the Heartbleed vulnerability. What critical risk does this create?",
        choices: [
          {
            text: "Memory leakage exposing private keys and sensitive data",
            correct: true,
            points: 20,
            feedback: "Exactly! Heartbleed allows reading server memory through SSL connections.",
            nextStep: 1
          },
          {
            text: "The SSL handshake might fail occasionally",
            correct: false,
            points: 5,
            feedback: "Connection failures are operational, not the Heartbleed risk.",
            nextStep: 0
          },
          {
            text: "Some browsers might show certificate warnings",
            correct: false,
            points: 5,
            feedback: "Certificate issues are different from Heartbleed.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can Heartbleed be exploited to compromise a server?",
        choices: [
          {
            text: "Repeatedly trigger the vulnerability to extract private keys from memory",
            correct: true,
            points: 25,
            feedback: "Correct! Heartbleed can reveal private keys, enabling full server compromise.",
            nextStep: 2
          },
          {
            text: "Directly modify the SSL certificate",
            correct: false,
            points: -15,
            feedback: "Heartbleed reads memory, doesn't modify certificates.",
            nextStep: 2
          },
          {
            "text": "Use it to perform DDoS attacks on the server",
            correct: false,
            points: -20,
            feedback: "While possible, data theft is the critical risk.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Vulnerable components! Outdated OpenSSL with Heartbleed vulnerability enabling memory leakage and private key theft.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you protect against Heartbleed and similar vulnerabilities?",
        choices: [
          {
            text: "Immediately update to patched OpenSSL versions and regularly update all components",
            correct: true,
            points: 20,
            feedback: "Essential! Prompt updates are crucial for critical vulnerabilities like Heartbleed.",
            nextStep: 1
          },
          {
            text: "Use longer SSL key sizes to compensate",
            correct: false,
            points: -20,
            feedback: "Key size doesn't help if the private key is leaked from memory.",
            nextStep: 1
          },
          {
            text: "Disable SSL and use only TLS",
            correct: false,
            points: -15,
            feedback: "Heartbleed affects specific OpenSSL versions, not the protocol itself.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive component security strategy?",
        choices: [
          {
            text: "Regular vulnerability scanning, prompt patching, and component inventory",
            correct: true,
            points: 25,
            feedback: "Enterprise component security! Multiple approaches ensure timely vulnerability management.",
            nextStep: 2
          },
          {
            text: "Use only old, proven stable versions of components",
            correct: false,
            points: -25,
            feedback: "Old versions often have known vulnerabilities - update regularly.",
            nextStep: 2
          },
          {
            text: "Hide version information to avoid detection",
            correct: false,
            points: -20,
            feedback: "Hiding versions doesn't fix vulnerabilities - patch them.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Component security improved! Now regularly scanning and promptly updating all software components.",
        choices: []
      }
    ]
  }
},

authFailure496: {
  id: 496,
  title: "Session Not Invalidated on Password Change",
  difficulty: "Tricky",
  vulnerability: "A07:2021 - Identification and Authentication Failures",
  attacker: {
    story: [
      {
        text: "A user changes their password but their old session remains active. What security risk does this create if an attacker has their old session?",
        choices: [
          {
            text: "The attacker maintains access even after the password change",
            correct: true,
            points: 25,
            feedback: "Exactly! Sessions should be invalidated when credentials change.",
            nextStep: 1
          },
          {
            text: "The user might get logged out unexpectedly",
            correct: false,
            points: 10,
            feedback: "That would be secure behavior - sessions should end on password change.",
            nextStep: 0
          },
          {
            text: "The new password might not take effect immediately",
            correct: false,
            points: 5,
            feedback: "Password changes should be immediate - the issue is session management.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is session persistence after password change dangerous?",
        choices: [
          {
            text: "It allows continued account access through stolen sessions despite password changes",
            correct: true,
            points: 30,
            feedback: "Correct! This undermines the security benefit of password changes.",
            nextStep: 2
          },
          {
            text: "The user might forget their new password",
            correct: false,
            points: -20,
            feedback: "Password memory is a user issue, not a session management flaw.",
            nextStep: 2
          },
          {
            text: "It causes password synchronization issues across devices",
            correct: false,
            points: -15,
            feedback: "Synchronization is different from session invalidation.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Authentication failure! Sessions not invalidated on password change enabling continued unauthorized access.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should password changes affect active sessions?",
        choices: [
          {
            text: "Invalidate all other sessions and require re-authentication",
            correct: true,
            points: 25,
            feedback: "Essential! Password changes should terminate all existing sessions.",
            nextStep: 1
          },
          {
            text: "Allow existing sessions to continue for user convenience",
            correct: false,
            points: -25,
            feedback: "Convenience should not compromise security.",
            nextStep: 1
          },
          {
            text: "Invalidate sessions only on other devices",
            correct: false,
            points: -20,
            feedback: "All sessions, including current device, should be invalidated.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive session security approach?",
        choices: [
          {
            text: "Session invalidation on password change, logout, and suspicious activity",
            correct: true,
            points: 30,
            feedback: "Enterprise session security! Multiple triggers ensure session integrity.",
            nextStep: 2
          },
          {
            text: "Allow multiple sessions per user for flexibility",
            correct: false,
            points: -30,
            feedback: "Multiple sessions are acceptable if properly managed and invalidated.",
            nextStep: 2
          },
          {
            text: "Use the same session rules for all user types",
            correct: false,
            points: -25,
            feedback: "Different user types may require different session security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Session management secured! Now invalidating all sessions on password changes.",
        choices: []
      }
    ]
  }
},

softwareIntegrity497: {
  id: 497,
  title: "Client-Side Access Control Checks",
  difficulty: "Easy",
  vulnerability: "A08:2021 - Software and Data Integrity Failures",
  attacker: {
    story: [
      {
        text: "A web application uses JavaScript to hide admin features from regular users, but the features are still in the HTML. What happens if you modify the HTML to show these features?",
        choices: [
          {
            text: "You might be able to access admin features without proper authorization",
            correct: true,
            points: 15,
            feedback: "Exactly! Client-side hiding doesn't prevent access to features.",
            nextStep: 1
          },
          {
            text: "The JavaScript will detect the change and block access",
            correct: false,
            points: 5,
            feedback: "That would require the JavaScript to validate itself - unlikely.",
            nextStep: 0
          },
          {
            text: "Only the display will change but the features won't work",
            correct: false,
            points: 5,
            feedback: "If only client-side checks exist, the features might work.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is client-side access control insufficient?",
        choices: [
          {
            text: "Users can bypass client-side checks and access unauthorized functionality",
            correct: true,
            points: 20,
            feedback: "Correct! All security checks must be enforced server-side.",
            nextStep: 2
          },
          {
            text: "JavaScript might be disabled in some browsers",
            correct: false,
            points: -10,
            feedback: "While true, this is not the primary security concern.",
            nextStep: 2
          },
          {
            text: "Client-side code takes longer to execute",
            correct: false,
            points: -15,
            feedback: "Performance is not the security issue.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Software integrity failure! Client-side access control enabling unauthorized feature access.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should access control be implemented?",
        choices: [
          {
            text: "Enforce all access controls server-side, use client-side only for user experience",
            correct: true,
            points: 15,
            feedback: "Essential! Server-side enforcement cannot be bypassed by users.",
            nextStep: 1
          },
          {
            text: "Use complex JavaScript to make bypassing harder",
            correct: false,
            points: -15,
            feedback: "Complex client-side code can still be bypassed - enforce server-side.",
            nextStep: 1
          },
          {
            text: "Remove features from the HTML for unauthorized users",
            correct: false,
            points: -10,
            feedback: "Features might still be accessible through APIs - validate server-side.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the fundamental security principle for access control?",
        choices: [
          {
            text: "Never trust the client - enforce all security checks server-side",
            correct: true,
            points: 20,
            feedback: "Fundamental rule! Client-side can be for usability, server-side for security.",
            nextStep: 2
          },
          {
            text: "Use the same access control for all application features",
            correct: false,
            points: -20,
            feedback: "Different features may require different access levels.",
            nextStep: 2
          },
          {
            text: "Allow some flexibility in access control for power users",
            correct: false,
            points: -15,
            feedback: "Access control should be consistently enforced.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Access control secured! Now enforcing all security checks server-side.",
        choices: []
      }
    ]
  }
},

loggingFailures498: {
  id: 498,
  title: "Not Logging User Agent and Geographic Information",
  difficulty: "Medium",
  vulnerability: "A09:2021 - Security Logging and Monitoring Failures",
  attacker: {
    story: [
      {
        text: "Security logs record usernames and timestamps but not user agents, IP addresses, or geographic data. How does this limit security investigations?",
        choices: [
          {
            text: "Unable to correlate attacks or identify patterns across multiple incidents",
            correct: true,
            points: 20,
            feedback: "Exactly! Missing context makes incident investigation much harder.",
            nextStep: 1
          },
          {
            text: "The logs take up less storage space",
            correct: false,
            points: 5,
            feedback: "Storage savings are insignificant compared to security impact.",
            nextStep: 0
          },
          {
            text: "Log analysis tools might process faster",
            correct: false,
            points: 5,
            feedback: "Performance impact is minimal - security visibility is crucial.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why are user agent and geographic logs important for security?",
        choices: [
          {
            text: "They help identify attack patterns and correlate related security events",
            correct: true,
            points: 25,
            feedback: "Correct! Contextual information is essential for understanding attack campaigns.",
            nextStep: 2
          },
          {
            text: "They make the logs more readable for administrators",
            correct: false,
            points: -15,
            feedback: "Readability is secondary to investigation capability.",
            nextStep: 2
          },
          {
            text: "They are required by compliance regulations",
            correct: false,
            points: -20,
            feedback: "While often true, the security benefit is the primary reason.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Logging failure! Missing contextual information preventing effective security investigation and pattern recognition.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "What information should security logs include?",
        choices: [
          {
            text: "User identity, timestamp, IP, user agent, action, and outcome",
            correct: true,
            points: 20,
            feedback: "Essential! Comprehensive logging enables effective security monitoring.",
            nextStep: 1
          },
          {
            text: "Only the basic action and timestamp to reduce log size",
            correct: false,
            points: -20,
            feedback: "Basic logs are insufficient for security investigations.",
            nextStep: 1
          },
          {
            text: "Just successful actions to avoid log clutter",
            correct: false,
            points: -15,
            feedback: "Failed attempts are crucial for detecting attacks.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the balanced logging strategy?",
        choices: [
          {
            text: "Log sufficient context for investigations while managing storage appropriately",
            correct: true,
            points: 25,
            feedback: "Balanced approach! Security visibility with practical storage management.",
            nextStep: 2
          },
          {
            text: "Log everything possible for complete visibility",
            correct: false,
            points: -25,
            feedback: "Excessive logging can hide important signals - be strategic.",
            nextStep: 2
          },
          {
            text: "Use the same log format for all applications",
            correct: false,
            points: -20,
            feedback: "Different applications may have different logging needs.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Logging improved! Now capturing comprehensive contextual information for security investigations.",
        choices: []
      }
    ]
  }
},

ssrf499: {
  id: 499,
  title: "PDF Generator SSRF Through Image Embedding",
  difficulty: "Tricky",
  vulnerability: "A10:2021 - Server-Side Request Forgery",
  attacker: {
    story: [
      {
        text: "A web application generates PDF reports and embeds images from user-provided URLs. What happens if you provide a URL like 'http://169.254.169.254/latest/meta-data/'?",
        choices: [
          {
            text: "The PDF generator might fetch cloud metadata during report generation",
            correct: true,
            points: 25,
            feedback: "Exactly! PDF generators often fetch external resources, enabling SSRF.",
            nextStep: 1
          },
          {
            text: "The URL will be rejected as not an image",
            correct: false,
            points: 10,
            feedback: "That would be secure behavior, but we're testing for vulnerabilities.",
            nextStep: 0
          },
          {
            text: "Only image URLs from approved domains will work",
            correct: false,
            points: 5,
            feedback: "Internal URLs might work if no protections are in place.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is PDF generation particularly risky for SSRF?",
        choices: [
          {
            text: "PDF libraries often automatically fetch embedded resources without validation",
            correct: true,
            points: 30,
            feedback: "Correct! PDF generation is a common SSRF vector through resource embedding.",
            nextStep: 2
          },
          {
            text: "PDF files can contain executable code",
            correct: false,
            points: -20,
            feedback: "While true, this is different from SSRF.",
            nextStep: 2
          },
          {
            text: "PDF generation uses more server resources",
            correct: false,
            points: -15,
            feedback: "Resource usage is not the security risk.",
            nextStep: 2
          }
        ]
      },
      {
        text: "SSRF vulnerability! PDF generator fetching external resources without URL validation, enabling cloud metadata access.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure PDF generation features?",
        choices: [
          {
            text: "Validate all URLs and block internal addresses before fetching resources",
            correct: true,
            points: 25,
            feedback: "Essential! Resource fetching should be restricted to approved external sources.",
            nextStep: 1
          },
          {
            text: "Use a proxy for all external requests",
            correct: false,
            points: -25,
            feedback: "Proxies might still allow internal network access.",
            nextStep: 1
          },
          {
            text: "Only allow data URLs for embedded images",
            correct: false,
            points: -20,
            feedback: "This severely limits functionality - validate URLs instead.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive resource fetching security?",
        choices: [
          {
            text: "URL validation, allowlisting, and network segmentation",
            correct: true,
            points: 30,
            feedback: "Enterprise resource security! Multiple layers prevent SSRF attacks.",
            nextStep: 2
          },
          {
            text: "Allow any URL but timeout quickly",
            correct: false,
            points: -30,
            feedback: "Timeouts don't prevent the initial connection attempt.",
            nextStep: 2
          },
          {
            text: "Use the same URL validation for all features",
            correct: false,
            points: -25,
            feedback: "Different features may require different security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "PDF generation secured! Now validating all URLs before fetching external resources.",
        choices: []
      }
    ]
  }
},

accessControl500: {
  id: 500,
  title: "API Key Exposure Through Client-Side Code",
  difficulty: "Medium",
  vulnerability: "A01:2021 - Broken Access Control",
  attacker: {
    story: [
      {
        text: "You view a web application's JavaScript code and find API keys hardcoded in the client-side code. What security risk does this create?",
        choices: [
          {
            text: "Anyone can extract and misuse the API keys for unauthorized access",
            correct: true,
            points: 20,
            feedback: "Exactly! Client-side API keys are accessible to all users and can be abused.",
            nextStep: 1
          },
          {
            text: "The API keys might expire frequently",
            correct: false,
            points: 5,
            feedback: "Expiration is good practice but doesn't solve the exposure issue.",
            nextStep: 0
          },
          {
            text: "The JavaScript code will load slower",
            correct: false,
            points: 5,
            feedback: "Performance impact is not the security concern.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can exposed API keys be exploited?",
        choices: [
          {
            text: "Make unauthorized API calls, potentially incurring costs or accessing data",
            correct: true,
            points: 25,
            feedback: "Correct! Exposed API keys can be used to make unauthorized requests to backend services.",
            nextStep: 2
          },
          {
            text: "Decrypt the website's SSL certificates",
            correct: false,
            points: -15,
            feedback: "API keys don't relate to SSL certificate decryption.",
            nextStep: 2
          },
          {
            text: "Take over the website domain",
            correct: false,
            points: -20,
            feedback: "API keys don't provide domain control.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Access control failure! API keys exposed in client-side code enabling unauthorized API access.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should API keys be managed for client-side applications?",
        choices: [
          {
            text: "Use backend proxies to make API calls, never expose keys in client code",
            correct: true,
            points: 20,
            feedback: "Essential! All sensitive operations should happen server-side.",
            nextStep: 1
          },
          {
            text: "Encrypt the API keys in the JavaScript code",
            correct: false,
            points: -20,
            feedback: "Client-side encryption can be reverse-engineered - use backend proxies.",
            nextStep: 1
          },
          {
            text: "Use very long API keys that are hard to guess",
            correct: false,
            points: -15,
            feedback: "Length doesn't matter if the key is exposed in client code.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the secure architecture for client-server applications?",
        choices: [
          {
            text: "Backend APIs with proper authentication, never trust client-side security",
            correct: true,
            points: 25,
            feedback: "Enterprise architecture! Sensitive operations and data must be protected server-side.",
            nextStep: 2
          },
          {
            text: "Allow client-side API calls for better performance",
            correct: false,
            points: -25,
            feedback: "Performance should not compromise security.",
            nextStep: 2
          },
          {
            text: "Use the same API keys for all client applications",
            correct: false,
            points: -20,
            feedback: "Different applications should have different security contexts.",
            nextStep: 2
          }
        ]
      },
      {
        text: "API security implemented! Now using backend proxies for all sensitive operations.",
        choices: []
      }
    ]
  }
},

accessControl501: {
  id: 501,
  title: "Bypassing Tenant Isolation in Multi-tenant SaaS",
  difficulty: "Hard",
  vulnerability: "A01:2021 - Broken Access Control",
  attacker: {
    story: [
      {
        text: "You're testing a multi-tenant SaaS application where each company has isolated data. You notice API endpoints include tenant IDs in requests. What happens if you modify the tenant ID parameter to access another company's data?",
        choices: [
          {
            text: "You can access other tenants' data by manipulating tenant context",
            correct: true,
            points: 30,
            feedback: "Critical finding! Missing tenant isolation allows cross-company data access in multi-tenant architectures.",
            nextStep: 1
          },
          {
            text: "The request fails with authentication errors",
            correct: false,
            points: 5,
            feedback: "That would indicate proper tenant isolation is working.",
            nextStep: 0
          },
          {
            text: "Only your own tenant data is returned regardless of ID",
            correct: false,
            points: 10,
            feedback: "This would show the system enforces tenant context properly.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can you systematically test tenant isolation across different API endpoints?",
        choices: [
          {
            text: "Test all data access endpoints with different tenant IDs and check if isolation is consistent",
            correct: true,
            points: 35,
            feedback: "Sophisticated approach! Comprehensive testing ensures no endpoints bypass tenant isolation.",
            nextStep: 2
          },
          {
            text: "Focus only on sensitive endpoints like user management",
            correct: false,
            points: -25,
            feedback: "Isolation must be consistent across ALL endpoints, not just sensitive ones.",
            nextStep: 2
          },
          {
            text: "Use SQL injection to directly access other tenants' data",
            correct: false,
            points: -30,
            feedback: "This would be a different vulnerability - we're testing access control, not injection.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced access control failure! Multi-tenant architecture missing proper tenant isolation, enabling cross-company data breaches.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you implement proper tenant isolation in a multi-tenant system?",
        choices: [
          {
            text: "Derive tenant context from authenticated session, never trust client-provided tenant IDs",
            correct: true,
            points: 30,
            feedback: "Essential! Tenant context should be determined server-side from authentication, not client input.",
            nextStep: 1
          },
          {
            text: "Use database-level row security policies for automatic tenant filtering",
            correct: true,
            points: 25,
            feedback: "Excellent additional layer! Database-level enforcement provides defense in depth.",
            nextStep: 1
          },
          {
            text: "Hide tenant IDs in the UI but keep them in API parameters",
            correct: false,
            points: -35,
            feedback: "UI hiding doesn't prevent API manipulation - enforce isolation server-side.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive multi-tenant security architecture?",
        choices: [
          {
            text: "Session-based tenant context, database row security, and regular isolation testing",
            correct: true,
            points: 35,
            feedback: "Enterprise multi-tenant security! Multiple layers ensure consistent tenant isolation.",
            nextStep: 2
          },
          {
            text: "Allow flexible tenant switching for administrative users",
            correct: false,
            points: -40,
            feedback: "Tenant switching should be strictly controlled and audited.",
            nextStep: 2
          },
          {
            text: "Use the same isolation strategy for all tenant sizes",
            correct: false,
            points: -35,
            feedback: "Different tenant types may require different isolation approaches.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Multi-tenant security implemented! Now using session-based tenant context with database-level enforcement.",
        choices: []
      }
    ]
  }
},

cryptoFailures502: {
  id: 502,
  title: "Insecure Cryptographic Storage of Biometric Data",
  difficulty: "Hard",
  vulnerability: "A02:2021 - Cryptographic Failures",
  attacker: {
    story: [
      {
        text: "A system stores biometric templates (fingerprint data) using symmetric encryption with a database-stored key. What fundamental cryptographic flaw exists for sensitive biometric data?",
        choices: [
          {
            text: "Biometric data should never be reversible - it must be hashed like passwords",
            correct: true,
            points: 30,
            feedback: "Critical finding! Biometric data requires irreversible storage since it cannot be changed if compromised.",
            nextStep: 1
          },
          {
            text: "The encryption key is not long enough",
            correct: false,
            points: 10,
            feedback: "Key length is important, but the fundamental issue is using reversible encryption for biometrics.",
            nextStep: 0
          },
          {
            text: "Biometric data should be stored in plain text for fast matching",
            correct: false,
            points: -40,
            feedback: "Never store biometric data in plain text - it's permanently compromising.",
            nextStep: 0
          }
        ]
      },
      {
        text: "Why is reversible encryption particularly dangerous for biometric data compared to passwords?",
        choices: [
          {
            text: "Biometrics cannot be changed - once stolen, they're compromised forever",
            correct: true,
            points: 35,
            feedback: "Fundamental security principle! Unlike passwords, biometric identifiers are permanent and cannot be reset.",
            nextStep: 2
          },
          {
            text: "Biometric data takes up more storage space when encrypted",
            correct: false,
            points: -30,
            feedback: "Storage size is not the security concern for biometric data.",
            nextStep: 2
          },
          {
            text: "Encryption makes biometric matching slower",
            correct: false,
            points: -25,
            feedback: "Performance impact is not the primary security risk.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Critical cryptographic failure! Biometric data stored with reversible encryption, creating permanent privacy compromise risk.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How should biometric data be securely stored and processed?",
        choices: [
          {
            text: "Store only irreversible biometric templates using secure hashing algorithms",
            correct: true,
            points: 30,
            feedback: "Essential! Biometric data must be hashed using algorithms designed for template matching.",
            nextStep: 1
          },
          {
            text: "Use homomorphic encryption for matching without decryption",
            correct: true,
            points: 25,
            feedback: "Advanced approach! Homomorphic encryption allows matching while keeping data encrypted.",
            nextStep: 1
          },
          {
            text: "Store raw biometric data in encrypted databases",
            correct: false,
            points: -40,
            feedback: "Never store raw biometric data - use templates and irreversible storage.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive biometric security framework?",
        choices: [
          {
            text: "Template hashing, local processing, and privacy-by-design architecture",
            correct: true,
            points: 35,
            feedback: "Enterprise biometric security! Multiple protections for irreversible biometric processing.",
            nextStep: 2
          },
          {
            text: "Allow biometric data export for backup purposes",
            correct: false,
            points: -45,
            feedback: "Biometric data should never leave the secure processing environment.",
            nextStep: 2
          },
          {
            text: "Use the same storage for all biometric modalities",
            correct: false,
            points: -40,
            feedback: "Different biometric types may require different security handling.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Biometric security implemented! Now using irreversible template storage with secure matching algorithms.",
        choices: []
      }
    ]
  }
},

injection503: {
  id: 503,
  title: "Server-Side Template Injection in Email Generation",
  difficulty: "Hard",
  vulnerability: "A03:2021 - Injection",
  attacker: {
    story: [
      {
        text: "An application generates personalized emails using templates that incorporate user input directly. What injection risk exists if template syntax is not sanitized?",
        choices: [
          {
            text: "Server-side template injection enabling remote code execution during email generation",
            correct: true,
            points: 30,
            feedback: "Critical finding! Template injection in email systems can lead to server compromise.",
            nextStep: 1
          },
          {
            text: "The emails might have formatting issues",
            correct: false,
            points: 5,
            feedback: "Formatting problems are usability issues, not security vulnerabilities.",
            nextStep: 0
          },
          {
            text: "Email delivery might be delayed",
            correct: false,
            points: 5,
            feedback: "Performance impact is not the security risk.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can template injection in email systems be exploited beyond simple code execution?",
        choices: [
          {
            text: "Access sensitive data, send phishing emails, or compromise the email infrastructure",
            correct: true,
            points: 35,
            feedback: "Sophisticated attack vector! Email template injection can compromise the entire email system and data.",
            nextStep: 2
          },
          {
            text: "Only modify the appearance of outgoing emails",
            correct: false,
            points: -30,
            feedback: "Template injection typically enables full server-side code execution, not just visual changes.",
            nextStep: 2
          },
          {
            text: "Use it to perform DDoS attacks on the email server",
            correct: false,
            points: -25,
            feedback: "While possible, code execution and data access are more critical risks.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced injection vulnerability! Server-side template injection in email generation enabling system compromise and data breach.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure email template processing?",
        choices: [
          {
            text: "Use logic-less templates or sandboxed execution environments",
            correct: true,
            points: 30,
            feedback: "Essential! Logic-less templates prevent code injection in template processing.",
            nextStep: 1
          },
          {
            text: "Validate template syntax before processing",
            correct: false,
            points: -35,
            feedback: "Malicious templates can use valid syntax - use logic-less templates instead.",
            nextStep: 1
          },
          {
            text: "Encode all user input before template insertion",
            correct: false,
            points: -30,
            feedback: "Encoding can break legitimate template functionality - use safer templates.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive email security architecture?",
        choices: [
          {
            text: "Logic-less templates, input validation, and isolated processing environments",
            correct: true,
            points: 35,
            feedback: "Enterprise email security! Multiple layers protect against template injection.",
            nextStep: 2
          },
          {
            text: "Allow template flexibility for marketing personalization",
            correct: false,
            points: -40,
            feedback: "Flexibility should not compromise security - use safe templating approaches.",
            nextStep: 2
          },
          {
            text: "Use the same template engine for all email types",
            correct: false,
            points: -35,
            feedback: "Different email types may require different security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Email template security implemented! Now using logic-less templates with proper input sanitization.",
        choices: []
      }
    ]
  }
},

insecureDesign504: {
  id: 504,
  title: "Missing Non-Repudiation in Digital Signatures",
  difficulty: "Hard",
  vulnerability: "A04:2021 - Insecure Design",
  attacker: {
    story: [
      {
        text: "A document signing system uses digital signatures but doesn't include timestamps or proper certificate validation. What fundamental design flaw enables repudiation attacks?",
        choices: [
          {
            text: "Signers can deny authorship by claiming signatures were created outside valid timeframes",
            correct: true,
            points: 30,
            feedback: "Critical design flaw! Missing non-repudiation enables signers to deny document authorship.",
            nextStep: 1
          },
          {
            text: "The signatures might be visually unappealing",
            correct: false,
            points: 5,
            feedback: "Visual appearance is not the security concern.",
            nextStep: 0
          },
          {
            text: "Document processing might be slower without timestamps",
            correct: false,
            points: 5,
            feedback: "Performance impact is not the design flaw.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can missing non-repudiation be exploited in legal or financial contexts?",
        choices: [
          {
            text: "Signers can dispute contract validity by claiming signatures were forged or timed incorrectly",
            correct: true,
            points: 35,
            feedback: "Sophisticated legal risk! Non-repudiation failures undermine the legal foundation of digital signatures.",
            nextStep: 2
          },
          {
            text: "Attackers can easily forge digital signatures",
            correct: false,
            points: -30,
            feedback: "Signature forgery is different from repudiation - we're discussing design flaws in validation.",
            nextStep: 2
          },
          {
            text: "Documents might become corrupted during signing",
            correct: false,
            points: -25,
            feedback: "Data corruption is a reliability issue, not a non-repudiation failure.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Insecure design! Digital signature system missing non-repudiation features, enabling signature disputes and legal challenges.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you implement proper non-repudiation in digital signatures?",
        choices: [
          {
            text: "Use trusted timestamping and proper certificate chain validation",
            correct: true,
            points: 30,
            feedback: "Essential! Trusted timestamps and certificate validation provide non-repudiation evidence.",
            nextStep: 1
          },
          {
            text: "Store signature images with high resolution",
            correct: false,
            points: -40,
            feedback: "Visual representation doesn't provide cryptographic non-repudiation.",
            nextStep: 1
          },
          {
            text: "Require multiple witnesses for each signature",
            correct: false,
            points: -35,
            feedback: "While helpful for physical documents, digital systems need cryptographic proofs.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive digital signature architecture?",
        choices: [
          {
            text: "Trusted timestamps, certificate validation, and audit trails with legal compliance",
            correct: true,
            points: 35,
            feedback: "Enterprise digital signature security! Multiple mechanisms ensure non-repudiation and legal validity.",
            nextStep: 2
          },
          {
            text: "Allow offline signing for user convenience",
            correct: false,
            points: -45,
            feedback: "Offline signing can compromise timestamp validity and non-repudiation.",
            nextStep: 2
          },
          {
            text: "Use the same signing process for all document types",
            correct: false,
            points: -40,
            feedback: "Different document types may have different legal requirements.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Digital signature design secured! Now implementing trusted timestamps and proper certificate validation.",
        choices: []
      }
    ]
  }
},

securityMisconfig505: {
  id: 505,
  title: "Over-Privileged Service Accounts in Microservices",
  difficulty: "Hard",
  vulnerability: "A05:2021 - Security Misconfiguration",
  attacker: {
    story: [
      {
        text: "A microservices architecture uses service accounts with broad permissions across multiple services. What lateral movement risk exists if one service is compromised?",
        choices: [
          {
            text: "Attackers can pivot through over-privileged service accounts to access other services",
            correct: true,
            points: 30,
            feedback: "Critical finding! Over-privileged service accounts enable lateral movement in microservices architectures.",
            nextStep: 1
          },
          {
            text: "The services might have communication delays",
            correct: false,
            points: 5,
            feedback: "Performance issues are operational, not security misconfigurations.",
            nextStep: 0
          },
          {
            text: "Service discovery might not work properly",
            correct: false,
            points: 5,
            feedback: "Discovery issues are different from privilege misconfigurations.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can over-privileged service accounts lead to full architecture compromise?",
        choices: [
          {
            text: "Compromise one service, then use its broad permissions to access and control other services",
            correct: true,
            points: 35,
            feedback: "Sophisticated microservices attack! Privilege escalation through service account abuse enables full architecture takeover.",
            nextStep: 2
          },
          {
            text: "Directly modify the service mesh configuration",
            correct: false,
            points: -35,
            feedback: "Service mesh modification requires different access - we're discussing privilege abuse.",
            nextStep: 2
          },
          {
            text: "Use the services to mine cryptocurrency",
            correct: false,
            points: -30,
            feedback: "While possible, architecture compromise is the critical risk.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Security misconfiguration! Over-privileged service accounts enabling lateral movement and full microservices architecture compromise.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you properly configure service accounts in microservices?",
        choices: [
          {
            text: "Implement principle of least privilege with service-specific minimal permissions",
            correct: true,
            points: 30,
            feedback: "Essential! Each service should have only the permissions needed for its specific functions.",
            nextStep: 1
          },
          {
            text: "Use the same service account for all related services",
            correct: false,
            points: -40,
            feedback: "Shared service accounts create massive lateral movement risk.",
            nextStep: 1
          },
          {
            text: "Grant broad permissions for development flexibility",
            correct: false,
            points: -35,
            feedback: "Flexibility should not compromise security - use minimal privileges.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the zero-trust microservices security model?",
        choices: [
          {
            text: "Service identity, least privilege, and mutual TLS with continuous verification",
            correct: true,
            points: 35,
            feedback: "Enterprise microservices security! Zero-trust approach prevents lateral movement.",
            nextStep: 2
          },
          {
            text: "Allow full internal service communication for operational simplicity",
            correct: false,
            points: -45,
            feedback: "Internal trust creates security risks - verify all service interactions.",
            nextStep: 2
          },
          {
            text: "Use the same security policies for all microservices",
            correct: false,
            points: -40,
            feedback: "Different services may require different security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Microservices security hardened! Now implementing least privilege service accounts with zero-trust architecture.",
        choices: []
      }
    ]
  }
},

vulnerableComponents506: {
  id: 506,
  title: "Blockchain Smart Contract Reentrancy Vulnerability",
  difficulty: "Hard",
  vulnerability: "A06:2021 - Vulnerable and Outdated Components",
  attacker: {
    story: [
      {
        text: "A DeFi smart contract makes external calls before updating internal state. What classic vulnerability enables recursive fund drainage?",
        choices: [
          {
            text: "Reentrancy attack - recursive calls can drain contract funds before state updates",
            correct: true,
            points: 30,
            feedback: "Critical blockchain finding! Reentrancy is a classic smart contract vulnerability with devastating financial impact.",
            nextStep: 1
          },
          {
            text: "The contract might use too much gas",
            correct: false,
            points: 10,
            feedback: "Gas usage is economic, not the reentrancy vulnerability.",
            nextStep: 0
          },
          {
            text: "Transaction ordering might be unpredictable",
            correct: false,
            points: 5,
            feedback: "Transaction ordering is a different blockchain consideration.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How does reentrancy enable complete fund drainage from smart contracts?",
        choices: [
          {
            text: "Malicious contract recursively calls withdrawal function before balance is updated",
            correct: true,
            points: 35,
            feedback: "Sophisticated blockchain attack! Reentrancy exploits the gap between external calls and state updates.",
            nextStep: 2
          },
          {
            text: "Directly modify the contract bytecode on the blockchain",
            correct: false,
            points: -35,
            feedback: "Blockchain immutability prevents direct bytecode modification.",
            nextStep: 2
          },
          {
            text: "Use quantum computing to break blockchain cryptography",
            correct: false,
            points: -30,
            feedback: "Quantum attacks are theoretical and different from reentrancy.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Critical component vulnerability! Smart contract reentrancy enabling recursive fund drainage and complete financial loss.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent reentrancy attacks in smart contracts?",
        choices: [
          {
            text: "Use checks-effects-interactions pattern and reentrancy guards",
            correct: true,
            points: 30,
            feedback: "Essential! CEI pattern and guards prevent state manipulation during external calls.",
            nextStep: 1
          },
          {
            text: "Make all functions private to prevent external calls",
            correct: false,
            points: -40,
            feedback: "This breaks contract functionality - use proper patterns instead.",
            nextStep: 1
          },
          {
            text: "Use larger gas limits to prevent recursive calls",
            correct: false,
            points: -35,
            feedback: "Gas limits don't prevent reentrancy, just limit recursion depth.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive smart contract security framework?",
        choices: [
          {
            text: "Secure patterns, formal verification, and extensive testing with bug bounties",
            correct: true,
            points: 35,
            feedback: "Enterprise blockchain security! Multiple approaches ensure smart contract safety.",
            nextStep: 2
          },
          {
            text: "Use the same contract patterns for all blockchain applications",
            correct: false,
            points: -45,
            feedback: "Different applications require different security considerations.",
            nextStep: 2
          },
          {
            text: "Allow contract upgrades to fix vulnerabilities later",
            correct: false,
            points: -40,
            feedback: "Upgradeability introduces its own security risks.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Smart contract security implemented! Now using CEI pattern with reentrancy guards and formal verification.",
        choices: []
      }
    ]
  }
},

authFailure507: {
  id: 507,
  title: "JWT Algorithm Confusion with Asymmetric Keys",
  difficulty: "Hard",
  vulnerability: "A07:2021 - Identification and Authentication Failures",
  attacker: {
    story: [
      {
        text: "A JWT implementation supports both symmetric (HS256) and asymmetric (RS256) algorithms but doesn't properly validate the algorithm against expected key types. What authentication bypass risk exists?",
        choices: [
          {
            text: "Algorithm confusion - using symmetric algorithm with public key to forge valid tokens",
            correct: true,
            points: 30,
            feedback: "Critical finding! JWT algorithm confusion enables token forgery through algorithm switching.",
            nextStep: 1
          },
          {
            text: "Tokens might have inconsistent expiration times",
            correct: false,
            points: 5,
            feedback: "Expiration timing is operational, not an algorithm confusion vulnerability.",
            nextStep: 0
          },
          {
            text: "Key rotation might not work properly",
            correct: false,
            points: 5,
            feedback: "Key management issues are different from algorithm validation flaws.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can algorithm confusion lead to complete authentication bypass?",
        choices: [
          {
            text: "Forge admin tokens by using public key as HMAC secret with symmetric algorithm",
            correct: true,
            points: 35,
            feedback: "Sophisticated JWT attack! Algorithm confusion exploits key type validation failures to create valid forged tokens.",
            nextStep: 2
          },
          {
            text: "Directly steal the private signing key",
            correct: false,
            points: -35,
            feedback: "Key theft requires different vulnerabilities - algorithm confusion works with public keys.",
            nextStep: 2
          },
          {
            text: "Use timing attacks to predict JWT secrets",
            correct: false,
            points: -30,
            feedback: "Timing attacks are different from algorithm confusion.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Advanced authentication failure! JWT algorithm confusion enabling token forgery and complete authentication bypass.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you prevent JWT algorithm confusion attacks?",
        choices: [
          {
            text: "Explicitly specify allowed algorithms and ignore the alg field in tokens",
            correct: true,
            points: 30,
            feedback: "Essential! Server should dictate allowed algorithms, not trust client-provided alg field.",
            nextStep: 1
          },
          {
            text: "Use only symmetric algorithms for simplicity",
            correct: false,
            points: -40,
            feedback: "Symmetric algorithms have key distribution challenges - use proper algorithm validation instead.",
            nextStep: 1
          },
          {
            text: "Validate token signatures with multiple algorithms",
            correct: false,
            points: -35,
            feedback: "Multiple validation doesn't prevent confusion - explicitly specify allowed algorithms.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive JWT security strategy?",
        choices: [
          {
            text: "Explicit algorithm validation, key ID verification, and proper library usage",
            correct: true,
            points: 35,
            feedback: "Enterprise JWT security! Multiple validation layers prevent various JWT attacks.",
            nextStep: 2
          },
          {
            text: "Allow all algorithms for maximum compatibility",
            correct: false,
            points: -45,
            feedback: "This creates the vulnerability - restrict to known secure algorithms.",
            nextStep: 2
          },
          {
            text: "Use the same JWT configuration for all services",
            correct: false,
            points: -40,
            feedback: "Different services may require different JWT security levels.",
            nextStep: 2
          }
        ]
      },
      {
        text: "JWT security hardened! Now using explicit algorithm validation with proper key management.",
        choices: []
      }
    ]
  }
},

softwareIntegrity508: {
  id: 508,
  title: "CI/CD Pipeline Dependency Chain Compromise",
  difficulty: "Hard",
  vulnerability: "A08:2021 - Software and Data Integrity Failures",
  attacker: {
    story: [
      {
        text: "A CI/CD pipeline uses third-party actions and containers without integrity verification. What supply chain risk exists through dependency compromise?",
        choices: [
          {
            text: "Malicious dependencies can inject backdoors into production artifacts",
            correct: true,
            points: 30,
            feedback: "Critical finding! Unverified dependencies enable supply chain attacks through CI/CD pipelines.",
            nextStep: 1
          },
          {
            text: "Builds might take longer with external dependencies",
            correct: false,
            points: 5,
            feedback: "Performance impact is operational, not the integrity risk.",
            nextStep: 0
          },
          {
            text: "Artifact sizes might be larger than expected",
            correct: false,
            points: 5,
            feedback: "Size variations are not the security concern.",
            nextStep: 0
          }
        ]
      },
      {
        text: "How can dependency chain compromise lead to widespread system infection?",
        choices: [
          {
            text: "Compromised dependency injects malware that propagates to all deployed artifacts",
            correct: true,
            points: 35,
            feedback: "Sophisticated supply chain attack! Dependency compromise affects all systems built through the pipeline.",
            nextStep: 2
          },
          {
            text: "Directly modify the source code in version control",
            correct: false,
            points: -35,
            feedback: "Source modification requires different access - we're discussing dependency compromise.",
            nextStep: 2
          },
          {
            text: "Use the pipeline to mine cryptocurrency",
            correct: false,
            points: -30,
            feedback: "While possible, backdoor injection is the critical supply chain risk.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Software integrity failure! CI/CD pipeline dependency chain compromise enabling widespread backdoor injection through supply chain attacks.",
        choices: []
      }
    ]
  },
  defender: {
    story: [
      {
        text: "How do you secure CI/CD pipeline dependencies?",
        choices: [
          {
            text: "Use dependency pinning, integrity verification, and trusted registries",
            correct: true,
            points: 30,
            feedback: "Essential! Dependency pinning and verification prevent unauthorized changes.",
            nextStep: 1
          },
          {
            text: "Allow latest versions for automatic security updates",
            correct: false,
            points: -40,
            feedback: "Latest versions can introduce new vulnerabilities - use pinned versions with controlled updates.",
            nextStep: 1
          },
          {
            text: "Use checksums without cryptographic signing",
            correct: false,
            points: -35,
            feedback: "Checksums don't provide provenance - need cryptographic signatures.",
            nextStep: 1
          }
        ]
      },
      {
        text: "What's the comprehensive software supply chain security?",
        choices: [
          {
            text: "SBOM generation, provenance verification, and policy enforcement with scanning",
            correct: true,
            points: 35,
            feedback: "Enterprise supply chain security! Multiple controls ensure software integrity from source to deployment.",
            nextStep: 2
          },
          {
            text: "Allow dependency updates without security review",
            correct: false,
            points: -45,
            feedback: "All dependency changes should be reviewed for security impact.",
            nextStep: 2
          },
          {
            text: "Use the same dependencies for all projects",
            correct: false,
            points: -40,
            feedback: "Different projects may have different security requirements.",
            nextStep: 2
          }
        ]
      },
      {
        text: "Supply chain security implemented! Now using dependency pinning with provenance verification and SBOM tracking.",
        choices: []
      }
    ]
  }
},


  insecureDesign: {
    id: 10,
    title: "Insecure Design",
    difficulty: "Medium",
    vulnerability: "A04:2021 - Insecure Design",
    attacker: {
      story: [
        {
          text: "You're reviewing an application's business logic. You notice users can vote multiple times. What do you test?",
          choices: [
            {
              text: "Exploit the flawed business logic to manipulate voting results",
              correct: true,
              points: 15,
              feedback: "Correct! Insecure design in business logic can be exploited to manipulate application behavior.",
              nextStep: 1
            },
            {
              text: "Look for technical vulnerabilities like SQL injection",
              correct: false,
              points: 5,
              feedback: "This is a design flaw, not a technical implementation vulnerability.",
              nextStep: 0
            },
            {
              text: "Report it as a feature request",
              correct: false,
              points: 0,
              feedback: "This is a security design flaw, not a missing feature.",
              nextStep: 0
            }
          ]
        },
        {
          text: "You successfully manipulated the voting system. How do you demonstrate the business impact?",
          choices: [
            {
              text: "Show how the flaw affects business decisions or financial outcomes",
              correct: true,
              points: 20,
              feedback: "Excellent! Demonstrating real business impact makes the security risk clear to stakeholders.",
              nextStep: 2
            },
            {
              text: "Just document the technical issue",
              correct: false,
              points: 10,
              feedback: "Good for technical teams, but business impact drives action.",
              nextStep: 2
            },
            {
              text: "Manipulate results to cause maximum damage",
              correct: false,
              points: -10,
              feedback: "Unethical and potentially illegal. Focus on demonstrating, not causing harm.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Design flaw exploited! Insecure business logic can lead to manipulated outcomes and financial loss.",
          choices: []
        }
      ]
    },
    defender: {
      story: [
        {
          text: "You're involved in application design phase. How do you prevent insecure design?",
          choices: [
            {
              text: "Implement threat modeling and security requirements from the start",
              correct: true,
              points: 15,
              feedback: "Perfect! Security should be built into the design, not bolted on later.",
              nextStep: 1
            },
            {
              text: "Add security testing at the end of development",
              correct: false,
              points: 5,
              feedback: "Too late! Design flaws are expensive to fix after implementation.",
              nextStep: 1
            },
            {
              text: "Use the latest security libraries",
              correct: false,
              points: 5,
              feedback: "Libraries help with implementation security, not design security.",
              nextStep: 1
            }
          ]
        },
        {
          text: "Good approach! What comprehensive secure design methodology should you adopt?",
          choices: [
            {
              text: "Adopt Secure SDLC, conduct design reviews, and use security patterns",
              correct: true,
              points: 20,
              feedback: "Excellent! Secure Software Development Lifecycle ensures security throughout the process.",
              nextStep: 2
            },
            {
              text: "Hire penetration testers for each release",
              correct: false,
              points: 10,
              feedback: "Pen testing is good but reactive. Secure design is proactive.",
              nextStep: 2
            },
            {
              text: "Implement all security controls possible",
              correct: false,
              points: 5,
              feedback: "Not all controls are needed. Threat modeling helps prioritize appropriately.",
              nextStep: 2
            }
          ]
        },
        {
          text: "Secure design established! Security considered throughout the development lifecycle.",
          choices: []
        }
      ]
    }
  }
};

async function pushChallengesToFirestore() {
  try {
    const batch = db.batch();
    let operationCount = 0;
    let batchCount = 0;
    
    const scenarioKeys = Object.keys(scenarios);
    console.log(` Total keys in scenarios object: ${scenarioKeys.length}`);
    
    let validScenarios = 0;
    let invalidScenarios = 0;

    for (const [key, scenario] of Object.entries(scenarios)) {
      // Check if scenario is valid
      if (!scenario || typeof scenario !== 'object' || Object.keys(scenario).length === 0) {
        console.log(` Skipping invalid scenario: ${key}`);
        invalidScenarios++;
        continue;
      }
      
      const docRef = db.collection('challenges').doc(key);
      batch.set(docRef, {
        ...scenario,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp()
      }, { merge: true });
      
      operationCount++;
      validScenarios++;

      if (operationCount === 500) {
        await batch.commit();
        console.log(` Batch ${++batchCount} committed (500 operations)`);
        operationCount = 0;
      }
    }

    if (operationCount > 0) {
      await batch.commit();
      console.log(` Final batch committed (${operationCount} operations)`);
    }

    console.log(` Summary:`);
    console.log(`   Total keys: ${scenarioKeys.length}`);
    console.log(`   Valid scenarios: ${validScenarios}`);
    console.log(`   Invalid scenarios: ${invalidScenarios}`);
    console.log(`   Operations performed: ${validScenarios}`);
    
    process.exit(0);
  } catch (error) {
    console.error('Error pushing challenges to Firestore:', error);
    process.exit(1);
  }
}

pushChallengesToFirestore();