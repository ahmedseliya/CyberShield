import React, { useEffect, useState, useMemo, useCallback } from 'react';
import { db } from '../firebaseConfig';
import {
    collection,
    onSnapshot,
    query,
    orderBy,
    addDoc,
    getDocs,
    doc,
    setDoc,
    where
} from 'firebase/firestore';

const VULNCHECK_API_URL = "https://api.vulncheck.com/v3/index/nist-nvd2";

const owaspCategories = {
    A01: ['access control', 'authorization'],
    A02: ['encryption', 'ssl', 'tls', 'cryptographic'],
    A03: ['sql injection', 'xss', 'command injection', 'cross-site scripting'],
    A04: ['insecure design', 'business logic'],
    A05: ['security misconfiguration', 'misconfiguration'],
    A06: ['vulnerable component', 'dependency', 'third-party library'],
    A07: ['broken authentication', 'jwt', 'session'],
    A08: ['ssrf', 'server-side request forgery'],
    A09: ['logging', 'monitoring', 'insufficient logging'],
    A10: ['unsafe consumption of apis']
};

const categorizeOWASP = (desc) => {
    if (!desc) return 'Uncategorized';
    const lowerDesc = desc.toLowerCase();
    for (const category in owaspCategories) {
        if (owaspCategories[category].some(word => lowerDesc.includes(word))) {
            return category;
        }
    }
    return 'Uncategorized';
};

const VulnerabilityFeed = () => {
    const [vulns, setVulns] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [fetchStatus, setFetchStatus] = useState({ loading: false, error: null });

    const refreshCVEs = useCallback(async () => {
        setFetchStatus({ loading: true, error: null });
        try {
            const metadataRef = doc(db, 'metadata', 'lastFetch');
            const metadataSnap = await getDoc(metadataRef);
            const lastFetchTime = metadataSnap.exists() ? metadataSnap.data().timestamp.toDate() : null;

            const now = new Date();
            if (lastFetchTime && (now - lastFetchTime) / (1000 * 60 * 60) < 1) {
                setFetchStatus({ loading: false, error: null });
                return;
            }

            const response = await fetch(`${VULNCHECK_API_URL}?size=100`);

            if (!response.ok) throw new Error(`API Error: ${response.status}`);
            
            const data = await response.json();

            for (const item of data.data || []) {
                const description = item.cve.descriptions.find(d => d.lang === 'en')?.value || 'No description.';
                const category = categorizeOWASP(description);

                if (category === 'Uncategorized') continue;

                const cveId = item.cve.id;
                const q = query(collection(db, 'vulnerabilities'), where("id", "==", cveId));
                const querySnapshot = await getDocs(q);

                if (querySnapshot.empty) {
                    const newDoc = {
                        id: cveId,
                        description: description,
                        severity: item.cve.metrics.cvssMetricV31?.[0]?.cvssData.baseSeverity || 'UNKNOWN',
                        category: category,
                        tech: ['Node.js', 'React', 'PHP', 'Python', 'Java'].filter(tech => description.toLowerCase().includes(tech.toLowerCase())),
                        timestamp: new Date(item.cve.published),
                    };
                    await addDoc(collection(db, 'vulnerabilities'), newDoc);
                }
            }

            await setDoc(metadataRef, { timestamp: now });
            setFetchStatus({ loading: false, error: null });

        } catch (err) {
            console.error("Failed to refresh CVEs:", err);
            setFetchStatus({ loading: false, error: err.message });
        }
    }, []);

    // --- Seeder Function ---
    // This function is attached to the global window object so you can call it from the browser console.
    window.dispatchSeed = useCallback(async () => {
        console.log("SEEDER: Starting one-time database seed...");
        setFetchStatus({ loading: true, error: "Seeding database..." });
        
        const response = await fetch(`${VULNCHECK_API_URL}?size=100`);
        const data = await response.json();
        let count = 0;

        for (const item of data.data || []) {
            const description = item.cve.descriptions.find(d => d.lang === 'en')?.value || 'No description.';
            const category = categorizeOWASP(description);

            if (category === 'Uncategorized') continue;

            const cveId = item.cve.id;
            const newDoc = {
                id: cveId,
                description: description,
                severity: item.cve.metrics.cvssMetricV31?.[0]?.cvssData.baseSeverity || 'UNKNOWN',
                category: category,
                tech: ['Node.js', 'React', 'PHP', 'Python', 'Java'].filter(tech => description.toLowerCase().includes(tech.toLowerCase())),
                timestamp: new Date(item.cve.published),
            };
            await addDoc(collection(db, 'vulnerabilities'), newDoc);
            count++;
        }
        
        console.log(`SEEDER: Finished. Added ${count} new vulnerabilities to your database.`);
        await setDoc(doc(db, 'metadata', 'lastFetch'), { timestamp: new Date() });
        setFetchStatus({ loading: false, error: null });
    }, []);


    useEffect(() => {
        const q = query(collection(db, "vulnerabilities"), orderBy("timestamp", "desc"));
        const unsubscribe = onSnapshot(q, (snapshot) => {
            const data = snapshot.docs.map(doc => ({ ...doc.data(), docId: doc.id, timestamp: doc.data().timestamp.toDate() }));
            setVulns(data);
            setIsLoading(false);
        });

        // Start the automatic refresh cycle
        const intervalId = setInterval(refreshCVEs, 15 * 60 * 1000);

        return () => {
            unsubscribe();
            clearInterval(intervalId);
        };
    }, [refreshCVEs]);

    const dashboardData = useMemo(() => {
        const severityCounts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, UNKNOWN: 0 };
        const categoryCounts = {};
        let affectedTech = new Set();
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        vulns.forEach(v => {
            if (v.severity) severityCounts[v.severity]++;
            if (v.category) categoryCounts[v.category] = (categoryCounts[v.category] || 0) + 1;
            v.tech.forEach(t => affectedTech.add(t));
        });

        const todaysCriticalAlerts = vulns.filter(v => v.severity === 'CRITICAL' && v.timestamp >= today);
        const trendingCategories = Object.entries(categoryCounts).sort(([,a],[,b]) => b - a).slice(0, 3).map(([category, count]) => ({ category, count }));

        return { severityCounts, todaysCriticalAlerts, trendingCategories, affectedTech: Array.from(affectedTech) };
    }, [vulns]);

    if (isLoading) {
        return <div className="loading-container"><h2>Initializing Dashboard...</h2></div>;
    }

    return (
        <div className="feed-container">
            <header className="dashboard-header">
                <h1>üîê OWASP Top 10 Vulnerability Dashboard</h1>
            </header>
            <div className="metrics-grid">
                <div className="metric-card">
                    <h3>Severity Meters</h3>
                    <div className="severity-meters">
                        {Object.entries(dashboardData.severityCounts).map(([level, count]) => (
                            <div key={level} className="meter">
                                <span className="meter-label">{level}</span>
                                <span className={`meter-count severity-${level.toLowerCase()}`}>{count}</span>
                            </div>
                        ))}
                    </div>
                </div>
                <div className="metric-card">
                    <h3>üî• Trending Exploits</h3>
                    <div className="trending-list">
                        {dashboardData.trendingCategories.length > 0 ? (
                            dashboardData.trendingCategories.map(item => (
                                <div key={item.category}>{item.category} ({item.count} alerts)</div>
                            ))
                        ) : <p>Awaiting new trend data...</p>}
                    </div>
                </div>
                <div className="metric-card">
                    <h3>üõ† Affected Technologies</h3>
                    <div className="tech-tags">
                        {dashboardData.affectedTech.length > 0 ? dashboardData.affectedTech.map(t => <span key={t} className="tech-tag">{t}</span>) : 'None detected'}
                    </div>
                </div>
            </div>
            <div className="critical-alerts">
                <h2>üî¥ Today's Critical Alerts</h2>
                <div className="vuln-list">
                    {dashboardData.todaysCriticalAlerts.length > 0 ? (
                        dashboardData.todaysCriticalAlerts.map(v => (
                            <div key={v.docId} className={`vuln-box severity-critical`}>
                                <h3>{v.category}: {v.id}</h3>
                                <p>{v.description}</p>
                            </div>
                        ))
                    ) : <p className="empty-state">No critical OWASP alerts published in the last 24 hours.</p>}
                </div>
            </div>
            <h2>Recent OWASP Vulnerability Feed</h2>
            <div className="vuln-list">
                {vulns.length > 0 ? (
                    vulns.map((v) => (
                        <div key={v.docId} className={`vuln-box severity-${v.severity.toLowerCase()}`}>
                            <h3>{v.category}: {v.id}</h3>
                            <p>{v.description}</p>
                            <p><strong>Severity:</strong> <span className={`severity-${v.severity.toLowerCase()}`}>{v.severity}</span></p>
                            <p><strong>Tech:</strong> {v.tech.join(', ') || 'N/A'}</p>
                            <p><em>Disclosed: {new Date(v.timestamp).toLocaleString()}</em></p>
                        </div>
                    ))
                ) : <p className="empty-state">No data found. Please run the one-time seed script from the browser console by typing: window.dispatchSeed()</p>}
            </div>
        </div>
    );
};

export default VulnerabilityFeed;

