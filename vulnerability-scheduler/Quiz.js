const admin = require('firebase-admin');
const axios = require('axios');
const cron = require('node-cron');
const fs = require('fs');
const path = require('path');

// Load environment variables from .env file
require('dotenv').config();

// Initialize Firebase Admin
const serviceAccount = require('./serviceAccountKey.json');
admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
  databaseURL: `https://${serviceAccount.project_id}.firebaseio.com`
});

// Gemini API Configuration
const GEMINI_API_KEY = process.env.GEMINI_API_KEY || 'AIzaSyDeLo-2KWu1dezUlERM7b4yW1QrtWBULQI';
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent';

console.log('üîß Cybersecurity Quiz Generator - Local Version');
console.log('===============================================\n');

// Main function to generate quiz
async function generateQuiz() {
  try {
    const today = new Date().toISOString().split('T')[0];
    console.log(`üöÄ Starting quiz generation for ${today}...`);
    
    const db = admin.firestore();
    
    // Check if quiz already exists for today - DELETE IT if exists
    const quizRef = db.collection('dailyQuizzes').doc(today);
    const existingQuiz = await quizRef.get();
    
    if (existingQuiz.exists) {
      console.log('üóëÔ∏è Deleting existing quiz for today...');
      await quizRef.delete();
    }
    
    // Generate new quiz using Gemini API via axios
    console.log('üîÑ Generating new quiz with Gemini AI...');
    const questions = await generateQuizWithGemini();
    
    // Randomize options for each question
    const randomizedQuestions = questions.map(q => {
      const options = [...q.options];
      // Fisher-Yates shuffle
      for (let i = options.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [options[i], options[j]] = [options[j], options[i]];
      }
      
      // Find the new index of the correct answer after shuffling
      let originalCorrectIndex = -1;
      const originalCorrectOption = q.options.find(opt => opt.correct);
      if (originalCorrectOption) {
        originalCorrectIndex = q.options.indexOf(originalCorrectOption);
      }
      
      return {
        ...q,
        options: options,
        originalCorrectIndex: originalCorrectIndex,
        shuffled: true
      };
    });
    
    // Save to Firestore
    await quizRef.set({
      date: today,
      questions: randomizedQuestions,
      generatedAt: admin.firestore.FieldValue.serverTimestamp(),
      active: true,
      totalAttempts: 0,
      userAttempts: {},
      isAIgenerated: true
    });
    
    console.log(`‚úÖ Successfully generated quiz for ${today} with ${questions.length} questions`);
    
    // Delete ALL old quizzes immediately (not wait 7 days)
    await deleteAllOldQuizzes(today);
    
    // Save a local backup copy
    await saveLocalBackup(today, randomizedQuestions);
    
    return {
      success: true,
      message: `Quiz generated for ${today}`,
      date: today,
      questionsCount: questions.length,
      questions: randomizedQuestions.slice(0, 2)
    };
    
  } catch (error) {
    console.error('‚ùå Error generating quiz:', error.message);
    
    // Try to create fallback quiz
    try {
      console.log('üîÑ Trying to create fallback quiz...');
      await createFallbackQuiz();
      return {
        success: true,
        message: 'Fallback quiz created',
        fallback: true
      };
    } catch (fallbackError) {
      console.error('‚ùå Fallback also failed:', fallbackError.message);
      return {
        success: false,
        error: error.message,
        fallbackError: fallbackError.message
      };
    }
  }
}

// SIMPLE TEXT-BASED PARSING - NO JSON REQUIRED
async function generateQuizWithGemini() {
  try {
    console.log('üì° Calling Gemini API...');
    
    // Simple text-based prompt - NO JSON!
    const prompt = {
      contents: [{
        parts: [{
          text: `Create 10 cybersecurity quiz questions strictly related to cyber security concepts few interview based.

Format each question EXACTLY like this:

Q1: [Question text]
A) [Option A]
B) [Option B]
C) [Option C]
D) [Option D]
ANSWER: [Letter of correct answer]
EXPLANATION: [Explanation text]
CATEGORY: [Category]
DIFFICULTY: [easy/medium/hard]

IMPORTANT:
- Create exactly 10 questions
- Each question must have exactly 4 options A-D
- Only one correct answer per question
- Use cybersecurity topics only
- Difficulty mix: 3 easy, 4 medium, 3 hard
- Categories: any cyber security related catgeories eg Cryptography
- Separate questions with a blank line`
        }]
      }],
      generationConfig: {
        temperature: 0.7,
        maxOutputTokens: 4000,
      }
    };

    const response = await axios.post(
      `${GEMINI_API_URL}?key=${GEMINI_API_KEY}`,
      prompt,
      {
        headers: {
          'Content-Type': 'application/json'
        },
        timeout: 30000
      }
    );

    console.log('üì• Received response from Gemini API');
    
    let generatedText;
    if (response.data.candidates && response.data.candidates[0] && response.data.candidates[0].content && response.data.candidates[0].content.parts && response.data.candidates[0].content.parts[0]) {
      generatedText = response.data.candidates[0].content.parts[0].text.trim();
    } else {
      throw new Error('Invalid API response');
    }
    
    // Save raw response
    fs.writeFileSync('raw_response.txt', generatedText);
    console.log('üíæ Saved raw response to raw_response.txt');
    
    // Parse the text format
    const questions = parseTextQuestions(generatedText);
    
    if (questions.length >= 10) {
      console.log(`‚úÖ Successfully parsed ${questions.length} questions`);
      return questions.slice(0, 10);
    } else {
      console.warn(`‚ö†Ô∏è Only parsed ${questions.length} questions, using fallback`);
      return getFallbackQuestions();
    }
    
  } catch (error) {
    console.error('‚ùå AI generation failed:', error.message);
    return getFallbackQuestions();
  }
}

// Text-based parser - NO JSON parsing!
function parseTextQuestions(text) {
  const questions = [];
  const lines = text.split('\n');
  
  let currentQuestion = null;
  let optionCount = 0;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // Skip empty lines
    if (!line) continue;
    
    // Detect new question
    if (line.match(/^Q\d+:/i) || line.match(/^Question \d+:/i)) {
      // Save previous question if exists
      if (currentQuestion && currentQuestion.options.length === 4) {
        questions.push(currentQuestion);
        if (questions.length >= 10) break;
      }
      
      // Extract question number and text
      const match = line.match(/^(?:Q|Question\s*)(\d+):\s*(.+)/i);
      if (match) {
        currentQuestion = {
          id: parseInt(match[1]) || questions.length + 1,
          question: match[2].trim(),
          options: [],
          explanation: '',
          category: 'Cybersecurity',
          difficulty: 'medium'
        };
        optionCount = 0;
      }
    }
    
    // Parse options A-D
    else if (line.match(/^[A-D]\)/) && currentQuestion) {
      const optionText = line.substring(2).trim();
      const optionLetter = line.charAt(0);
      
      currentQuestion.options.push({
        text: optionText,
        correct: false, // Will be set when we find ANSWER
        letter: optionLetter
      });
      optionCount++;
    }
    
    // Parse answer
    else if (line.match(/^ANSWER:/i) && currentQuestion) {
      const answerMatch = line.match(/^ANSWER:\s*([A-D])/i);
      if (answerMatch) {
        const correctLetter = answerMatch[1].toUpperCase();
        // Mark correct answer
        currentQuestion.options.forEach(opt => {
          if (opt.letter === correctLetter) {
            opt.correct = true;
          }
        });
      }
    }
    
    // Parse explanation
    else if (line.match(/^EXPLANATION:/i) && currentQuestion) {
      currentQuestion.explanation = line.replace(/^EXPLANATION:\s*/i, '').trim();
    }
    
    // Parse category
    else if (line.match(/^CATEGORY:/i) && currentQuestion) {
      currentQuestion.category = line.replace(/^CATEGORY:\s*/i, '').trim();
    }
    
    // Parse difficulty
    else if (line.match(/^DIFFICULTY:/i) && currentQuestion) {
      const diff = line.replace(/^DIFFICULTY:\s*/i, '').trim().toLowerCase();
      if (['easy', 'medium', 'hard'].includes(diff)) {
        currentQuestion.difficulty = diff;
      }
    }
    
    // Handle continuation lines for long explanations
    else if (currentQuestion && currentQuestion.explanation && 
             !line.match(/^(Q|A\)|B\)|C\)|D\)|ANSWER|EXPLANATION|CATEGORY|DIFFICULTY)/i)) {
      currentQuestion.explanation += ' ' + line;
    }
  }
  
  // Add the last question if it exists
  if (currentQuestion && currentQuestion.options.length === 4) {
    questions.push(currentQuestion);
  }
  
  // Clean up - remove temporary letter property
  questions.forEach(q => {
    if (q.options) {
      q.options.forEach(opt => {
        delete opt.letter;
      });
    }
  });
  
  return questions;
}

// Fallback questions
function getFallbackQuestions() {
  console.log('üîÑ Using fallback questions');
  return [
    {
      id: 1,
      question: "What does SSL/TLS primarily encrypt?",
      options: [
        { text: "Data at rest on servers", correct: false },
        { text: "Data in transit between client and server", correct: true },
        { text: "Data in CPU cache", correct: false },
        { text: "Backup data", correct: false }
      ],
      explanation: "SSL/TLS encrypts data during transmission over networks to prevent eavesdropping and man-in-the-middle attacks.",
      category: "Cryptography",
      difficulty: "easy"
    },
    {
      id: 2,
      question: "What is the main goal of a phishing attack?",
      options: [
        { text: "To overload a network", correct: false },
        { text: "To steal sensitive information through deception", correct: true },
        { text: "To encrypt files for ransom", correct: false },
        { text: "To create backdoor access", correct: false }
      ],
      explanation: "Phishing uses social engineering to trick users into revealing passwords, credit card numbers, or other sensitive data.",
      category: "Social Engineering",
      difficulty: "easy"
    },
    {
      id: 3,
      question: "What does MFA stand for in cybersecurity?",
      options: [
        { text: "Multiple File Access", correct: false },
        { text: "Multi-Factor Authentication", correct: true },
        { text: "Malware Filtering Application", correct: false },
        { text: "Managed Firewall Access", correct: false }
      ],
      explanation: "Multi-Factor Authentication adds extra security layers beyond just passwords, requiring additional verification methods.",
      category: "Authentication",
      difficulty: "easy"
    },
    {
      id: 4,
      question: "What is SQL Injection?",
      options: [
        { text: "Injecting SQL databases with malware", correct: false },
        { text: "Inserting malicious SQL code through user inputs", correct: true },
        { text: "Backing up SQL databases", correct: false },
        { text: "Optimizing SQL queries", correct: false }
      ],
      explanation: "SQL Injection attacks insert malicious SQL statements into input fields to manipulate databases or access unauthorized data.",
      category: "Web Security",
      difficulty: "medium"
    },
    {
      id: 5,
      question: "What does DDoS stand for?",
      options: [
        { text: "Distributed Data on Server", correct: false },
        { text: "Distributed Denial of Service", correct: true },
        { text: "Direct Denial of System", correct: false },
        { text: "Data Destruction on Storage", correct: false }
      ],
      explanation: "DDoS attacks flood a target with traffic from multiple sources to make it unavailable to legitimate users.",
      category: "Network Security",
      difficulty: "medium"
    },
    {
      id: 6,
      question: "What is a zero-day vulnerability?",
      options: [
        { text: "A vulnerability that's been known for zero days", correct: false },
        { text: "A vulnerability unknown to vendors with no patch available", correct: true },
        { text: "A vulnerability that expires in 24 hours", correct: false },
        { text: "A vulnerability with zero impact", correct: false }
      ],
      explanation: "Zero-day vulnerabilities are unknown to software vendors, giving them zero days to fix before potential exploitation.",
      category: "Vulnerability Management",
      difficulty: "medium"
    },
    {
      id: 7,
      question: "What is the purpose of a VPN?",
      options: [
        { text: "To create a private network over a public connection", correct: true },
        { text: "To scan for viruses", correct: false },
        { text: "To backup data", correct: false },
        { text: "To manage passwords", correct: false }
      ],
      explanation: "VPNs encrypt internet traffic and create secure connections over public networks, protecting data from interception.",
      category: "Network Security",
      difficulty: "medium"
    },
    {
      id: 8,
      question: "What is ransomware?",
      options: [
        { text: "Malware that steals data silently", correct: false },
        { text: "Malware that encrypts files and demands payment", correct: true },
        { text: "Malware that shows unwanted ads", correct: false },
        { text: "Malware that mines cryptocurrency", correct: false }
      ],
      explanation: "Ransomware encrypts victim's files and demands payment (ransom) for the decryption key.",
      category: "Malware",
      difficulty: "hard"
    },
    {
      id: 9,
      question: "What is the principle of least privilege?",
      options: [
        { text: "Give all users admin rights", correct: false },
        { text: "Grant only necessary permissions for tasks", correct: true },
        { text: "Limit user count", correct: false },
        { text: "Use simple passwords", correct: false }
      ],
      explanation: "Users should only have access to what they absolutely need for their job functions, minimizing attack surfaces.",
      category: "Access Control",
      difficulty: "hard"
    },
    {
      id: 10,
      question: "What is a man-in-the-middle attack?",
      options: [
        { text: "Attacking middle management", correct: false },
        { text: "Intercepting communication between two parties", correct: true },
        { text: "Attacking midday", correct: false },
        { text: "Targeting middleware software", correct: false }
      ],
      explanation: "MitM attacks secretly intercept and potentially alter communications between two parties who believe they're directly communicating.",
      category: "Network Security",
      difficulty: "hard"
    }
  ];
}

// Create fallback quiz
async function createFallbackQuiz() {
  const db = admin.firestore();
  const today = new Date().toISOString().split('T')[0];
  
  const questions = getFallbackQuestions();
  
  // Randomize options
  const randomizedQuestions = questions.map(q => {
    const options = [...q.options];
    for (let i = options.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [options[i], options[j]] = [options[j], options[i]];
    }
    
    let originalCorrectIndex = -1;
    const originalCorrectOption = q.options.find(opt => opt.correct);
    if (originalCorrectOption) {
      originalCorrectIndex = q.options.indexOf(originalCorrectOption);
    }
    
    return {
      ...q,
      options: options,
      originalCorrectIndex: originalCorrectIndex,
      shuffled: true
    };
  });
  
  const quizRef = db.collection('dailyQuizzes').doc(today);
  await quizRef.set({
    date: today,
    questions: randomizedQuestions,
    generatedAt: admin.firestore.FieldValue.serverTimestamp(),
    active: true,
    totalAttempts: 0,
    userAttempts: {},
    isFallback: true,
    isAIgenerated: false
  });
  
  console.log('‚úÖ Created fallback quiz for', today);
  return true;
}

// Delete ALL old quizzes (immediately, not wait 7 days)
async function deleteAllOldQuizzes(currentDate) {
  const db = admin.firestore();
  
  try {
    // Get ALL quizzes except today's
    const allQuizzes = await db.collection('dailyQuizzes')
      .where('date', '!=', currentDate)
      .get();
    
    const deletePromises = [];
    allQuizzes.forEach(doc => {
      deletePromises.push(doc.ref.delete());
    });
    
    await Promise.all(deletePromises);
    console.log(`üóëÔ∏è Deleted ${allQuizzes.size} old quizzes`);
    
  } catch (error) {
    console.error('Error deleting old quizzes:', error.message);
  }
}

// Save local backup
async function saveLocalBackup(date, questions) {
  try {
    const backupDir = path.join(__dirname, 'backups');
    if (!fs.existsSync(backupDir)) {
      fs.mkdirSync(backupDir, { recursive: true });
    }
    
    const backupFile = path.join(backupDir, `quiz_${date}.json`);
    const backupData = {
      date: date,
      generatedAt: new Date().toISOString(),
      questions: questions
    };
    
    fs.writeFileSync(backupFile, JSON.stringify(backupData, null, 2));
    console.log(`üíæ Saved local backup to: ${backupFile}`);
  } catch (error) {
    console.error('Failed to save backup:', error.message);
  }
}

// Check quiz status
async function checkQuizStatus() {
  const today = new Date().toISOString().split('T')[0];
  const db = admin.firestore();
  
  const quizRef = db.collection('dailyQuizzes').doc(today);
  const quizSnap = await quizRef.get();
  
  const status = {
    today: today,
    quizExists: quizSnap.exists,
    quizData: quizSnap.exists ? {
      date: quizSnap.data().date,
      questionsCount: quizSnap.data().questions?.length || 0,
      generatedAt: quizSnap.data().generatedAt?.toDate?.() || quizSnap.data().generatedAt,
      totalAttempts: quizSnap.data().totalAttempts || 0,
      isFallback: quizSnap.data().isFallback || false,
      isAIgenerated: quizSnap.data().isAIgenerated || false
    } : null,
    timestamp: new Date().toISOString(),
    status: quizSnap.exists ? "READY" : "NOT_GENERATED"
  };
  
  console.log('üìä Quiz Status:');
  console.log('---------------');
  console.log(`Date: ${status.today}`);
  console.log(`Exists: ${status.quizExists ? '‚úÖ YES' : '‚ùå NO'}`);
  console.log(`Status: ${status.status}`);
  
  if (status.quizData) {
    console.log(`Questions: ${status.quizData.questionsCount}`);
    console.log(`Total Attempts: ${status.quizData.totalAttempts}`);
    console.log(`Type: ${status.quizData.isAIgenerated ? 'AI Generated' : 'Fallback'}`);
    console.log(`Generated: ${status.quizData.generatedAt}`);
  }
  
  return status;
}

// Initialize first quiz
async function initializeQuiz() {
  const today = new Date().toISOString().split('T')[0];
  const db = admin.firestore();
  
  // Check if quiz exists
  const quizRef = db.collection('dailyQuizzes').doc(today);
  const existingQuiz = await quizRef.get();
  
  if (existingQuiz.exists) {
    console.log('‚úÖ Quiz already initialized');
    return {
      success: true,
      message: 'Quiz already initialized',
      date: today
    };
  }
  
  // Create first quiz
  console.log('üöÄ Initializing quiz system with fallback questions...');
  await createFallbackQuiz();
  
  console.log('‚úÖ Quiz system initialized with fallback questions');
  return {
    success: true,
    message: 'Quiz system initialized with fallback questions',
    date: today
  };
}

// Start scheduled generation (runs daily at midnight)
function startScheduler() {
  console.log('‚è∞ Starting daily scheduler (runs at midnight UTC)...');
  
  // Schedule to run every day at midnight UTC
  cron.schedule('0 0 * * *', async () => {
    console.log('\nüïõ Midnight UTC - Generating daily quiz...');
    const result = await generateQuiz();
    console.log('Result:', result.message);
  }, {
    scheduled: true,
    timezone: "UTC"
  });
  
  console.log('‚úÖ Scheduler started. It will run daily at 00:00 UTC.');
  console.log('Press Ctrl+C to stop.');
  
  // Keep the script running
  process.stdin.resume();
}

// Display help
function showHelp() {
  console.log(`
Usage: node quiz.js [command]

Commands:
  --generate    Generate today's quiz (delete old if exists)
  --manual      Same as generate (alias)
  --status      Check today's quiz status
  --schedule    Start scheduler to run daily at midnight
  --init        Initialize quiz system with fallback questions
  --help        Show this help message

Examples:
  node quiz.js                   # Delete old & generate new quiz
  node quiz.js --status          # Check quiz status
  node quiz.js --schedule        # Start daily scheduler
  node quiz.js --init            # Initialize with fallback

Environment Variables:
  Create a .env file with:
  GEMINI_API_KEY=your_api_key_here

Files Required:
  serviceAccountKey.json         # Firebase service account
  .env                           # Environment variables (optional)
  `);
}

// Manual generation (force new quiz) - same as generate now
async function manualGenerate() {
  console.log('üîß Generating new quiz (deleting old if exists)...');
  return await generateQuiz();
}

// Main function
async function main() {
  const args = process.argv.slice(2);
  const command = args[0] || '--generate';
  
  switch (command) {
    case '--generate':
    case '--manual':
      const result = await generateQuiz();
      console.log('\nüìã Result:', result.message);
      if (result.questions) {
        console.log('\nüìù Sample Questions:');
        result.questions.forEach((q, i) => {
          console.log(`\n${i + 1}. ${q.question}`);
          console.log(`   Category: ${q.category}`);
          console.log(`   Difficulty: ${q.difficulty}`);
        });
      }
      break;
      
    case '--status':
      await checkQuizStatus();
      break;
      
    case '--schedule':
      startScheduler();
      break;
      
    case '--init':
      await initializeQuiz();
      break;
      
    case '--help':
      showHelp();
      break;
      
    default:
      console.log(`Unknown command: ${command}`);
      showHelp();
      break;
  }
  
  // Exit after completion (unless scheduler is running)
  if (command !== '--schedule') {
    console.log('\n‚ú® Done!');
    process.exit(0);
  }
}

// Handle errors
process.on('unhandledRejection', (error) => {
  console.error('‚ùå Unhandled Promise Rejection:', error.message);
  process.exit(1);
});

// Run main function
main().catch(error => {
  console.error('‚ùå Fatal error:', error.message);
  process.exit(1);
});