// scheduler.js

const admin = require('firebase-admin');
const axios = require('axios');
const cron = require('node-cron');

// ⚠️ UPDATE THIS LINE: Replace 'your-service-account-key.json' with the name of your downloaded JSON file.
const serviceAccount = require('./serviceAccountKey.json'); 

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount)
});
const db = admin.firestore();

// Keywords to map CVEs to OWASP Top 10 2021 categories
const owaspKeywords = {
  "A01:2021-Broken Access Control": ["access control", "authorization", "unauthorized", "privilege escalation", "bypass", "directory traversal"],
  "A02:2021-Cryptographic Failures": ["cryptographic", "encryption", "weak cipher", "data exposure", "sensitive data"],
  "A03:2021-Injection": ["injection", "sql", "sqli", "xss", "cross-site scripting", "command injection", "os injection"],
  "A04:2021-Insecure Design": ["insecure design", "flaw in business logic"],
  "A05:2021-Security Misconfiguration": ["misconfiguration", "default credentials", "exposed services", "security headers"],
  "A06:2021-Vulnerable & Outdated Components": ["outdated", "known vulnerability", "unpatched", "third-party library"],
  "A07:2021-Identification & Authentication Failures": ["authentication", "session management", "credential stuffing", "brute force"],
  "A08:2021-Software & Data Integrity Failures": ["integrity", "deserialization", "tampering", "unsigned"],
  "A09:2021-Security Logging & Monitoring Failures": ["logging", "monitoring", "insufficient logging"],
  "A10:2021-Server-Side Request Forgery (SSRF)": ["ssrf", "server-side request forgery", "url parsing"],
};

const categorizeByOWASP = (description) => {
  if (!description) return "Uncategorized";
  const text = description.toLowerCase();
  for (const [category, keywords] of Object.entries(owaspKeywords)) {
    if (keywords.some((word) => text.includes(word))) {
      return category;
    }
  }
  return "Uncategorized";
};

const fetchVulnerabilities = async () => {
  console.log("Starting vulnerability fetch job.");

  const endDate = new Date();
  const startDate = new Date();
  startDate.setDate(endDate.getDate() - 3);

  const NVD_API_URL = `https://services.nvd.nist.gov/rest/json/cves/2.0?pubStartDate=${startDate.toISOString()}&pubEndDate=${endDate.toISOString()}`;

  try {
    const response = await axios.get(NVD_API_URL);
    const vulnerabilities = response.data.vulnerabilities || [];
    const batch = db.batch();
    const vulnsCollection = db.collection("vulnerabilities");

    for (const entry of vulnerabilities) {
      const cve = entry.cve;
      const description = cve.descriptions?.find((d) => d.lang === "en")?.value || "";
      const category = categorizeByOWASP(description);

      if (category === "Uncategorized") continue;

      const vulnId = cve.id;
      const docRef = vulnsCollection.doc(vulnId);

      const newVuln = {
        id: vulnId,
        title: description,
        published: cve.published,
        severity: cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseSeverity || "UNKNOWN",
        score: cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore || 0,
        category: category,
        link: `https://nvd.nist.gov/vuln/detail/${vulnId}`,
      };

      batch.set(docRef, newVuln, { merge: true });
    }

    await batch.commit();
    console.log(`Job finished. Added/updated vulnerabilities.`);

    // Logic to keep only the latest 12 vulnerabilities
    const allVulnsQuery = vulnsCollection.orderBy("published", "desc");
    const allVulnsSnapshot = await allVulnsQuery.get();
    if (allVulnsSnapshot.docs.length > 12) {
      const deleteBatch = db.batch();
      const docsToDelete = allVulnsSnapshot.docs.slice(12);
      docsToDelete.forEach(doc => deleteBatch.delete(doc.ref));
      await deleteBatch.commit();
      console.log(`Pruned ${docsToDelete.length} old vulnerabilities.`);
    }

  } catch (error) {
    console.error("Error fetching or storing vulnerabilities:", error);
  }
};

// Schedule the task to run every 2 hours
cron.schedule('0 */2 * * *', fetchVulnerabilities);

// Run the job once on start
fetchVulnerabilities();